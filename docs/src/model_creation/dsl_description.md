# [The Reaction DSL](@id dsl_description)
This tutorial describes the syntax for building chemical reaction
network models using Catalyst's domain-specific language (DSL). Examples showing
how to both construct and solve ODE, SDE, and jump models are provided in [Basic
Chemical Reaction Network Examples](@ref basic_CRN_examples). To learn more about the symbolic
[`ReactionSystem`](@ref)s generated by the DSL, and how to use them directly, see
the tutorial on [Programmatic Construction of Symbolic Reaction Systems](@ref programmatic_CRN_construction).

We first load the `Catalyst` package, which is required for the code in this tutorial to run
```@example tut2
using Catalyst
```

## [Basic syntax](@id basic_examples)

The `@reaction_network` macro allows the (symbolic) specification of reaction
networks with a simple format. Its input is a set of chemical reactions, and
from them it generates a symbolic [`ReactionSystem`](@ref) reaction network
object. The `ReactionSystem` can be used as input to ModelingToolkit
`ODEProblem`, `NonlinearProblem`, `SteadyStateProblem`, `SDEProblem`,
`JumpProblem`, and more. `ReactionSystem`s can also be incrementally extended as
needed, allowing for programmatic construction of networks and network
composition.

The basic syntax is:

```@example tut2
rn = @reaction_network begin
  2.0, X + Y --> XY
  1.0, XY --> Z1 + Z2
end
```
where each line of the [`@reaction_network`](@ref) macro corresponds to a
chemical reaction. Each reaction consists of a reaction rate (the expression on
the left-hand side of  `,`), a set of substrates (the expression in-between `,`
and `-->`), and a set of products (the expression on the right-hand side of
`-->`). The substrates and the products may contain one or more reactants,
separated by `+`. The naming convention for these is the same as for normal
variables in Julia.

The chemical reaction model is generated by the `@reaction_network` macro and
stored in the `rn` variable (a normal Julia variable, which does not need to be
called `rn`). It corresponds to a [`ReactionSystem`](@ref), a symbolic
representation of the chemical network. The generated `ReactionSystem` can be
converted to a symbolic differential equation model via
```@example tut2
osys = convert(ODESystem, rn)
osys = complete(osys)
```

We can then convert the symbolic ODE model into a compiled, optimized
representation for use in the SciML ODE solvers by constructing an `ODEProblem`.
Creating an `ODEProblem` also requires our specifying the initial conditions for
the model. We do this by creating a mapping from each symbolic variable
representing a chemical species to its initial value
```@example tut2
# define the symbolic variables
t = default_t()
@species X(t) Y(t) Z(t) XY(t) Z1(t) Z2(t)

# create the mapping
u0 = [X => 1.0, Y => 1.0, XY => 1.0, Z1 => 1.0, Z2 => 1.0]
```
Alternatively, we can create a mapping using Julia `Symbol`s for each variable,
and then convert them to a mapping involving symbolic variables like
```@example tut2
u0 = symmap_to_varmap(rn, [:X => 1.0, :Y => 1.0, :XY => 1.0, :Z1 => 1.0, :Z2 => 1.0])
```
Given the mapping, we can then create an `ODEProblem` from our symbolic `ODESystem`
```@example tut2
tspan = (0.0, 1.0)  # the time interval to solve on
oprob = ODEProblem(osys, u0, tspan, [])
```

Catalyst provides a shortcut to avoid having to explicitly `convert` to an
`ODESystem` and/or use `symmap_to_varmap`, allowing direct construction
of the `ODEProblem` like
```@example tut2
u0 = [:X => 1.0, :Y => 1.0, :XY => 1.0, :Z1 => 1.0, :Z2 => 1.0]
oprob = ODEProblem(rn, u0, tspan, [])
```

For more detailed examples, see the [Basic Chemical Reaction Network
Examples](@ref basic_CRN_examples).

## Defining parameters and species
Numeric parameter values do not need to be set when the model is created, i.e.
Catalyst supports symbolic parameters too:
```@example tut2
rn = @reaction_network begin
  k1, X --> Y
  k2, Y --> X
end
```
All symbols that do not appear as a substrate or product in a reaction are
designated by Catalyst as a parameter (i.e. all symbols appearing only within
rate expressions and/or as [stoichiometric coefficients](@ref parametric_stoichiometry)). In this example `X` and `Y`
appear as a substrates and products, but neither `k1` nor `k2`. Hence `k1` and `k2` are
designated as parameters. Later in this tutorial, we will describe how to manually specify what should be
considered a species or parameter.

## Production, Destruction, and Stoichiometry
Sometimes reactants are produced/destroyed from/to nothing. This can be
designated using either `0` or `∅`:
```@example tut2
rn = @reaction_network begin
  2.0, 0 --> X
  1.0, X --> 0
end
```
If several molecules of the same reactant are involved in a reaction, the
stoichiometry of a reactant in a reaction can be set using a number. Here, two
molecules of species `X` form the dimer `X2`:
```@example tut2
rn = @reaction_network begin
  1.0, 2X --> Y
end
```
this corresponds to the differential equation:
```@example tut2
convert(ODESystem, rn)
```
Other numbers than 2 can be used, and parenthesis can be used to reuse the same
stoichiometry for several reactants:
```@example tut2
rn = @reaction_network begin
  1.0, X + 2(Y + Z) --> W
end
```
Note, one can explicitly multiply by integer coefficients too, i.e.
```@example tut2
rn = @reaction_network begin
  1.0, X + 2*(Y + Z) --> W
end
```

## Arrow variants
A variety of Unicode arrows are accepted by the DSL in addition to `-->`. All of
these work:  `>`, `→` `↣`, `↦`, `⇾`, `⟶`, `⟼`, `⥟`, `⥟`, `⇀`, `⇁`. Backwards
arrows can also be used to write the reaction in the opposite direction. For
example, these reactions are equivalent:
```@example tut2
rn = @reaction_network begin
  1.0, X + Y --> XY
  1.0, X + Y → XY
  1.0, XY ← X + Y
  1.0, XY <-- X + Y
end
```

## Bi-directional arrows for reversible reactions
Bi-directional arrows, including bidirectional Unicode arrows like ↔, can be
used to designate a reversible reaction. For example, these two models are
equivalent:
```@example tut2
rn = @reaction_network begin
  2.0, X + Y --> XY
  2.0, X + Y <-- XY
end
```
```@example tut2
rn2 = @reaction_network begin
  (2.0,2.0), X + Y <--> XY
end
```

If the reaction rates in the backward and forward directions are different, they
can be designated in the following way:
```@example tut2
rn = @reaction_network begin
  (2.0,1.0), X + Y <--> XY
end
```
which is identical to
```@example tut2
rn = @reaction_network begin
  2.0, X + Y --> XY
  1.0, X + Y <-- XY
end
```

## Combining several reactions in one line
Several similar reactions can be combined in one line by providing a tuple of
reaction rates and/or substrates and/or products. If several tuples are provided,
they must all be of identical length. These pairs of reaction networks are all
identical.

Pair 1:
```@example tut2
rn1 = @reaction_network begin
  1.0, S --> (P1,P2)
end
```
```@example tut2
rn2 = @reaction_network begin
  1.0, S --> P1
  1.0, S --> P2
end
```
Pair 2:
```@example tut2
rn1 = @reaction_network begin
  (1.0,2.0), (S1,S2) --> P
end
```
```@example tut2
rn2 = @reaction_network begin
  1.0, S1 --> P
  2.0, S2 --> P
end
```
Pair 3:
```@example tut2
rn1 = @reaction_network begin
  (1.0,2.0,3.0), (S1,S2,S3) --> (P1,P2,P3)
end
```
```@example tut2
rn2 = @reaction_network begin
  1.0, S1 --> P1
  2.0, S2 --> P2
  3.0, S3 --> P3
end
```
This can also be combined with bi-directional arrows, in which case separate
tuples can be provided for the backward and forward reaction rates.
These reaction networks are identical
```@example tut2
rn1 = @reaction_network begin
 (1.0,(1.0,2.0)), S <--> (P1,P2)
end
```
```@example tut2
rn2 = @reaction_network begin
  1.0, S --> P1
  1.0, S --> P2
  1.0, P1 --> S
  2.0, P2 --> S
end
```

## Variable reaction rates
Reaction rates do not need to be a single parameter or a number, but can also be
expressions depending on time or the current amounts of system species (when, for
example, one species can activate the production of another). For instance, this
is a valid notation:
```@example tut2
rn = @reaction_network begin
  1.0, X --> ∅
  k*X, Y --> ∅
end
```
corresponding to the ODE model
```@example tut2
convert(ODESystem,rn)
```

With respect to the corresponding mass action ODE model, this is actually
equivalent to the reaction system
```@example tut2
rn = @reaction_network begin
  1.0, X --> ∅
  k, X + Y --> X
end
```
```@example tut2
convert(ODESystem,rn)
```
!!! note
    While the ODE models corresponding to the preceding two reaction systems are
    identical, in the latter example the `Reaction` stored in `rn` will be classified as
    [`ismassaction`](@ref) while in the former it will not, which can impact optimizations
    used in generating `JumpSystem`s. For this reason, it is recommended to use the
    latter representation when possible.

Most expressions and functions are valid reaction rates, e.g.:
```@example tut2
using SpecialFunctions
rn = @reaction_network begin
  2.0*X^2, 0 --> X + Y
  t*gamma(Y), X --> ∅
  pi*X/Y, Y --> ∅
end
```
where here `t` always denotes Catalyst's time variable. Please note that many
user-defined functions can be called directly, but others will require
registration with Symbolics.jl ([see the faq](@ref user_functions)).

## [Explicit specification of network species and parameters](@id dsl_description_explicit_species)
Recall that the `@reaction_network` macro automatically designates symbols used
in the macro as either parameters or species, with symbols that appear as a
substrate or product being species, and all other symbols becoming parameters
(i.e. those that only appear within a rate expression and/or as [stoichiometric coefficients](@ref parametric_stoichiometry)). Sometimes, one might want to manually override this default
behavior for a given symbol. E.g one might want something to be considered as a
species, even if it only appears within a rate expression. In the following
network
```@example tut2
rn = @reaction_network begin
  k*X, Y --> 0
end
```
`X` (as well as `k`) will be considered a parameter.

By using the `@species` and `@parameters` options within the `@reaction_network`
macro, one can manually declare that specified symbols should be considered a
species or parameter. E.g in:
```@example tut2
rn = @reaction_network begin
  @species X(t) Y(t)
  k*X, Y --> 0
end
```
`X` and `Y` are set as species. Please note that when declaring species using
the `@species` option, their dependant variable (almost always `t`) also needs
to be designated. Similarly in
```@example tut2
rn = @reaction_network begin
  @parameters k
  k*X, Y --> 0
end
```
both `X` and `k` will be considered as parameters. It is also possible to use
both options simultaneously, allowing users to fully specify which symbols are
species and/or parameters:
```@example tut2
rn = @reaction_network begin
  @species X(t) Y(t)
  @parameters k
  k*X, Y --> 0
end
```
Here, `X` and `Y` are designated as species and `k` as a parameter.

The lists provided to the `@species` and `@parameters` options do not need to be extensive. Any symbol that appears in neither list will use the default option as determined by the macro. E.g. in the previous example, where we only want to change the default designation of `X` (making it a species rather than a parameter), we can simply write:
```@example tut2
rn = @reaction_network begin
  @species X(t)
  k*X, Y --> 0
end
```

Finally, note that the `@species` and `@parameters` options can also be used in
`begin ... end` block form, allowing more formatted lists of species/parameters:
```@example tut2
rn = @reaction_network begin
  @parameters begin
      d1
      d2
  end
  @species begin
      X1(t)
      X2(t)
  end
  d2, X2 --> 0
  d1, X1 --> 0
end
```
This can be especially useful when declaring default values for clarity of model
specification (see the next section).

## [Setting default values for initial conditions and parameters](@id dsl_description_defaults)
When using the `@species` and ` @parameters` macros to declare species and/or
parameters, one can also provide default initial conditions for each species and
values for each parameter:
```@example tut2
rn = @reaction_network begin
  @species X(t)=1.0
  @parameters p=1.0 d=0.1
  p, 0 --> X
  d, X --> ∅
end
```
This system can now be simulated without providing initial condition or
parameter vectors to the DifferentialEquations.jl solvers:
```@example tut2
using DifferentialEquations, Plots
u0 = []
tspan = (0.0, 10.0)
p = []
oprob = ODEProblem(rn, u0, tspan, p)
sol = solve(oprob)
plot(sol)
```

When providing default values, it is possible to do so for only a subset of the
species or parameters, in which case the rest can be specified when constructing
the problem type to solve:
```@example tut2
rn = @reaction_network begin
  @species X(t)
  @parameters p=1.0 d
  p, 0 --> X
  d, X --> 0
end

u0 = [:X => 1.0]
tspan = (0.0, 10.0)
p = [:d => .1]
oprob = ODEProblem(rn, u0, tspan, p)
sol = solve(oprob)
plot(sol)
```

Finally, default values can be overridden by passing mapping vectors to the
DifferentialEquations.jl problem being constructed. Only those initial conditions
or parameters for which we want to change their value from the default will need to be passed
```@example tut2
u0 = [:X => 1.0]
tspan = (0.0, 10.0)
p = [:p => 2.0, :d => .1]   # we change p to 2.0
oprob = ODEProblem(rn, u0, tspan, p)
sol = solve(oprob)
plot(sol)
```

## Constant/fixed species
It is possible to fix the amount of a species in a reaction. Without fixing
a species, a reaction could look like
```@example tut2
rn = @reaction_network begin
    k, X + Y --> 0
end
```

```@example tut2
ode_sys = convert(ODESystem, rn)
```

```@example tut2
equations(ode_sys)
```

Fixing a species could either be achieved by modifying the reaction specification
and specifying constant species explicitly as species as described
[above](@ref dsl_description_explicit_species), i.e.,
```@example tut2
rn = @reaction_network begin
    @species X(t)
    k * X, Y --> 0
end
```

```@example tut2
ode_sys = convert(ODESystem, rn)
```

```@example tut2
equations(ode_sys)
```

The species can of course also just be used as parameter - using the same modification
of the reaction, i.e.,
```@example tut2
rn = @reaction_network begin
    k * X, Y --> 0
end
```

```@example tut2
ode_sys = convert(ODESystem, rn)
```

```@example tut2
equations(ode_sys)
```

The same result can also be achieved by declaring a species as fixed/constant
without having to change the reaction itself, i.e.,
```@example tut2
rn = @reaction_network begin
    @parameters X [isconstantspecies = true]
    k, X + Y --> 0
end
```

```@example tut2
ode_sys = convert(ODESystem, rn)
```

```@example tut2
equations(ode_sys)
```

## [Setting initial conditions that depend on parameters](@id dsl_description_parametric_initial_conditions)
It is possible to set the initial condition of one (or several) species so that they depend on some system parameter. This is done in a similar way as default initial conditions, but giving the parameter instead of a value. When doing this, we also need to ensure that the initial condition parameter is a variable of the system:
```@example tut2
rn = @reaction_network begin
  @parameters X0
  @species X(t)=X0
  p, 0 --> X
  d, X --> ∅
end
```
We can now simulate the network without providing any initial conditions:
```@example tut2
u0 = []
tspan = (0.0, 10.0)
p = [:p => 2.0, :d => .1, :X0 => 1.0]
oprob = ODEProblem(rn, u0, tspan, p)
sol = solve(oprob)
plot(sol)
```

## Naming the generated `ReactionSystem`
ModelingToolkit uses system names to allow for compositional and hierarchical
models. To specify a name for the generated `ReactionSystem` via the
[`@reaction_network`](@ref) macro, just place the name before `begin`:
```@example tut2
rn = @reaction_network production_degradation begin
  p, ∅ --> X
  d, X --> ∅
end
ModelingToolkit.nameof(rn) == :production_degradation
```

## Pre-defined functions
Hill functions and a Michaelis-Menten function are pre-defined and can be used
as rate laws. Below, the pair of reactions within `rn1` are equivalent, as are
the pair of reactions within `rn2`:
```@example tut2
rn1 = @reaction_network begin
  hill(X,v,K,n), ∅ --> X
  v*X^n/(X^n+K^n), ∅ --> X
end
```
```@example tut2
rn2 = @reaction_network begin
  mm(X,v,K), ∅ --> X
  v*X/(X+K), ∅ --> X
end
```
Repressor Hill (`hillr`) and Michaelis-Menten (`mmr`) functions are also
provided:
```@example tut2
rn1 = @reaction_network begin
  hillr(X,v,K,n), ∅ --> X
  v*K^n/(X^n+K^n), ∅ --> X
end
```
```@example tut2
rn2 = @reaction_network begin
  mmr(X,v,K), ∅ --> X
  v*K/(X+K), ∅ --> X
end
```

Please see the API [Rate Laws](@ref api_rate_laws) section for more details.

## Including non-species variables
Non-species unknown variables can be specified in the DSL using the `@variables`
macro. These are declared similarly to species. For example,
```@example tut2
rn_with_volume = @reaction_network begin
  @variables V(t)
  k*V, 0 --> A
end
```
creates a network with one species
```@example tut2
species(rn_with_volume)
```
and one non-species
```@example tut2
nonspecies(rn_with_volume)
```
giving two unknown variables, always internally ordered by species and then
nonspecies:
```@example tut2
unknowns(rn_with_volume)
```

`rn_with_volume` could then be extended with constraint equations for how `V(t)`
evolves in time, see the [associated tutorial](@ref constraint_equations).

## Specifying alternative time variables and/or extra independent variables
While the DSL defaults to allowing `t` as the time variable, one can use the
`@ivs` macro to specify an alternative independent variable. For example, to
make `s` the default time variable one can say
```@example tut2
rn_with_s = @reaction_network begin
    @ivs s
    @variables V(s)
    @species B(s)
    k, A + V*B --> C
end
show(stdout, MIME"text/plain"(), rn_with_s)  # hide
```
where we see all unknowns are now functions of `s`.

Similarly, if one wants unknowns to be functions of more than one independent
variable, for example to encode a spatial problem, one can list more than one
variable, i.e. `@ivs t x y`. Here the first listed independent variable is
always chosen to represent time. For example,
```@example tut2
rn_with_many_ivs = @reaction_network begin
    @ivs s x
    @variables V1(s) V2(s,x)
    @species A(s) B(s,x)
    k, V1*A --> V2*B + C
end
show(stdout, MIME"text/plain"(), rn_with_many_ivs)  # hide
```
Here again `s` will be the time variable, and any inferred species, `C` in this
case, are made functions of both variables, i.e. `C(s, x)`.

## [Interpolation of Julia variables](@id dsl_description_interpolation_of_variables)
The DSL allows Julia variables to be interpolated for the network name, within
rate constant expressions, or for species/stoichiometry within reactions. Using
the lower-level symbolic interface we can then define symbolic variables and
parameters outside of the macro, which can then be used within expressions in
the DSL (see the [Programmatic Construction of Symbolic Reaction Systems](@ref programmatic_CRN_construction)
tutorial for details on the lower-level symbolic interface). For example,
```@example tut2
t = default_t()
@parameters k α
@species A(t)
spec = A
par = α
rate = k*A
name = :network
rn = @reaction_network $name begin
    $rate*B, 2*$spec + $par*B --> $spec + C
  end
```
As the parameters `k` and `α` were pre-defined and appeared via interpolation,
we did not need to declare them within the `@reaction_network` macro,
i.e. they are automatically detected as parameters:
```@example tut2
parameters(rn)
```
as are the species coming from interpolated variables
```@example tut2
species(rn)
```

!!! note
    When using interpolation, expressions like `2$spec` won't work; the
    multiplication symbol must be explicitly included like `2*$spec`.

## Including observables
Sometimes, one might want to include observable variables. These are variables that can be computed directly from the other system variables (rather than having their values implicitly given through some differential equation). These can be introduced through the `@observables` option.

Let us consider a simple example where two species ($X$ and $Y$) are produced and degraded at constant rates. They can also bind, forming a complex ($XY$). If we want to access the total amount of $X$ in the system we can create an observable that denotes this quantity ($Xtot = X + XY$). Here, we create observables for the total amount of $X$ and $Y$:
```@example obs1
using Catalyst # hide
rn = @reaction_network begin
  @observables begin
    Xtot ~ X + XY
    Ytot ~ Y + XY
  end
  (pX,dX), 0 <--> X
  (pY,dY), 0 <--> Y
  (kB,kD), X + Y <--> XY
end
```
The `@observables` option is followed by one line for each observable formula (enclosed by a `begin ... end` block). The left-hand sides indicate the observables' names, and the right-hand sides how their values are computed. The two sides are separated by a `~`. 

If we now simulate our model:
```@example obs1
using DifferentialEquations # hide
u0 = [:X => 0.0, :Y => 0.0, :XY => 0.0]
tspan = (0.0, 10.0)
ps = [:pX => 1.0, :dX => 0.2, :pY => 1.0, :dY => 0.5, :kB => 1.0, :kD => 0.2]
oprob = ODEProblem(rn, u0, tspan, ps)
sol = solve(oprob)
nothing # hide
```
we can index the solution using our observables (just like for [other variables](@ref simulation_structure_interfacing_solutions)). E.g. we can receive a vector with all $Xtot$ values using
```@example obs1
sol[:Xtot]
```
similarly, we can plot the values of $Xtot$ and $Ytot$ using
```@example obs1
plot(sol; idxs=[:Xtot, :Ytot], label=["Total X" "Total Y"])
```

If we only wish to provide a single observable, the `begin ... end` block is note required. E.g., to record only the total amount of $X$ we can use:
```@example obs1
using Catalyst # hide
rn = @reaction_network begin
  @observables Xtot ~ X + XY
  (pX,dX), 0 <--> X
  (pY,dY), 0 <--> Y
  (kB,kD), X + Y <--> XY
end
```

Finally, some general rules for creating observables:
- Observables can depend on any species, parameters, or variables, but not on other observables.
- All observables components appearing on the right side of the `~` must be declared somewhere (i.e., they cannot only appear as a part of the observables formula).
- Only a single `@observables` option block can be used in each `@reaction_network` call.
- The left-hand side of the observables expression must be a single symbol, indicating the observable's name.
- Metadata can, however, be provided, e.g through `@observables (Xtot, [description="Total amount of X"]) ~ X + XY`.
- The right-hand side of the observables expression can be any valid algebraic expression.
- Observables are (by default, but this can be changed) considered `variables` (and not `species`). This can be changed by e.g. pre-declaring them using the `@species` option:
```@example obs2
using Catalyst # hide
rn = @reaction_network begin
  @species Xtot(t)
  @observables Xtot ~ X1 + X2
  (k1,k2), X1 <--> X2
end
nothing # hide
```

## Incorporating (differential) equations into reaction network models
Some models cannot be purely described as reaction networks. E.g. consider the growth of a cell, where the rate of change in the cell's volume depends on some growth factor. Here, the cell's volume would be described by a normal ODE. Such equations can be incorporated into a model using the `@equations` option. Here, we create a model where a growth factor ($G$) is produced and degraded at a linear rates, and the rate of change in cell volume ($V$) is linear in the amount of growth factor:
```@example eqs1
using Catalyst #hide
rn = @reaction_network begin
  @equations begin
    D(V) ~ G
  end
  (p,d), 0 <--> G
end
```
Here, `D(V)` indicates the (time) derivative with respect to `D`. The differential equation left and right hand sides are separated by a `~`. The left-hand side should contain differential only, the right hand side can contain any algebraic expression.

We can check the differential equation corresponding to this reaction network using latexify:
```@example eqs1
using Latexify
latexify(rn; form=:ode)
```
We can also simulate it using the normal syntax
```@example eqs1
using DifferentialEquations, Plots # hide
u0 = [:G => 0.0, :V => 0.1]
ps = [:p => 1.0, :d => 0.5]
oprob = ODEProblem(rn, u0, (0.0, 1.0), ps)
sol = solve(oprob)
plot(sol)
```
Here, growth is indefinite. To improve the model, [a callback](@ref advanced_simulations_callbacks) can be used to half the volume (cell division) once some threshold is reached.

When creating differential equations this way, the subject of the differential is automatically inferred to be a variable, however, any component on the right-hand side must be declare somewhere in the macro. E.g. to add a scaling parameter ($k$), we must declare that $k$ is a parameter using the `@parameters` option:
```@example eqs1
rn = @reaction_network begin
  @parameters k
  @equations begin
    D(V) ~ k*G
  end
  (p,d), 0 <--> G
end
nothing #hide
```
If the differential does not appear isolated on the lhs, its subject variable must also be explicitly declared (as it is not inferred for these cases).

It is possible to add several equations to the model. In this case, each have a separate line. E.g. to keep track of a supply of nutrition ($N$) in the growth media, we can use:
```@example eqs1
rn = @reaction_network begin
  @equations begin
    D(V) ~ G
    D(N) ~ -G
  end
  (p,d), 0 <--> G
end
nothing #hide
```

When only a single equation is added, the `begin ... end` statement can be omitted. E.g., the first model can be declared equivalently using:
```@example eqs1
rn = @reaction_network begin
  @equations D(V) ~ G
  (p,d), 0 <--> G
end
nothing # hide
```
