# Catalyst.jl for Reaction Models

`Catalyst.jl` is a domain specific language (DSL) for easily specifying chemical
reactions and generating corresponding [`ModelingToolkit.ReactionSystem`](@ref)s
to encode the models. It helps users quickly build discrete stochastic and
differential equation based representations of biological and chemical models,
which can then be solved and analyzing using [SciML](https://sciml.ai) packages.
These tools allow one to define the models at a high level by specifying
reactions and rate constants, with the creation of the actual SciML `Problem`s
then handled by [ModelingToolkit](https://github.com/SciML/ModelingToolkit.jl).

## Installation

Catalyst can be installed through the Julia package manager:

```julia
]add Catalyst
using Catalyst
```

## The Reaction DSL - Basics
This section covers some of the basic syntax for building chemical reaction
network models. Examples showing how to both construct and solve network models
are provided in [Basic Chemical Reaction Network Examples](@ref).

#### Basic syntax

The `@reaction_network` macro allows the (symbolic) specification of reaction
networks with a simple format. Its input is a set of chemical reactions, and
from them it generates a [`ReactionSystem`](@ref) reaction network object. The
`ReactionSystem` can be used as input to `ODEProblem`, `SteadyStateProblem`,
`SDEProblem`, `JumpProblem` and more. `ReactionSystem`s can also be
incrementally extended as needed, allowing for programmatic construction of
networks and network composition.

The basic syntax is:

```julia
rn = @reaction_network begin
  2.0, X + Y --> XY               
  1.0, XY --> Z1 + Z2            
end
```

where each line corresponds to a chemical reaction. Each reaction consists of a
reaction rate (the expression on the left hand side of  `,`), a set of
substrates (the expression in-between `,` and `-->`), and a set of products (the
expression on the right hand side of `-->`). The substrates and the products may
contain one or more reactants, separated by `+`.  The naming convention for
these are the same as for normal variables in Julia.

The chemical reaction model is generated by the `@reaction_network` macro and
stored in the `rn` variable (a normal Julia variable, which does not need to be
called `rn`). The generated `ReactionSystem` can be converted to a differential
equation model via
```julia
osys = convert(ODESystem, rn)
oprob = ODEProblem(osys, Pair.(species(rn),u0), t, Pair.(params(rn),p))
```
or more directly via
```julia
oprob = ODEProblem(rn, u0, t, p)
```
See the detailed examples below. The generated differential equations use the
law of mass action. For the above example the ODEs are then

```math
\frac{d[X]}{dt} = -2 [X] [Y]\\
\frac{d[Y]}{dt} = -2 [X] [Y]\\
\frac{d[XY]}{dt} = 2 [X] [Y] - [XY]\\
\frac{d[Z1]}{dt}= [XY]\\
\frac{d[Z2]}{dt} = [XY]
```

#### Arrow variants
A variety of unicode arrows are accepted by the DSL in addition to `-->`. All of
these work:  `>`, `→` `↣`, `↦`, `⇾`, `⟶`, `⟼`, `⥟`, `⥟`, `⇀`, `⇁`. Backwards
arrows can also be used to write the reaction in the opposite direction. For example,
these three reactions are equivalent:
```julia
rn = @reaction_network begin
  1.0, X + Y --> XY               
  1.0, X + Y → XY      
  1.0, XY ← X + Y      
end
```
*Note, currently Julia's parser does not support `<--`, `<->` or `<-->`, so that
`-->` is the only supported plain text arrow.*

#### Using bi-directional arrows
Bi-directional unicode arrows can be used to designate a reaction that goes two
ways. These two models are equivalent:
```julia
rn = @reaction_network begin
  2.0, X + Y → XY             
  2.0, X + Y ← XY          
end
rn = @reaction_network begin
  2.0, X + Y ↔ XY               
end
```
If the reaction rates in the backward and forward directions are different they
can be designated in the following way:
```julia
rn = @reaction_network begin
  (2.0,1.0) X + Y ↔ XY               
end
```
which is identical to
```julia
rn = @reaction_network begin
  2.0, X + Y → XY             
  1.0, X + Y ← XY          
end
```

#### Combining several reactions in one line
Several similar reactions can be combined in one line by providing a tuple of
reaction rates and/or substrates and/or products. If several tuples are provided
they must all be of identical length. These pairs of reaction networks are all
identical:
```julia
rn1 = @reaction_network begin
  1.0, S → (P1,P2)               
end
rn2 = @reaction_network begin
  1.0, S → P1     
  1.0, S → P2
end
```
```julia
rn1 = @reaction_network begin
  (1.0,2.0), (S1,S2) → P             
end
rn2 = @reaction_network begin
  1.0, S1 → P     
  2.0, S2 → P
end
```
```julia
rn1 = @reaction_network begin
  (1.0,2.0,3.0), (S1,S2,S3) → (P1,P2,P3)        
end
rn2 = @reaction_network begin
  1.0, S1 → P1
  2.0, S2 → P2   
  3.0, S3 → P3  
end
```
This can also be combined with bi-directional arrows, in which case separate
tuples can be provided for the backward and forward reaction rates.
These reaction networks are identical
```julia
rn1 = @reaction_network begin
 (1.0,(1.0,2.0)), S ↔ (P1,P2)  
end
rn2 = @reaction_network begin
  1.0, S → P1
  1.0, S → P2
  1.0, P1 → S   
  2.0, P2 → S
end
```

#### Production and Destruction and Stoichiometry
Sometimes reactants are produced/destroyed from/to nothing. This can be
designated using either `0` or `∅`:
```julia
rn = @reaction_network begin
  2.0, 0 → X
  1.0, X → ∅
end
```
If several molecules of the same reactant are involved in a reaction, the
stoichiometry of a reactant in a reaction can be set using a number. Here two
molecules of species `X` form the dimer `X2`:
```julia
rn = @reaction_network begin
  1.0, 2X → X2
end
```
this corresponds to the differential equation:

```math
\frac{d[X]}{dt} = -[X]^2\\
\frac{d[X2]}{dt} = \frac{1}{2!} [X]^2
```

Other numbers than 2 can be used, and parenthesis can be used to reuse the same
stoichiometry for several reactants:
```julia
rn = @reaction_network begin
  1.0, X + 2(Y + Z) → XY2Z2
end
```

#### Variable reaction rates
Reaction rates do not need to be constant, but can also depend on the current
concentration of the various reactants (when e.g. one reactant can activate the
production of another). E.g. this is a valid notation:
```julia
rn = @reaction_network begin
  X, Y → ∅
end
```
and will have `Y` degraded at rate

```math
\frac{d[Y]}{dt} = -[X][Y]
```

Note that this is actually equivalent to the reaction
```julia
rn = @reaction_network begin
  1.0, X + Y → X
end
```
*except* that the latter will be classified as `ismassaction` and the former
will not, which can impact optimizations used in generating `JumpSystem`s. For
this reason, it is recommended to use the latter representation when possible.

Most expressions and functions are valid reaction rates, e.g:
```julia
rn = @reaction_network begin
  2.0*X^2, 0 → X + Y
  gamma(Y)/5, X → ∅
  pi*X/Y, Y → ∅
end
```
but please note that user defined functions cannot be called directly (see later
section [User defined functions in reaction rates](@ref)).

#### Defining parameters
Parameter values do not need to be set when the model is created. Components can
be designated as symbolic parameters by declaring them at the end:
```julia
rn = @reaction_network begin
  p, ∅ → X
  d, X → ∅
end p d
```
Parameters can only exist in the reaction rates (where they can be mixed with
reactants). All variables not declared after `end` will be treated as a chemical
species, and may lead to undefined behavior if unchanged by *all* reactions.

#### Pre-defined functions
Hill functions and a Michaelis-Menten function are pre-defined and can be used
as rate laws. Below, the pair of reactions within `rn1` are equivalent, as are
the pair of reactions within `rn2`:
```julia
rn1 = @reaction_network begin
  hill(X,v,K,n), ∅ → X
  v*X^n/(X^n+K^n), ∅ → X
end v K n
rn2 = @reaction_network begin
  mm(X,v,K), ∅ → X
  v*X/(X+K), ∅ → X
end v K
```
Repressor Hill (`hillr`) and Michaelis-Menten (`mmr`) functions are also
provided:
```julia
rn1 = @reaction_network begin
  hillr(X,v,K,n), ∅ → X
  v*K^n/(X^n+K^n), ∅ → X
end v K n
rn2 = @reaction_network begin
  mmr(X,v,K), ∅ → X
  v*K/(X+K), ∅ → X
end v K
```

## Model Simulation

Once created, a reaction network can be used as input to various problem types
which can be solved by
[DifferentialEquations.jl](https://github.com/JuliaDiffEq/DifferentialEquations.jl/),
and more broadly used within [SciML](https://sciml.ai) packages.

#### Deterministic simulations using ODEs
A reaction network can be used as input to an `ODEProblem` instead of a
function, using 
```julia
odeprob = ODEProblem(rn, args...; kwargs...) 
``` 
E.g. a model can be created and simulated using:
```julia
using DiffEqBase, OrdinaryDiffEq
rn = @reaction_network begin
  p, ∅ → X
  d, X → ∅
end p d
p = [1.0,2.0]
u0 = [0.1]
tspan = (0.,1.)
prob = ODEProblem(rn,u0,tspan,p)
sol = solve(prob, Tsit5())
```
Here the order of unknowns in `u0` and `p` matches the order that species and
parameters first appear within the DSL. They can also be determined by examining
the ordering within the `species(rn)` and `params(rn)` vectors, or accessed more
explicitly through the `speciesmap(rn)` and `paramsmap(rn)` dictionaries, which
map the ModelingToolkit `Variable`s corresponding to each species or parameter
to their integer id. Note, if no parameters are given in the `@reaction_network`
then `p` does not need to be provided.

To solve for a steady-state starting from the guess `u0`, one can use
```julia
using SteadyStateDiffEq
prob = SteadyStateProblem(rn,u0,p)
sol = solve(prob, SSRootfind())
```
or
```julia
prob = SteadyStateProblem(rn,u0,p)
sol = solve(prob, DynamicSS(Tsit5()))
```

#### Stochastic simulations using SDEs
In a similar way an SDE can be created using 
```julia
using StochasticDiffEq
sdeprob = SDEProblem(rn, args...; kwargs...)
```
In this case the chemical Langevin equations (as derived in Gillespie, J. Chem.
Phys. 2000) will be used to generate stochastic differential equations.

#### Stochastic simulations using discrete stochastic simulation algorithms
Instead of solving SDEs one can create a stochastic jump process model using
integer copy numbers and a discrete stochastic simulation algorithm (i.e.
Gillespie Method or Kinetic Monte Carlo). This can be done using:
```julia
using DiffEqJump
rn = @reaction_network begin
  p, ∅ → X
  d, X → ∅
end p d
p = [1.0,2.0]
u0 = [10]
tspan = (0.,1.)
discrete_prob = DiscreteProblem(rn, u0, tspan, p)
jump_prob = JumpProblem(rn, discrete_prob, Direct())
sol = solve(jump_prob, SSAStepper())
```
Here we used Gillespie's `Direct` method as the underlying stochastic simulation
algorithm.

#### Reaction rate laws used in simulations
In generating mathematical models from a [`ReactionSystem`](@ref), reaction
rates are treated as *microscopic* rates. That is, for a general mass action
reaction of the form $n_1 S_1 + n_2 S_2 + \dots n_M S_M \to \dots$ with
stoichiometric substrate coefficients $\{n_i\}_{i=1}^M$ and rate constant $k$,
the corresponding ODE rate law is taken to be
```math
k \prod_{i=1}^M \frac{(S_i)^{n_i}}{n_i!},
```
while the jump process transition rate (i.e. propensity function) is
```math
k \prod_{i=1}^M \frac{S_i (S_i-1) \dots (S_i-n_i+1)}{n_i!}.
```
For example, the ODE model of the reaction $2X + 3Y \to Z$ with rate constant $k$ would be
```math
\frac{dX}{dt} =  -2 k \frac{X^2}{2!} \frac{Y^3}{3!} = -k \frac{X^2 Y^3}{3!} \\
\frac{dY}{dt} =  -3 k \frac{X^2}{2!} \frac{Y^3}{3!} = -k \frac{X^2 Y^3}{4} \\
\frac{dZ}{dt} = k \frac{X^2}{2!} \frac{Y^3}{3!}.
```

## Basic Chemical Reaction Network Examples

#### Example: Birth-Death Process

```julia
rs = @reaction_network begin
  c1, X --> 2X
  c2, X --> 0
  c3, 0 --> X
end c1 c2 c3
p = (1.0,2.0,50.) # [c1,c2,c3]
tspan = (0.,4.)
u0 = [5.]         # [X]

# solve ODEs
oprob = ODEProblem(rs, u0, tspan, p)
osol  = solve(oprob, Tsit5())

# solve for Steady-States
ssprob = SteadyStateProblem(rs, u0, p)
sssol  = solve(ssprob, SSRootfind())

# solve SDEs
sprob = SDEProblem(rs, u0, tspan, p)
ssol  = solve(sprob, EM(), dt=.01)

# solve JumpProblem
u0 = [5]
dprob = DiscreteProblem(rs, u0, tspan, p)
jprob = JumpProblem(rs, dprob, Direct())
jsol = solve(jprob, SSAStepper())
```

#### Example: Michaelis-Menten Enzyme Kinetics

```julia
rs = @reaction_network begin
  c1, S + E --> SE
  c2, SE --> S + E
  c3, SE --> P + E
end c1 c2 c3
p = (0.00166,0.0001,0.1)   # [c1,c2,c3]
tspan = (0., 100.)
u0 = [301., 100., 0., 0.]  # [S,E,SE,P]

# solve ODEs
oprob = ODEProblem(rs, u0, tspan, p)
osol  = solve(oprob, Tsit5())

# solve JumpProblem
u0 = [301, 100, 0, 0] 
dprob = DiscreteProblem(rs, u0, tspan, p)
jprob = JumpProblem(rs, dprob, Direct())
jsol = solve(jprob, SSAStepper())
```

## The Reaction DSL - Advanced
This section covers some of the more advanced syntax and features for building
chemical reaction network models (still not very complicated!).

#### User defined functions in reaction rates
The reaction network DSL cannot "see" user defined functions. E.g. this is not
correct syntax:

```julia
myHill(x) = 2.0*x^3/(x^3+1.5^3)
rn = @reaction_network begin
  myHill(X), ∅ → X
end
```
However, it is possible to define functions in such a way that the DSL can see
them using the `@reaction_func` macro:

```julia
@reaction_func myHill(x) = 2.0*x^3/(x^3+1.5^3)
rn = @reaction_network begin
  myHill(X), ∅ → X
end
```

#### Ignoring mass action kinetics
While generally one wants the reaction rate to use the law of mass action, so
the reaction
```julia
rn = @reaction_network begin
  k, X → ∅
end k
```
occurs at the rate ``d[X]/dt = -k[X]``, it is possible to ignore this by using
any of the following non-filled arrows when declaring the reaction: `⇐`, `⟽`,
`⇒`, `⟾`, `⇔`, `⟺`. This means that the reaction

```julia
rn = @reaction_network begin
  k, X ⇒ ∅
end k
```

will occur at rate ``d[X]/dt = -k`` (which might become a problem since ``[X]``
will be degraded at a constant rate even when very small or equal to 0.

## The generated [`ReactionSystem`](@ref) and [`Reaction`](@ref)s
The `@reaction_network` macro generates a [`ReactionSystem`](@ref) object, which
has a number of fields that can be accessed directly or via the [Catalyst.jl
API](@ref) (the recommended route). Below we list these components, with the recommended
API method listed first:

* `species(rn)`, `states(rn)` and `rn.states` is a vector of all the chemical
  species within the system, each represented as a `ModelingToolkit.Variable`.
* `params(rn)`, `parameters(rn)` and `rn.ps` is a vector of all the parameters
  within the system, each represented as a `ModelingToolkit.Variable`.
* `reactions(rn)`, `equations(rn)` and `rn.eqs` is a vector of all the `Reaction`s within the system.
* `independent_variable(rn)` and `rn.iv` are the independent variable of the
  system , usually `t` for time, represented as a `ModelingToolkit.Variable`. 

Each `Reaction` within `reactions(rn)` has a number of subfields. For `rx` a `Reaction` we have
* `rx.substrates`, a vector of `ModelingToolkit.Operation`s storing each
  substrate variable.
* `rx.products`, a vector of `ModelingToolkit.Operation`s storing each product
  variable.
* `rx.substoich`, a vector storing the corresponding integer stoichiometry of
  each substrate species in `rx.substrates`.
* `rx.prodstoich`, a vector storing the corresponding integer stoichiometry of
  each product species in `rx.products`.
* `rx.rate`, a `ModelingToolkit.Operation` representing the reaction rate. e.g.
  for a reaction like `k*X, Y --> X+Y` we'd have `rate = k*X`.
* `rx.netstoich`, a vector of pairs mapping the `ModelingToolkit.Variable` for
  each species that changes numbers by the reaction to how much it changes. E.g.
  for `k, X + 2Y --> X + W` we'd have `rx.netstoich = [Y => -2, W => 1]`. 
* `rx.only_use_rate`, a boolean that is `true` if the reaction was made with
  non-filled arrows and should ignore mass action kinetics. `false` by default.

Empty `ReactionSystem`s can be generated via [`make_empty_network`](@ref) or
[`@reaction_network`](@ref) with no arguments. `ReactionSystem`s can be
programmatically extended using [`addspecies!`](@ref), [`addparam!`](@ref),
[`addreaction!`](@ref), [`@add_reactions`](@ref), or composed using `merge` and
`merge!`.

## Advanced Chemical Reaction Network Examples
For additional flexibility we can convert the generated `ReactionSystem` first
to another `ModelingToolkit.AbstractSystem`, e.g. an `ODESystem`, `SDESystem`,
`JumpSystem`, etc. These systems can then be used in problem generation. Please
also see the [ModelingToolkit](http://mtk.sciml.ai/stable/) docs, which give
many options for optimized problem generation (i.e. generating dense or sparse
Jacobians with or without threading and/or parallelization), creating LaTeX
representations for systems, etc.

Note, when generating problems from other system types, `u0` and `p` must
provide vectors of `Pair`s that map each `Variable` corresponding to a species
or parameter to their numerical value. E.g. for the Michaelis-Menten example
above we'd use
```julia
rs = @reaction_network begin
  c1, X --> 2X
  c2, X --> 0
  c3, 0 --> X
end c1 c2 c3
p     = (1.0,2.0,50.) 
tspan = (0.,4.)
u0    = [5.]   
osys  = convert(ODESystem, rs)
u0map = map((x,y) -> Pair(x,y), species(rs), u0)
pmap  = map((x,y) -> Pair(x,y), params(rs), p)
oprob = ODEProblem(osys, u0map, tspan, pmap)
sol   = solve(oprob, Tsit5())
```

#### Example: Disabling rescaling of reaction rates
As explained in the [Reaction rate laws used in simulations](@ref) section, for
a reaction such as `k, 2X --> 0`, the generated rate law will rescale the rate
constant, giving `k*X^2/2` instead of `k*X^2` for ODEs and `k*X*(X-1)/2` instead
of `k*X*(X-1)` for jumps. This can be disabled when directly `convert`ing a
[`ReactionSystem`](@ref). If `rn` is a generated [`ReactionSystem`](@ref) we can
do
```julia
osys = convert(ODESystem, rn; combinatoric_ratelaws=false)
```
Disabling these rescalings should work for all conversions of `ReactionSystem`s
to other `ModelingToolkit.AbstractSystem`s.

#### Example: Modifying generated ODEs by adding forcing
Conversion to other `ModelingToolkit.AbstractSystem`s allows the possibility to
modify the system with further terms that are difficult to encode as a chemical
reaction. For example, suppose we wish to add a forcing term, $10\sin(10t)$, to
the ODE for `dX/dt` above. We can do so as:
```julia
dXdteq = equations(osys)[1]           
t      = independent_variable(osys)()    
dXdteq = Equation(dXdteq.lhs, dXdteq.rhs + 10*sin(10*t))   
osys2  = ODESystem([dXdteq], t, states(osys), parameters(osys))
oprob  = ODEProblem(osys2, u0map, tspan, pmap)
osol   = solve(oprob, Tsit5())
```
We can add $e^{-X}$ to $dX/dt$ as a forcing term by
```julia
dXdteq = equations(osys)[1]           
@variables X
dXdteq = Equation(dXdteq.lhs, dXdteq.rhs + exp(-X))   
osys2  = ODESystem([dXdteq], t, states(osys), parameters(osys))
oprob  = ODEProblem(osys2, u0map, tspan, pmap)
osol   = solve(oprob, Tsit5())
```