# [Parameter Estimation](@id parameter_estimation)

The parameters of a model, generated by Catalyst, can be estimated using various
packages available in the Julia ecosystem. Refer
[here](https://docs.sciml.ai/Overview/stable/highlevels/inverse_problems/) for
more extensive information. Below follows a quick tutorial of how
[Optimization.jl](https://docs.sciml.ai/Optimization/stable/) can be used to fit
a parameter set to data.

First, we fetch the required packages.

```@example pe1
using Catalyst
using DifferentialEquations
using SciMLSensitivity
using Optimization

# for the ADAM optimizer
using OptimizationOptimisers
```

Next, we declare our model. For our example, we will use the Brusselator, a
simple oscillator.

```@example pe1
brusselator = @reaction_network begin
    A, ∅ → X
    1, 2X + Y → 3X
    B, X → Y
    1, X → ∅
end
p_real = [:A => 1.0, :B => 2.0]
```

We simulate our model, and from the simulation generate sampled data points
(with added noise), to which we will attempt to fit a parameter et.

```@example pe1
u0 = [:X => 1.0, :Y => 1.0]
tspan = (0.0, 30.0)

sample_times = range(tspan[1]; stop = tspan[2], length = 100)
prob = ODEProblem(brusselator, u0, tspan, p_real)
sol_real = solve(prob, Rosenbrock23(); tstops = sample_times)
sample_vals = Array(sol_real(sample_times))
sample_vals .*= (1 .+ 0.1 * rand(Float64, size(sample_vals)) .- 0.05)
nothing   # hide
```

We can plot the real solution, as well as the noisy samples.

```@example pe1
using Plots
default(; lw = 3, framestyle = :box, size = (800, 400))

plot(sol_real; legend = nothing, color = [:darkblue :darkred])
scatter!(sample_times, sample_vals'; color = [:blue :red], legend = nothing)
```

Next, we create a function to fit the parameters using the `ADAM` optimizer. For
a given initial estimate of the parameter values, `pinit`, this function will
fit parameter values, `p`, to our data samples. `tend` is used to indicate the
time interval over which to fit to the ODE solution.

```@example pe1
function optimise_p(pinit, tend)
    function loss(p, _)
        newtimes = filter(<=(tend), sample_times)
        newprob = remake(prob; tspan = (0.0, tend), p = p)
        sol = Array(solve(newprob, Rosenbrock23(); saveat = newtimes))
        loss = sum(abs2, sol .- sample_vals[:, 1:size(sol, 2)])
        return loss, sol
    end

    # optimize for the parameters that minimize the loss
    optf = OptimizationFunction(loss, Optimization.AutoZygote())
    optprob = OptimizationProblem(optf, pinit)
    sol = solve(optprob, ADAM(0.1); maxiters = 100)

    # return the parameters we found
    return sol.u
end
nothing # hide
```

Next, we will fit a parameter set to the data on the interval `(0, 10)`.

```@example pe1
p_estimate = optimise_p([5.0, 5.0], 10.0)
```

We can compare this to the real solution, as well as the sample data

```@example pe1
newprob = remake(prob; tspan = (0.0, 10.0), p = p_estimate)
sol_estimate = solve(newprob, Rosenbrock23())
plot(sol_real; color = [:blue :red], label = ["X real" "Y real"], linealpha = 0.2)
scatter!(sample_times, sample_vals'; color = [:blue :red],
         label = ["Samples of X" "Samples of Y"], alpha = 0.4)
plot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,
      label = ["X estimated" "Y estimated"], xlimit = tspan)
```

Next, we use this parameter estimate as the input to the next iteration of our
fitting process, this time on the interval `(0, 20)`.

```@example pe1
p_estimate = optimise_p(p_estimate, 20.0)
newprob = remake(prob; tspan = (0.0, 20.0), p = p_estimate)
sol_estimate = solve(newprob, Rosenbrock23())
plot(sol_real; color = [:blue :red], label = ["X real" "Y real"], linealpha = 0.2)
scatter!(sample_times, sample_vals'; color = [:blue :red],
         label = ["Samples of X" "Samples of Y"], alpha = 0.4)
plot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,
      label = ["X estimated" "Y estimated"], xlimit = tspan)
```

Finally, we use this estimate as the input to fit a parameter set on the full
time interval of the sampled data.

```@example pe1
p_estimate = optimise_p(p_estimate, 30.0)

newprob = remake(prob; tspan = (0.0, 30.0), p = p_estimate)
sol_estimate = solve(newprob, Rosenbrock23())
plot(sol_real; color = [:blue :red], label = ["X real" "Y real"], linealpha = 0.2)
scatter!(sample_times, sample_vals'; color = [:blue :red],
         label = ["Samples of X" "Samples of Y"], alpha = 0.4)
plot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,
      label = ["X estimated" "Y estimated"], xlimit = tspan)
```

The final parameter estimate is then

```@example pe1
p_estimate
```

which is close to the actual parameters of `[1.0, 2.0]`.

## Why we fit the parameters in iterations.

The reason we chose to fit the model on a smaller interval to begin with, and
then extend the interval, is to avoid getting stuck in a local minimum. Here
specifically, we chose our initial interval to be smaller than a full cycle of
the oscillation. If we had chosen to fit a parameter set on the full interval
immediately we would have received an inferior solution.

```@example pe1
p_estimate = optimise_p([5.0, 5.0], 30.0)

newprob = remake(prob; tspan = (0.0, 30.0), p = p_estimate)
sol_estimate = solve(newprob, Rosenbrock23())
plot(sol_real; color = [:blue :red], label = ["X real" "Y real"], linealpha = 0.2)
scatter!(sample_times, sample_vals'; color = [:blue :red],
         label = ["Samples of X" "Samples of Y"], alpha = 0.4)
plot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,
      label = ["X estimated" "Y estimated"], xlimit = tspan)
```
