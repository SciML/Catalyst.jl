# [Introduction to Catalyst](@id introduction_to_catalyst)

In this tutorial we provide an introduction to using Catalyst to specify
chemical reaction networks, and then to solve ODE, jump, and SDE models
generated from them[^1]. At the end we show what mathematical rate laws and
transition rate functions (i.e. intensities or propensities) are generated by
Catalyst for ODE, SDE and jump process models. The [Mathematical Models Catalyst
can Generate](@ref math_models_in_catalyst) documentation illustrates the
abstract mathematical models Catalyst reaction models can be converted to,
but please note it assumes one has already read this tutorial as a
prerequisite.

We begin by installing Catalyst and any needed packages into a new environment.
This step can be skipped if you have already installed them in your current,
active environment:

```julia
using Pkg

# name of the environment
Pkg.activate("catalyst_introduction")

# packages we will use in this tutorial
Pkg.add("Catalyst")
Pkg.add("OrdinaryDiffEqTsit5")
Pkg.add("Plots")
Pkg.add("Latexify")
Pkg.add("JumpProcesses")
Pkg.add("StochasticDiffEq")
```

We next load the basic packages we'll need for our first example:

```@example tut1
using Catalyst, OrdinaryDiffEqTsit5, Plots, Latexify
```

Let's start by using the Catalyst [`@reaction_network`](@ref) macro to specify a
simple chemical reaction network: the well-known repressilator. We first construct
the reaction network. The basic types of arrows and predefined rate laws one can
use are discussed in detail within the tutorial, [The Reaction DSL](@ref
dsl_description). Here, we use a mix of first order, zero order, and repressive
Hill function rate laws. Note, $\varnothing$ corresponds to the empty state, and
is used for zeroth order production and first order degradation reactions:

```@example tut1
rn = @reaction_network Repressilator begin
    hillr(P₃,α,K,n), ∅ --> m₁
    hillr(P₁,α,K,n), ∅ --> m₂
    hillr(P₂,α,K,n), ∅ --> m₃
    (δ,γ), m₁ <--> ∅
    (δ,γ), m₂ <--> ∅
    (δ,γ), m₃ <--> ∅
    β, m₁ --> m₁ + P₁
    β, m₂ --> m₂ + P₂
    β, m₃ --> m₃ + P₃
    μ, P₁ --> ∅
    μ, P₂ --> ∅
    μ, P₃ --> ∅
end
show(stdout, MIME"text/plain"(), rn) # hide
```

showing that we've created a new network model named `Repressilator` with the
listed chemical species and unknowns. [`@reaction_network`](@ref) returns a
[`ReactionSystem`](@ref), which we saved in the `rn` variable. It can
be converted to a variety of other mathematical models represented as
`ModelingToolkit.AbstractSystem`s, or analyzed in various ways using the
[Catalyst.jl API](@ref api). For example, to see the chemical species, parameters,
and reactions we can use

```@example tut1
species(rn)
```

```@example tut1
parameters(rn)
```

and

```@example tut1
reactions(rn)
```

We can also use Latexify to see the corresponding reactions in Latex, which shows what
the `hillr` terms mathematically correspond to

```julia
latexify(rn)
```

```@example tut1
rn #hide
```

Catalyst also has functionality for visualizing networks using the [Makie](https://docs.makie.org/stable/)
plotting ecosystem. The relevant packages to load are Catalyst, GraphMakie, NetworkLayout, and a Makie backend
such as CairoMakie. Doing so and then using the `plot_network` function allows us to
visualize the network:

```@example tut1
using Catalyst
import CairoMakie, GraphMakie, NetworkLayout
g = plot_network(rn)
```

The network graph shows a variety of information, representing each species as a
blue node, and each reaction as an green node. Black arrows from species to
reactions indicate reactants, and are labelled with their input stoichiometry.
Similarly, black arrows from reactions to species indicate products, and are
labelled with their output stoichiometry. In contrast, red arrows from a species
to reactions indicate the species is used within the reactions' rate
expressions. For the repressilator, the reactions

```julia
hillr(P₃,α,K,n), ∅ --> m₁
hillr(P₁,α,K,n), ∅ --> m₂
hillr(P₂,α,K,n), ∅ --> m₃
```

have rates that depend on the proteins, and hence lead to red arrows from each
`Pᵢ`.

Note, from the REPL or scripts one can always use Makie's `save` function to save
the graph.

```julia
save("repressilator_graph.png", g)
```

## [Mass action ODE models](@id introduction_to_catalyst_massaction_ode)

Let's now use our `ReactionSystem` to generate and solve a corresponding mass
action ODE model. We first convert the system to a `ModelingToolkit.ODESystem`
by

```@example tut1
odesys = convert(ODESystem, rn)
```

(Here Latexify is used automatically to display `odesys` in Latex within Markdown
documents or notebook environments like Pluto.jl.)

Before we can solve the ODEs, we need to specify the values of the parameters in
the model, the initial condition, and the time interval to solve the model on.
To do this we need to build mappings from the symbolic parameters and the
species to the corresponding numerical values for parameters and initial
conditions. We can build such mappings in several ways. One is to use Julia
`Symbols` to specify the values like

```@example tut1
pmap  = (:α => .5, :K => 40, :n => 2, :δ => log(2)/120,
         :γ => 5e-3, :β => log(2)/6, :μ => log(2)/60)
u₀map = [:m₁ => 0., :m₂ => 0., :m₃ => 0., :P₁ => 20., :P₂ => 0., :P₃ => 0.]
nothing   # hide
```

Alternatively, we can use ModelingToolkit-based symbolic species variables to
specify these mappings like

```@example tut1
psymmap  = (rn.α => .5, rn.K => 40, rn.n => 2, rn.δ => log(2)/120,
    rn.γ => 5e-3, rn.β => 20*log(2)/120, rn.μ => log(2)/60)
u₀symmap = [rn.m₁ => 0., rn.m₂ => 0., rn.m₃ => 0., rn.P₁ => 20.,
    rn.P₂ => 0., rn.P₃ => 0.]
nothing   # hide
```

Knowing one of the preceding mappings we can set up the `ODEProblem` we want to
solve:

```@example tut1
# time interval to solve on
tspan = (0., 10000.)

# create the ODEProblem we want to solve
oprob = ODEProblem(rn, u₀map, tspan, pmap)
nothing   # hide
```

By passing `rn` directly to the `ODEProblem`, Catalyst has to
(internally) call `convert(ODESystem, rn)` again to generate the
symbolic ODEs. We could instead pass `odesys` directly like

```@example tut1
odesys = complete(odesys)
oprob2 = ODEProblem(odesys, u₀map, tspan, pmap)
nothing   # hide
```

`oprob` and `oprob2` are functionally equivalent, each representing the same
underlying problem.

At this point we are all set to solve the ODEs. We can now use any ODE solver
from within the
[OrdinaryDiffEq.jl](https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/)
package. We'll use the recommended default explicit solver, `Tsit5()`, and then
plot the solutions:

```@example tut1
sol = solve(oprob, Tsit5(), saveat=10.0)
plot(sol)
```

We see the well-known oscillatory behavior of the repressilator! For more on the
choices of ODE solvers, see the [OrdinaryDiffEq.jl
documentation](https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/).

!!! note
    In the above example we used `odesys = complete(odesys)` to mark the `ODESystem` as *complete*, indicating to Catalyst and ModelingToolkit that these models are finalized. This must be done before any system is given as input to a `convert` call or some problem type. `ReactionSystem` models created through the `@reaction_network` DSL, like `rn` above, are always marked as complete when generated. Hence `complete` does not need to be called on them. Symbolically generated `ReactionSystem`s, `ReactionSystem`s generated via the `@network_component` macro, and any ModelingToolkit system generated by `convert` always needs to be manually marked as `complete` as we do for `odesys` above. An expanded description on *completeness* can be found [here](@ref completeness_note).

---

## Stochastic simulation algorithms (SSAs) for stochastic chemical kinetics

Let's now look at a stochastic chemical kinetics model of the repressilator,
modeling it with jump processes. Here, we will construct a
[JumpProcesses](https://docs.sciml.ai/JumpProcesses/stable/) `JumpProblem` that uses
Gillespie's `Direct` method, and then solve it to generate one realization of
the jump process:

```@example tut1
# imports the JumpProcesses packages
using JumpProcesses

# redefine the initial condition to be integer valued
u₀map = [:m₁ => 0, :m₂ => 0, :m₃ => 0, :P₁ => 20, :P₂ => 0, :P₃ => 0]

# next we process the inputs for the jump problem
jinputs = JumpInputs(rn, u₀map, tspan, pmap)

# now, we create a JumpProblem, and let a solver be chosen for us automatically
# in this case Gillespie's Direct Method will be selected
jprob = JumpProblem(jinputs)

# now, let's solve and plot the jump process:
sol = solve(jprob)
plot(sol)
Catalyst.PNG(plot(sol; fmt = :png, dpi = 200)) # hide
```

We see that oscillations remain, but become much noisier. Note, in constructing
the `JumpProblem` we could have specified any of the SSAs that are part of
JumpProcesses instead of letting JumpProcesses auto-select a solver, see the
list of SSAs (i.e., constant rate jump aggregators) in the
[documentation](https://docs.sciml.ai/JumpProcesses/stable/jump_types/#Jump-Aggregators-for-Exact-Simulation).
For example, to choose the `SortingDirect` method we would instead say

```@example tut1
jprob = JumpProblem(jinputs, SortingDirect())
sol = solve(jprob)
plot(sol)
Catalyst.PNG(plot(sol; fmt = :png, dpi = 200)) # hide
```

Common questions that arise in using the JumpProcesses SSAs (i.e. Gillespie methods)
are collated in the [JumpProcesses FAQ](https://docs.sciml.ai/JumpProcesses/stable/faq/).

---

## Chemical Langevin equation (CLE) stochastic differential equation (SDE) models

At an intermediate physical scale between macroscopic ODE models and microscopic
stochastic chemical kinetics models lies the CLE, given by a system of SDEs that
add to each ODE above a noise term. As the repressilator has species that get
very close to zero in size, it is not a good candidate to model with the CLE
(where solutions can then go negative and become unphysical). Let's create a
simpler reaction network for a birth-death process that will stay non-negative:

```@example tut1
bdp = @reaction_network begin
  c₁, X --> 2X
  c₂, X --> 0
  c₃, 0 --> X
end
p = (:c₁ => 1.0, :c₂ => 2.0, :c₃ => 50.)
u₀ = [:X => 5.]
tspan = (0.,4.)
nothing   # hide
```

The corresponding Chemical Langevin Equation SDE is then

```math
dX(t) = \left( c_1 X\left( t \right) - c_2 X\left( t \right) + c_3 \right) dt + \sqrt{c_1 X(t)} dW_1(t) - \sqrt{c_2 X(t)} dW_2(t) + \sqrt{c_3} dW_3(t)
```

where each $W_i(t)$ denotes an independent Brownian Motion. We can solve the CLE
model by creating an `SDEProblem` and solving it similarly to what we did for ODEs
above:

```@example tut1
# imports the StochasticDiffEq package for SDE simulations
using StochasticDiffEq

# SDEProblem for CLE
sprob = SDEProblem(bdp, u₀, tspan, p)

# solve and plot, tstops is used to specify enough points
# that the plot looks well-resolved
sol = solve(sprob, LambaEM(), tstops = range(0., step = 4e-3, length = 1001))
plot(sol)
```

We again have complete freedom to select any of the
StochasticDiffEq.jl SDE solvers, see the
[documentation](https://docs.sciml.ai/stable/modules/DiffEqDocs/solvers/sde_solve/).

---

## Specifying a complete model via the DSL

In the previous examples we specified initial conditions and parameter values
via mappings that were constructed after building our [`ReactionSystem`](@ref).
Catalyst also supports specifying default values for these during
`ReactionSystem` construction. For example, for the last SDE example we
could have also built and simulated the complete model using the DSL like

```@example tut1
bdp2 = @reaction_network begin
    @parameters c₁ = 1.0 c₂ = 2.0 c₃ = 50.0
    @species X(t) = 5.0
    c₁, X --> 2X
    c₂, X --> 0
    c₃, 0 --> X
end
tspan = (0., 4.)
sprob2 = SDEProblem(bdp2, [], tspan)
```

Let's now simulate both models, starting from the same random number generator
seed, and check we get the same solutions

```@example tut1
using Random
Random.seed!(1)
sol = solve(sprob, LambaEM(), tstops = range(0., step = 4e-3, length = 1001))
p1 = plot(sol)
Random.seed!(1)
sol2 = solve(sprob2, LambaEM(), tstops = range(0., step = 4e-3, length = 1001))
p2 = plot(sol2)
plot(p1, p2, layout = (2,1))
```

For details on what information can be specified via the DSL see the [The
Reaction DSL](@ref dsl_description) tutorial.

---

## [Reaction rate laws used in simulations](@id introduction_to_catalyst_ratelaws)

In generating mathematical models from a [`ReactionSystem`](@ref), reaction
rates are treated as *microscopic* rates. That is, for a general mass action
reaction of the form $n_1 S_1 + n_2 S_2 + \dots n_M S_M \to \dots$ with
stoichiometric substrate coefficients $\{n_i\}_{i=1}^M$ and rate constant $k$,
the corresponding ODE and SDE rate laws are taken to be

```math
k \prod_{i=1}^M \frac{(S_i)^{n_i}}{n_i!},
```

while the jump process transition rate (i.e., the propensity or intensity
function) is

```math
k \prod_{i=1}^M \frac{S_i (S_i-1) \dots (S_i-n_i+1)}{n_i!}.
```

For example, the rate law of the reaction $2X + 3Y \to Z$ with rate constant $k$ would be

```math
k \frac{X^2}{2!} \frac{Y^3}{3!} \\
```

giving the ODE model

```math
\begin{align*}
\frac{dX}{dt} &=  -2 k \frac{X^2}{2!} \frac{Y^3}{3!}, &
\frac{dY}{dt} &=  -3 k \frac{X^2}{2!} \frac{Y^3}{3!}, &
\frac{dZ}{dt} &= k \frac{X^2}{2!} \frac{Y^3}{3!}.
\end{align*}
```

This implicit rescaling of rate constants can be disabled through explicit
conversion of a [`ReactionSystem`](@ref) to another system via
[`Base.convert`](@ref) using the `combinatoric_ratelaws=false` keyword
argument, i.e.

```julia
rn = @reaction_network ...
convert(ODESystem, rn; combinatoric_ratelaws=false)
```

For the previous example using this keyword argument would give the rate law

```math
k X^2 Y^3
```

and the ODE model

```math
\begin{align*}
\frac{dX}{dt} &=  -2 k X^2 Y^3, &
\frac{dY}{dt} &=  -3 k X^2 Y^3, &
\frac{dZ}{dt} &= k X^2 Y^3.
\end{align*}
```

A more detailed summary of the precise mathematical equations Catalyst can generate is available in the [Mathematical Models Catalyst can Generate](@ref math_models_in_catalyst) documentation.

---

## Notes

1. For each of the preceding models we converted the `ReactionSystem` to, i.e.,
   ODEs, jumps, or SDEs, we had two paths for conversion:

    a. Convert to the corresponding ModelingToolkit system and then use it in
       creating the corresponding problem.

    b. Directly create the desired problem type from the `ReactionSystem`.

   The latter is more convenient, however, the former will be more efficient if
   one needs to repeatedly create the associated `Problem`.
2. ModelingToolkit offers many options for optimizing the generated ODEs and
   SDEs, including options to build functions for evaluating Jacobians and/or
   multithreaded versions of derivative evaluation functions. See the options
   for
   [`ODEProblem`s](https://mtk.sciml.ai/dev/systems/ODESystem/#DiffEqBase.ODEProblem)
   and
   [`SDEProblem`s](https://mtk.sciml.ai/dev/systems/SDESystem/#DiffEqBase.SDEProblem).

---

## References

[^1]: [Torkel E. Loman, Yingbo Ma, Vasily Ilin, Shashi Gowda, Niklas Korsbo, Nikhil Yewale, Chris Rackauckas, Samuel A. Isaacson, *Catalyst: Fast and flexible modeling of reaction networks*, PLOS Computational Biology (2023).](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1011530)
