<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Network Analysis in Catalyst · Catalyst.jl</title><meta name="title" content="Network Analysis in Catalyst · Catalyst.jl"/><meta property="og:title" content="Network Analysis in Catalyst · Catalyst.jl"/><meta property="twitter:title" content="Network Analysis in Catalyst · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/model_creation/network_analysis/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/model_creation/network_analysis/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/model_creation/network_analysis/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><span class="tocitem">Model Creation and Properties</span><ul><li><a class="tocitem" href="../dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../conservation_laws/">Working with conservation laws</a></li><li><a class="tocitem" href="../parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../reactionsystem_content_accessing/">Accessing model properties</a></li><li class="is-active"><a class="tocitem" href>Network Analysis in Catalyst</a><ul class="internal"><li><a class="tocitem" href="#network_analysis_repressilator_representation"><span>Network representation of the Repressilator <code>ReactionSystem</code></span></a></li><li><a class="tocitem" href="#network_analysis_matrix_vector_representation"><span>Matrix-vector reaction rate equation representation</span></a></li><li><a class="tocitem" href="#network_analysis_reaction_complexes"><span>Reaction complex representation</span></a></li><li><a class="tocitem" href="#network_analysis_structural_aspects"><span>Aspects of reaction network structure</span></a></li><li><a class="tocitem" href="#network_analysis_caching_properties"><span>Caching of Network Properties in <code>ReactionSystems</code></span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Model simulation</span><ul><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for performant ODE simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for performant SDE simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Model simulation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/examples/periodic_events_simulation/">Modelling a periodic event during ODE and jump simulations</a></li></ul></li></ul></li><li><span class="tocitem">Steady state analysis</span><ul><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><span class="tocitem">Spatial Modelling</span><ul><li><a class="tocitem" href="../../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial jump simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model Creation and Properties</a></li><li class="is-active"><a href>Network Analysis in Catalyst</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Network Analysis in Catalyst</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/model_creation/network_analysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="network_analysis"><a class="docs-heading-anchor" href="#network_analysis">Network Analysis in Catalyst</a><a id="network_analysis-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis" title="Permalink"></a></h1><p>In this tutorial we introduce several of the Catalyst API functions for network analysis. A complete summary of the exported functions is given in the API section <a href="https://docs.sciml.ai/Catalyst/stable/api/catalyst_api/#Network-Analysis-and-Representations"><code>Network-Analysis-and-Representations</code></a>.</p><p>Note, currently API functions for network analysis and conservation law analysis do not work with constant species (currently only generated by SBMLToolkit).</p><h2 id="network_analysis_repressilator_representation"><a class="docs-heading-anchor" href="#network_analysis_repressilator_representation">Network representation of the Repressilator <code>ReactionSystem</code></a><a id="network_analysis_repressilator_representation-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis_repressilator_representation" title="Permalink"></a></h2><p>We first load Catalyst and construct our model of the repressilator</p><pre><code class="language-julia hljs">using Catalyst
repressilator = @reaction_network Repressilator begin
       hillr(P₃,α,K,n), ∅ --&gt; m₁
       hillr(P₁,α,K,n), ∅ --&gt; m₂
       hillr(P₂,α,K,n), ∅ --&gt; m₃
       (δ,γ), m₁ &lt;--&gt; ∅
       (δ,γ), m₂ &lt;--&gt; ∅
       (δ,γ), m₃ &lt;--&gt; ∅
       β, m₁ --&gt; m₁ + P₁
       β, m₂ --&gt; m₂ + P₂
       β, m₃ --&gt; m₃ + P₃
       μ, P₁ --&gt; ∅
       μ, P₂ --&gt; ∅
       μ, P₃ --&gt; ∅
end</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightarrow{\frac{K^{n} \alpha}{K^{n} + P_3^{n}}} \mathrm{m_1} \\
\varnothing &amp;\xrightarrow{\frac{K^{n} \alpha}{P_1^{n} + K^{n}}} \mathrm{m_2} \\
\varnothing &amp;\xrightarrow{\frac{K^{n} \alpha}{K^{n} + P_2^{n}}} \mathrm{m_3} \\
\mathrm{m_1} &amp;\xrightleftharpoons[\gamma]{\delta} \varnothing \\
\mathrm{m_2} &amp;\xrightleftharpoons[\gamma]{\delta} \varnothing \\
\mathrm{m_3} &amp;\xrightleftharpoons[\gamma]{\delta} \varnothing \\
\mathrm{m_1} &amp;\xrightarrow{\beta} \mathrm{m_1} + \mathrm{P_1} \\
\mathrm{m_2} &amp;\xrightarrow{\beta} \mathrm{m_2} + \mathrm{P_2} \\
\mathrm{m_3} &amp;\xrightarrow{\beta} \mathrm{m_3} + \mathrm{P_3} \\
\mathrm{P_1} &amp;\xrightarrow{\mu} \varnothing \\
\mathrm{P_2} &amp;\xrightarrow{\mu} \varnothing \\
\mathrm{P_3} &amp;\xrightarrow{\mu} \varnothing  
 \end{align*}
 \]</p><p>In the <a href="../../introduction_to_catalyst/introduction_to_catalyst/#introduction_to_catalyst">Introduction to Catalyst</a> tutorial we showed how the above network could be visualized as a species-reaction graph. There, species are represented by the nodes of the graph and edges show the reactions in which a given species is a substrate or product.</p><pre><code class="language-julia hljs">g = Graph(repressilator)</code></pre><p><img src="../../assets/repressilator.svg" alt="Repressilator solution"/></p><p>We also showed in the <a href="../../introduction_to_catalyst/introduction_to_catalyst/#introduction_to_catalyst">Introduction to Catalyst</a> tutorial that the reaction rate equation ODE model for the repressilator is</p><p class="math-container">\[\begin{aligned}
\frac{dm_1(t)}{dt} =&amp; \frac{\alpha K^{n}}{K^{n} + \left( {P_3}\left( t \right) \right)^{n}} - \delta {m_1}\left( t \right) + \gamma \\
\frac{dm_2(t)}{dt} =&amp; \frac{\alpha K^{n}}{K^{n} + \left( {P_1}\left( t \right) \right)^{n}} - \delta {m_2}\left( t \right) + \gamma \\
\frac{dm_3(t)}{dt} =&amp; \frac{\alpha K^{n}}{K^{n} + \left( {P_2}\left( t \right) \right)^{n}} - \delta {m_3}\left( t \right) + \gamma \\
\frac{dP_1(t)}{dt} =&amp; \beta {m_1}\left( t \right) - \mu {P_1}\left( t \right) \\
\frac{dP_2(t)}{dt} =&amp; \beta {m_2}\left( t \right) - \mu {P_2}\left( t \right) \\
\frac{dP_3(t)}{dt} =&amp; \beta {m_3}\left( t \right) - \mu {P_3}\left( t \right)
\end{aligned}\]</p><h2 id="network_analysis_matrix_vector_representation"><a class="docs-heading-anchor" href="#network_analysis_matrix_vector_representation">Matrix-vector reaction rate equation representation</a><a id="network_analysis_matrix_vector_representation-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis_matrix_vector_representation" title="Permalink"></a></h2><p>In general, reaction rate equation (RRE) ODE models for chemical reaction networks can be represented as a first-order system of ODEs in a compact matrix-vector notation. Suppose we have a reaction network with <span>$K$</span> reactions and <span>$M$</span> species, labelled by the state vector</p><p class="math-container">\[\mathbf{x}(t) = \begin{pmatrix} x_1(t) \\ \vdots \\ x_M(t)) \end{pmatrix}.\]</p><p>For the repressilator, <span>$\mathbf{x}(t)$</span> is just</p><pre><code class="language-julia hljs">x = species(repressilator)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 m₁(t)
 m₂(t)
 m₃(t)
 P₁(t)
 P₂(t)
 P₃(t)</code></pre><p>The RRE ODEs satisfied by <span>$\mathbf{x}(t)$</span> are then</p><p class="math-container">\[\frac{d\mathbf{x}}{dt} = N \mathbf{v}(\mathbf{x}(t),t),\]</p><p>where <span>$N$</span> is a constant <span>$M$</span> by <span>$K$</span> matrix with <span>$N_{m k}$</span> the net stoichiometric coefficient of species <span>$m$</span> in reaction <span>$k$</span>. <span>$\mathbf{v}(\mathbf{x}(t),t)$</span> is the rate law vector, with <span>$v_k(\mathbf{x}(t),t)$</span> the rate law for the <span>$k$</span>th reaction. For example, for the first reaction of the repressilator above, the rate law is</p><p class="math-container">\[v_1(\mathbf{x}(t),t) = \frac{\alpha K^{n}}{K^{n} + \left( P_3(t) \right)^{n}}.\]</p><p>We can calculate each of these in Catalyst via</p><pre><code class="language-julia hljs">N = netstoichmat(repressilator)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6×15 Matrix{Int64}:
 1  0  0  -1  1   0  0   0  0  0  0  0   0   0   0
 0  1  0   0  0  -1  1   0  0  0  0  0   0   0   0
 0  0  1   0  0   0  0  -1  1  0  0  0   0   0   0
 0  0  0   0  0   0  0   0  0  1  0  0  -1   0   0
 0  0  0   0  0   0  0   0  0  0  1  0   0  -1   0
 0  0  0   0  0   0  0   0  0  0  0  1   0   0  -1</code></pre><p>and by using the <a href="../../api/#Catalyst.oderatelaw"><code>oderatelaw</code></a> function</p><pre><code class="language-julia hljs">rxs = reactions(repressilator)
ν = oderatelaw.(rxs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">15-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 Catalyst.hillr(P₃(t), α, K, n)
 Catalyst.hillr(P₁(t), α, K, n)
 Catalyst.hillr(P₂(t), α, K, n)
 m₁(t)*δ
 γ
 m₂(t)*δ
 γ
 m₃(t)*δ
 γ
 m₁(t)*β
 m₂(t)*β
 m₃(t)*β
 P₁(t)*μ
 P₂(t)*μ
 P₃(t)*μ</code></pre><p>Note, as <a href="../../api/#Catalyst.oderatelaw"><code>oderatelaw</code></a> takes just one reaction as input we use broadcasting to apply it to each element of <code>rxs</code>.</p><p>Let&#39;s check that this really gives the same ODEs as Catalyst. Here is what Catalyst generates by converting to an <code>ODESystem</code></p><pre><code class="language-julia hljs">osys = convert(ODESystem, repressilator)

# for display purposes we just pull out the right side of the equations
odes = [eq.rhs for eq in equations(osys)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 Catalyst.hillr(P₃(t), α, K, n) + γ - m₁(t)*δ
 Catalyst.hillr(P₁(t), α, K, n) + γ - m₂(t)*δ
 Catalyst.hillr(P₂(t), α, K, n) + γ - m₃(t)*δ
 -P₁(t)*μ + m₁(t)*β
 m₂(t)*β - P₂(t)*μ
 -P₃(t)*μ + m₃(t)*β</code></pre><p>whereas our matrix-vector representation gives</p><pre><code class="language-julia hljs">odes2 = N * ν</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Any}:
 Catalyst.hillr(P₃(t), α, K, n) + γ - m₁(t)*δ
 Catalyst.hillr(P₁(t), α, K, n) + γ - m₂(t)*δ
 Catalyst.hillr(P₂(t), α, K, n) + γ - m₃(t)*δ
 -P₁(t)*μ + m₁(t)*β
 m₂(t)*β - P₂(t)*μ
 -P₃(t)*μ + m₃(t)*β</code></pre><p>Let&#39;s check these are equal symbolically</p><pre><code class="language-julia hljs">isequal(odes, odes2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h2 id="network_analysis_reaction_complexes"><a class="docs-heading-anchor" href="#network_analysis_reaction_complexes">Reaction complex representation</a><a id="network_analysis_reaction_complexes-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis_reaction_complexes" title="Permalink"></a></h2><p>We now introduce a further decomposition of the RRE ODEs, which has been used to facilitate analysis of a variety of reaction network properties. Consider a simple reaction system like</p><pre><code class="language-julia hljs">rn = @reaction_network begin
 k*A, 2*A + 3*B --&gt; A + 2*C + D
 b, C + D --&gt; 2*A + 3*B
end</code></pre><p class="math-container">\[ \begin{align*}
2 \mathrm{A} + 3 \mathrm{B} &amp;\xrightarrow{A k} \mathrm{A} + 2 \mathrm{C} + \mathrm{D} \\
\mathrm{C} + \mathrm{D} &amp;\xrightarrow{b} 2 \mathrm{A} + 3 \mathrm{B}  
 \end{align*}
 \]</p><p>We can think of the first reaction as converting the <em>reaction complex</em>, <span>$2A+3B$</span> to the complex <span>$A+2C+D$</span> with rate <span>$kA$</span>. Suppose we order our species the same way as Catalyst does, i.e.</p><p class="math-container">\[\begin{pmatrix}
x_1(t)\\
x_2(t)\\
x_3(t)\\
x_4(t)
\end{pmatrix} =
\begin{pmatrix}
A(t)\\
B(t)\\
C(t)\\
D(t)
\end{pmatrix},\]</p><p>which should be the same as</p><pre><code class="language-julia hljs">species(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 A(t)
 B(t)
 C(t)
 D(t)</code></pre><p>We can describe a given reaction complex by the stoichiometric coefficients of each species within the complex. For the reactions in <code>rn</code> these vectors would be</p><p class="math-container">\[\begin{align*}
2A+3B = \begin{pmatrix}
2\\
3\\
0\\
0
\end{pmatrix}, &amp;&amp;
A+2C+D = \begin{pmatrix}
1\\
0\\
2\\
1
\end{pmatrix},
 &amp;&amp;
C+D = \begin{pmatrix}
0\\
0\\
1\\
1
\end{pmatrix}
\end{align*}\]</p><p>Catalyst can calculate these representations as the columns of the complex stoichiometry matrix,</p><pre><code class="language-julia hljs">Z = complexstoichmat(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×3 Matrix{Int64}:
 2  1  0
 3  0  0
 0  2  1
 0  1  1</code></pre><p>If we have <span>$C$</span> complexes, <span>$Z$</span> is a <span>$M$</span> by <span>$C$</span> matrix with <span>$Z_{m c}$</span> giving the stoichiometric coefficient of species <span>$m$</span> within complex <span>$c$</span>.</p><p>We can use this representation to provide another representation of the RRE ODEs. The net stoichiometry matrix can be factored as <span>$N = Z B$</span>, where <span>$B$</span> is called the incidence matrix of the reaction network,</p><pre><code class="language-julia hljs">B = incidencemat(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×2 Matrix{Int64}:
 -1   1
  1   0
  0  -1</code></pre><p>Here <span>$B$</span> is a <span>$C$</span> by <span>$K$</span> matrix with <span>$B_{c k} = 1$</span> if complex <span>$c$</span> appears as a product of reaction <span>$k$</span>, and <span>$B_{c k} = -1$</span> if complex <span>$c$</span> is a substrate of reaction <span>$k$</span>.</p><p>Using our decomposition of <span>$N$</span>, the RRE ODEs become</p><p class="math-container">\[\frac{dx}{dt} = Z B \mathbf{v}(\mathbf{x}(t),t).\]</p><p>Let&#39;s verify that <span>$N = Z B$</span>,</p><pre><code class="language-julia hljs">N = netstoichmat(rn)
N == Z*B</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Reaction complexes give an alternative way to visualize a reaction network graph. Catalyst&#39;s <a href="../../api/#Catalyst.complexgraph"><code>complexgraph</code></a> command will calculate the complexes of a network and then show how they are related. For example,</p><pre><code class="language-julia hljs">complexgraph(rn)</code></pre><p>gives</p><p><img src="../../assets/simple_complexgraph.svg" alt="Simple example complex graph"/></p><p>while for the repressilator we find</p><pre><code class="language-julia hljs">complexgraph(repressilator)</code></pre><p><img src="../../assets/repressilator_complexgraph.svg" alt="Repressilator complex"/></p><p>Here ∅ represents the empty complex, black arrows show reactions converting substrate complexes into product complexes where the rate is just a number or parameter, and red arrows indicate the conversion of substrate complexes into product complexes where the rate is an expression involving chemical species.</p><h2 id="network_analysis_structural_aspects"><a class="docs-heading-anchor" href="#network_analysis_structural_aspects">Aspects of reaction network structure</a><a id="network_analysis_structural_aspects-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis_structural_aspects" title="Permalink"></a></h2><p>The reaction complex representation can be exploited via <a href="https://en.wikipedia.org/wiki/Chemical_reaction_network_theory">Chemical Reaction Network Theory</a> to provide insight into possible steady state and time-dependent properties of RRE ODE models and stochastic chemical kinetics models. We&#39;ll now illustrate some of the types of network properties that Catalyst can determine, using the reaction complex representation in these calculations.</p><p>Consider the following reaction network.</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    (k1,k2), A + B &lt;--&gt; C
    k3, C --&gt; D+E
    (k4,k5), D+E &lt;--&gt; F
    (k6,k7), 2A &lt;--&gt; B+G
    k8, B+G --&gt; H
    k9, H --&gt; 2A
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{A} + \mathrm{B} &amp;\xrightleftharpoons[k2]{k1} \mathrm{C} \\
\mathrm{C} &amp;\xrightarrow{k3} \mathrm{D} + \mathrm{E} \\
\mathrm{D} + \mathrm{E} &amp;\xrightleftharpoons[k5]{k4} \mathrm{F} \\
2 \mathrm{A} &amp;\xrightleftharpoons[k7]{k6} \mathrm{B} + \mathrm{G} \\
\mathrm{B} + \mathrm{G} &amp;\xrightarrow{k8} \mathrm{H} \\
\mathrm{H} &amp;\xrightarrow{k9} 2 \mathrm{A}  
 \end{align*}
 \]</p><p>with graph</p><pre><code class="language-julia hljs">complexgraph(rn)</code></pre><p><img src="../../assets/complex_rn.svg" alt="network_1"/></p><h4 id="network_analysis_structural_aspects_linkage"><a class="docs-heading-anchor" href="#network_analysis_structural_aspects_linkage">Linkage classes and sub-networks of the reaction network</a><a id="network_analysis_structural_aspects_linkage-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis_structural_aspects_linkage" title="Permalink"></a></h4><p>The preceding reaction complex graph shows that <code>rn</code> is composed of two disconnected sub-graphs, one containing the complexes <span>$A+B$</span>, <span>$C$</span>, <span>$D+E$</span>, and <span>$F$</span>, the other containing the complexes <span>$2A$</span>, <span>$B + G$</span>, and <span>$H$</span>. These sets, <span>$\{A+B, C, D+E, F\}$</span> and <span>$\{2A, B + G,H\}$</span> are called the &quot;linkage classes&quot; of the reaction network. The function <a href="../../api/#Catalyst.linkageclasses"><code>linkageclasses</code></a> will calculate these for a given network, returning a vector of the integer indices of reaction complexes participating in each set of linkage-classes. Note, indices of reaction complexes can be determined from the ordering returned by <a href="../../api/#Catalyst.reactioncomplexes"><code>reactioncomplexes</code></a>.</p><pre><code class="language-julia hljs"># we must first calculate the reaction complexes -- they are cached in rn
reactioncomplexes(rn)

# now we can calculate the linkage classes
lcs = linkageclasses(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Vector{Int64}}:
 [1, 2, 3, 4]
 [5, 6, 7]</code></pre><p>It can often be convenient to obtain the disconnected sub-networks as distinct <code>ReactionSystem</code>s, which are returned by the <a href="../../api/#Catalyst.subnetworks"><code>subnetworks</code></a> function:</p><pre><code class="language-julia hljs">subnets = subnetworks(rn)

# check the reactions in each subnetwork
reactions.(subnets)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Vector{Reaction}}:
 [k1, A + B --&gt; C, k2, C --&gt; A + B, k3, C --&gt; D + E, k4, D + E --&gt; F, k5, F --&gt; D + E]
 [k6, 2*A --&gt; B + G, k7, B + G --&gt; 2*A, k8, B + G --&gt; H, k9, H --&gt; 2*A]</code></pre><p>The graphs of the reaction complexes in the two sub-networks are then</p><pre><code class="language-julia hljs">  complexgraph(subnets[1])</code></pre><p><img src="../../assets/complex_subnets1.svg" alt="subnetwork_1"/></p><p>and,</p><pre><code class="language-julia hljs"> complexgraph(subnets[2])</code></pre><p><img src="../../assets/complex_subnets2.svg" alt="subnetwork_2"/></p><h4 id="network_analysis_structural_aspects_deficiency"><a class="docs-heading-anchor" href="#network_analysis_structural_aspects_deficiency">Deficiency of the network</a><a id="network_analysis_structural_aspects_deficiency-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis_structural_aspects_deficiency" title="Permalink"></a></h4><p>A famous theorem in Chemical Reaction Network Theory, the Deficiency Zero Theorem <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>, allows us to use knowledge of the net stoichiometry matrix and the linkage classes of a <em>mass action</em> RRE ODE system to draw conclusions about the system&#39;s possible steady states. In this section we&#39;ll see how Catalyst can calculate a network&#39;s deficiency.</p><p>The rank, <span>$r$</span>, of a reaction network is defined as the dimension of the subspace spanned by the net stoichiometry vectors of the reaction-network <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>, i.e. the span of the columns of the net stoichiometry matrix <code>N</code>. It corresponds to the number of independent species in a chemical reaction network. That is, if we calculate the linear conservation laws of a network, and use them to eliminate the dependent species of the network, we will have <span>$r$</span> independent species remaining. For our current example the conservation laws are given by</p><pre><code class="language-julia hljs"># first we calculate the conservation laws -- they are cached in rn
conservationlaws(rn)

# then we display them as equations for the dependent variables
conservedequations(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Equation}:
 E(t) ~ D(t) + Γ[1]
 G(t) ~ B(t) + D(t) + C(t) + F(t) + Γ[2]
 H(t) ~ -B(t) - 1.5D(t) - 0.5A(t) - 1.5C(t) - 1.5F(t) + Γ[3]</code></pre><p>Here the parameters <code>Γ[i]</code> represent the constants of the three conservation laws, and we see that there are three dependent species that could be eliminated. As</p><pre><code class="language-julia hljs">numspecies(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8</code></pre><p>we find that there are five independent species. Let&#39;s check this is correct:</p><pre><code class="language-julia hljs">using LinearAlgebra
rank(netstoichmat(rn)) == 5</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>So we know that the rank of our reaction network is five. An extended section discussing how to utilise conservation law elimination during chemical reaction network modelling can be found <a href="../conservation_laws/#conservation_laws">here</a>.</p><p>The deficiency, <span>$\delta$</span>, of a reaction network is defined as</p><p class="math-container">\[\delta = \textrm{(number of complexes)} - \textrm{(number of linkage classes)} - \textrm{(rank)}.\]</p><p>For our network this is <span>$7 - 2 - 5 = 0$</span>, which we can calculate in Catalyst as</p><pre><code class="language-julia hljs"># first we calculate the reaction complexes of rn and cache them in rn
reactioncomplexes(rn)

# then we can calculate the deficiency
δ = deficiency(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0</code></pre><p>Quoting Feinberg <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><blockquote><p>Deficiency zero networks are ones for which the reaction vectors [i.e. net stoichiometry vectors] are as independent as the partition of complexes into linkage classes will allow.</p></blockquote><h4 id="network_analysis_structural_aspects_reversibility"><a class="docs-heading-anchor" href="#network_analysis_structural_aspects_reversibility">Reversibility of the network</a><a id="network_analysis_structural_aspects_reversibility-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis_structural_aspects_reversibility" title="Permalink"></a></h4><p>A reaction network is <em>reversible</em> if the &quot;arrows&quot; of the reactions are symmetric so that every reaction is accompanied by its reverse reaction. Catalyst&#39;s API provides the <a href="../../api/#Catalyst.isreversible"><code>isreversible</code></a> function to determine whether a reaction network is reversible. As an example, consider</p><pre><code class="language-julia hljs">rn = @reaction_network begin
  (k1,k2),A &lt;--&gt; B
  (k3,k4),A + C &lt;--&gt; D
  (k5,k6),D &lt;--&gt; B+E
  (k7,k8),B+E &lt;--&gt; A+C
end

# calculate the set of reaction complexes
reactioncomplexes(rn)

# test if the system is reversible
isreversible(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Consider another example,</p><pre><code class="language-julia hljs">rn = @reaction_network begin
  (k1,k2),A &lt;--&gt; B
  k3, A + C --&gt; D
  k4, D --&gt; B+E
  k5, B+E --&gt; A+C
end
reactioncomplexes(rn)
isreversible(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><pre><code class="language-julia hljs">complexgraph(rn)</code></pre><p><img src="../../assets/complex_reversibility.svg" alt="reversibility"/></p><p>It is evident from the preceding graph that the network is not reversible. However, it satisfies a weaker property in that there is a path from each reaction complex back to itself within its associated subgraph. This is known as <em>weak reversibility</em>. One can test a network for weak reversibility by using the <a href="../../api/#Catalyst.isweaklyreversible"><code>isweaklyreversible</code></a> function:</p><pre><code class="language-julia hljs"># need subnetworks from the reaction network first
subnets = subnetworks(rn)
isweaklyreversible(rn, subnets)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Every reversible network is also weakly reversible, but not every weakly reversible network is reversible.</p><h4 id="network_analysis_structural_aspects_deficiency_zero_theorem"><a class="docs-heading-anchor" href="#network_analysis_structural_aspects_deficiency_zero_theorem">Deficiency Zero Theorem</a><a id="network_analysis_structural_aspects_deficiency_zero_theorem-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis_structural_aspects_deficiency_zero_theorem" title="Permalink"></a></h4><p>Knowing the deficiency and weak reversibility of a mass action chemical reaction network ODE model allows us to make inferences about the corresponding steady state behavior. Before illustrating how this works for one example, we need one last definition.</p><p>Recall that in the matrix-vector representation for the RRE ODEs, the entries, <span>$N_{m k}$</span>, of the stoichiometry matrix, <span>$N$</span>, give the net change in species <span>$m$</span> due to reaction <span>$k$</span>. If we let <span>$\mathbf{N}_k$</span> denote the <span>$k$</span>th column of this matrix, this vector corresponds to the change in the species state vector, <span>$\mathbf{x}(t)$</span>, due to reaction <span>$k$</span>, i.e. when reaction <span>$k$</span> occurs <span>$\mathbf{x}(t) \to \mathbf{x}(t) + \mathbf{N}_k$</span>. Moreover, by integrating the ODE</p><p class="math-container">\[\frac{d\mathbf{x}}{dt} = N \mathbf{v}(\mathbf{x}(t)) = \sum_{k=1}^{K} v_k(\mathbf{x}(t)) \, \mathbf{N}_k\]</p><p>we find</p><p class="math-container">\[\mathbf{x}(t) = \mathbf{x}(0) + \sum_{k=1}^K \left(\int_0^t v_k(\mathbf{x})(s) \, ds\right) \mathbf{N}_k,\]</p><p>which demonstrates that <span>$\mathbf{x}(t) - \mathbf{x}(0)$</span> is always given by a linear combination of the stoichiometry vectors, i.e.</p><p class="math-container">\[\mathbf{x}(t) - \mathbf{x}(0) \in \operatorname{span}\{\mathbf{N}_k \}.\]</p><p>In particular, this says that <span>$\mathbf{x}(t)$</span> lives in the translation of the <span>$\operatorname{span}\{\mathbf{N}_k \}$</span> by <span>$\mathbf{x}(0)$</span> which we write as <span>$(\mathbf{x}(0) + \operatorname{span}\{\mathbf{N}_k\})$</span>. In fact, since the solution should stay non-negative, if we let <span>$\bar{\mathbb{R}}_+^{M}$</span> denote the subset of vectors in <span>$\mathbb{R}^{M}$</span> with non-negative components, the possible physical values for the solution, <span>$\mathbf{x}(t)$</span>, must be in the set</p><p class="math-container">\[(\mathbf{x}(0) + \operatorname{span}\{\mathbf{N}_k\}) \cap \bar{\mathbb{R}}_+^{M}.\]</p><p>This set is called the stoichiometric compatibility class of <span>$\mathbf{x}(t)$</span>. The key property of stoichiometric compatibility classes is that they are invariant under the RRE ODE&#39;s dynamics, i.e. a solution will always remain within the subspace given by the stoichiometric compatibility class. Finally, we note that the <em>positive</em> stoichiometric compatibility class generated by <span>$\mathbf{x}(0)$</span> is just <span>$(\mathbf{x}(0) + \operatorname{span}\{\mathbf{N}_k\}) \cap \mathbb{R}_+^{M}$</span>, where <span>$\mathbb{R}_+^{M}$</span> denotes the vectors in <span>$\mathbb{R}^M$</span> with strictly positive components.</p><p>With these definitions we can now see how knowing the deficiency and weak reversibility of the network can tell us about its steady state behavior. Consider the previous example, which we know is weakly reversible. Its deficiency is</p><pre><code class="language-julia hljs">deficiency(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0</code></pre><p>We also verify that the system is purely mass action (though it is apparent from the network&#39;s definition):</p><pre><code class="language-julia hljs">all(rx -&gt; ismassaction(rx, rn), reactions(rn))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>We can therefore apply the Deficiency Zero Theorem to draw conclusions about the system&#39;s steady state behavior. The Deficiency Zero Theorem (roughly) says that a mass action network with deficiency zero satisfies</p><ol><li>If the network is weakly reversible, then independent of the reaction rate constants the RRE ODEs have exactly one equilibrium solution within each positive stoichiometric compatibility class. That equilibrium is locally asymptotically stable.</li><li>If the network is not weakly reversible, then the RRE ODEs cannot admit a positive equilibrium solution.</li></ol><p>See <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> for a more precise statement, proof, and additional examples.</p><p>We can therefore conclude that for any initial condition that is positive, and hence in some positive stoichiometric compatibility class, <code>rn</code> will have exactly one equilibrium solution which will be positive and locally asymptotically stable.</p><p>As a final example, consider the following network from <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><pre><code class="language-julia hljs">rn = @reaction_network begin
  (k1,k2),A &lt;--&gt; 2B
  (k3,k4), A + C &lt;--&gt; D
  k5, B+E --&gt; C + D
end
reactioncomplexes(rn)
subnets = subnetworks(rn)
isma = all(rx -&gt; ismassaction(rx,rn), reactions(rn))
def = deficiency(rn)
iswr = isweaklyreversible(rn, subnets)
isma,def,iswr</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(true, 0, false)</code></pre><p>which we see is mass action and has deficiency zero, but is not weakly reversible. As such, we can conclude that for any choice of rate constants the RRE ODEs cannot have a positive equilibrium solution.</p><h2 id="network_analysis_caching_properties"><a class="docs-heading-anchor" href="#network_analysis_caching_properties">Caching of Network Properties in <code>ReactionSystems</code></a><a id="network_analysis_caching_properties-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis_caching_properties" title="Permalink"></a></h2><p>When calling many of the network API functions, Catalyst calculates and caches in <code>rn</code> a variety of information. For example the first call to</p><pre><code class="language-julia hljs">rcs,B = reactioncomplexes(rn)</code></pre><p>calculates, caches, and returns the reaction complexes, <code>rcs</code>, and the incidence matrix, <code>B</code>, of <code>rn</code>. Subsequent calls simply return <code>rcs</code> and <code>B</code> from the cache.</p><p>Similarly, the first call to</p><pre><code class="language-julia hljs">N = netstoichmat(rn)</code></pre><p>calculates, caches and returns the net stoichiometry matrix. Subsequent calls then simply return the cached value of <code>N</code>. Caching such information means users do not need to manually know which subsets of network properties are needed for a given calculation (like the deficiency). Generally only</p><pre><code class="language-julia hljs">rcs,B = reactioncomplexes(rn)    # must be called once to cache rcs and B
any_other_network_property(rn)</code></pre><p>should work to calculate a desired network property, with the API doc strings indicating when <code>reactioncomplexes(rn)</code> must be called at least once before a given function is used.</p><p>Because of the caching of network properties, subsequent calls to most API functions will be fast, simply returning the previously calculated and cached values. In some cases it may be desirable to reset the cache and recalculate these properties. This can be done by calling</p><pre><code class="language-julia hljs">Catalyst.reset_networkproperties!(rn)</code></pre><p>Network property functions will then recalculate their associated properties and cache the new values the next time they are called.</p><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://link.springer.com/book/10.1007/978-3-030-03858-8?noAccess=true">Feinberg, M. <em>Foundations of Chemical Reaction Network Theory</em>, Applied Mathematical Sciences 202, Springer (2019).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reactionsystem_content_accessing/">« Accessing model properties</a><a class="docs-footer-nextpage" href="../chemistry_related_functionality/">Chemistry-related functionality »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Monday 22 July 2024 23:26">Monday 22 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
