<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Catalyst.jl</title><meta name="title" content="API · Catalyst.jl"/><meta property="og:title" content="API · Catalyst.jl"/><meta property="twitter:title" content="API · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/api/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/api/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/api/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><span class="tocitem">Model Creation and Properties</span><ul><li><a class="tocitem" href="../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../model_creation/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../model_creation/conservation_laws/">Working with conservation laws</a></li><li><a class="tocitem" href="../model_creation/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../model_creation/reactionsystem_content_accessing/">Accessing model properties</a></li><li><a class="tocitem" href="../model_creation/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../model_creation/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Model simulation</span><ul><li><a class="tocitem" href="../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../model_simulation/simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../model_simulation/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../model_simulation/ode_simulation_performance/">Advice for performant ODE simulations</a></li><li><a class="tocitem" href="../model_simulation/sde_simulation_performance/">Advice for performant SDE simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Model simulation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model_simulation/examples/periodic_events_simulation/">Modelling a periodic event during ODE and jump simulations</a></li></ul></li></ul></li><li><span class="tocitem">Steady state analysis</span><ul><li><a class="tocitem" href="../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../inverse_problems/behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><span class="tocitem">Spatial Modelling</span><ul><li><a class="tocitem" href="../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../spatial_modelling/spatial_jump_simulations/">Spatial jump simulations</a></li></ul></li><li><a class="tocitem" href="../faqs/">FAQs</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Reaction-network-generation-and-representation"><span>Reaction network generation and representation</span></a></li><li><a class="tocitem" href="#api_dsl_options"><span>Options for the <code>@reaction_network</code> DSL</span></a></li><li><a class="tocitem" href="#api_accessor_functions"><span>ModelingToolkit and Catalyst accessor functions</span></a></li><li><a class="tocitem" href="#Basic-system-properties"><span>Basic system properties</span></a></li><li><a class="tocitem" href="#Coupled-reaction/equation-system-properties"><span>Coupled reaction/equation system properties</span></a></li><li><a class="tocitem" href="#Basic-species-properties"><span>Basic species properties</span></a></li><li><a class="tocitem" href="#Basic-reaction-properties"><span>Basic reaction properties</span></a></li><li><a class="tocitem" href="#api_rx_metadata"><span>Reaction metadata</span></a></li><li><a class="tocitem" href="#api_network_extension_and_modification"><span>Functions to extend or modify a network</span></a></li><li><a class="tocitem" href="#Network-analysis-and-representations"><span>Network analysis and representations</span></a></li><li><a class="tocitem" href="#Network-comparison"><span>Network comparison</span></a></li><li><a class="tocitem" href="#Network-visualization"><span>Network visualization</span></a></li><li><a class="tocitem" href="#api_rate_laws"><span>Rate laws</span></a></li><li><a class="tocitem" href="#Transformations"><span>Transformations</span></a></li><li><a class="tocitem" href="#Chemistry-related-functionalities"><span>Chemistry-related functionalities</span></a></li><li><a class="tocitem" href="#Unit-validation"><span>Unit validation</span></a></li><li><a class="tocitem" href="#Utility-functions"><span>Utility functions</span></a></li><li><a class="tocitem" href="#api_lattice_simulations"><span>Spatial modelling</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="api"><a class="docs-heading-anchor" href="#api">Catalyst.jl API</a><a id="api-1"></a><a class="docs-heading-anchor-permalink" href="#api" title="Permalink"></a></h1><h2 id="Reaction-network-generation-and-representation"><a class="docs-heading-anchor" href="#Reaction-network-generation-and-representation">Reaction network generation and representation</a><a id="Reaction-network-generation-and-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Reaction-network-generation-and-representation" title="Permalink"></a></h2><p>Catalyst provides the <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro for generating a complete network, stored as a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, which in turn is composed of <a href="#Catalyst.Reaction"><code>Reaction</code></a>s. <code>ReactionSystem</code>s can be converted to other <code>ModelingToolkit.AbstractSystem</code>s, including a <code>ModelingToolkit.ODESystem</code>, <code>ModelingToolkit.SDESystem</code>, or <code>ModelingToolkit.JumpSystem</code>.</p><p>When using the <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro, Catalyst will automatically attempt to detect what is a species and what is a parameter. Everything that appear as a substrate or product in some reaction will be treated as a species, while all remaining symbols will be considered parameters (corresponding to those symbols that only appear within rate expressions and/or as stoichiometric coefficients). I.e. in</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    k*X, Y --&gt; W
end</code></pre><p><code>Y</code> and <code>W</code> will all be classified as chemical species, while <code>k</code> and <code>X</code> will be classified as parameters.</p><p>The <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> generated by the <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro is a <code>ModelingToolkit.AbstractSystem</code> that symbolically represents a system of chemical reactions. In some cases it can be convenient to bypass the macro and directly generate a collection of symbolic <a href="#Catalyst.Reaction"><code>Reaction</code></a>s and a corresponding <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> encapsulating them. Below we illustrate with a simple SIR example how a system can be directly constructed, and demonstrate how to then generate from the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and solve corresponding chemical reaction ODE models, chemical Langevin equation SDE models, and stochastic chemical kinetics jump process models.</p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEq, StochasticDiffEq, JumpProcesses, Plots
t = default_t()
@parameters β γ
@species S(t) I(t) R(t)

rxs = [Reaction(β, [S,I], [I], [1,1], [2])
       Reaction(γ, [I], [R])]
@named rs = ReactionSystem(rxs, t)
rs = complete(rs)

u₀map    = [S =&gt; 999.0, I =&gt; 1.0, R =&gt; 0.0]
parammap = [β =&gt; 1/10000, γ =&gt; 0.01]
tspan    = (0.0, 250.0)

# solve as ODEs
odesys = convert(ODESystem, rs)
odesys = complete(odesys)
oprob = ODEProblem(odesys, u₀map, tspan, parammap)
sol = solve(oprob, Tsit5())
p1 = plot(sol, title = &quot;ODE&quot;)

# solve as SDEs
sdesys = convert(SDESystem, rs)
sdesys = complete(sdesys)
sprob = SDEProblem(sdesys, u₀map, tspan, parammap)
sol = solve(sprob, EM(), dt=.01, saveat = 2.0)
p2 = plot(sol, title = &quot;SDE&quot;)

# solve as jump process
jumpsys = convert(JumpSystem, rs)
jumpsys = complete(jumpsys)
u₀map    = [S =&gt; 999, I =&gt; 1, R =&gt; 0]
dprob = DiscreteProblem(jumpsys, u₀map, tspan, parammap)
jprob = JumpProblem(jumpsys, dprob, Direct())
sol = solve(jprob)
p3 = plot(sol, title = &quot;jump&quot;)
plot(p1, p2, p3; layout = (3,1))</code></pre><img src="c173cfc9.png" alt="Example block output"/><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.@reaction_network" href="#Catalyst.@reaction_network"><code>Catalyst.@reaction_network</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@reaction_network</code></pre><p>Generates a <a href="../model_creation/dsl_basics/#dsl_description"><code>ReactionSystem</code></a> that encodes a chemical reaction network.</p><p>See <a href="../model_creation/dsl_basics/#dsl_description">The Reaction DSL</a> documentation for details on parameters to the macro.</p><p>Examples:</p><pre><code class="language-julia hljs"># a basic SIR model, with name SIR
sir_model = @reaction_network SIR begin
    c1, s + i --&gt; 2i
    c2, i --&gt; r
end

# a basic SIR model, with random generated name
sir_model = @reaction_network begin
    c1, s + i --&gt; 2i
    c2, i --&gt; r
end

# an empty network with name empty
emptyrn = @reaction_network empty

# an empty network with random generated name
emptyrn = @reaction_network</code></pre><p>ReactionSystems generated through <code>@reaction_network</code> are complete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/dsl.jl#L110-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.@network_component" href="#Catalyst.@network_component"><code>Catalyst.@network_component</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@network_component</code></pre><p>Equivalent to <code>@reaction_network</code> except the generated <code>ReactionSystem</code> is not marked as complete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/dsl.jl#L175-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.make_empty_network" href="#Catalyst.make_empty_network"><code>Catalyst.make_empty_network</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_empty_network(; iv=DEFAULT_IV, name=gensym(:ReactionSystem))</code></pre><p>Construct an empty <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. <code>iv</code> is the independent variable, usually time, and <code>name</code> is the name to give the <code>ReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L1322-L1327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.@reaction" href="#Catalyst.@reaction"><code>Catalyst.@reaction</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@reaction</p><p>Generates a single <a href="#Catalyst.Reaction"><code>Reaction</code></a> object.</p><p>Examples:</p><pre><code class="language-julia hljs">rx = @reaction k*v, A + B --&gt; C + D

# is equivalent to
t = default_t()
@parameters k v
@species A(t) B(t) C(t) D(t)
rx == Reaction(k*v, [A,B], [C,D])</code></pre><p>Here <code>k</code> and <code>v</code> will be parameters and <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code> will be variables. Interpolation of existing parameters/variables also works</p><pre><code class="language-julia hljs">t = default_t()
@parameters k b
@species A(t)
ex = k*A^2 + t
rx = @reaction b*$ex*$A, $A --&gt; C</code></pre><p>Notes:</p><ul><li>Any symbols arising in the rate expression that aren&#39;t interpolated are treated as</li></ul><p>parameters. In the reaction part (<code>α*A + B --&gt; C + D</code>), coefficients are treated as parameters, e.g. <code>α</code>, and rightmost symbols as species, e.g. <code>A,B,C,D</code>.</p><ul><li>Works with any <em>single</em> arrow types supported by <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a>.</li><li>Interpolation of Julia variables into the macro works similar to the <code>@reaction_network</code></li></ul><p>macro. See <a href="../model_creation/dsl_basics/#dsl_description">The Reaction DSL</a> tutorial for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/dsl.jl#L826-L858">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.Reaction" href="#Catalyst.Reaction"><code>Catalyst.Reaction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Reaction{S, T}</code></pre><p>One chemical reaction.</p><p><strong>Fields</strong></p><ul><li><p><code>rate</code>: The rate function (excluding mass action terms).</p></li><li><p><code>substrates</code>: Reaction substrates.</p></li><li><p><code>products</code>: Reaction products.</p></li><li><p><code>substoich</code>: The stoichiometric coefficients of the reactants.</p></li><li><p><code>prodstoich</code>: The stoichiometric coefficients of the products.</p></li><li><p><code>netstoich</code>: The net stoichiometric coefficients of all species changed by the reaction.</p></li><li><p><code>only_use_rate</code>: <code>false</code> (default) if <code>rate</code> should be multiplied by mass action terms to give the rate law. <code>true</code> if <code>rate</code> represents the full reaction rate law.</p></li></ul><ul><li><code>metadata</code>: Contain additional data, such whenever the reaction have a specific noise-scaling expression for the chemical Langevin equation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Catalyst
t = default_t()
@parameters k[1:20]
@species A(t) B(t) C(t) D(t)
rxs = [Reaction(k[1], nothing, [A]),            # 0 -&gt; A
       Reaction(k[2], [B], nothing),            # B -&gt; 0
       Reaction(k[3],[A],[C]),                  # A -&gt; C
       Reaction(k[4], [C], [A,B]),              # C -&gt; A + B
       Reaction(k[5], [C], [A], [1], [2]),      # C -&gt; A + A
       Reaction(k[6], [A,B], [C]),              # A + B -&gt; C
       Reaction(k[7], [B], [A], [2], [1]),      # 2B -&gt; A
       Reaction(k[8], [A,B], [A,C]),            # A + B -&gt; A + C
       Reaction(k[9], [A,B], [C,D]),            # A + B -&gt; C + D
       Reaction(k[10], [A], [C,D], [2], [1,1]), # 2A -&gt; C + D
       Reaction(k[11], [A], [A,B], [2], [1,1]), # 2A -&gt; A + B
       Reaction(k[12], [A,B,C], [C,D], [1,3,4], [2, 3]),          # A+3B+4C -&gt; 2C + 3D
       Reaction(k[13], [A,B], nothing, [3,1], nothing),           # 3A+B -&gt; 0
       Reaction(k[14], nothing, [A], nothing, [2]),               # 0 -&gt; 2A
       Reaction(k[15]*A/(2+A), [A], nothing; only_use_rate=true), # A -&gt; 0 with custom rate
       Reaction(k[16], [A], [B]; only_use_rate=true),             # A -&gt; B with custom rate.
       Reaction(k[17]*A*exp(B), [C], [D], [2], [1]),              # 2C -&gt; D with non constant rate.
       Reaction(k[18]*B, nothing, [B], nothing, [2]),             # 0 -&gt; 2B with non constant rate.
       Reaction(k[19]*t, [A], [B]),                                # A -&gt; B with non constant rate.
       Reaction(k[20]*t*A, [B,C], [D],[2,1],[2])                  # 2A +B -&gt; 2C with non constant rate.
  ]</code></pre><p>Notes:</p><ul><li><code>nothing</code> can be used to indicate a reaction that has no reactants or no products. In this case the corresponding stoichiometry vector should also be set to <code>nothing</code>.</li><li>The three-argument form assumes all reactant and product stoichiometric coefficients are one.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reaction.jl#L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.ReactionSystem" href="#Catalyst.ReactionSystem"><code>Catalyst.ReactionSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReactionSystem{V&lt;:Catalyst.NetworkProperties} &lt;: AbstractTimeDependentSystem</code></pre><p>A system of chemical reactions.</p><p><strong>Fields</strong></p><ul><li><p><code>eqs</code>: The equations (reactions and algebraic/differential) defining the system.</p></li><li><p><code>rxs</code>: The Reactions defining the system.</p></li><li><p><code>iv</code>: Independent variable (usually time).</p></li><li><p><code>sivs</code>: Spatial independent variables</p></li><li><p><code>unknowns</code>: All dependent (unknown) variables, species and non-species. Must not contain the independent variable.</p></li><li><p><code>species</code>: Dependent unknown variables representing species</p></li><li><p><code>ps</code>: Parameter variables. Must not contain the independent variable.</p></li><li><p><code>var_to_name</code>: Maps Symbol to corresponding variable.</p></li><li><p><code>observed</code>: Equations for observed variables.</p></li><li><p><code>name</code>: The name of the system</p></li><li><p><code>systems</code>: Internal sub-systems</p></li><li><p><code>defaults</code>: The default values to use when initial conditions and/or parameters are not supplied in <code>ODEProblem</code>.</p></li></ul><ul><li><p><code>connection_type</code>: Type of the system</p></li><li><p><code>networkproperties</code>: <code>NetworkProperties</code> object that can be filled in by API functions. INTERNAL – not considered part of the public API.</p></li><li><p><code>combinatoric_ratelaws</code>: Sets whether to use combinatoric scalings in rate laws. true by default.</p></li><li><p><code>continuous_events</code>: continuous_events: A <code>Vector{SymbolicContinuousCallback}</code> that model events. The integrator will use root finding to guarantee that it steps at each zero crossing.</p></li></ul><ul><li><code>discrete_events</code>: discrete_events: A <code>Vector{SymbolicDiscreteCallback}</code> that models events. Symbolic analog to <code>SciMLBase.DiscreteCallback</code> that executes an affect when a given condition is true at the end of an integration step.</li></ul><ul><li><code>metadata</code>: Metadata for the system, to be used by downstream packages.</li></ul><ul><li><code>complete</code>: complete: if a model <code>sys</code> is complete, then <code>sys.x</code> no longer performs namespacing.</li></ul><p><strong>Example</strong></p><p>Continuing from the example in the <a href="#Catalyst.Reaction"><code>Reaction</code></a> definition:</p><pre><code class="language-julia hljs"># simple constructor that infers species and parameters
@named rs = ReactionSystem(rxs, t)

# allows specification of species and parameters
@named rs = ReactionSystem(rxs, t, [A,B,C,D], k)</code></pre><p>Keyword Arguments:</p><ul><li><code>observed::Vector{Equation}</code>, equations specifying observed variables.</li><li><code>systems::Vector{AbstractSystems}</code>, vector of sub-systems. Can be <code>ReactionSystem</code>s, <code>ODESystem</code>s, or <code>NonlinearSystem</code>s.</li><li><code>name::Symbol</code>, the name of the system (must be provided, or <code>@named</code> must be used).</li><li><code>defaults::Dict</code>, a dictionary mapping parameters to their default values and species to their default initial values.</li><li><code>checks = true</code>, boolean for whether to check units.</li><li><code>networkproperties = NetworkProperties()</code>, cache for network properties calculated via API functions.</li><li><code>combinatoric_ratelaws = true</code>, sets the default value of <code>combinatoric_ratelaws</code> used in calls to <code>convert</code> or calling various problem types with the <code>ReactionSystem</code>.</li><li><code>balanced_bc_check = true</code>, sets whether to check that BC species appearing in reactions are balanced (i.e appear as both a substrate and a product with the same stoichiometry).</li></ul><p>Notes:</p><ul><li>ReactionSystems currently do rudimentary unit checking, requiring that all species have the same units, and all reactions have rate laws with units of (species units) / (time units). Unit checking can be disabled by passing the keyword argument <code>checks=false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L234">source</a></section></article><h2 id="api_dsl_options"><a class="docs-heading-anchor" href="#api_dsl_options">Options for the <code>@reaction_network</code> DSL</a><a id="api_dsl_options-1"></a><a class="docs-heading-anchor-permalink" href="#api_dsl_options" title="Permalink"></a></h2><p>We have <a href="../model_creation/dsl_advanced/#dsl_advanced_options">previously described</a> how options permits the user to supply non-reaction information to <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> created through the DSL. Here follows a list of all options currently available.</p><ul><li>[<code>parameters</code>]:(@ref dsl<em>advanced</em>options<em>declaring</em>species<em>and</em>parameters) Allows the designation of a set of symbols as system parameter.</li><li><a href="../model_creation/dsl_advanced/#dsl_advanced_options_declaring_species_and_parameters"><code>species</code></a>: Allows the designation of a set of symbols as system species.</li><li><a href="../model_creation/dsl_advanced/#dsl_advanced_options_declaring_species_and_parameters"><code>variables</code></a>: Allows the designation of a set of symbols as system non-species variables.</li><li><a href="../model_creation/dsl_advanced/#dsl_advanced_options_ivs"><code>ivs</code></a>: Allows the designation of a set of symbols as system independent variables.</li><li><a href="../model_creation/chemistry_related_functionality/#chemistry_functionality_compounds"><code>compounds</code></a>: Allows the designation of compound species.</li><li><a href="../model_creation/dsl_advanced/#dsl_advanced_options_observables"><code>observables</code></a>: Allows the designation of compound observables.</li><li><a href="../model_simulation/simulation_introduction/#simulation_intro_SDEs_noise_saling"><code>default_noise_scaling</code></a>: Enables the setting of a default noise scaling expression.</li><li><a href="../model_creation/constraint_equations/#constraint_equations_coupling_constraints"><code>differentials</code></a>: Allows the designation of differentials.</li><li><a href="../model_creation/constraint_equations/#constraint_equations_coupling_constraints"><code>equations</code></a>: Allows the creation of algebraic and/or differential equations.</li><li><a href="../model_creation/constraint_equations/#constraint_equations_events"><code>continuous_events</code></a>: Allows the creation of continuous events.</li><li><a href="../model_creation/constraint_equations/#constraint_equations_events"><code>discrete_events</code></a>: Allows the creation of discrete events.</li><li><a href="../faqs/#faq_combinatoric_ratelaws"><code>combinatoric_ratelaws</code></a>: Takes a single option (<code>true</code> or <code>false</code>), which sets whether to use combinatorial rate laws.</li></ul><h2 id="api_accessor_functions"><a class="docs-heading-anchor" href="#api_accessor_functions">ModelingToolkit and Catalyst accessor functions</a><a id="api_accessor_functions-1"></a><a class="docs-heading-anchor-permalink" href="#api_accessor_functions" title="Permalink"></a></h2><p>A <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> is an instance of a <code>ModelingToolkit.AbstractTimeDependentSystem</code>, and has a number of fields that can be accessed using the Catalyst API and the <a href="https://docs.sciml.ai/ModelingToolkit/stable/basics/AbstractSystem/">ModelingToolkit.jl Abstract System Interface</a>. Below we overview these components.</p><p>There are three basic sets of convenience accessors that will return information either from a top-level system, the top-level system and all sub-systems that are also <code>ReactionSystem</code>s (i.e. the full reaction-network), or the top-level system, all subs-systems, and all constraint systems (i.e. the full model). To retrieve info from just a base <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> <code>rn</code>, ignoring sub-systems of <code>rn</code>, one can use the ModelingToolkit accessors (these provide direct access to the corresponding internal fields of the <code>ReactionSystem</code>)</p><ul><li><code>ModelingToolkit.get_unknowns(rn)</code> is a vector that collects all the species defined within <code>rn</code>, ordered by species and then non-species variables.</li><li><code>Catalyst.get_species(rn)</code> is a vector of all the species variables in the system. The entries in <code>get_species(rn)</code> correspond to the first <code>length(get_species(rn))</code> components in <code>get_unknowns(rn)</code>.</li><li><code>ModelingToolkit.get_ps(rn)</code> is a vector that collects all the parameters defined <em>within</em> reactions in <code>rn</code>.</li><li><code>ModelingToolkit.get_eqs(rn)</code> is a vector that collects all the <a href="#Catalyst.Reaction"><code>Reaction</code></a>s and <code>Symbolics.Equation</code> defined within <code>rn</code>, ordering all <code>Reaction</code>s before <code>Equation</code>s.</li><li><code>Catalyst.get_rxs(rn)</code> is a vector of all the <a href="#Catalyst.Reaction"><code>Reaction</code></a>s in <code>rn</code>, and corresponds to the first <code>length(get_rxs(rn))</code> entries in <code>get_eqs(rn)</code>.</li><li><code>ModelingToolkit.get_iv(rn)</code> is the independent variable used in the system (usually <code>t</code> to represent time).</li><li><code>ModelingToolkit.get_systems(rn)</code> is a vector of all sub-systems of <code>rn</code>.</li><li><code>ModelingToolkit.get_defaults(rn)</code> is a dictionary of all the default values for parameters and species in <code>rn</code>.</li></ul><p>The preceding accessors do not allocate, directly accessing internal fields of the <code>ReactionSystem</code>.</p><p>To retrieve information from the full reaction network represented by a system <code>rn</code>, which corresponds to information within both <code>rn</code> and all sub-systems, one can call:</p><ul><li><code>ModelingToolkit.unknowns(rn)</code> returns all species <em>and variables</em> across the system, <em>all sub-systems</em>, and all constraint systems. Species are ordered before non-species variables in <code>unknowns(rn)</code>, with the first <code>numspecies(rn)</code> entries in <code>unknowns(rn)</code> being the same as <code>species(rn)</code>.</li><li><a href="#Catalyst.species"><code>species(rn)</code></a> is a vector collecting all the chemical species within the system and any sub-systems that are also <code>ReactionSystems</code>.</li><li><code>ModelingToolkit.parameters(rn)</code> returns all parameters across the system, <em>all sub-systems</em>, and all constraint systems.</li><li><code>ModelingToolkit.equations(rn)</code> returns all <a href="#Catalyst.Reaction"><code>Reaction</code></a>s and all <code>Symbolics.Equations</code> defined across the system, <em>all sub-systems</em>, and all constraint systems. <code>Reaction</code>s are ordered ahead of <code>Equation</code>s with the first <code>numreactions(rn)</code> entries in <code>equations(rn)</code> being the same as <code>reactions(rn)</code>.</li><li><a href="#Catalyst.reactions"><code>reactions(rn)</code></a> is a vector of all the <code>Reaction</code>s within the system and any sub-systems that are also <code>ReactionSystem</code>s.</li></ul><p>These accessors will generally allocate new arrays to store their output unless there are no subsystems. In the latter case the usually return the same vector as the corresponding <code>get_*</code> function.</p><p>Below we list the remainder of the Catalyst API accessor functions mentioned above.</p><h2 id="Basic-system-properties"><a class="docs-heading-anchor" href="#Basic-system-properties">Basic system properties</a><a id="Basic-system-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-system-properties" title="Permalink"></a></h2><p>See <a href="../model_creation/programmatic_CRN_construction/#programmatic_CRN_construction">Programmatic Construction of Symbolic Reaction Systems</a> for examples and <a href="#api_accessor_functions">ModelingToolkit and Catalyst Accessor Functions</a> for more details on the basic accessor functions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.species" href="#Catalyst.species"><code>Catalyst.species</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">species(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of all species defined in the system and any subsystems that are of type <code>ReactionSystem</code>. To get the species and non-species variables in the system and all subsystems, including non-<code>ReactionSystem</code> subsystems, uses <code>unknowns(network)</code>.</p><p>Notes:</p><ul><li>If <code>ModelingToolkit.get_systems(network)</code> is non-empty will allocate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L683-L693">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.get_species" href="#Catalyst.get_species"><code>Catalyst.get_species</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_species(sys::ReactionSystem)</code></pre><p>Return the current dependent variables that represent species in <code>sys</code> (toplevel system only).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L610-L615">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.nonspecies" href="#Catalyst.nonspecies"><code>Catalyst.nonspecies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nonspecies(network)</code></pre><p>Return the non-species variables within the network, i.e. those unknowns for which <code>isspecies == false</code>.</p><p>Notes:</p><ul><li>Allocates a new array to store the non-species variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L715-L723">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.reactions" href="#Catalyst.reactions"><code>Catalyst.reactions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactions(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of all <code>Reactions</code> in the system.</p><p>Notes:</p><ul><li>If <code>ModelingToolkit.get_systems(network)</code> is not empty, will allocate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L787-L794">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.get_rxs" href="#Catalyst.get_rxs"><code>Catalyst.get_rxs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_rxs(sys::ReactionSystem)</code></pre><p>Return the system&#39;s <code>Reaction</code> vector (toplevel system only).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L619-L623">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.nonreactions" href="#Catalyst.nonreactions"><code>Catalyst.nonreactions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nonreactions(network)</code></pre><p>Return the non-reaction equations within the network (i.e. algebraic and differential equations).</p><p>Notes:</p><ul><li>Allocates a new array to store the non-species variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L816-L823">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.numspecies" href="#Catalyst.numspecies"><code>Catalyst.numspecies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numspecies(network)</code></pre><p>Return the total number of species within the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and subsystems that are <code>ReactionSystem</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L701-L706">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.numparams" href="#Catalyst.numparams"><code>Catalyst.numparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numparams(network)</code></pre><p>Return the total number of parameters within the given system and all subsystems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L756-L760">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.numreactions" href="#Catalyst.numreactions"><code>Catalyst.numreactions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numreactions(network)</code></pre><p>Return the total number of reactions within the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and subsystems that are <code>ReactionSystem</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L802-L807">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.speciesmap" href="#Catalyst.speciesmap"><code>Catalyst.speciesmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">speciesmap(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a Dictionary mapping species that participate in <code>Reaction</code>s to their index within <a href="#Catalyst.species"><code>species(network)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L728-L733">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.paramsmap" href="#Catalyst.paramsmap"><code>Catalyst.paramsmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">paramsmap(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a Dictionary mapping from all parameters that appear within the system to their index within <code>parameters(network)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L769-L775">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.isautonomous" href="#Catalyst.isautonomous"><code>Catalyst.isautonomous</code></a> — <span class="docstring-category">Function</span></header><section><div><p>isautonomous(rs::ReactionSystem)</p><p>Checks if a system is autonomous (i.e. no rate or equation depend on the independent variable(s)). Example:</p><pre><code class="language-julia hljs">rs1 = @reaction_system
    (p,d), 0 &lt;--&gt; X
end
isautonomous(rs1) # Returns `true`.

rs2 = @reaction_system
    (p/t,d), 0 &lt;--&gt; X
end
isautonomous(rs2) # Returns `false`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L1201-L1217">source</a></section></article><h2 id="Coupled-reaction/equation-system-properties"><a class="docs-heading-anchor" href="#Coupled-reaction/equation-system-properties">Coupled reaction/equation system properties</a><a id="Coupled-reaction/equation-system-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Coupled-reaction/equation-system-properties" title="Permalink"></a></h2><p>The following system property accessor functions are primarily relevant to reaction system <a href="../model_creation/constraint_equations/#constraint_equations">coupled to differential and/or algebraic equations</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.has_alg_equations" href="#ModelingToolkit.has_alg_equations"><code>ModelingToolkit.has_alg_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_alg_equations(sys::AbstractSystem)</code></pre><p>For a system, returns true if it contain at least one algebraic equation (i.e. that does not contain any differentials).</p><p>Example:</p><pre><code class="language-julia hljs">using ModelingToolkit
using ModelingToolkit: t_nounits as t, D_nounits as D
@parameters p d
@variables X(t)
eq1 = D(X) ~ p - d*X
eq2 = 0 ~ p - d*X
@named osys1 = ODESystem([eq1], t)
@named osys2 = ODESystem([eq2], t)

has_alg_equations(osys1) # returns `false`.
has_alg_equations(osys2) # returns `true`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v9.32.0/src/systems/abstractsystem.jl#L3136-L3156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.alg_equations" href="#ModelingToolkit.alg_equations"><code>ModelingToolkit.alg_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alg_equations(sys::AbstractSystem)</code></pre><p>For a system, returns a vector of all its algebraic equations (i.e. that does not contain any differentials).</p><p>Example: ```julia using ModelingToolkit using ModelingToolkit: t<em>nounits as t, D</em>nounits as D @parameters p d @variables X(t) eq1 = D(X) ~ p - d<em>X eq2 = 0 ~ p - d</em>X @named osys = ODESystem([eq1, eq2], t)</p><p>alg_equations(osys) # returns <code>[0 ~ p - d*X(t)]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v9.32.0/src/systems/abstractsystem.jl#L3097-L3114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.has_diff_equations" href="#ModelingToolkit.has_diff_equations"><code>ModelingToolkit.has_diff_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_diff_equations(sys::AbstractSystem)</code></pre><p>For a system, returns true if it contain at least one differential equation (i.e. that contain a differential).</p><p>Example:</p><pre><code class="language-julia hljs">using ModelingToolkit
using ModelingToolkit: t_nounits as t, D_nounits as D
@parameters p d
@variables X(t)
eq1 = D(X) ~ p - d*X
eq2 = 0 ~ p - d*X
@named osys1 = ODESystem([eq1], t)
@named osys2 = ODESystem([eq2], t)

has_diff_equations(osys1) # returns `true`.
has_diff_equations(osys2) # returns `false`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v9.32.0/src/systems/abstractsystem.jl#L3159-L3178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.diff_equations" href="#ModelingToolkit.diff_equations"><code>ModelingToolkit.diff_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diff_equations(sys::AbstractSystem)</code></pre><p>For a system, returns a vector of all its differential equations (i.e. that does contain a differential).</p><p>Example: ```julia using ModelingToolkit using ModelingToolkit: t<em>nounits as t, D</em>nounits as D @parameters p d @variables X(t) eq1 = D(X) ~ p - d<em>X eq2 = 0 ~ p - d</em>X @named osys = ODESystem([eq1, eq2], t)</p><p>diff_equations(osys) # returns <code>[Differential(t)(X(t)) ~ p - d*X(t)]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v9.32.0/src/systems/abstractsystem.jl#L3117-L3133">source</a></section></article><h2 id="Basic-species-properties"><a class="docs-heading-anchor" href="#Basic-species-properties">Basic species properties</a><a id="Basic-species-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-species-properties" title="Permalink"></a></h2><p>The following functions permits the querying of species properties.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.isspecies" href="#Catalyst.isspecies"><code>Catalyst.isspecies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isspecies(s)</code></pre><p>Tests if the given symbolic variable corresponds to a chemical species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reaction.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.isconstant" href="#Catalyst.isconstant"><code>Catalyst.isconstant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Catalyst.isconstant(s)</code></pre><p>Tests if the given symbolic variable corresponds to a constant species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reaction.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.isbc" href="#Catalyst.isbc"><code>Catalyst.isbc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Catalyst.isbc(s)</code></pre><p>Tests if the given symbolic variable corresponds to a boundary condition species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reaction.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.isvalidreactant" href="#Catalyst.isvalidreactant"><code>Catalyst.isvalidreactant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isvalidreactant(s)</code></pre><p>Test if a species is valid as a reactant (i.e. a species variable or a constant parameter).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reaction.jl#L58-L62">source</a></section></article><h2 id="Basic-reaction-properties"><a class="docs-heading-anchor" href="#Basic-reaction-properties">Basic reaction properties</a><a id="Basic-reaction-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-reaction-properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.ismassaction" href="#Catalyst.ismassaction"><code>Catalyst.ismassaction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ismassaction(rx, rs; rxvars = get_variables(rx.rate),
                              haveivdep = nothing,
                              unknownset = Set(unknowns(rs)),
                              ivset = nothing)</code></pre><p>True if a given reaction is of mass action form, i.e. <code>rx.rate</code> does not depend on any chemical species that correspond to unknowns of the system, and does not depend explicitly on the independent variable (usually time).</p><p><strong>Arguments</strong></p><ul><li><code>rx</code>, the <a href="#Catalyst.Reaction"><code>Reaction</code></a>.</li><li><code>rs</code>, a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> containing the reaction.</li><li>Optional: <code>rxvars</code>, <code>Variable</code>s which are not in <code>rxvars</code> are ignored as possible dependencies.</li><li>Optional: <code>haveivdep</code>, <code>true</code> if the <a href="#Catalyst.Reaction"><code>Reaction</code></a> <code>rate</code> field explicitly depends on any independent variable (i.e. t or for spatial systems x,y,etc). If not set, will be automatically calculated.</li><li>Optional: <code>unknownset</code>, set of unknowns which if the rxvars are within mean rx is non-mass action.</li><li>Optional: <code>ivset</code>, a <code>Set</code> of the independent variables of the system. If not provided and the system is spatial, i.e. <code>isspatial(rs) == true</code>, it will be created with all the spatial variables and the time variable. If the rate expression contains any element of <code>ivset</code>, then <code>ismassaction(rx,rs) == false</code>. Pass a custom set to control this behavior.</li></ul><p>Notes:</p><ul><li>Non-integer stoichiometry is treated as non-mass action. This includes symbolic variables/terms or floating point numbers for stoichiometric coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem_conversions.jl#L197-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.dependents" href="#Catalyst.dependents"><code>Catalyst.dependents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dependents(rx, network)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a> and a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of the <em>non-constant</em> species and variables the reaction rate law depends on. e.g., for</p><p><code>k*W, 2X + 3Y --&gt; 5Z + W</code></p><p>the returned vector would be <code>[W(t),X(t),Y(t)]</code>.</p><p>Notes:</p><ul><li>Allocates</li><li>Does not check for dependents within any subsystems.</li><li>Constant species are not considered dependents since they are internally treated as parameters.</li><li>If the rate expression depends on a non-species unknown variable that will be included in the dependents, i.e. in<pre><code class="language-julia hljs">t = default_t()
@parameters k
@variables V(t)
@species A(t) B(t) C(t)
rx = Reaction(k*V, [A, B], [C])
@named rs = ReactionSystem([rx], t)
issetequal(dependents(rx, rs), [A,B,V]) == true</code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L1156-L1182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.dependants" href="#Catalyst.dependants"><code>Catalyst.dependants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dependents(rx, network)</code></pre><p>See documentation for <a href="#Catalyst.dependents"><code>dependents</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L1192-L1196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.substoichmat" href="#Catalyst.substoichmat"><code>Catalyst.substoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">substoichmat(rn; sparse=false)</code></pre><p>Returns the substrate stoichiometry matrix, <span>$S$</span>, with <span>$S_{i j}$</span> the stoichiometric coefficient of the ith substrate within the jth reaction.</p><p>Note:</p><ul><li>Set sparse=true for a sparse matrix representation</li><li>Note that constant species are not considered substrates, but just components that modify the associated rate law.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L878-L888">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.prodstoichmat" href="#Catalyst.prodstoichmat"><code>Catalyst.prodstoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prodstoichmat(rn; sparse=false)</code></pre><p>Returns the product stoichiometry matrix, <span>$P$</span>, with <span>$P_{i j}$</span> the stoichiometric coefficient of the ith product within the jth reaction.</p><p>Note:</p><ul><li>Set sparse=true for a sparse matrix representation</li><li>Note that constant species are not treated as products, but just components that modify the associated rate law.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L928-L938">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.netstoichmat" href="#Catalyst.netstoichmat"><code>Catalyst.netstoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">netstoichmat(rn, sparse=false)</code></pre><p>Returns the net stoichiometry matrix, <span>$N$</span>, with <span>$N_{i j}$</span> the net stoichiometric coefficient of the ith species within the jth reaction.</p><p>Notes:</p><ul><li>Set sparse=true for a sparse matrix representation</li><li>Caches the matrix internally within <code>rn</code> so subsequent calls are fast.</li><li>Note that constant species are not treated as reactants, but just components that modify the associated rate law. As such they do not contribute to the net stoichiometry matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L983-L994">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.reactionrates" href="#Catalyst.reactionrates"><code>Catalyst.reactionrates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactionrates(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, returns a vector of the symbolic reaction rates for each reaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L828-L833">source</a></section></article><h2 id="api_rx_metadata"><a class="docs-heading-anchor" href="#api_rx_metadata">Reaction metadata</a><a id="api_rx_metadata-1"></a><a class="docs-heading-anchor-permalink" href="#api_rx_metadata" title="Permalink"></a></h2><p>The following functions permits the retrieval of <a href="../model_creation/dsl_advanced/#dsl_advanced_options_reaction_metadata">reaction metadata</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.hasnoisescaling" href="#Catalyst.hasnoisescaling"><code>Catalyst.hasnoisescaling</code></a> — <span class="docstring-category">Function</span></header><section><div><p>hasnoisescaling(reaction::Reaction)</p><p>Returns <code>true</code> if the input reaction has the <code>noise_scaing</code> metadata field assigned, else <code>false</code>.</p><p>Arguments:</p><ul><li><code>reaction</code>: The reaction we wish to check for the <code>noise_scaing</code> metadata field.</li></ul><p>Example:</p><pre><code class="language-julia hljs">reaction = @reaction k, 0 --&gt; X, [noise_scaling=0.0]
hasnoisescaling(reaction)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reaction.jl#L509-L522">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.getnoisescaling" href="#Catalyst.getnoisescaling"><code>Catalyst.getnoisescaling</code></a> — <span class="docstring-category">Function</span></header><section><div><p>getnoisescaling(reaction::Reaction)</p><p>Returns <code>noise_scaing</code> metadata field for the input reaction.</p><p>Arguments:</p><ul><li><code>reaction</code>: The reaction we wish to retrieve the <code>noise_scaing</code> metadata field.</li></ul><p>Example:</p><pre><code class="language-julia hljs">reaction = @reaction k, 0 --&gt; X, [noise_scaling=0.0]
getnoisescaling(reaction)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reaction.jl#L527-L540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.hasdescription" href="#Catalyst.hasdescription"><code>Catalyst.hasdescription</code></a> — <span class="docstring-category">Function</span></header><section><div><p>hasdescription(reaction::Reaction)</p><p>Returns <code>true</code> if the input reaction has the <code>description</code> metadata field assigned, else <code>false</code>.</p><p>Arguments:</p><ul><li><code>reaction</code>: The reaction we wish to check for the <code>description</code> metadata field.</li></ul><p>Example:</p><pre><code class="language-julia hljs">reaction = @reaction k, 0 --&gt; X, [description=&quot;A reaction&quot;]
hasdescription(reaction)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reaction.jl#L550-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.getdescription" href="#Catalyst.getdescription"><code>Catalyst.getdescription</code></a> — <span class="docstring-category">Function</span></header><section><div><p>getdescription(reaction::Reaction)</p><p>Returns <code>description</code> metadata field for the input reaction.</p><p>Arguments:</p><ul><li><code>reaction</code>: The reaction we wish to retrieve the <code>description</code> metadata field.</li></ul><p>Example:</p><pre><code class="language-julia hljs">reaction = @reaction k, 0 --&gt; X, [description=&quot;A reaction&quot;]
getdescription(reaction)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reaction.jl#L568-L581">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.hasmisc" href="#Catalyst.hasmisc"><code>Catalyst.hasmisc</code></a> — <span class="docstring-category">Function</span></header><section><div><p>hasmisc(reaction::Reaction)</p><p>Returns <code>true</code> if the input reaction has the <code>misc</code> metadata field assigned, else <code>false</code>.</p><p>Arguments:</p><ul><li><code>reaction</code>: The reaction we wish to check for the <code>misc</code> metadata field.</li></ul><p>Example:</p><pre><code class="language-julia hljs">reaction = @reaction k, 0 --&gt; X, [misc=&quot;A reaction&quot;]
hasmisc(reaction)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reaction.jl#L591-L604">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.getmisc" href="#Catalyst.getmisc"><code>Catalyst.getmisc</code></a> — <span class="docstring-category">Function</span></header><section><div><p>getmisc(reaction::Reaction)</p><p>Returns <code>misc</code> metadata field for the input reaction.</p><p>Arguments:</p><ul><li><code>reaction</code>: The reaction we wish to retrieve the <code>misc</code> metadata field.</li></ul><p>Example:</p><pre><code class="language-julia hljs">reaction = @reaction k, 0 --&gt; X, [misc=&quot;A reaction&quot;]
getmisc(reaction)</code></pre><p>Notes:</p><ul><li>The <code>misc</code> field can contain any valid Julia structure. This mean that Catalyst cannot check it</li></ul><p>for symbolic variables that are added here. This means that symbolic variables (e.g. parameters of  species) that are stored here are not accessible to Catalyst. This can cause troubles when e.g.  creating a <code>ReactionSystem</code> programmatically (in which case any symbolic variables stored in the <code>misc</code> metadata field should also be explicitly provided to the <code>ReactionSystem</code> constructor). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reaction.jl#L609-L630">source</a></section></article><h2 id="api_network_extension_and_modification"><a class="docs-heading-anchor" href="#api_network_extension_and_modification">Functions to extend or modify a network</a><a id="api_network_extension_and_modification-1"></a><a class="docs-heading-anchor-permalink" href="#api_network_extension_and_modification" title="Permalink"></a></h2><p><code>ReactionSystem</code>s can be programmatically extended using <a href="#ModelingToolkit.extend"><code>ModelingToolkit.extend</code></a> and <a href="#ModelingToolkit.compose"><code>ModelingToolkit.compose</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.setdefaults!" href="#Catalyst.setdefaults!"><code>Catalyst.setdefaults!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setdefaults!(rn, newdefs)</code></pre><p>Sets the default (initial) values of parameters and species in the <code>ReactionSystem</code>, <code>rn</code>.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
setdefaults!(sir, [:S =&gt; 999.0, :I =&gt; 1.0, :R =&gt; 1.0, :β =&gt; 1e-4, :ν =&gt; .01])

# or
t = default_t()
@parameter β ν
@species S(t) I(t) R(t)
setdefaults!(sir, [S =&gt; 999.0, I =&gt; 1.0, R =&gt; 0.0, β =&gt; 1e-4, ν =&gt; .01])</code></pre><p>gives initial/default values to each of <code>S</code>, <code>I</code> and <code>β</code></p><p>Notes:</p><ul><li>Can not be used to set default values for species, variables or parameters of subsystems or constraint systems. Either set defaults for those systems directly, or <a href="#ModelingToolkit.flatten"><code>flatten</code></a> to collate them into one system before setting defaults.</li><li>Defaults can be specified in any iterable container of symbols to value pairs or symbolics to value pairs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L1106-L1135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.extend" href="#ModelingToolkit.extend"><code>ModelingToolkit.extend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extend(
    sys::ModelingToolkit.AbstractSystem,
    basesys::ModelingToolkit.AbstractSystem;
    name,
    gui_metadata
) -&gt; ReactionSystem{Catalyst.NetworkProperties{Int64, V}} where V&lt;:SymbolicUtils.BasicSymbolic{Real}
</code></pre><p>Extend the <code>basesys</code> with <code>sys</code>, the resulting system would inherit <code>sys</code>&#39;s name by default.</p><p>See also <a href="#ModelingToolkit.compose"><code>compose</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v9.32.0/src/systems/abstractsystem.jl#L2829">source</a></section><section><div><pre><code class="language-julia hljs">ModelingToolkit.extend(sys::AbstractSystem, rs::ReactionSystem; name::Symbol=nameof(sys))</code></pre><p>Extends the indicated <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> with another <code>AbstractSystem</code>.</p><p>Notes:</p><ul><li>The <code>AbstractSystem</code> being added in must be an <code>ODESystem</code>, <code>NonlinearSystem</code>, or <code>ReactionSystem</code> currently.</li><li>Returns a new <code>ReactionSystem</code> and does not modify <code>rs</code>.</li><li>By default, the new <code>ReactionSystem</code> will have the same name as <code>sys</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L1384-L1394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.compose" href="#ModelingToolkit.compose"><code>ModelingToolkit.compose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compose(sys, systems; name)
</code></pre><p>Compose multiple systems together. The resulting system would inherit the first system&#39;s name.</p><p>See also <a href="#ModelingToolkit.extend"><code>extend</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v9.32.0/src/systems/abstractsystem.jl#L2881">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.flatten" href="#ModelingToolkit.flatten"><code>ModelingToolkit.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Catalyst.flatten(rs::ReactionSystem)</code></pre><p>Merges all subsystems of the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> up into <code>rs</code>.</p><p>Notes:</p><ul><li>Returns a new <code>ReactionSystem</code> that represents the flattened system.</li><li>All <code>Reaction</code>s within subsystems are namespaced and merged into the list of <code>Reactions</code> of <code>rs</code>. The merged list is then available as <code>reactions(rs)</code>.</li><li>All algebraic and differential equations are merged in the equations of <code>rs</code>.</li><li>Currently only <code>ReactionSystem</code>s, <code>NonlinearSystem</code>s and <code>ODESystem</code>s are supported as sub-systems when flattening.</li><li><code>rs.networkproperties</code> is reset upon flattening.</li><li>The default value of <code>combinatoric_ratelaws</code> will be the logical or of all <code>ReactionSystem</code>s.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L1347-L1362">source</a></section></article><h2 id="Network-analysis-and-representations"><a class="docs-heading-anchor" href="#Network-analysis-and-representations">Network analysis and representations</a><a id="Network-analysis-and-representations-1"></a><a class="docs-heading-anchor-permalink" href="#Network-analysis-and-representations" title="Permalink"></a></h2><p>Note, currently API functions for network analysis and conservation law analysis do not work with constant species (currently only generated by SBMLToolkit).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.conservationlaws" href="#Catalyst.conservationlaws"><code>Catalyst.conservationlaws</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservationlaws(netstoichmat::AbstractMatrix)::Matrix</code></pre><p>Given the net stoichiometry matrix of a reaction system, computes a matrix of conservation laws, each represented as a row in the output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L640-L645">source</a></section><section><div><pre><code class="language-julia hljs">conservationlaws(rs::ReactionSystem)</code></pre><p>Return the conservation law matrix of the given <code>ReactionSystem</code>, calculating it if it is not already stored within the system, or returning an alias to it.</p><p>Notes:</p><ul><li>The first time being called it is calculated and cached in <code>rn</code>, subsequent calls should be fast.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L690-L699">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.conservedquantities" href="#Catalyst.conservedquantities"><code>Catalyst.conservedquantities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservedquantities(state, cons_laws)</code></pre><p>Compute conserved quantities for a system with the given conservation laws.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L709-L713">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.conservedequations" href="#Catalyst.conservedequations"><code>Catalyst.conservedequations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservedequations(rn::ReactionSystem)</code></pre><p>Calculate symbolic equations from conservation laws, writing dependent variables as functions of independent variables and the conservation law constants.</p><p>Notes:</p><ul><li>Caches the resulting equations in <code>rn</code>, so will be fast on subsequent calls.</li></ul><p>Examples:</p><pre><code class="language- hljs">rn = @reaction_network begin
    k, A + B --&gt; C
    k2, C --&gt; A + B
    end
conservedequations(rn)</code></pre><p>gives</p><pre><code class="nohighlight hljs">2-element Vector{Equation}:
 B(t) ~ A(t) + Γ[1]
 C(t) ~ Γ[2] - A(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L580-L603">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.conservationlaw_constants" href="#Catalyst.conservationlaw_constants"><code>Catalyst.conservationlaw_constants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservationlaw_constants(rn::ReactionSystem)</code></pre><p>Calculate symbolic equations from conservation laws, writing the conservation law constants in terms of the dependent and independent variables.</p><p>Notes:</p><ul><li>Caches the resulting equations in <code>rn</code>, so will be fast on subsequent calls.</li></ul><p>Examples:</p><pre><code class="language- hljs">rn = @reaction_network begin
    k, A + B --&gt; C
    k2, C --&gt; A + B
    end
conservationlaw_constants(rn)</code></pre><p>gives</p><pre><code class="nohighlight hljs">2-element Vector{Equation}:
 Γ[1] ~ B(t) - A(t)
 Γ[2] ~ A(t) + C(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L610-L633">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.ReactionComplexElement" href="#Catalyst.ReactionComplexElement"><code>Catalyst.ReactionComplexElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReactionComplexElement{T}</code></pre><p>One reaction complex element</p><p><strong>Fields</strong></p><ul><li><p><code>speciesid</code>: The integer id of the species representing this element.</p></li><li><p><code>speciesstoich</code>: The stoichiometric coefficient of this species.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.ReactionComplex" href="#Catalyst.ReactionComplex"><code>Catalyst.ReactionComplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReactionComplex{V&lt;:Integer} &lt;: AbstractArray{Catalyst.ReactionComplexElement{V&lt;:Integer}, 1}</code></pre><p>One reaction complex.</p><p><strong>Fields</strong></p><ul><li><p><code>speciesids</code>: The integer ids of all species participating in this complex.</p></li><li><p><code>speciesstoichs</code>: The stoichiometric coefficients of all species participating in this complex.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.reactioncomplexmap" href="#Catalyst.reactioncomplexmap"><code>Catalyst.reactioncomplexmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactioncomplexmap(rn::ReactionSystem)</code></pre><p>Find each <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a> within the specified system, constructing a mapping from the complex to vectors that indicate which reactions it appears in as substrates and products.</p><p>Notes:</p><ul><li>Each <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a> is mapped to a vector of pairs, with each pair having the form <code>reactionidx =&gt; ± 1</code>, where <code>-1</code> indicates the complex appears as a substrate and <code>+1</code> as a product in the reaction with integer label <code>reactionidx</code>.</li><li>Constant species are ignored as part of a complex. i.e. if species <code>A</code> is constant then the reaction <code>A + B --&gt; C + D</code> is considered to consist of the complexes <code>B</code> and <code>C + D</code>. Likewise <code>A --&gt; B</code> would be treated as the same as <code>0 --&gt; B</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L23-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.reactioncomplexes" href="#Catalyst.reactioncomplexes"><code>Catalyst.reactioncomplexes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactioncomplexes(network::ReactionSystem; sparse=false)</code></pre><p>Calculate the reaction complexes and complex incidence matrix for the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>.</p><p>Notes:</p><ul><li>returns a pair of a vector of <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a>s and the complex incidence matrix.</li><li>An empty <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a> denotes the null (∅) state (from reactions like ∅ -&gt; A or A -&gt; ∅).</li><li>Constant species are ignored in generating a reaction complex. i.e. if A is constant then A –&gt; B consists of the complexes ∅ and B.</li><li>The complex incidence matrix, <span>$B$</span>, is number of complexes by number of reactions with</li></ul><p class="math-container">\[B_{i j} = \begin{cases}
-1, &amp;\text{if the i&#39;th complex is the substrate of the j&#39;th reaction},\\
1, &amp;\text{if the i&#39;th complex is the product of the j&#39;th reaction},\\
0, &amp;\text{otherwise.}
\end{cases}\]</p><ul><li>Set sparse=true for a sparse matrix representation of the incidence matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L71-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.incidencemat" href="#Catalyst.incidencemat"><code>Catalyst.incidencemat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">incidencemat(rn::ReactionSystem; sparse=false)</code></pre><p>Calculate the incidence matrix of <code>rn</code>, see <a href="#Catalyst.reactioncomplexes"><code>reactioncomplexes</code></a>.</p><p>Notes:</p><ul><li>Is cached in <code>rn</code> so that future calls, assuming the same sparsity, will also be fast.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L136-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.complexstoichmat" href="#Catalyst.complexstoichmat"><code>Catalyst.complexstoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexstoichmat(network::ReactionSystem; sparse=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and vector of reaction complexes, return a matrix with positive entries of size number of species by number of complexes, where the non-zero positive entries in the kth column denote stoichiometric coefficients of the species participating in the kth reaction complex.</p><p>Notes:</p><ul><li>Set sparse=true for a sparse matrix representation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L146-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.complexoutgoingmat" href="#Catalyst.complexoutgoingmat"><code>Catalyst.complexoutgoingmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexoutgoingmat(network::ReactionSystem; sparse=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and complex incidence matrix, <span>$B$</span>, return a matrix of size num of complexes by num of reactions that identifies substrate complexes.</p><p>Notes:</p><ul><li>The complex outgoing matrix, <span>$\Delta$</span>, is defined by</li></ul><p class="math-container">\[\Delta_{i j} = \begin{cases}
    = 0,    &amp;\text{if } B_{i j} = 1, \\
    = B_{i j}, &amp;\text{otherwise.}
\end{cases}\]</p><ul><li>Set sparse=true for a sparse matrix representation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L195-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.incidencematgraph" href="#Catalyst.incidencematgraph"><code>Catalyst.incidencematgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">incidencematgraph(rn::ReactionSystem)</code></pre><p>Construct a directed simple graph where nodes correspond to reaction complexes and directed edges to reactions converting between two complexes.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
incidencematgraph(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L257-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.linkageclasses" href="#Catalyst.linkageclasses"><code>Catalyst.linkageclasses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linkageclasses(rn::ReactionSystem)</code></pre><p>Given the incidence graph of a reaction network, return a vector of the connected components of the graph (i.e. sub-groups of reaction complexes that are connected in the incidence graph).</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
linkageclasses(sir)</code></pre><p>gives</p><pre><code class="language-julia hljs">2-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L319-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.deficiency" href="#Catalyst.deficiency"><code>Catalyst.deficiency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deficiency(rn::ReactionSystem)</code></pre><p>Calculate the deficiency of a reaction network.</p><p>Here the deficiency, <span>$\delta$</span>, of a network with <span>$n$</span> reaction complexes, <span>$\ell$</span> linkage classes and a rank <span>$s$</span> stoichiometric matrix is</p><p class="math-container">\[\delta = n - \ell - s\]</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
δ = deficiency(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L401-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.subnetworks" href="#Catalyst.subnetworks"><code>Catalyst.subnetworks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subnetworks(rn::ReactionSystem)</code></pre><p>Find subnetworks corresponding to each linkage class of the reaction network.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
subnetworks(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L455-L468">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.linkagedeficiencies" href="#Catalyst.linkagedeficiencies"><code>Catalyst.linkagedeficiencies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linkagedeficiencies(network::ReactionSystem)</code></pre><p>Calculates the deficiency of each sub-reaction network within <code>network</code>.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
linkage_deficiencies = linkagedeficiencies(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L487-L500">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.isreversible" href="#Catalyst.isreversible"><code>Catalyst.isreversible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isreversible(rn::ReactionSystem)</code></pre><p>Given a reaction network, returns if the network is reversible or not.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
isreversible(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L513-L526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.isweaklyreversible" href="#Catalyst.isweaklyreversible"><code>Catalyst.isweaklyreversible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isweaklyreversible(rn::ReactionSystem, subnetworks)</code></pre><p>Determine if the reaction network with the given subnetworks is weakly reversible or not.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
subnets = subnetworks(rn)
isweaklyreversible(rn, subnets)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/network_analysis.jl#L532-L546">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.reset_networkproperties!" href="#Catalyst.reset_networkproperties!"><code>Catalyst.reset_networkproperties!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset_networkproperties!(rn::ReactionSystem)</code></pre><p>Clears the cache of various properties (like the netstoichiometry matrix). Use if such properties need to be recalculated for some reason.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L1145-L1150">source</a></section></article><h2 id="Network-comparison"><a class="docs-heading-anchor" href="#Network-comparison">Network comparison</a><a id="Network-comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Network-comparison" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{Reaction, Reaction}" href="#Base.:==-Tuple{Reaction, Reaction}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(rx1::Reaction, rx2::Reaction)</code></pre><p>Tests whether two <a href="#Catalyst.Reaction"><code>Reaction</code></a>s are identical.</p><p>Notes:</p><ul><li>Ignores the order in which stoichiometry components are listed.</li><li><em>Does not</em> currently simplify rates, so a rate of <code>A^2+2*A+1</code> would be   considered different than <code>(A+1)^2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reaction.jl#L284-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.isequivalent" href="#Catalyst.isequivalent"><code>Catalyst.isequivalent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isequivalent(rn1::ReactionSystem, rn2::ReactionSystem; ignorenames = true)</code></pre><p>Tests whether the underlying species, parameters and reactions are the same in the two <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>s. Ignores the names of the systems in testing equality.</p><p>Notes:</p><ul><li><em>Does not</em> currently simplify rates, so a rate of <code>A^2+2*A+1</code> would be   considered different than <code>(A+1)^2</code>.</li><li>Does not include <code>defaults</code> in determining equality.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L576-L587">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Tuple{ReactionSystem, ReactionSystem}" href="#Base.:==-Tuple{ReactionSystem, ReactionSystem}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(rn1::ReactionSystem, rn2::ReactionSystem)</code></pre><p>Tests whether the underlying species, parameters and reactions are the same in the two <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>s. Requires the systems to have the same names too.</p><p>Notes:</p><ul><li><em>Does not</em> currently simplify rates, so a rate of <code>A^2+2*A+1</code> would be   considered different than <code>(A+1)^2</code>.</li><li>Does not include <code>defaults</code> in determining equality.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L560-L571">source</a></section></article><h2 id="Network-visualization"><a class="docs-heading-anchor" href="#Network-visualization">Network visualization</a><a id="Network-visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Network-visualization" title="Permalink"></a></h2><p><a href="https://korsbo.github.io/Latexify.jl/stable/">Latexify</a> can be used to convert networks to LaTeX equations by</p><pre><code class="language-julia hljs">using Latexify
latexify(rn)</code></pre><p>An optional argument, <code>form</code> allows using <code>latexify</code> to display a reaction network&#39;s ODE (as generated by the reaction rate equation) or SDE (as generated by the chemical Langevin equation) form:</p><pre><code class="language-julia hljs">latexify(rn; form=:ode)</code></pre><pre><code class="language-julia hljs">latexify(rn; form=:sde)</code></pre><p>(As of writing this, an upstream bug causes the SDE form to be erroneously displayed as the ODE form)</p><p>Finally, another optional argument (<code>expand_functions=true</code>) automatically expands functions defined by Catalyst (such as <code>mm</code>). To disable this, set <code>expand_functions=false</code>.</p><p>If <a href="https://graphviz.org/">Graphviz</a> is installed and commandline accessible, it can be used to create and save network diagrams using <a href="#Catalyst.Graph"><code>Graph</code></a> and <a href="#Catalyst.savegraph"><code>savegraph</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.Graph" href="#Catalyst.Graph"><code>Catalyst.Graph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Graph(rn::ReactionSystem)</code></pre><p>Converts a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> into a Graphviz graph. Reactions correspond to small green circles, and species to blue circles.</p><p>Notes:</p><ul><li>Black arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry.</li><li>Black arrows from reactions to species indicate products, and are labelled with their output stoichiometry.</li><li>Red arrows from species to reactions indicate that species is used within the rate expression. For example, in the reaction <code>k*A, B --&gt; C</code>, there would be a red arrow from <code>A</code> to the reaction node. In <code>k*A, A+B --&gt; C</code>, there would be red and black arrows from <code>A</code> to the reaction node.</li><li>Requires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/graphs.jl#L370-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.complexgraph" href="#Catalyst.complexgraph"><code>Catalyst.complexgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexgraph(rn::ReactionSystem; complexdata=reactioncomplexes(rn))</code></pre><p>Creates a Graphviz graph of the <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a>s in <code>rn</code>. Reactions correspond to arrows and reaction complexes to blue circles.</p><p>Notes:</p><ul><li>Black arrows from complexes to complexes indicate reactions whose rate is a parameter or a <code>Number</code>. i.e. <code>k, A --&gt; B</code>.</li><li>Red dashed arrows from complexes to complexes indicate reactions whose rate depends on species. i.e. <code>k*C, A --&gt; B</code> for <code>C</code> a species.</li><li>Requires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/graphs.jl#L322-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.savegraph" href="#Catalyst.savegraph"><code>Catalyst.savegraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">savegraph(g::Graph, fname, fmt=&quot;png&quot;)</code></pre><p>Given a <code>Graph</code> generated by <a href="#Catalyst.Graph"><code>Graph</code></a>, save the graph to the file with name <code>fname</code> and extension <code>fmt</code>.</p><p>Notes:</p><ul><li><code>fmt=&quot;png&quot;</code> is the default output format.</li><li>Requires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/graphs.jl#L413-L422">source</a></section></article><h2 id="api_rate_laws"><a class="docs-heading-anchor" href="#api_rate_laws">Rate laws</a><a id="api_rate_laws-1"></a><a class="docs-heading-anchor-permalink" href="#api_rate_laws" title="Permalink"></a></h2><p>As the underlying <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> is comprised of <code>ModelingToolkit</code> expressions, one can directly access the generated rate laws, and using <code>ModelingToolkit</code> tooling generate functions or Julia <code>Expr</code>s from them.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.oderatelaw" href="#Catalyst.oderatelaw"><code>Catalyst.oderatelaw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">oderatelaw(rx; combinatoric_ratelaw=true)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a>, return the symbolic reaction rate law used in generated ODEs for the reaction. Note, for a reaction defined by</p><p><code>k*X*Y, X+Z --&gt; 2X + Y</code></p><p>the expression that is returned will be <code>k*X(t)^2*Y(t)*Z(t)</code>. For a reaction of the form</p><p><code>k, 2X+3Y --&gt; Z</code></p><p>the expression that is returned will be <code>k * (X(t)^2/2) * (Y(t)^3/6)</code>.</p><p>Notes:</p><ul><li>Allocates</li><li><code>combinatoric_ratelaw=true</code> uses factorial scaling factors in calculating the   rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. If   <code>combinatoric_ratelaw=false</code> then the ratelaw is <code>k*S^2</code>, i.e. the scaling   factor is ignored.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem_conversions.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.jumpratelaw" href="#Catalyst.jumpratelaw"><code>Catalyst.jumpratelaw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jumpratelaw(rx; combinatoric_ratelaw=true)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a>, return the symbolic reaction rate law used in generated stochastic chemical kinetics model SSAs for the reaction. Note, for a reaction defined by</p><p><code>k*X*Y, X+Z --&gt; 2X + Y</code></p><p>the expression that is returned will be <code>k*X^2*Y*Z</code>. For a reaction of the form</p><p><code>k, 2X+3Y --&gt; Z</code></p><p>the expression that is returned will be <code>k * binomial(X,2) * binomial(Y,3)</code>.</p><p>Notes:</p><ul><li>Allocates</li><li><code>combinatoric_ratelaw=true</code> uses binomials in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S*(S-1)/2</code>. If <code>combinatoric_ratelaw=false</code> then the ratelaw is <code>k*S*(S-1)</code>, i.e. the rate law is not normalized by the scaling factor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem_conversions.jl#L148-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.mm" href="#Catalyst.mm"><code>Catalyst.mm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mm(X,v,K) = v*X / (X + K)</code></pre><p>A Michaelis-Menten rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/registered_functions.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.mmr" href="#Catalyst.mmr"><code>Catalyst.mmr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mmr(X,v,K) = v*K / (X + K)</code></pre><p>A repressive Michaelis-Menten rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/registered_functions.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.hill" href="#Catalyst.hill"><code>Catalyst.hill</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hill(X,v,K,n) = v*(X^n) / (X^n + K^n)</code></pre><p>A Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/registered_functions.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.hillr" href="#Catalyst.hillr"><code>Catalyst.hillr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hillr(X,v,K,n) = v*(K^n) / (X^n + K^n)</code></pre><p>A repressive Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/registered_functions.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.hillar" href="#Catalyst.hillar"><code>Catalyst.hillar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hillar(X,Y,v,K,n) = v*(X^n) / (X^n + Y^n + K^n)</code></pre><p>An activation/repressing Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/registered_functions.jl#L83-L87">source</a></section></article><h2 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert" href="#Base.convert"><code>Base.convert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:ODESystem},rs::ReactionSystem)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.ODESystem</code>.</p><p>Keyword args and default values:</p><ul><li><code>combinatoric_ratelaws=true</code> uses factorial scaling factors in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. Set <code>combinatoric_ratelaws=false</code> for a ratelaw of <code>k*S^2</code>, i.e. the scaling factor is ignored. Defaults to the value given when the <code>ReactionSystem</code> was constructed (which itself defaults to true).</li><li><code>remove_conserved=false</code>, if set to <code>true</code> will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.</li><li><code>remove_conserved_warn = true</code>: If <code>true</code>, if also <code>remove_conserved = true</code>, there will be a warning regarding limitations of modifying problems generated from the created system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem_conversions.jl#L471-L488">source</a></section><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:NonlinearSystem},rs::ReactionSystem)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.NonlinearSystem</code>.</p><p>Keyword args and default values:</p><ul><li><code>combinatoric_ratelaws=true</code> uses factorial scaling factors in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. Set <code>combinatoric_ratelaws=false</code> for a ratelaw of <code>k*S^2</code>, i.e. the scaling factor is ignored. Defaults to the value given when the <code>ReactionSystem</code> was constructed (which itself defaults to true).</li><li><code>remove_conserved=false</code>, if set to <code>true</code> will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.</li><li><code>remove_conserved_warn = true</code>: If <code>true</code>, if also <code>remove_conserved = true</code>, there will be a warning regarding limitations of modifying problems generated from the created system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem_conversions.jl#L517-L535">source</a></section><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:SDESystem},rs::ReactionSystem)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.SDESystem</code>.</p><p>Notes:</p><ul><li><code>combinatoric_ratelaws=true</code> uses factorial scaling factors in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. Set <code>combinatoric_ratelaws=false</code> for a ratelaw of <code>k*S^2</code>, i.e. the scaling factor is ignored. Defaults to the value given when the <code>ReactionSystem</code> was constructed (which itself defaults to true).</li><li><code>remove_conserved=false</code>, if set to <code>true</code> will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.</li><li><code>remove_conserved_warn = true</code>: If <code>true</code>, if also <code>remove_conserved = true</code>, there will be a warning regarding limitations of modifying problems generated from the created system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem_conversions.jl#L600-L618">source</a></section><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:JumpSystem},rs::ReactionSystem; combinatoric_ratelaws=true)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.JumpSystem</code>.</p><p>Notes:</p><ul><li><code>combinatoric_ratelaws=true</code> uses binomials in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S*(S-1)/2</code>. If <code>combinatoric_ratelaws=false</code> then the ratelaw is <code>k*S*(S-1)</code>, i.e. the rate law is not normalized by the scaling factor. Defaults to the value given when the <code>ReactionSystem</code> was constructed (which itself defaults to true).</li><li>Does not currently support <code>ReactionSystem</code>s that include coupled algebraic or differential equations.</li><li>Does not currently support continuous events as these are not supported by <code>ModelingToolkit.JumpSystems</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem_conversions.jl#L654-L671">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.JumpInputs" href="#Catalyst.JumpInputs"><code>Catalyst.JumpInputs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct JumpInputs{S&lt;:JumpSystem, T&lt;:SciMLBase.AbstractODEProblem}</code></pre><p>Inputs for a JumpProblem from a given <code>ReactionSystem</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>sys</code>: The <code>JumpSystem</code> to define the problem over</p></li><li><p><code>prob</code>: The problem the JumpProblem should be defined over, for example DiscreteProblem</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem_conversions.jl#L772">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.structural_simplify" href="#ModelingToolkit.structural_simplify"><code>ModelingToolkit.structural_simplify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">structural_simplify(sys; ...)
structural_simplify(
    sys,
    io;
    simplify,
    split,
    allow_symbolic,
    allow_parameter,
    conservative,
    fully_determined,
    kwargs...
)
</code></pre><p>Structurally simplify algebraic equations in a system and compute the topological sort of the observed equations in <code>sys</code>.</p><p><strong>Optional Arguments:</strong></p><ul><li>optional argument <code>io</code> may take a tuple <code>(inputs, outputs)</code>. This will convert all <code>inputs</code> to parameters and allow them to be unconnected, i.e., simplification will allow models where <code>n_unknowns = n_equations - n_inputs</code>.</li></ul><p><strong>Optional Keyword Arguments:</strong></p><ul><li>When <code>simplify=true</code>, the <code>simplify</code> function will be applied during the tearing process.</li><li><code>allow_symbolic=false</code>, <code>allow_parameter=true</code>, and <code>conservative=false</code> limit the coefficient types during tearing. In particular, <code>conservative=true</code> limits tearing to only solve for trivial linear systems where the coefficient has the absolute value of <span>$1$</span>.</li><li><code>fully_determined=true</code> controls whether or not an error will be thrown if the number of equations don&#39;t match the number of inputs, outputs, and equations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v9.32.0/src/systems/systems.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.set_default_noise_scaling" href="#Catalyst.set_default_noise_scaling"><code>Catalyst.set_default_noise_scaling</code></a> — <span class="docstring-category">Function</span></header><section><div><p>set<em>default</em>noise<em>scaling(rs::ReactionSystem, noise</em>scaling)</p><p>Creates an updated <code>ReactionSystem</code>. This is the old <code>ReactionSystem</code>, but each <code>Reaction</code> that does not have a <code>noise_scaling</code> metadata have its noise<em>scaling metadata updated. The input <code>ReactionSystem</code> is not mutated. Any subsystems of <code>rs</code> have their `noise</em>scaling` metadata updated as well.</p><p>Arguments:</p><ul><li><code>rs::ReactionSystem</code>: The <code>ReactionSystem</code> which you wish to remake.</li><li><code>noise_scaling</code>: The updated noise scaling terms</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L1304-L1314">source</a></section></article><h2 id="Chemistry-related-functionalities"><a class="docs-heading-anchor" href="#Chemistry-related-functionalities">Chemistry-related functionalities</a><a id="Chemistry-related-functionalities-1"></a><a class="docs-heading-anchor-permalink" href="#Chemistry-related-functionalities" title="Permalink"></a></h2><p>Various functionalities primarily relevant to modelling of chemical systems (but potentially also in biology).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.@compound" href="#Catalyst.@compound"><code>Catalyst.@compound</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@compound</code></pre><p>Macro that creates a compound species, which is composed of smaller component species.</p><p>Example:</p><pre><code class="language-julia hljs">t = default_t()
@species C(t) O(t)
@compound CO2(t) ~ C + 2O</code></pre><p>Notes: </p><ul><li>The component species must be defined before using the <code>@compound</code> macro.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/chemistry_functionality.jl#L54-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.@compounds" href="#Catalyst.@compounds"><code>Catalyst.@compounds</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@compounds</code></pre><p>Macro that creates several compound species, which each is composed of smaller component species. Uses the same syntax as <code>@compound</code>, but with one compound species one each line.</p><p>Example:</p><pre><code class="language-julia hljs">t = default_t()
@species C(t) H(t) O(t) 
@compounds
    CH4(t) = C + 4H
    O2(t) = 2O
    CO2(t) = C + 2O
    H2O(t) = 2H + O
end</code></pre><p>Notes: </p><ul><li>The component species must be defined before using the <code>@compound</code> macro.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/chemistry_functionality.jl#L154-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.iscompound" href="#Catalyst.iscompound"><code>Catalyst.iscompound</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iscompound(s)</code></pre><p>Returns <code>true</code> if the input is a compound species (else false).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/chemistry_functionality.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.components" href="#Catalyst.components"><code>Catalyst.components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">components(s)</code></pre><p>Returns a vector with a list of all the components of a compound species (created using e.g. the @compound macro).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/chemistry_functionality.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.coefficients" href="#Catalyst.coefficients"><code>Catalyst.coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coefficients(s)</code></pre><p>Returns a vector with a list of all the stoichiometric coefficients of the components of a compound species (created using e.g. the @compound macro).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/chemistry_functionality.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.component_coefficients" href="#Catalyst.component_coefficients"><code>Catalyst.component_coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">component_coefficients(s)</code></pre><p>Returns a Vector{Pari{Symbol,Int64}}, listing a compounds species (created using e.g. the @compound macro) all the coefficients and their stoichiometric coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/chemistry_functionality.jl#L42-L46">source</a></section></article><h2 id="Unit-validation"><a class="docs-heading-anchor" href="#Unit-validation">Unit validation</a><a id="Unit-validation-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-validation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.validate-Tuple{Reaction}" href="#ModelingToolkit.validate-Tuple{Reaction}"><code>ModelingToolkit.validate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate(rx::Reaction; info::String = &quot;&quot;)</code></pre><p>Check that all substrates and products within the given <a href="#Catalyst.Reaction"><code>Reaction</code></a> have the same units, and that the units of the reaction&#39;s rate expression are internally consistent (i.e. if the rate involves sums, each term in the sum has the same units).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reaction.jl#L641-L649">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.validate" href="#ModelingToolkit.validate"><code>ModelingToolkit.validate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">validate(rs::ReactionSystem, info::String=&quot;&quot;)</code></pre><p>Check that all species in the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> have the same units, and that the rate laws of all reactions reduce to units of (species units) / (time units).</p><p>Notes:</p><ul><li>Does not check subsystems, constraint equations, or non-species variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem.jl#L1443-L1452">source</a></section></article><h2 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.symmap_to_varmap" href="#Catalyst.symmap_to_varmap"><code>Catalyst.symmap_to_varmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">symmap_to_varmap(sys, symmap)</code></pre><p>Given a system and map of <code>Symbol</code>s to values, generates a map from corresponding symbolic variables/parameters to the values that can be used to pass initial conditions and parameter mappings.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network sir begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
subsys = @reaction_network subsys begin
    k, A --&gt; B
end
@named sys = compose(sir, [subsys])</code></pre><p>gives</p><pre><code class="nohighlight hljs">Model sys with 3 equations
Unknowns (5):
  S(t)
  I(t)
  R(t)
  subsys₊A(t)
  subsys₊B(t)
Parameters (3):
  β
  ν
  subsys₊k</code></pre><p>to specify initial condition and parameter mappings from <em>symbols</em> we can use</p><pre><code class="language-julia hljs">symmap = [:S =&gt; 1.0, :I =&gt; 1.0, :R =&gt; 1.0, :subsys₊A =&gt; 1.0, :subsys₊B =&gt; 1.0]
u0map  = symmap_to_varmap(sys, symmap)
pmap   = symmap_to_varmap(sys, [:β =&gt; 1.0, :ν =&gt; 1.0, :subsys₊k =&gt; 1.0])</code></pre><p><code>u0map</code> and <code>pmap</code> can then be used as input to various problem types.</p><p>Notes:</p><ul><li>Any <code>Symbol</code>, <code>sym</code>, within <code>symmap</code> must be a valid field of <code>sys</code>. i.e. <code>sys.sym</code> must be defined.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/reactionsystem_conversions.jl#L919-L962">source</a></section></article><h2 id="api_lattice_simulations"><a class="docs-heading-anchor" href="#api_lattice_simulations">Spatial modelling</a><a id="api_lattice_simulations-1"></a><a class="docs-heading-anchor-permalink" href="#api_lattice_simulations" title="Permalink"></a></h2><p>The first step of spatial modelling is to create a so-called <code>LatticeReactionSystem</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.LatticeReactionSystem" href="#Catalyst.LatticeReactionSystem"><code>Catalyst.LatticeReactionSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LatticeReactionSystem{Q, R, S, T} &lt;: AbstractTimeDependentSystem</code></pre><p>A representation of a spatial system of chemical reactions on a discrete (lattice) space. </p><p><strong>Fields</strong></p><ul><li><p><code>reactionsystem</code>: The (non-spatial) reaction system within each vertex.</p></li><li><p><code>spatial_reactions</code>: The spatial reactions defined between individual vertices.</p></li><li><p><code>lattice</code>: The lattice on which the (discrete) spatial system is defined.</p></li><li><p><code>num_verts</code>: The number of vertices (compartments).</p></li><li><p><code>num_edges</code>: The number of edges.</p></li><li><p><code>num_species</code>: The number of species.</p></li><li><p><code>spatial_species</code>: List of species that may move spatially.</p></li><li><p><code>parameters</code>: All parameters related to the lattice reaction system (both those whose values are tied to vertices and edges).</p></li></ul><ul><li><code>vertex_parameters</code>: Parameters which values are tied to vertices, e.g. that possibly could have unique values at each vertex of the system.</li></ul><ul><li><code>edge_parameters</code>: Parameters whose values are tied to edges (adjacencies), e.g. that possibly could have unique values at each edge of the system.</li></ul><ul><li><code>edge_iterator</code>: An iterator over all the lattice&#39;s edges. Currently, the format is always a Vector{Pair{Int64,Int64}}. However, in the future, different types could potentially be used for different types of lattice (E.g. for a Cartesian grid, we do not technically need to enumerate each edge)</li></ul><p>Arguments:</p><ul><li><code>rs</code>: The non-spatial <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> model that is expanded to a spatial model.</li><li><code>srs</code>: A vector of spatial reactions. These provide the rules for how species may move spatially.</li><li><code>lattice</code>: Either a Cartesian grid, a masked grid, or a graph. This describes the discrete space</li></ul><p>to which the non-spatial model is expanded.</p><p>Keyword Arguments:</p><ul><li><code>diagonal_connections = false</code>: Only relevant for Cartesian and masked lattices. If <code>true</code>, </li></ul><p>diagonally adjacent compartments are considered adjacent, and spatial reactions in between these are possible.</p><p>Example:</p><pre><code class="language-julia hljs"># Fetch packages.
using Catalyst, OrdinaryDiffEq
import CairoMakie

# Creates the `LatticeReactionSystem` model.
rs = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
diffusion_rx = @transport_reaction D X
lattice = CartesianGrid((5,5))
lrs = LatticeReactionSystem(rs, [diffusion_rx], lattice)

# Simulates the model (using ODE and jumps).
u0 = [:X =&gt; rand(5,5)]
tspan = (0.0, 1.0)
ps = [:p =&gt; 1.0, :d =&gt; 0.5, :D =&gt; 0.1]
oprob = ODEProblem(lrs, u0, tspan, ps)
osol = solve(oprob)

# Saves an animation of the solution to the file &quot;lattice_animation.mp4&quot;.
lattice_animation(osol, :X, lrs, &quot;lattice_animation.mp4&quot;)</code></pre><p>Notes:</p><ul><li>Spatial modelling in Catalyst is still a work in progress, any feedback (or contributions) to this</li></ul><p>is highly welcome.</p><ul><li><code>LatticeReactionSystem</code>s are primarily intended to model systems in discrete space. Modelling</li></ul><p>continuous space systems with them is possible, but requires the user to determine the discretisation (the lattice). Better support for continuous space models is a work in progress.</p><ul><li>Catalyst contains extensive documentation on spatial modelling, which can be found <a href="https://docs.sciml.ai/Catalyst/stable/spatial_modelling/lattice_reaction_systems/">here</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L8">source</a></section></article><p>The following functions can be used to querying the properties of <code>LatticeReactionSystem</code>s:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.reactionsystem" href="#Catalyst.reactionsystem"><code>Catalyst.reactionsystem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactionsystem(lrs::LatticeReactionSystem)</code></pre><p>Returns the non-spatial <code>ReactionSystem</code> stored in a <code>LatticeReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L307-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.spatial_reactions" href="#Catalyst.spatial_reactions"><code>Catalyst.spatial_reactions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spatial_reactions(lrs::LatticeReactionSystem)</code></pre><p>Returns a vector with all the spatial reactions stored in a <code>LatticeReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L314-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.lattice" href="#Catalyst.lattice"><code>Catalyst.lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lattice(lrs::LatticeReactionSystem)</code></pre><p>Returns the lattice stored in a <code>LatticeReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L321-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.num_verts" href="#Catalyst.num_verts"><code>Catalyst.num_verts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_verts(lrs::LatticeReactionSystem)</code></pre><p>Returns the number of vertices (i.e. compartments) in the lattice stored in a <code>LatticeReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L328-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.num_edges" href="#Catalyst.num_edges"><code>Catalyst.num_edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_edges(lrs::LatticeReactionSystem)</code></pre><p>Returns the number of edges (i.e. connections between vertices) in the lattice stored in a  <code>LatticeReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L335-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.num_species" href="#Catalyst.num_species"><code>Catalyst.num_species</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_species(lrs::LatticeReactionSystem)</code></pre><p>Returns the number of species that a <code>LatticeReactionSystem</code> contains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L343-L347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.spatial_species" href="#Catalyst.spatial_species"><code>Catalyst.spatial_species</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spatial_species(lrs::LatticeReactionSystem)</code></pre><p>Returns the number of species that can move spatially that a <code>LatticeReactionSystem</code> contains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L350-L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.vertex_parameters" href="#Catalyst.vertex_parameters"><code>Catalyst.vertex_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vertex_parameters(lrs::LatticeReactionSystem)</code></pre><p>Returns all the parameters of a <code>LatticeReactionSystem</code> whose values are tied to vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L360-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.edge_parameters" href="#Catalyst.edge_parameters"><code>Catalyst.edge_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edge_parameters(lrs::LatticeReactionSystem)</code></pre><p>Returns all the parameters of a <code>LatticeReactionSystem</code> whose values are tied to edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L367-L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.edge_iterator" href="#Catalyst.edge_iterator"><code>Catalyst.edge_iterator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edge_iterator(lrs::LatticeReactionSystem)</code></pre><p>Returns an iterator over all of the edges in the lattice stored in a <code>LatticeReactionSystem</code>. Each edge is a <code>Pair{Int64, Int64}</code>, taking the source vertex to the destination vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L374-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.is_transport_system" href="#Catalyst.is_transport_system"><code>Catalyst.is_transport_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_transport_system(lrs::LatticeReactionSystem)</code></pre><p>Returns <code>true</code> if all spatial reactions in <code>lrs</code> are <code>TransportReaction</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L383-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.has_cartesian_lattice" href="#Catalyst.has_cartesian_lattice"><code>Catalyst.has_cartesian_lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_cartesian_lattice(lrs::LatticeReactionSystem)</code></pre><p>Returns <code>true</code> if <code>lrs</code> was created using a cartesian grid lattice (e.g. created via <code>CartesianGrid(5,5)</code>).  Otherwise, returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L392-L397">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.has_masked_lattice" href="#Catalyst.has_masked_lattice"><code>Catalyst.has_masked_lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_masked_lattice(lrs::LatticeReactionSystem)</code></pre><p>Returns <code>true</code> if <code>lrs</code> was created using a masked grid lattice (e.g. created via <code>[true true; true false]</code>).  Otherwise, returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L401-L406">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.has_grid_lattice" href="#Catalyst.has_grid_lattice"><code>Catalyst.has_grid_lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_grid_lattice(lrs::LatticeReactionSystem)</code></pre><p>Returns <code>true</code> if <code>lrs</code> was created using a cartesian or masked grid lattice. Otherwise, returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L409-L413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.has_graph_lattice" href="#Catalyst.has_graph_lattice"><code>Catalyst.has_graph_lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_graph_lattice(lrs::LatticeReactionSystem)</code></pre><p>Returns <code>true</code> if <code>lrs</code> was created using a graph grid lattice (e.g. created via <code>path_graph(5)</code>).  Otherwise, returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L418-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.grid_size" href="#Catalyst.grid_size"><code>Catalyst.grid_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">grid_size(lrs::LatticeReactionSystem)</code></pre><p>Returns the size of <code>lrs</code>&#39;s lattice (only if it is a cartesian or masked grid lattice).  E.g. for a lattice <code>CartesianGrid(4,6)</code>, <code>(4,6)</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L426-L431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.grid_dims" href="#Catalyst.grid_dims"><code>Catalyst.grid_dims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">grid_dims(lrs::LatticeReactionSystem)</code></pre><p>Returns the number of dimensions of <code>lrs</code>&#39;s lattice (only if it is a cartesian or masked grid lattice).  The output is either <code>1</code>, <code>2</code>, or <code>3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L439-L444">source</a></section></article><p>In addition, most accessor functions for normal <code>ReactionSystem</code>s (such as <code>species</code> and <code>parameters</code>) works when applied to <code>LatticeReactionSystem</code>s as well.</p><p>The following two helper functions can be used to create non-uniform parameter values.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.make_edge_p_values" href="#Catalyst.make_edge_p_values"><code>Catalyst.make_edge_p_values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_edge_p_values(lrs::LatticeReactionSystem, make_edge_p_value::Function)</code></pre><p>Generates edge parameter values for a lattice reaction system. Only work for (Cartesian or masked)  grid lattices (without diagonal adjacencies). </p><p>Input:</p><ul><li><code>lrs</code>: The lattice reaction system for which values should be generated.<ul><li><code>make_edge_p_value</code>: a function describing a rule for generating the edge parameter values.</li></ul></li></ul><p>Output:     - <code>ep_vals</code>: A sparse matrix of size (num<em>verts,num</em>verts) (where num<em>verts is the number of      vertices in <code>lrs</code>). Here, <code>eps[i,j]</code> is filled only if there is an edge going from vertex i to      vertex j. The value of <code>eps[i,j]</code> is determined by `make</em>edge<em>p</em>value`.</p><p>Here, <code>make_edge_p_value</code> should take two arguments, <code>src_vert</code> and <code>dst_vert</code>, which correspond to  the grid indices of an edge&#39;s source and destination vertices, respectively. It outputs a single value, which is the value assigned to that edge.</p><p>Example:     In the following example, we assign the value <code>0.1</code> to all edges, except for the one leading from     vertex (1,1) to vertex (1,2), to which we assign the value <code>1.0</code>.</p><pre><code class="language-julia hljs">using Catalyst
rn = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
tr = @transport_reaction D X
lattice = CartesianGrid((5,5))
lrs = LatticeReactionSystem(rn, [tr], lattice)

function make_edge_p_value(src_vert, dst_vert)
    if src_vert == (1,1) &amp;&amp; dst_vert == (1,2)
        return 1.0
    else
        return 0.1
    end
end

D_vals = make_edge_p_values(lrs, make_edge_p_value)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L506-L547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.make_directed_edge_values" href="#Catalyst.make_directed_edge_values"><code>Catalyst.make_directed_edge_values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_directed_edge_values(lrs::LatticeReactionSystem, x_vals::Tuple{T,T}, y_vals::Tuple{T,T} = (undef,undef), 
                 z_vals::Tuple{T,T} = (undef,undef)) where {T}</code></pre><p>Generates edge parameter values for a lattice reaction system. Only work for (Cartesian or masked)  grid lattices (without diagonal adjacencies). Each dimension (x, and possibly y and z), and  direction has assigned its own constant edge parameter value.</p><p>Input:     - <code>lrs</code>: The lattice reaction system for which values should be generated.     - <code>x_vals::Tuple{T,T}</code>: The values in the increasing (from a lower x index to a higher x index)      and decreasing (from a higher x index to a lower x index) direction along the x dimension.     - <code>y_vals::Tuple{T,T}</code>: The values in the increasing and decreasing direction along the y dimension.      Should only be used for 2 and 3-dimensional grids.     - <code>z_vals::Tuple{T,T}</code>: The values in the increasing and decreasing direction along the z dimension.      Should only be used for 3-dimensional grids.</p><p>Output:     - <code>ep_vals</code>: A sparse matrix of size (num<em>verts,num</em>verts) (where num<em>verts is the number of      vertices in <code>lrs</code>). Here, <code>eps[i,j]</code> is filled only if there is an edge going from vertex i to      vertex j. The value of <code>eps[i,j]</code> is determined by the `x</em>vals<code>,</code>y<em>vals<code>, and</code>z</em>vals` Tuples,      and vertices i and j&#39;s relative position in the grid.</p><p>It should be noted that two adjacent vertices will always be different in exactly a single dimension  (x, y, or z). The corresponding tuple determines which value is assigned.</p><p>Example:     In the following example, we wish to have diffusion in the x dimension, but a constant flow from     low y values to high y values (so not transportation from high to low y). We achieve it in the      following manner:</p><pre><code class="language-julia hljs">using Catalyst
rn = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
tr = @transport_reaction D X
lattice = CartesianGrid((5,5))
lrs = LatticeReactionSystem(rn, [tr], lattice)

D_vals = make_directed_edge_values(lrs, (0.1, 0.1), (0.1, 0.0))</code></pre><p>Here, since we have a 2d grid, we only provide the first two Tuples to <code>make_directed_edge_values</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_reaction_systems.jl#L570-L612">source</a></section></article><p>The following functions can be used to access, or change, species or parameter values stored in problems, integrators, and solutions that are based on <code>LatticeReactionSystem</code>s.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.lat_getu" href="#Catalyst.lat_getu"><code>Catalyst.lat_getu</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lat_getu(sim_struct, sp, lrs::LatticeReactionSystem)</code></pre><p>For a problem or integrators, retrieves its <code>u</code> values. For non-lattice models, this is can be done through direct interfacing (e.g. <code>prob[X]</code>). However, for  <code>LatticeReactionSystem</code>-based problems and integrators, this function must be used instead. The output format depends on the lattice (a dense array for cartesian grid lattices, a sparse array for masked grid lattices, and a vector for graph lattices). This format is similar to which is used to designate species initial conditions.</p><p>Arguments:</p><ul><li><code>sim_struct</code>: The simulation structure which <code>u</code> value we wish to retrieve. Can be either a <code>ODEProblem</code>, <code>JumpProblem</code>, or an integrator derived from either of these.</li><li><code>sp</code>: The species which value we wish to update. Can be provided either in its symbolic form (e.g. <code>X</code>) or as a symbol (e.g. <code>:X</code>).</li><li><code>lrs</code>: The <code>LatticeReactionSystem</code> which was used to generate the structure we wish to modify.</li></ul><p>Notes:</p><ul><li>Even if the species is spatially uniform, a full array with its values across all vertices will be retrieved. </li></ul><p>Example:</p><pre><code class="language-julia hljs"># Prepare `LatticeReactionSystem`s.
using Catalyst
rs = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
tr = @transport_reaction D X1
lrs = LatticeReactionSystem(rs, [tr], CartesianGrid((2,3)))

# Prepares a corresponding ODEProblem.
u0 = [:X1 =&gt; [1.0 2.0 3.0; 4.0 5.0 6.0], :X2 =&gt; 2.0]
tspan = (0.0, 50.0)
ps = [:k1 =&gt; 2.0, :k2 =&gt; 1.0, :D =&gt; 0.01]
oprob = ODEProblem(lrs, u0, tspan, ps)

# Updates the `ODEProblem`.
lat_getu(oprob, :X1, lrs) # Retrieves the value of `X1`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_sim_struct_interfacing.jl#L223-L260">source</a></section><section><div><pre><code class="language-julia hljs">lat_getu(sol, sp, lrs::LatticeReactionSystem; t = nothing)</code></pre><p>A function for retrieving the solution of a <code>LatticeReactionSystem</code>-based simulation on various desired forms. Generally, for <code>LatticeReactionSystem</code>s, the values in <code>sol</code> is ordered in a  way which is not directly interpretable by the user. Furthermore, the normal Catalyst interface for solutions (e.g. <code>sol[:X]</code>) does not work for these solutions. Hence this function is used instead.</p><p>The output is a vector, which in each position contains sp&#39;s value (either at a time step of time, depending on the input <code>t</code>). Its shape depends on the lattice (using a similar form as heterogeneous initial conditions). I.e. for a NxM cartesian grid, the values are NxM matrices. For a masked grid, the values are sparse matrices. For a graph lattice, the values are vectors (where the value in the n&#39;th position corresponds to sp&#39;s value in the n&#39;th vertex).</p><p>Arguments:</p><ul><li><code>sol</code>: The solution from which we wish to retrieve some values.</li><li><code>sp</code>: The species which value we wish to update. Can be provided either in its symbolic form (e.g. <code>X</code>) or as a symbol (e.g. <code>:X</code>).</li><li><code>lrs</code>: The <code>LatticeReactionSystem</code> which was simulated to generate the solution.</li><li><code>t = nothing</code>: If <code>nothing</code>, we simply return the solution across all saved time steps (default). If <code>t</code> instead is a vector (or range of values), returns the solution interpolated at these time points.</li></ul><p>Notes:</p><ul><li>The <code>lat_getu</code> is not optimised for performance. However, it should still be quite performant, but there might be some limitations if called a very large number of times.</li><li>Long-term it is likely that this function gets replaced with a sleeker interface.</li></ul><p>Example:</p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEq

# Prepare `LatticeReactionSystem`s.
rs = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
tr = @transport_reaction D X1 
lrs = LatticeReactionSystem(rs, [tr], CartesianGrid((2,2)))

# Create problems.
u0 = [:X1 =&gt; 1, :X2 =&gt; 2]
tspan = (0.0, 10.0)
ps = [:k1 =&gt; 1, :k2 =&gt; 2.0, :D =&gt; 0.1]

oprob = ODEProblem(lrs1, u0, tspan, ps)
osol = solve(oprob1, Tsit5())
lat_getu(osol, :X1, lrs) # Returns the value of X1 at each time step.
lat_getu(osol, :X1, lrs; t = 0.0:10.0) # Returns the value of X1 at times 0.0, 1.0, ..., 10.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_sim_struct_interfacing.jl#L284-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.lat_setu!" href="#Catalyst.lat_setu!"><code>Catalyst.lat_setu!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lat_setu!(sim_struct, sp, lrs::LatticeReactionSystem, u)</code></pre><p>For a problem or integrators, update its <code>u</code> vector with the input <code>u</code>. For non-lattice models, this is can be done through direct interfacing (e.g. <code>prob[X] = 1.0</code>). However, for  <code>LatticeReactionSystem</code>-based problems and integrators, this function must be used instead.</p><p>Arguments:</p><ul><li><code>sim_struct</code>: The simulation structure which <code>u</code> value we wish to update. Can be either a <code>ODEProblem</code>, <code>JumpProblem</code>, or an integrator derived from either of these.</li><li><code>sp</code>: The species which value we wish to update. Can be provided either in its symbolic form (e.g. <code>X</code>) or as a symbol (e.g. <code>:X</code>).</li><li><code>lrs</code>: The <code>LatticeReactionSystem</code> which was used to generate the structure we wish to modify.</li><li><code>u</code>: The species&#39;s new values. Must be given in a form which is also a valid initial input to the <code>ODEProblem</code>/<code>JumpProblem</code>.</li></ul><p>Example:</p><pre><code class="language-julia hljs"># Prepare `LatticeReactionSystem`s.
using Catalyst
rs = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
tr = @transport_reaction D X1
lrs = LatticeReactionSystem(rs, [tr], CartesianGrid((2,3)))

# Prepares a corresponding ODEProblem.
u0 = [:X1 =&gt; [1.0 2.0 3.0; 4.0 5.0 6.0], :X2 =&gt; 2.0]
tspan = (0.0, 50.0)
ps = [:k1 =&gt; 2.0, :k2 =&gt; 1.0, :D =&gt; 0.01]
oprob = ODEProblem(lrs, u0, tspan, ps)

# Updates the `ODEProblem`.
lat_setu!(oprob, :X1, lrs, 0.0) # Sets `X1` to uniformly 0 across the lattice.
lat_setu!(oprob, :X2, lrs, [1.0 0.0 0.0; 0.0 0.0 0.0]) # Sets `X2` to `1.0` in one vertex, and 0 elsewhere.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_sim_struct_interfacing.jl#L144-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.lat_getp" href="#Catalyst.lat_getp"><code>Catalyst.lat_getp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lat_getp(sim_struct, p, lrs::LatticeReactionSystem)</code></pre><p>For a problem or integrators, retrieves its <code>p</code> values. For non-lattice models, this is can be done through direct interfacing (e.g. <code>prob[p]</code>). However, for  <code>LatticeReactionSystem</code>-based problems and integrators, this function must be used instead. The output format depends on the lattice (a dense array for cartesian grid lattices, a sparse array for masked grid lattices, and a vector for graph lattices). This format is similar to what is used to designate parameter initial values.</p><p>Arguments:</p><ul><li><code>sim_struct</code>: The simulation structure which <code>p</code> value we wish to retrieve. Can be either a <code>ODEProblem</code>,</li></ul><p><code>JumpProblem</code>, or an integrator derived from either of these.</p><ul><li><code>p</code>: The species which value we wish to update. Can be provided either in its symbolic form (e.g. <code>k</code>) or as a symbol (e.g. <code>:k</code>).</li><li><code>lrs</code>: The <code>LatticeReactionSystem</code> which was used to generate the structure we wish to modify.</li></ul><p>Notes:</p><ul><li>Even if the parameter is spatially uniform, a full array with its values across all vertices will be retrieved. </li></ul><p>Example:</p><pre><code class="language-julia hljs"># Prepare `LatticeReactionSystem`s.
using Catalyst
rs = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
tr = @transport_reaction D X1
lrs = LatticeReactionSystem(rs, [tr], CartesianGrid((2,3)))

# Prepares a corresponding ODEProblem.
u0 = [:X1 =&gt; 1.0, :X2 =&gt; 2.0]
tspan = (0.0, 50.0)
ps = [:k1 =&gt; [1.0 2.0 3.0; 4.0 5.0 6.0], :k2 =&gt; 1.0, :D =&gt; 0.01]
oprob = ODEProblem(lrs, u0, tspan, ps)

# Updates the `ODEProblem`.
lat_getp(oprob, :k1, lrs) # Retrieves the value of `k1`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_sim_struct_interfacing.jl#L81-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.lat_setp!" href="#Catalyst.lat_setp!"><code>Catalyst.lat_setp!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lat_setp!(sim_struct, p, lrs::LatticeReactionSystem, p_val)</code></pre><p>For a problem or integrators, update its <code>p</code> vector with the input <code>p_val</code>. For non-lattice models, this is can be done through direct interfacing (e.g. <code>prob[p] = 1.0</code>). However, for  <code>LatticeReactionSystem</code>-based problems and integrators, this function must be used instead.</p><p>Arguments:</p><ul><li><code>sim_struct</code>: The simulation structure which <code>u</code> value we wish to update. Can be either a <code>ODEProblem</code>, <code>JumpProblem</code>, or an integrator derived from either of these.</li><li><code>p</code>: The species which value we wish to update. Can be provided either in its symbolic form (e.g. <code>k</code>) or as a symbol (e.g. <code>:k</code>).</li><li><code>lrs</code>: The <code>LatticeReactionSystem</code> which was used to generate the structure we wish to modify.</li><li><code>p_val</code>: The parameter&#39;s new values. Must be given in a form which is also a valid initial input to the <code>ODEProblem</code>/<code>JumpProblem</code>.</li></ul><p>Example:</p><pre><code class="language-julia hljs"># Prepare `LatticeReactionSystem`s.
using Catalyst
rs = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
tr = @transport_reaction D X1
lrs = LatticeReactionSystem(rs, [tr], CartesianGrid((2,3)))

# Prepares a corresponding ODEProblem.
u0 = [:X1 =&gt; 1.0, :X2 =&gt; 2.0]
tspan = (0.0, 50.0)
ps = [:k1 =&gt; [1.0 2.0 3.0; 4.0 5.0 6.0], :k2 =&gt; 1.0, :D =&gt; 0.01]
oprob = ODEProblem(lrs, u0, tspan, ps)

# Updates the `ODEProblem`.
lat_setp!(oprob, :k1, lrs, 0.0) # Sets `k1` to uniformly 0 across the lattice.
lat_setp!(oprob, :k2, lrs, [1.0 0.0 0.0; 0.0 0.0 0.0]) # Sets `k2` to `1.0` in one vertex, and 0 elsewhere.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_sim_struct_interfacing.jl#L3-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.rebuild_lat_internals!" href="#Catalyst.rebuild_lat_internals!"><code>Catalyst.rebuild_lat_internals!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rebuild_lat_internals!(sciml_struct)</code></pre><p>Rebuilds the internal functions for simulating a LatticeReactionSystem. Whenever a problem or  integrator has had its parameter values updated, this function should be called for the update to  be taken into account. For ODE simulations, <code>rebuild_lat_internals!</code> needs only to be called when</p><ul><li>An edge parameter has been updated.</li><li>When a parameter with spatially homogeneous values has been given spatially heterogeneous values (or vice versa).</li></ul><p>Arguments:</p><ul><li><code>sciml_struct</code>: The problem (e.g. an <code>ODEProblem</code>) or an integrator which we wish to rebuild.</li></ul><p>Notes:</p><ul><li>Currently does not work for <code>DiscreteProblem</code>s, <code>JumpProblem</code>s, or their integrators.</li><li>The function is not built with performance in mind, so avoid calling it multiple times in performance-critical applications.</li></ul><p>Example:</p><pre><code class="language-julia hljs"># Creates an initial `ODEProblem`
rs = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
tr = @transport_reaction D X1 
grid = CartesianGrid((2,2))
lrs = LatticeReactionSystem(rs, [tr], grid)

u0 = [:X1 =&gt; 2, :X2 =&gt; [5 6; 7 8]]
tspan = (0.0, 10.0)
ps = [:k1 =&gt; 1.5, :k2 =&gt; [1.0 1.5; 2.0 3.5], :D =&gt; 0.1]

oprob = ODEProblem(lrs, u0, tspan, ps)

# Updates parameter values.
oprob.ps[:ks] = [2.0 2.5; 3.0 4.5]
oprob.ps[:D] = 0.05

# Rebuilds `ODEProblem` to make changes have an effect.
rebuild_lat_internals!(oprob)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_sim_struct_interfacing.jl#L374-L413">source</a></section></article><p>Finally, we provide the following helper functions to plot and animate spatial lattice simulations.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.lattice_plot" href="#Catalyst.lattice_plot"><code>Catalyst.lattice_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lattice_plot(sol, sp, lrs::LatticeReactionSystem, filename::String; t = sol.tspan[2], kwargs...)</code></pre><p>Creates a plot of a <code>LatticeReactionSystem</code> simulation. The plot is created at the time point specified by <code>t</code> (defaults to the simulation&#39;s final time point).</p><p>Arguments (all lattices):</p><ul><li><code>sol</code>: The simulation we wish to plot.</li><li><code>sp</code>: The species whose values we wish to plot. Can be provided either in its symbolic form or as a symbol.</li><li><code>lrs</code>: The <code>LatticeReactionSystem</code> which was simulated.</li><li><code>t = sol.t[end]</code>: The time point at which we wish to plot the solution</li></ul><p>In addition, depending on the type of lattice used, the following optional arguments might be relevant.</p><p>Arguments (1d lattices):</p><ul><li><code>markersize = 20</code>: The size of the markers marking each compartment&#39;s value.</li></ul><p>Arguments (Graph &amp; 2d lattices):</p><ul><li><code>colormap = :BuGn_7</code>: The colour map with which we display the species amounts in the animation.</li><li><code>plot_min = nothing</code>: The minimum value for the colour scale (values less than this will be set at this value when the colour scale is computed). If <code>nothing</code>, use the simulation&#39;s minimum value (across the entire simulation, not just at the plotted time value).</li><li><code>plot_max = nothing</code>: The maximum value for the colour scale (values more than this will be set at this value when the colour scale is computed). If <code>nothing</code>, use the simulation&#39;s minimum value (across the entire simulation, not just at the plotted time value).</li></ul><p>Arguments (Graph lattices):</p><ul><li><code>node_size = 50</code>: The size of the compartments in the plot.</li><li><code>layout = Spring()</code>: The layout for the graph nodes in the plot. Can be provided as a vector, where the i&#39;th element is a 2-valued tuple (determining the i&#39;th compartment&#39;s y and x positions, respectively).</li></ul><p>Notes: </p><ul><li>For masked lattices, there are no value displayed for grid points which do not correspond to a compartments.</li><li>The current plotting interface is a work in progress, and modifications are expected. if you have any feedback, please contact the package authors.</li><li>Additional arguments can be passed to <code>lattice_plot</code>, which then will be passed to Makie&#39;s <code>lines</code> plotting command.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_simulation_plotting.jl#L6-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.lattice_animation" href="#Catalyst.lattice_animation"><code>Catalyst.lattice_animation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lattice_animation(sol, sp, lrs::LatticeReactionSystem, filename::String; kwargs...)</code></pre><p>Creates an animation of a <code>LatticeReactionSystem</code> simulation. The animation is saved to a file,  whose name is provided in the <code>filename</code> argument.</p><p>Arguments (all lattices):</p><ul><li><code>sol</code>: The simulation we wish to animate.</li><li><code>sp</code>: The species which values we wish to animate. Can be provided either in its symbolic form or as a symbol.</li><li><code>lrs</code>: The <code>LatticeReactionSystem</code> which was simulated.</li><li><code>filename</code>: The name of the file to which we wish to save the animation.</li><li><code>nframes = 200</code>: The number of frames in the animation (these are evenly samples across the simulation).</li><li><code>framerate = 20</code>: The frame rate of the animation.</li><li><code>ttitle = true</code>: Whether to add a title showing the simulation&#39;s time throughout the animation.</li></ul><p>In addition, depending on the type of lattice used, the following optional arguments might be relevant.</p><p>Arguments (1d lattices):</p><ul><li><code>markersize = 20</code>: The size of the markers marking each compartment&#39;s value.</li><li><code>plot_min = nothing</code>: The y-scale&#39;s minimum. If <code>nothing</code>, use the simulation&#39;s minimum value.</li><li><code>plot_max = nothing</code>: The y-scale&#39;s maximum. If <code>nothing</code>, use the simulation&#39;s maximum value.</li></ul><p>Arguments (Graph &amp; 2d lattices):</p><ul><li><code>colormap = :BuGn_7</code>: The colour map with which we display the species amounts in the animation.</li><li><code>plot_min = nothing</code>: The minimum value for the colour scale (values less than this will be set at this value when the colour scale is computed). If <code>nothing</code>, use the simulation&#39;s minimum value.</li><li><code>plot_max = nothing</code>: The maximum value for the colour scale (values more than this will be set at this value when the colour scale is computed). If <code>nothing</code>, use the simulation&#39;s minimum value.</li></ul><p>Arguments (Graph lattices):</p><ul><li><code>node_size = 50</code>: The size of the compartments in the plot.</li><li><code>layout = Spring()</code>: The layout for the graph nodes in the plot. Can be provided as a vector, where the i&#39;th element is a 2-valued tuple (determining the i&#39;th compartment&#39;s y and x positions, respectively).</li></ul><p>Notes: </p><ul><li>For masked lattices, there are no value displayed for grid points which do not correspond to a compartments.</li><li>The current animation interface if a work in progress, and modifications are expected. if you have any feedback, please contact the package authors.</li><li>Additional arguments can be passed to <code>lattice_animation</code>, which then will be passed to Makie&#39;s <code>heatmap</code> plotting command.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_simulation_plotting.jl#L39-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.lattice_kymograph" href="#Catalyst.lattice_kymograph"><code>Catalyst.lattice_kymograph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lattice_kymograph(sol, sp, lrs::LatticeReactionSystem, kwargs...)</code></pre><p>Creates a kymograph of a <code>LatticeReactionSystem</code> simulation based on a Cartesian or masked lattice.  The plot shows the compartments on the y-axis, and the time development of the system&#39;s state along the x-axis. Species amounts are shown as a heatmap.</p><p>Arguments (all lattices):</p><ul><li><code>sol</code>: The simulation we wish to plot.</li><li><code>sp</code>: The species whose values we wish to plot. Can be provided either in its symbolic form or as a symbol.</li><li><code>lrs</code>: The <code>LatticeReactionSystem</code> which was simulated.</li><li><code>colormap = :BuGn_7</code>: The colour map with which we display the species amounts in the kymograph.</li><li><code>nframes = 200</code>: The number of time samples which the time series is sampled with.</li><li><code>plot_min = nothing</code>: The minimum value for the colour scale (values less than this will be set at this value when the colour scale is computed). If <code>nothing</code>, use the simulation&#39;s minimum value.</li><li><code>plot_max = nothing</code>: The maximum value for the colour scale (values more than this will be set at this value when the colour scale is computed). If <code>nothing</code>, use the simulation&#39;s minimum value.</li></ul><p>Notes: </p><ul><li>For masked lattices, there are no value displayed for grid points which do not correspond to a compartments.</li><li>The current plotting interface is a work in progress, and modifications are expected. if you have any feedback, please contact the package authors.</li><li>Additional arguments can be passed to <code>lattice_plot</code>, which then will be passed to Makie&#39;s <code>heatmap</code> plotting command.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/36c10b8661f44054571a7a70361ed7fd1315189f/src/spatial_reaction_systems/lattice_simulation_plotting.jl#L77-L97">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../faqs/">« FAQs</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Monday 12 August 2024 02:43">Monday 12 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
