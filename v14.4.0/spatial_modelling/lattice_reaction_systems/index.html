<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to Spatial Modelling with Catalyst · Catalyst.jl</title><meta name="title" content="Introduction to Spatial Modelling with Catalyst · Catalyst.jl"/><meta property="og:title" content="Introduction to Spatial Modelling with Catalyst · Catalyst.jl"/><meta property="twitter:title" content="Introduction to Spatial Modelling with Catalyst · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/spatial_modelling/lattice_reaction_systems/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/spatial_modelling/lattice_reaction_systems/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/spatial_modelling/lattice_reaction_systems/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><span class="tocitem">Model Creation and Properties</span><ul><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../model_creation/conservation_laws/">Working with conservation laws</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/reactionsystem_content_accessing/">Accessing model properties</a></li><li><a class="tocitem" href="../../model_creation/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Model simulation</span><ul><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for performant ODE simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for performant SDE simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Model simulation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/examples/periodic_events_simulation/">Modelling a periodic event during ODE and jump simulations</a></li></ul></li></ul></li><li><span class="tocitem">Steady state analysis</span><ul><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><span class="tocitem">Spatial Modelling</span><ul><li class="is-active"><a class="tocitem" href>Introduction to Spatial Modelling with Catalyst</a><ul class="internal"><li><a class="tocitem" href="#spatial_lattice_modelling_intro_example"><span>Basic example of a spatial simulation on a discrete domain</span></a></li><li><a class="tocitem" href="#spatial_lattice_modelling_intro_spatial_reactions"><span>Spatial reactions</span></a></li><li><a class="tocitem" href="#spatial_lattice_modelling_intro_lattices"><span>Defining discrete spatial domains (lattices)</span></a></li><li><a class="tocitem" href="#spatial_lattice_modelling_intro_simulation_inputs"><span>Non-uniform initial conditions and parameter values</span></a></li><li><a class="tocitem" href="#spatial_lattice_modelling_intro_simulation_edge_parameters"><span>Edge parameters and compartment parameters</span></a></li><li><a class="tocitem" href="#spatial_lattice_modelling_intro_limitations"><span>Spatial modelling limitations</span></a></li></ul></li><li><a class="tocitem" href="../lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../spatial_jump_simulations/">Spatial jump simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Spatial Modelling</a></li><li class="is-active"><a href>Introduction to Spatial Modelling with Catalyst</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction to Spatial Modelling with Catalyst</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/spatial_modelling/lattice_reaction_systems.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="spatial_lattice_modelling_intro"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro">Introduction to Spatial Modelling with Catalyst</a><a id="spatial_lattice_modelling_intro-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro" title="Permalink"></a></h1><p>Catalyst supports the expansion of non-spatial <a href="../../api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>s (created using e.g. the <code>@reaction_network</code> DSL) to spatial domains. Spatial simulation of Catalyst models is a work in progress. Currently, the following is supported:</p><ul><li>Spatial ODE and Jump simulations.</li><li>Discrete spatial domains.</li><li>Constant-rate transportation reactions (species moving spatially at constant rates). </li></ul><p>Features for which support is planned in future updates include:</p><ul><li>Models on continuous domains with automatic discretisation (these models can already be simulated if the user provides a discretisation).</li><li>SDE simulations.</li><li>Transport reactions with non-constant rates as well as more general spatial reactions.</li></ul><p>This tutorial introduces spatial modelling on discrete domains, here called lattices. It describes the basics of creating and simulating such models. To do so, it uses ODE simulations as examples. Additional tutorials provide further details on how to interact with <a href="../lattice_simulation_plotting/#lattice_simulation_plotting">spatial simulation structures</a> and <a href="../lattice_simulation_plotting/#lattice_simulation_plotting">plot spatial simulations</a>, and also provide further details on <a href="../spatial_ode_simulations/#spatial_lattice_ode_simulations">ODE</a> and <a href="../spatial_jump_simulations/#spatial_lattice_jump_simulations">jump</a> simulations, respectively.</p><h2 id="spatial_lattice_modelling_intro_example"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_example">Basic example of a spatial simulation on a discrete domain</a><a id="spatial_lattice_modelling_intro_example-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_example" title="Permalink"></a></h2><p>To perform discrete-space spatial simulations, the user must first define a <a href="../../api/#Catalyst.LatticeReactionSystem"><code>LatticeReactionSystem</code></a>. These combine:</p><ul><li>A (non-spatial) <code>ReactionSystem</code>(@ref) model (created using standard Catalyst syntax).</li><li>A vector of spatial reactions, describing how species can move spatially across the domain.</li><li>A lattice defining the spatial domain&#39;s compartments and how they are connected.</li></ul><p>Here, as an example, we will simulate a spatial <a href="../../model_creation/examples/basic_CRN_library/#basic_CRN_library_two_states">two-state model</a>. To do so, we first define our (non-spatial) model, the spatial reactions, and the lattice. These are then bundled into a <a href="../../api/#Catalyst.LatticeReactionSystem"><code>LatticeReactionSystem</code></a>.</p><pre><code class="language-julia hljs">using Catalyst
two_state_model = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
diffusion_rx = @transport_reaction D X1
lattice = CartesianGrid((5,5))
lrs = LatticeReactionSystem(two_state_model, [diffusion_rx], lattice)</code></pre><p>This model contains:</p><ul><li>A single spatial reaction, a transport reaction where <span>$X1$</span> moves at constant rate <span>$D$</span> between adjacent compartments.</li><li>A 2d Cartesian grid of 5x5 compartments to simulate our model on.</li></ul><p>More details on spatial reactions are available <a href="#spatial_lattice_modelling_intro_spatial_reactions">here</a>. In addition to Cartesian grid lattices (in 1, 2, and 3 dimensions), masked and unstructured (graph) lattices are also supported. The different lattice types described in more detail <a href="#spatial_lattice_modelling_intro_lattices">here</a>.</p><p>Once created, <a href="../../api/#Catalyst.LatticeReactionSystem"><code>LatticeReactionSystem</code></a>s can be used as input to various problem types, which then can be simulated using the same syntax as non-spatial models. Here, we prepare an ODE simulation by creating an <code>ODEProblem</code>:</p><pre><code class="language-julia hljs">u0 = [:X1 =&gt; rand(5, 5), :X2 =&gt; 2.0]
tspan = (0.0, 10.0)
ps = [:k1 =&gt; 1.0, :k2 =&gt; 2.0, :D =&gt; 0.2]
oprob = ODEProblem(lrs, u0, tspan, ps)</code></pre><p>In this example we used non-uniform values for <span>$X1$</span>&#39;s initial condition, but uniform values for the remaining initial condition and parameter values. More details of uniform and non-uniform initial conditions and parameter values are provided <a href="#spatial_lattice_modelling_intro_simulation_inputs">here</a>. We also note that the diffusion reaction introduces a new parameter, <span>$D$</span> (determining <span>$X1$</span>&#39;s diffusion rate), whose value must be designated in the parameter vector. </p><p>We can now simulate our model:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq
sol = solve(oprob)</code></pre><p>We note that simulations of spatial models are often computationally expensive. Advice on the performance of spatial ODE simulations is provided <a href="../spatial_ode_simulations/#spatial_lattice_ode_simulations_solvers">here</a>. </p><p>Finally, we can access &quot;<span>$X1$</span>&#39;s value across the simulation using</p><pre><code class="language-julia hljs">lat_getu(sol, :X1, lrs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">20-element Vector{Matrix{Float64}}:
 [0.6531878645719426 0.761795734101328 … 0.05098752959215369 0.18656651106442845; 0.20867389168847605 0.3542195679536667 … 0.7494842021774961 0.464807025342183; … ; 0.6152966634860595 0.6849232837413747 … 0.29512751189240083 0.21625227645381084; 0.4668017941557572 0.32910823478412043 … 0.5521990353093678 0.6836843376731069]
 [0.7987184592523713 0.8956434760606641 … 0.2348107181266478 0.35716457834801846; 0.38643894559438036 0.5184798938693839 … 0.8789340122648216 0.6216522164759534; … ; 0.7653533580840137 0.8286761391009559 … 0.46939305921116875 0.3912871426517161; 0.6237522307649482 0.49647454728510576 … 0.7021460767506951 0.8255119290137218]
 [1.0058709285068521 1.0859655371241128 … 0.4970272350152823 0.6005209324554509; 0.6400803216866128 0.7529649128610146 … 1.0633473230967891 0.8448557529708692; … ; 0.9789672825828172 1.0333644090355167 … 0.7178592436229246 0.6411219696981263; 0.8474933431653358 0.7352817740439123 … 0.9159008434022605 1.0273123986030255]
 [1.2042232416840606 1.2677478415595982 … 0.7492851993819825 0.8344866971830479; 0.8842104558664331 0.9786698360987001 … 1.2398890808369658 1.0585786178825978; … ; 1.183607934130494 1.2294506805241407 … 0.9567194114759123 0.8816725737388064; 1.062343865774352 0.9650354763444859 … 1.1210804774717564 1.2203697143339516]
 [1.3821020350039686 1.4299036585642073 … 0.9776690518466173 1.0458478310953794; 1.1054312237852388 1.1829439583011732 … 1.3977111169339531 1.2503873111871142; … ; 1.3673859447991688 1.405411345231147 … 1.1727532047512208 1.0996773798611448; 1.256032664660709 1.1729230192020492 … 1.305809749342413 1.3931924671936564]
 [1.518987232336642 1.5533121633990403 … 1.1568385100537424 1.2107714175007043; 1.2792554628363395 1.3428123574024815 … 1.5179998636496514 1.3983562964340543; … ; 1.5092878184938472 1.5409483986337373 … 1.3419572558628785 1.2709045182076464; 1.406590323844276 1.335682119818042 … 1.4489394917777334 1.5257126137154617]
 [1.613955140783567 1.6369630046461705 … 1.286084875048599 1.3283627487192615; 1.404993968397552 1.4573645572769867 … 1.5995248841236203 1.501647709895753; … ; 1.6084725776849005 1.6351264801688112 … 1.4636432904993582 1.3945828177344366; 1.513156214580299 1.452511111277101 … 1.549521251954575 1.6169927305468577]
 [1.6714407615609603 1.6850447334278098 … 1.3709442750727505 1.4037576968757473; 1.4879413699336688 1.5314346353151354 … 1.6462264269801359 1.5650925585391287; … ; 1.669516350511244 1.6923073330607312 … 1.5430071211049037 1.475900380896737; 1.580475493541976 1.5284013105038683 … 1.6120736133735327 1.6714120673210577]
 [1.701367560304294 1.7069264580233272 … 1.4237213971311955 1.4485336372334905; 1.5399111234913696 1.5760534509472248 … 1.6672524357794647 1.5993571958878878; … ; 1.7025891033417733 1.7222961873742129 … 1.5915822069168393 1.5265364290612102; 1.6192083723579713 1.574591412990591 … 1.646837173885863 1.6987449120498914]
 [1.7132763662955568 1.7117706230910128 … 1.45600911837356 1.4737477822321121; 1.5719917920577413 1.601718006849751 … 1.67167229984802 1.6146352373856068; … ; 1.7174058559322214 1.7345285464496318 … 1.620175090248858 1.5575065954508214; 1.639546865468486 1.601733921984264 … 1.6636666739231438 1.7084452265618881]
 [1.714831133399756 1.707027393596825 … 1.4770968033648613 1.488332678761633; 1.5930198619476357 1.6168544689641602 … 1.6669305648817192 1.619109048597482; … ; 1.7217464833181086 1.7365883542935743 … 1.6373559506349409 1.5776200451084879; 1.6497015383246323 1.6183726420623743 … 1.6705179074716812 1.70814974346622]
 [1.7110850664775836 1.6977502175741312 … 1.4930268236776298 1.4981911908481425; 1.6086551282690553 1.6269210869796633 … 1.6581140439946704 1.6181858797154403; … ; 1.7207096618003053 1.7334693689339216 … 1.6485857013143874 1.5925466003173454; 1.6550774053474446 1.6300513996547386 … 1.672642263295862 1.7029620949935296]
 [1.7048921551363132 1.686933327879137 … 1.5072210802278962 1.5067380940463164; 1.621971030598366 1.6349095476817044 … 1.6482428162192677 1.614978437347537; … ; 1.717157518966665 1.727974264421993 … 1.6567966260287736 1.6053840983228937; 1.6587483058109342 1.6398429921516375 … 1.6730105196583376 1.6958441208774178]
 [1.6976227116264364 1.6761965621252477 … 1.5213078855212288 1.5156960820569574; 1.634218487110143 1.6420700102655181 … 1.6389283094855827 1.6110844236260966; … ; 1.7124398891582997 1.7214089635136882 … 1.6631709291172794 1.6174129773895003; 1.6621815007634195 1.6490846278500417 … 1.6730079283010584 1.6883233875096761]
 [1.6898622921014248 1.6664383335600417 … 1.5359668928619234 1.5259130111120867; 1.6455874943953368 1.6486399385130597 … 1.6310182801674513 1.6073616978659628; … ; 1.707100613042163 1.7142561940976608 … 1.6679186521691072 1.6288543873365837; 1.6659524614023613 1.658110574183981 … 1.673115213964054 1.6811760711079573]
 [1.6819854262675809 1.6583584681712351 … 1.5513790668979683 1.5378485731069205; 1.6556011689066328 1.6542811097028347 … 1.6251161806868852 1.6045351881254144; … ; 1.7014223747895822 1.7067112505757167 … 1.670786614628224 1.6392682061270238; 1.6701761069214198 1.666644639182323 … 1.673356198604192 1.6749540618629153]
 [1.6747413083263256 1.6527667634767997 … 1.5668210729501748 1.551220978325585; 1.663117096191465 1.6582477136486682 … 1.6218445555716157 1.6035054633052745; … ; 1.6959217497515318 1.6992658755220553 … 1.6714558257726106 1.6475257766977893; 1.6744801437503065 1.6737400541390857 … 1.6734923226391358 1.6703114115783324]
 [1.669359989516495 1.6499872190708023 … 1.5798003174350082 1.5637555927846951; 1.667019103207888 1.6600234960577998 … 1.6212429512598634 1.6045450048353087; … ; 1.6915076574129941 1.6931138423200536 … 1.6703138764275671 1.6523786340303648; 1.6778244441866714 1.6781084019260872 … 1.6732284244221998 1.6676261559939]
 [1.665908609536546 1.6488326083881628 … 1.5886920470168342 1.5736339878958272; 1.6678130272510556 1.6606512910903224 … 1.6227725048127164 1.6062479790977924; … ; 1.6881445595874207 1.6887827086836558 … 1.6682688872990061 1.6543270289630525; 1.679702659914195 1.6799079390064053 … 1.6726608156387082 1.666147110525554]
 [1.6655396627336139 1.6489243007662129 … 1.5907371113972562 1.575465711294758; 1.6683356118271921 1.660498712953842 … 1.6225589770606648 1.6071449762900951; … ; 1.6879490499364398 1.6881156329121072 … 1.6682921875780676 1.6548466040666912; 1.6801500135417455 1.6803540845770988 … 1.6725882012084023 1.6661279237761013]</code></pre><p>and plot the simulation using</p><pre><code class="language-julia hljs">import CairoMakie
lattice_animation(sol, :X1, lrs, &quot;lattice_simulation_2d.mp4&quot;)</code></pre><p><video src="../lattice_simulation_2d.mp4" controls="true" title><a href="../lattice_simulation_2d.mp4"></a></video> More information on how to retrieve values from spatial simulations can be found <a href="../lattice_simulation_structure_ interaction/#lattice_simulation_structure_interaction_simulation_species">here</a>, and for plotting them, <a href="../lattice_simulation_plotting/#lattice_simulation_plotting">here</a>. Finally, a list of functions for querying <code>LatticeReactionSystems</code> for various properties can be found <a href="../../api/#api_lattice_simulations">here</a>.</p><h2 id="spatial_lattice_modelling_intro_spatial_reactions"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_spatial_reactions">Spatial reactions</a><a id="spatial_lattice_modelling_intro_spatial_reactions-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_spatial_reactions" title="Permalink"></a></h2><p>Spatial reactions describe reaction events which involve species across two connected compartments. Currently, only so-called <em>transportation reactions</em> are supported. These consist of:</p><ul><li>A rate at which the reaction occurs. As for non-spatial reactions, this can be any expression. However, currently, it may only consist of parameters and other constants. </li><li>A single species which is transported from one compartment to an adjacent one.</li></ul><p>At the occurrence of a transport reaction, the specific species moves to the adjacent compartment. Many common spatial models can be represented using transport reactions only. These can model phenomena such as diffusion or constant flux. A transportation reaction can be created using the <code>@transportation_reaction</code> macro. E.g. above we used</p><pre><code class="language-julia hljs">diffusion_rx = @transport_reaction D X1</code></pre><p>to create a reaction where species <span>$X$</span> moves at a constant rate <span>$D$</span> between adjacent compartments (in the ODE this creates terms <span>$D\cdot X1_i$</span>, where <span>$X1_i$</span> is the concentration of <span>$X1$</span> in compartment <span>$i$</span>). Transport reactions may have rates depending on several parameters. E.g. to model a system with two species <span>$X1$</span> and <span>$X2$</span>, where both species are transported at a rate which depends both on the species, but also on some non-uniform parameter which is unique to each connection (e.g. representing the area connecting two cells in a tissue) we could do:</p><pre><code class="language-julia hljs">dr_X1 = @transport_reaction D1*a X1
dr_X2 = @transport_reaction D2*a X2</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Any species which occurs is occurs in a transport reaction that is used to construct a <a href="../../api/#Catalyst.LatticeReactionSystem"><code>LatticeReactionSystem</code></a> must also occur in the corresponding non-spatial <a href="../../api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>.</p></div></div><h3 id="spatial_lattice_modelling_intro_spatial_reactions_programmatic"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_spatial_reactions_programmatic">Creating transport reactions programmatically</a><a id="spatial_lattice_modelling_intro_spatial_reactions_programmatic-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_spatial_reactions_programmatic" title="Permalink"></a></h3><p>If models are created <a href="../../model_creation/programmatic_CRN_construction/#programmatic_CRN_construction">programmatically</a> it is also possible to create transportation reactions programmatically. To do so, use the <code>TransportReaction</code> constructor, providing first the rate and then the transported species:</p><pre><code class="language-julia hljs">@variables t
@species X1(t) X2(t)
@parameters k1 k2 D [edgeparameter=true]
tr_X = TransportReaction(D, X1)</code></pre><p>Note that in this example, we specifically designate <span>$D$</span> as an <a href="#spatial_lattice_modelling_intro_simulation_edge_parameters">edge parameter</a>.</p><h2 id="spatial_lattice_modelling_intro_lattices"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_lattices">Defining discrete spatial domains (lattices)</a><a id="spatial_lattice_modelling_intro_lattices-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_lattices" title="Permalink"></a></h2><p>Discrete spatial domains can represent:</p><ol><li>Systems which are composed of a (finite number of) compartments, where each compartment can be considered well-mixed (e.g. can be modelled non-spatially) and where (potentially) species can move between adjacent compartments. Tissues, where each compartment corresponds to a biological cell, are examples of such systems.</li><li>Systems that are continuous in nature, but have been approximated as a discrete domain. Future Catalyst updates will include the ability for the definition, and automatic discretisation, of continuous domains. Currently, however, the user has to perform this discretisation themselves.</li></ol><p>Catalyst supports three distinct types of lattices:</p><ul><li><a href="#spatial_lattice_modelling_intro_lattices_cartesian">Cartesian lattices</a>. These are grids where each grid point corresponds to a compartment. Spatial transportation is permitted between adjacent compartments.</li><li><a href="#spatial_lattice_modelling_intro_lattices_masked">Masked lattices</a>. In these grids, only a subset of the grid point actually corresponds to compartments. Spatial transportation is permitted between adjacent compartments.</li><li><a href="#spatial_lattice_modelling_intro_lattices_graph">Unstructured (or graph) lattices</a>. These are defined by graphs, where vertices correspond to compartments and edges connect adjacent compartments.</li></ul><p>Here, Cartesian lattices are a subset of the masked lattices, which are a subset of the unstructured lattices. If possible, it is advantageous to use as narrow a lattice definition as possible (this may both improve simulation performance and simplify syntax). Cartesian and masked lattices can be defined as one, two, and three-dimensional. By default, these lattices assume that diagonally neighbouring compartments are non-adjacent (do not permit direct movement of species in between themselves). To change this, provide the <code>diagonally_adjacent = true</code> argument to your <a href="../../api/#Catalyst.LatticeReactionSystem"><code>LatticeReactionSystem</code></a> when it is created.</p><h3 id="spatial_lattice_modelling_intro_lattices_cartesian"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_lattices_cartesian">Defining Cartesian lattices</a><a id="spatial_lattice_modelling_intro_lattices_cartesian-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_lattices_cartesian" title="Permalink"></a></h3><p>A Cartesian lattice is defined using the <code>CartesianGrid</code> function, which takes a single argument. For a 1d grid, simply provide the length of the grid as a single argument:</p><pre><code class="language-julia hljs">cgrid_1d = CartesianGrid(5)</code></pre><p>For 2d and 3d grids, we instead provide a Tuple with the length of the grid in each dimension:</p><pre><code class="language-julia hljs">cgrid_2d = CartesianGrid((3, 9))
cgrid_3d = CartesianGrid((2, 4, 8))</code></pre><h3 id="spatial_lattice_modelling_intro_lattices_masked"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_lattices_masked">Defining masked lattices</a><a id="spatial_lattice_modelling_intro_lattices_masked-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_lattices_masked" title="Permalink"></a></h3><p>Masked lattices are defined through 1d, 2d, or 3d Boolean arrays. Each position in the array is <code>true</code> if it corresponds to a compartment, and <code>false</code> if it does not. E.g. to define a 1d grid corresponding to two disjoint sets, each with 3 compartments, use:</p><pre><code class="language-julia hljs">rgrid_1d = [true, true, true, false, true, true, true]</code></pre><p>To define a 2d grid corresponding to the shape of an (laying) &quot;8&quot;, we can use:</p><pre><code class="language-julia hljs">rgrid_2d = [
    true  true  true  true  true;
    true  false true  false true;
    true  true  true  true  true
]</code></pre><p>Finally, a 4x5x6 3d grid of randomly distributed compartments can be created using:</p><pre><code class="language-julia hljs">rgrid_3d = rand([true, false], 4, 5, 6)</code></pre><h3 id="spatial_lattice_modelling_intro_lattices_graph"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_lattices_graph">Defining unstructured lattices</a><a id="spatial_lattice_modelling_intro_lattices_graph-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_lattices_graph" title="Permalink"></a></h3><p>To define unstructured lattices, we must first import the <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a> package. Next, we can either use some <a href="https://juliagraphs.org/Graphs.jl/stable/core_functions/simplegraphs_generators/#Generators-for-common-graphs">pre-defined formula for building graphs</a>, or <a href="https://juliagraphs.org/Graphs.jl/stable/first_steps/construction/">build a graph from scratch</a>. Here we create a cyclic graph (where each compartment is connected to exactly two other compartments):</p><pre><code class="language-julia hljs">using Graphs
cycle_graph(7)</code></pre><p>Since graphs can represent any network of connected compartments, they do not have dimensions (like Cartesian or masked lattices). Another feature of graph lattices is that they can have non-symmetric connections, i.e. pairs of compartments where spatial movement of species is only permitted in one direction (in practice, this can be done for Cartesian and masked lattices as well, by <a href="#spatial_lattice_modelling_intro_simulation_inputs">defining non-uniform spatial rates</a> and setting them to zero in one direction). This can be done by using a <a href="https://juliagraphs.org/Graphs.jl/dev/algorithms/digraph/"><em>directed graph</em></a> as input. E.g. here we define a directed cyclic graph, where movement is only allowed in one direction of the cycle:</p><pre><code class="language-julia hljs">cycle_digraph(7)</code></pre><h2 id="spatial_lattice_modelling_intro_simulation_inputs"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_simulation_inputs">Non-uniform initial conditions and parameter values</a><a id="spatial_lattice_modelling_intro_simulation_inputs-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_simulation_inputs" title="Permalink"></a></h2><p>For spatial models, initial conditions and parameter values are provided similarly as for non-spatial models. Wherever a single value is provided, it is used <em>uniformly</em> across the lattice. E.g. if we, for our <a href="#spatial_lattice_modelling_intro_example">previous two-state model</a>, set</p><pre><code class="language-julia hljs">u0 = [:X1 =&gt; 1.0, :X2 =&gt; 2.0]
ps = [:k1 =&gt; 1.0, :k2 =&gt; 2.0, :D =&gt; 0.2]</code></pre><p>The initial condition will be <span>$1.0$</span> for <span>$X1$</span> across compartments, and <span>$2.0$</span> for <span>$X2$</span>. Furthermore, for each simulation, in each compartment, the value of <span>$1.0$</span> will be used for <span>$k1$</span> and <span>$2.0$</span> for <span>$k2$</span>. Finally, the transportation rate of <span>$X1$</span> (set by the parameter <span>$D$</span>) will be <span>$0.2$</span> across all connections. To set non-uniform values, non-scalar values must be provided in the map. How to do this depends on how the <a href="#spatial_lattice_modelling_intro_lattices">lattice was defined</a>. Furthermore, some parameters that are part of spatial reactions may have their value tied to <em>connections between compartments</em>, rather than compartments (we call these <em>edge parameters</em>). These are handled slightly differently. How to designate parameters as either <em>edge parameters</em> or <em>compartment parameters</em> is described <a href="#spatial_lattice_modelling_intro_simulation_edge_parameters">here</a>.</p><p>Below we describe how to set non-uniform values in the various cases.</p><h3 id="spatial_lattice_modelling_intro_simulation_inputs_cartesian"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_simulation_inputs_cartesian">Non-uniform compartment values for Cartesian lattices</a><a id="spatial_lattice_modelling_intro_simulation_inputs_cartesian-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_simulation_inputs_cartesian" title="Permalink"></a></h3><p>To provide non-uniform values across a Cartesian lattice, simply provide the values in an array of the same dimension and size as the Cartesian lattice. E.g. for a 5x10 Cartesian lattice:</p><pre><code class="language-julia hljs">ccart_lattices = CartesianGrid((5, 10))</code></pre><p>random values (uniformly distributed between <span>$0$</span> and <span>$1$</span>) can be provided using</p><pre><code class="language-julia hljs">[:X1 =&gt; rand(5, 10), :X2 =&gt; 10.0]</code></pre><p>Non-uniform values for parameters (which values are tied to compartments) are provided similarly.</p><h3 id="spatial_lattice_modelling_intro_simulation_inputs_masked"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_simulation_inputs_masked">Non-uniform compartment values for masked lattices</a><a id="spatial_lattice_modelling_intro_simulation_inputs_masked-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_simulation_inputs_masked" title="Permalink"></a></h3><p>Non-uniform values for masked lattices are provided in the same manner as for Cartesian lattices (however, values at coordinates that do not hold compartments are ignored). E.g. To provide random values for a masked lattice contained within a 5x10 Cartesian lattices we can again set:</p><pre><code class="language-julia hljs">[:X1 =&gt; rand(5, 10), :X2 =&gt; 10.0]</code></pre><p>If we want, it is also possible to provide the values as a <a href="https://github.com/JuliaSparse/SparseArrays.jl"><em>sparse array</em></a> with values only in the coordinates that corresponds to compartments.</p><h3 id="spatial_lattice_modelling_intro_simulation_inputs_graphs"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_simulation_inputs_graphs">Non-uniform compartment values for unstructured lattices</a><a id="spatial_lattice_modelling_intro_simulation_inputs_graphs-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_simulation_inputs_graphs" title="Permalink"></a></h3><p>In graphs (which are used to represent unstructured lattices) each vertex (i.e. compartment) has a specific index. To set non-uniform values for unstructured lattices, provide a vector where the <span>$i$</span>&#39;th value corresponds to the value in the compartment with index <span>$i$</span> in the graph. E.g. for a graph with 5 vertexes, where we want <span>$X$</span> to be zero in all compartments bar one (where it is <span>$1.0$</span>) we use:</p><pre><code class="language-julia hljs">[:X1 =&gt; [0.0, 0.0, 0.0, 0.0, 1.0], :X2 =&gt; 10.0]</code></pre><h3 id="spatial_lattice_modelling_intro_simulation_inputs_edge_parameters"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_simulation_inputs_edge_parameters">Non-uniform values for edge-parameters</a><a id="spatial_lattice_modelling_intro_simulation_inputs_edge_parameters-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_simulation_inputs_edge_parameters" title="Permalink"></a></h3><p>Adjacent compartments are connected by edges (with which compartments are connected by edges being defined by the lattice). For unstructured lattices, it is possible (if a directed graph was used) to have edges from one compartment to another, but not in the opposite direction. For a lattice with <span>$N$</span> compartments, edge values are set by a <span>$NxN$</span> matrix, where value <span>$(i,j)$</span> corresponds to the parameter&#39;s values in the edge going <em>from</em> compartment <span>$i$</span> <em>to</em> compartment <span>$j$</span>. This matrix can be either <a href="https://docs.julialang.org/en/v1/stdlib/SparseArrays/">sparse or non-sparse</a>. In the latter cases, values corresponding to non-existing edges are ignored. </p><p>Let&#39;s consider a 1d Cartesian lattice with 4 compartments. Here, an edge parameter&#39;s values are provided in a 4x4 matrix. For <a href="#spatial_lattice_modelling_intro_example">the Brusselator model described previously</a>, <span>$D$</span>&#39;s value was tied to edges. If we wish to set the value of <span>$D$</span> to various values between <span>$0.1$</span> and <span>$0.4$</span> we can do:</p><pre><code class="language-julia hljs">ps = [:k1 =&gt; 1.0, :k2 =&gt; 2.0,
      :D =&gt; [
        0.0 0.1 0.0 0.0;
        0.1 0.0 0.2 0.0;
        0.0 0.2 0.0 0.3;
        0.0 0.0 0.3 0.0]
]</code></pre><p>Here, the value at index <span>$i,j$</span> corresponds to <span>$D$</span>&#39;s value in the edge from compartment <span>$i$</span> to compartment <span>$j$</span>. <code>0.0</code> is used for elements that do not correspond to an edge. The <a href="../../api/#Catalyst.make_edge_p_values"><code>make_edge_p_values</code></a> and <a href="../../api/#Catalyst.make_directed_edge_values"><code>make_directed_edge_values</code></a> provide convenient interfaces for generating non-uniform edge parameter values.</p><h2 id="spatial_lattice_modelling_intro_simulation_edge_parameters"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_simulation_edge_parameters">Edge parameters and compartment parameters</a><a id="spatial_lattice_modelling_intro_simulation_edge_parameters-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_simulation_edge_parameters" title="Permalink"></a></h2><p>Parameters can be divided into <em>edge parameters</em> and <em>compartment parameters</em> (initial condition values are always tied to compartments). Here, edge parameters have their values tied to edges, while compartment parameters have their values tied to compartments. All parameters that are part of the rates (or stoichiometries) of non-spatial reactions must be compartment parameters. Parameters that are part of spatial reactions can be either compartment parameters or edge parameters. When a spatial reaction&#39;s rate is computed, edge parameters fetch their values for from the edge of the transition, and compartment parameters from the compartment <em>from which the edge originates</em>.</p><p>When a <a href="../../api/#Catalyst.LatticeReactionSystem"><code>LatticeReactionSystem</code></a> is created, its parameters is the union of all parameters occurring in the (non-spatial) <a href="../../api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and in all spatial reactions. By default, parameters occurring only in spatial reactions are considered edge parameters (and if they occur in the non-spatial <a href="../../api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> they are considered compartment parameters). It is, however, possible to designate a parameter specifically as an edge parameter (or not), by using the <code>edgeparameter</code> <a href="../../model_creation/dsl_advanced/#dsl_advanced_options_species_and_parameters_metadata">metadata</a>. E.g. to designate that <code>D</code> (when declared in a non-spatial <a href="../../api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> using the DSL) is an edge parameter, not a compartment parameter, we use:</p><pre><code class="language-julia hljs">two_state_model = @reaction_network begin
    @parameters D [edgeparameter=true]
    (k1,k2), X1 &lt;--&gt; X2
end</code></pre><p>To learn the compartment and edge parameters of a <code>LatticeReaction</code>, the <a href="../../api/#Catalyst.vertex_parameters"><code>vertex_parameters</code></a> and <a href="../../api/#Catalyst.edge_parameters"><code>edge_parameters</code></a> functions can be used:</p><pre><code class="language-julia hljs">two_state_model = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
diffusion_rx = @transport_reaction D X1
lattice = CartesianGrid((20,20))
lrs = LatticeReactionSystem(two_state_model, [diffusion_rx], lattice)
edge_parameters(lrs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Any}:
 D</code></pre><h2 id="spatial_lattice_modelling_intro_limitations"><a class="docs-heading-anchor" href="#spatial_lattice_modelling_intro_limitations">Spatial modelling limitations</a><a id="spatial_lattice_modelling_intro_limitations-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_lattice_modelling_intro_limitations" title="Permalink"></a></h2><p>Many features which are supported for non-spatial <code>ReactionSystem</code>s are currently unsupported for <a href="../../api/#Catalyst.LatticeReactionSystem"><code>LatticeReactionSystem</code></a>s. This includes <a href="../../model_creation/dsl_advanced/#dsl_advanced_options_observables">observables</a>, <a href="../../model_creation/constraint_equations/#constraint_equations">algebraic and differential equations</a>, <a href="../../model_creation/compositional_modeling/#compositional_modeling">hierarchical models</a>, and <a href="../../model_creation/constraint_equations/#constraint_equations_events">events</a>. It is possible that these features will be supported in the future. Furthermore, <a href="../../model_creation/conservation_laws/#conservation_laws">removal of conserved quantities</a> is not supported when creating spatial <code>ODEProblem</code>s.</p><p>If you are using Catalyst&#39;s features for spatial modelling, please give us feedback on how we can improve these features. Additionally, just letting us know that you use these features is useful, as it helps inform us whether continued development of spatial modelling features is worthwhile. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../inverse_problems/examples/ode_fitting_oscillation/">« Fitting Parameters for an Oscillatory System</a><a class="docs-footer-nextpage" href="../lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Saturday 31 August 2024 00:03">Saturday 31 August 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
