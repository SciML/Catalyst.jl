var documenterSearchIndex = {"docs":
[{"location":"tutorials/advanced/#The-Reaction-DSL-Advanced","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"","category":"section"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"This section covers some of the more advanced syntax and features for building chemical reaction network models (still not very complicated!).","category":"page"},{"location":"tutorials/advanced/#User-defined-functions-in-reaction-rates","page":"The Reaction DSL - Advanced","title":"User defined functions in reaction rates","text":"","category":"section"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"The reaction network DSL can \"see\" user defined functions that work with ModelingToolkit. E.g., this is should work","category":"page"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"myHill(x) = 2.0*x^3/(x^3+1.5^3)\nrn = @reaction_network begin\n  myHill(X), ∅ → X\nend","category":"page"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"In some cases, it may be necessary or desirable to register functions with Symbolics.jl before their use in Catalyst, see the discussion here.","category":"page"},{"location":"tutorials/advanced/#Ignoring-mass-action-kinetics","page":"The Reaction DSL - Advanced","title":"Ignoring mass action kinetics","text":"","category":"section"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"While generally one wants the reaction rate to use the law of mass action, so the reaction","category":"page"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"rn = @reaction_network begin\n  k, X → ∅\nend k","category":"page"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"occurs at the rate dXdt = -kX, it is possible to ignore this by using any of the following non-filled arrows when declaring the reaction: ⇐, ⟽, ⇒, ⟾, ⇔, ⟺. This means that the reaction","category":"page"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"rn = @reaction_network begin\n  k, X ⇒ ∅\nend k","category":"page"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"will occur at rate dXdt = -k (which might become a problem since X will be degraded at a constant rate even when very small or equal to 0).","category":"page"},{"location":"tutorials/basic_examples/#Basic-Chemical-Reaction-Network-Examples","page":"Basic Chemical Reaction Network Examples","title":"Basic Chemical Reaction Network Examples","text":"","category":"section"},{"location":"tutorials/basic_examples/#Example:-Birth-Death-Process","page":"Basic Chemical Reaction Network Examples","title":"Example: Birth-Death Process","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Chemical Reaction Network Examples","title":"Basic Chemical Reaction Network Examples","text":"rs = @reaction_network begin\n  c1, X --> 2X\n  c2, X --> 0\n  c3, 0 --> X\nend c1 c2 c3\np = (1.0,2.0,50.) # [c1,c2,c3]\ntspan = (0.,4.)\nu0 = [5.]         # [X]\n\n# solve ODEs\noprob = ODEProblem(rs, u0, tspan, p)\nosol  = solve(oprob, Tsit5())\n\n# solve for Steady-States\nssprob = SteadyStateProblem(rs, u0, p)\nsssol  = solve(ssprob, SSRootfind())\n\n# solve SDEs\nsprob = SDEProblem(rs, u0, tspan, p)\nssol  = solve(sprob, EM(), dt=.01)\n\n# solve JumpProblem\nu0 = [5]\ndprob = DiscreteProblem(rs, u0, tspan, p)\njprob = JumpProblem(rs, dprob, Direct())\njsol = solve(jprob, SSAStepper())","category":"page"},{"location":"tutorials/basic_examples/#Example:-Michaelis-Menten-Enzyme-Kinetics","page":"Basic Chemical Reaction Network Examples","title":"Example: Michaelis-Menten Enzyme Kinetics","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Chemical Reaction Network Examples","title":"Basic Chemical Reaction Network Examples","text":"rs = @reaction_network begin\n  c1, S + E --> SE\n  c2, SE --> S + E\n  c3, SE --> P + E\nend c1 c2 c3\np = (0.00166,0.0001,0.1)   # [c1,c2,c3]\ntspan = (0., 100.)\nu0 = [301., 100., 0., 0.]  # [S,E,SE,P]\n\n# solve ODEs\noprob = ODEProblem(rs, u0, tspan, p)\nosol  = solve(oprob, Tsit5())\n\n# solve JumpProblem\nu0 = [301, 100, 0, 0] \ndprob = DiscreteProblem(rs, u0, tspan, p)\njprob = JumpProblem(rs, dprob, Direct())\njsol = solve(jprob, SSAStepper())","category":"page"},{"location":"tutorials/advanced_examples/#Advanced-Chemical-Reaction-Network-Examples","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"","category":"section"},{"location":"tutorials/advanced_examples/","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"For additional flexibility, we can convert the generated ReactionSystem first to another ModelingToolkit.AbstractSystem, e.g., an ODESystem, SDESystem, JumpSystem, etc. These systems can then be used in problem generation. Please also see the ModelingToolkit docs, which give many options for optimized problem generation (i.e., generating dense or sparse Jacobians with or without threading and/or parallelization), creating LaTeX representations for systems, etc.","category":"page"},{"location":"tutorials/advanced_examples/","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"Note, when generating problems from other system types, u0 and p must provide vectors of Pairs that map each species or parameter to their numerical value. E.g., for the Michaelis-Menten example above we'd use","category":"page"},{"location":"tutorials/advanced_examples/","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"rs = @reaction_network begin\n  c1, X --> 2X\n  c2, X --> 0\n  c3, 0 --> X\nend c1 c2 c3\np     = (1.0,2.0,50.)\ntspan = (0.,4.)\nu0    = [5.]   \nosys  = convert(ODESystem, rs)\nu0map = map((x,y) -> Pair(x,y), species(rs), u0)\npmap  = map((x,y) -> Pair(x,y), params(rs), p)\noprob = ODEProblem(osys, u0map, tspan, pmap)\nsol   = solve(oprob, Tsit5())","category":"page"},{"location":"tutorials/advanced_examples/#Example:-Disabling-rescaling-of-reaction-rates","page":"Advanced Chemical Reaction Network Examples","title":"Example: Disabling rescaling of reaction rates","text":"","category":"section"},{"location":"tutorials/advanced_examples/","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"As explained in the Reaction rate laws used in simulations section, for a reaction such as k, 2X --> 0, the generated rate law will rescale the rate constant, giving k*X^2/2 instead of k*X^2 for ODEs and k*X*(X-1)/2 instead of k*X*(X-1) for jumps. This can be disabled when directly converting a ReactionSystem. If rn is a generated ReactionSystem, we can do","category":"page"},{"location":"tutorials/advanced_examples/","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"osys = convert(ODESystem, rn; combinatoric_ratelaws=false)","category":"page"},{"location":"tutorials/advanced_examples/","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"Disabling these rescalings should work for all conversions of ReactionSystems to other ModelingToolkit.AbstractSystems.","category":"page"},{"location":"tutorials/advanced_examples/#Example:-Modifying-generated-ODEs-by-adding-forcing","page":"Advanced Chemical Reaction Network Examples","title":"Example: Modifying generated ODEs by adding forcing","text":"","category":"section"},{"location":"tutorials/advanced_examples/","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"Conversion to other ModelingToolkit.AbstractSystems allows the possibility to modify the system with further terms that are difficult to encode as a chemical reaction. For example, suppose we wish to add a forcing term, 10sin(10t), to the ODE for dX/dt above. We can do so as:","category":"page"},{"location":"tutorials/advanced_examples/","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"dXdteq = equations(osys)[1]           \nt      = independent_variable(osys)    \ndXdteq = Equation(dXdteq.lhs, dXdteq.rhs + 10*sin(10*t))   \nosys2  = ODESystem([dXdteq], t, states(osys), parameters(osys))\noprob  = ODEProblem(osys2, u0map, tspan, pmap)\nosol   = solve(oprob, Tsit5())","category":"page"},{"location":"tutorials/advanced_examples/","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"We can add e^-X to dXdt as a forcing term by","category":"page"},{"location":"tutorials/advanced_examples/","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"dXdteq = equations(osys)[1]           \n@variables X(t)\ndXdteq = Equation(dXdteq.lhs, dXdteq.rhs + exp(-X))   \nosys2  = ODESystem([dXdteq], t, states(osys), parameters(osys))\noprob  = ODEProblem(osys2, u0map, tspan, pmap)\nosol   = solve(oprob, Tsit5())","category":"page"},{"location":"tutorials/using_catalyst/#Using-Catalyst","page":"Using Catalyst","title":"Using Catalyst","text":"","category":"section"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"In this tutorial we'll provide an introduction to using Catalyst to specify chemical reaction networks, and then to solve ODE, jump, and SDE models generated from them. Let's start by using the Catalyst @reaction_network macro to specify a simply chemical reaction network: the well-known repressilator.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We first import the basic packages we'll need:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"# If not already installed, first hit \"]\" within a Julia REPL. Then type:\n# add Catalyst DifferentialEquations Plots Latexify\n\nusing Catalyst, DifferentialEquations, Plots, Latexify","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We now construct the reaction network. The basic types of arrows and predefined rate laws one can use are discussed in detail within the next tutorial, The Reaction DSL. Here, we use a mix of first order, zero order, and repressive Hill function rate laws. Note, varnothing corresponds to the empty state, and is used for zeroth order production and first order degradation reactions:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"repressilator = @reaction_network begin\n    hillr(P₃,α,K,n), ∅ --> m₁\n    hillr(P₁,α,K,n), ∅ --> m₂\n    hillr(P₂,α,K,n), ∅ --> m₃\n    (δ,γ), m₁ ↔ ∅\n    (δ,γ), m₂ ↔ ∅\n    (δ,γ), m₃ ↔ ∅\n    β, m₁ --> m₁ + P₁\n    β, m₂ --> m₂ + P₂\n    β, m₃ --> m₃ + P₃\n    μ, P₁ --> ∅\n    μ, P₂ --> ∅\n    μ, P₃ --> ∅\nend α K n δ γ β μ;","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"@reaction_network returns a ModelingToolkit.ReactionSystem, which can be converted to a variety of other mathematical models represented as ModelingToolkit.AbstractSystems.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We can use Latexify to look at the corresponding reactions and understand the generated rates expressions for each reaction","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"latexify(repressilator)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"beginalign*\nrequiremhchem\nce varnothing -fracalpha K^nK^n + left( mathrmP_3left( t right) right)^n m_1\nce varnothing -fracalpha K^nK^n + left( mathrmP_1left( t right) right)^n m_2\nce varnothing -fracalpha K^nK^n + left( mathrmP_2left( t right) right)^n m_3\nce m_1 =deltagamma varnothing\nce m_2 =deltagamma varnothing\nce m_3 =deltagamma varnothing\nce m_1 -beta m_1 + P_1\nce m_2 -beta m_2 + P_2\nce m_3 -beta m_3 + P_3\nce P_1 -mu varnothing\nce P_2 -mu varnothing\nce P_3 -mu varnothing\nendalign*","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Assuming Graphviz is installed and commandline accessible, within a Jupyter notebook we can also graph the reaction network by","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"g = Graph(repressilator)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"giving","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"(Image: Repressilator solution)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"The network graph shows a variety of information, representing each species as a blue node, and each reaction as an orange dot. Black arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry. Similarly, black arrows from reactions to species indicate products, and are labelled with their output stoichiometry. In contrast, red arrows from a species to reactions indicate the species is used within the reactions' rate expressions. For the repressilator, the reactions","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"hillr(P₃,α,K,n), ∅ --> m₁\nhillr(P₁,α,K,n), ∅ --> m₂\nhillr(P₂,α,K,n), ∅ --> m₃","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"have rates that depend on the proteins, and hence lead to red arrows from each Pᵢ.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Note, from the REPL or scripts one can always use savegraph to save the graph (assuming Graphviz is installed).","category":"page"},{"location":"tutorials/using_catalyst/#Mass-Action-ODE-Models","page":"Using Catalyst","title":"Mass Action ODE Models","text":"","category":"section"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Let's now use our ReactionSystem to generate and solve a corresponding mass action ODE model. We first convert the system to a ModelingToolkit.ODESystem by","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"odesys = convert(ODESystem, repressilator)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We can once again use Latexify to look at the corresponding ODE model","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"latexify(odesys)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"beginaligned\nfracdm_1(t)dt = fracalpha K^nK^n + left( mathrmP_3left( t right) right)^n - delta mathrmm_1left( t right) + gamma \nfracdm_2(t)dt = fracalpha K^nK^n + left( mathrmP_1left( t right) right)^n - delta mathrmm_2left( t right) + gamma \nfracdm_3(t)dt = fracalpha K^nK^n + left( mathrmP_2left( t right) right)^n - delta mathrmm_3left( t right) + gamma \nfracdP_1(t)dt = beta mathrmm_1left( t right) - mu mathrmP_1left( t right) \nfracdP_2(t)dt = beta mathrmm_2left( t right) - mu mathrmP_2left( t right) \nfracdP_3(t)dt = beta mathrmm_3left( t right) - mu mathrmP_3left( t right)\nendaligned","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"(Note, there is currently a Latexify bug that causes different fonts to be used for the species symbols on each side of the equations.)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Before we can solve the ODEs, we need to specify the values of the parameters in the model, the initial condition, and the time interval to solve the model on. To do this it helps to know the orderings of the parameters and the species. Parameters are ordered in the same order they appear after the end statement in the @reaction_network macro. Species are ordered in the order they first appear within the @reaction_network macro. We can see these orderings using the speciesmap and paramsmap functions:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"speciesmap(repressilator)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Dict{Term{Real},Int64} with 6 entries:\n  P₃(t) => 6\n  m₃(t) => 3\n  P₂(t) => 5\n  P₁(t) => 4\n  m₁(t) => 1\n  m₂(t) => 2","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"paramsmap(repressilator)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Dict{Sym{ModelingToolkit.Parameter{Real}},Int64} with 7 entries:\n  μ => 7\n  β => 6\n  α => 1\n  δ => 4\n  K => 2\n  n => 3\n  γ => 5\n","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"which are consistent with the API functions:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"species(repressilator)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"6-element Array{Term{Real},1}:\n m₁(t)\n m₂(t)\n m₃(t)\n P₁(t)\n P₂(t)\n P₃(t)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"params(repressilator)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"7-element Array{Sym{ModelingToolkit.Parameter{Real}},1}:\n α\n K\n n\n δ\n γ\n β\n μ","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Knowing these orderings, we can create parameter and initial condition vectors, and then set up the ODEProblem we want to solve:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"# parameters [α,K,n,δ,γ,β,μ]\np = (.5, 40, 2, log(2)/120, 5e-3, 20*log(2)/120, log(2)/60)\n\n# initial condition [m₁,m₂,m₃,P₁,P₂,P₃]\nu₀ = [0.,0.,0.,20.,0.,0.]\n\n# time interval to solve on\ntspan = (0., 10000.)\n\n# create the ODEProblem we want to solve\noprob = ODEProblem(repressilator, u₀, tspan, p)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Note, by passing repressilator directly to the ODEProblem ModelingToolkit has to (internally) call convert(ODESystem, repressilator) again. We could instead pass odesys directly, provided we construct mappings from each species to their initial value, and each parameter to their value like:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"u₀map  = Pair.(species(repressilator), u₀)\npmap   = Pair.(params(repressilator), p)\noprob2 = ODEProblem(osys, u₀map, tspan, pmap)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"oprob and oprob2 are functionally equivalent, each representing the same underlying problem.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"At this point we are all set to solve the ODEs. We can now use any ODE solver from within the DifferentialEquations.jl package. We'll use the recommended default explicit solver, Tsit5(), and then plot the solutions:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"sol = solve(oprob, Tsit5(), saveat=10.)\nplot(sol)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"(Image: Repressilator ODE Solutions)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We see the well-known oscillatory behavior of the repressilator! For more on the choices of ODE solvers, see the DifferentialEquations.jl documentation.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"","category":"page"},{"location":"tutorials/using_catalyst/#Stochastic-Simulation-Algorithms-(SSAs)-for-Stochastic-Chemical-Kinetics","page":"Using Catalyst","title":"Stochastic Simulation Algorithms (SSAs) for Stochastic Chemical Kinetics","text":"","category":"section"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Let's now look at a stochastic chemical kinetics model of the repressilator, modeling it with jump processes. Here, we will construct a DiffEqJump JumpProblem that uses Gillespie's Direct method, and then solve it to generate one realization of the jump process:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"# redefine the initial condition to be integer valued\nu₀ = [0,0,0,20,0,0]\n\n# next we create a discrete problem to encode that our species are integer valued:\ndprob = DiscreteProblem(repressilator, u₀, tspan, p)\n\n# now, we create a JumpProblem, and specify Gillespie's Direct Method as the solver:\njprob = JumpProblem(repressilator, dprob, Direct(), save_positions=(false,false))\n\n# now, let's solve and plot the jump process:\nsol = solve(jprob, SSAStepper(), saveat=10.)\nplot(sol)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"(Image: Repressilator SSA Solutions)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We see that oscillations remain, but become much noisier. Note, in constructing the JumpProblem we could have used any of the SSAs that are part of DiffEqJump instead of the Direct method, see the list of SSAs (i.e., constant rate jump aggregators) in the documentation.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"","category":"page"},{"location":"tutorials/using_catalyst/#Chemical-Langevin-Equation-(CLE)-Stochastic-Differential-Equation-(SDE)-Models","page":"Using Catalyst","title":"Chemical Langevin Equation (CLE) Stochastic Differential Equation (SDE) Models","text":"","category":"section"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"At an intermediate physical scale between macroscopic ODE models and microscopic stochastic chemical kinetics models lies the CLE, given by a system of SDEs that add to each ODE above a noise term. As the repressilator has species that get very close to zero in size, it is not a good candidate to model with the CLE (where solutions can then go negative and become unphysical). Let's create a simpler reaction network for a birth-death process that will stay non-negative:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"bdp = @reaction_network begin\n  c₁, X --> 2X\n  c₂, X --> 0\n  c₃, 0 --> X\nend c₁ c₂ c₃\np = (1.0,2.0,50.)\nu₀ = [5.]\ntspan = (0.,4.)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"The corresponding Chemical Langevin Equation SDE is then","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"dX(t) = left( c_1 Xleft( t right) - c_2 Xleft( t right) + c_3 right) dt + sqrtc_1 X(t) dW_1(t) - sqrtc_2 X(t) dW_2(t) + sqrtc_3 dW_3(t)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"where each W_i(t) denotes an independent Brownian Motion. We can solve the CLE model by creating an SDEProblem and solving it similarly to what we did for ODEs above:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"# SDEProblem for CLE\nsprob = SDEProblem(bdp, u₀, tspan, p)\n\n# solve and plot, tstops is used to specify enough points\n# that the plot looks well-resolved\nsol = solve(sprob, LambaEM(), tstops=range(0., step=4e-3, length=1001))\nplot(sol)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"(Image: CLE Solution)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We again have complete freedom to select any of the StochasticDiffEq.jl SDE solvers, see the documentation.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"","category":"page"},{"location":"tutorials/using_catalyst/#Notes","page":"Using Catalyst","title":"Notes","text":"","category":"section"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"For each of the preceding models we converted the ReactionSystem to, i.e., ODEs, jumps, or SDEs, we had two paths for conversion:\na. Convert to the corresponding ModelingToolkit system and then use it in     creating the corresponding problem.\nb. Directly create the desired problem type from the ReactionSystem.\nThe latter is more convenient, however, the former will be more efficient if one needs to repeatedly create the associated Problem.\nModelingToolkit offers many options for optimizing the generated ODEs and SDEs, including options to build functions for evaluating Jacobians and/or multithreaded versions of derivative evaluation functions. See the options for ODEProblems and SDEProblems.","category":"page"},{"location":"api/catalyst_api/#Catalyst.jl-API","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"CurrentModule = Catalyst","category":"page"},{"location":"api/catalyst_api/#Reaction-Network-Generation-and-Representation","page":"Catalyst.jl API","title":"Reaction Network Generation and Representation","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"Catalyst provides the @reaction_network macro for generating a complete network, stored as a ModelingToolkit.ReactionSystem, which in turn is composed of ModelingToolkit.Reactions. ReactionSystems can be converted to other ModelingToolkit.AbstractSystems, including a ModelingToolkit.ODESystem, ModelingToolkit.SDESystem, or ModelingToolkit.JumpSystem.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"An empty network can be generated using @reaction_network with no arguments (or one argument to name the system), or the make_empty_network function. These can then be extended programmatically using addspecies!, addparam!, and addreaction!.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"It is important to note for @reaction_network that species which are used within the macro as part of a rate expression, but not as a substrate or product of some reaction, may lead to undefined behavior, i.e., avoid","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"rn = @reaction_network begin\n    k*X, Y --> W\nend k","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"as here X is never defined as either a species or parameter.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"@reaction_network\nmake_empty_network\nModelingToolkit.Reaction\nModelingToolkit.ReactionSystem","category":"page"},{"location":"api/catalyst_api/#Catalyst.@reaction_network","page":"Catalyst.jl API","title":"Catalyst.@reaction_network","text":"@reaction_network\n\nGenerates a ReactionSystem that encodes a chemical reaction network.\n\nSee the Catalyst.jl for Reaction Models documentation for details on parameters to the macro.\n\nExamples:\n\n# a basic SIR model, with name SIR\nsir_model = @reaction_network SIR begin\n    c1, s + i --> 2i\n    c2, i --> r\nend c1 c2\n\n# a basic SIR model, with random generated name\nsir_model = @reaction_network begin\n    c1, s + i --> 2i\n    c2, i --> r\nend c1 c2\n\n# an empty network with name empty\nemptyrn = @reaction_network empty\n\n# an empty network with random generated name\nemptyrn = @reaction_network \n\n\n\n\n\n","category":"macro"},{"location":"api/catalyst_api/#Catalyst.make_empty_network","page":"Catalyst.jl API","title":"Catalyst.make_empty_network","text":"make_empty_network(; iv=DEFAULT_IV, name=gensym(:ReactionSystem))\n\nConstruct an empty ReactionSystem. iv is the independent variable, usually time, and name is the name to give the ReactionSystem.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#ModelingToolkit.Reaction","page":"Catalyst.jl API","title":"ModelingToolkit.Reaction","text":"struct Reaction{S, T<:Number}\n\nOne chemical reaction.\n\nFields\n\nrate\nThe rate function (excluding mass action terms).\nsubstrates\nReaction substrates.\nproducts\nReaction products.\nsubstoich\nThe stoichiometric coefficients of the reactants.\nprodstoich\nThe stoichiometric coefficients of the products.\nnetstoich\nThe net stoichiometric coefficients of all species changed by the reaction.\nonly_use_rate\nfalse (default) if rate should be multiplied by mass action terms to give the rate law. true if rate represents the full reaction rate law.\n\nExamples\n\nusing ModelingToolkit\n@parameters t k[1:20]\n@variables A(t) B(t) C(t) D(t)\nrxs = [Reaction(k[1], nothing, [A]),            # 0 -> A\n       Reaction(k[2], [B], nothing),            # B -> 0\n       Reaction(k[3],[A],[C]),                  # A -> C\n       Reaction(k[4], [C], [A,B]),              # C -> A + B\n       Reaction(k[5], [C], [A], [1], [2]),      # C -> A + A\n       Reaction(k[6], [A,B], [C]),              # A + B -> C\n       Reaction(k[7], [B], [A], [2], [1]),      # 2B -> A\n       Reaction(k[8], [A,B], [A,C]),            # A + B -> A + C\n       Reaction(k[9], [A,B], [C,D]),            # A + B -> C + D\n       Reaction(k[10], [A], [C,D], [2], [1,1]), # 2A -> C + D\n       Reaction(k[11], [A], [A,B], [2], [1,1]), # 2A -> A + B\n       Reaction(k[12], [A,B,C], [C,D], [1,3,4], [2, 3]),          # A+3B+4C -> 2C + 3D\n       Reaction(k[13], [A,B], nothing, [3,1], nothing),           # 3A+B -> 0\n       Reaction(k[14], nothing, [A], nothing, [2]),               # 0 -> 2A\n       Reaction(k[15]*A/(2+A), [A], nothing; only_use_rate=true), # A -> 0 with custom rate\n       Reaction(k[16], [A], [B]; only_use_rate=true),             # A -> B with custom rate.\n       Reaction(k[17]*A*exp(B), [C], [D], [2], [1]),              # 2C -> D with non constant rate.\n       Reaction(k[18]*B, nothing, [B], nothing, [2]),             # 0 -> 2B with non constant rate.\n       Reaction(k[19]*t, [A], [B]),                                # A -> B with non constant rate.\n       Reaction(k[20]*t*A, [B,C], [D],[2,1],[2])                  # 2A +B -> 2C with non constant rate.\n  ]\n\nNotes:\n\nnothing can be used to indicate a reaction that has no reactants or no products. In this case the corresponding stoichiometry vector should also be set to nothing.\nThe three-argument form assumes all reactant and product stoichiometric coefficients are one.\n\n\n\n\n\n","category":"type"},{"location":"api/catalyst_api/#ModelingToolkit.ReactionSystem","page":"Catalyst.jl API","title":"ModelingToolkit.ReactionSystem","text":"struct ReactionSystem <: ModelingToolkit.AbstractSystem\n\nA system of chemical reactions.\n\nFields\n\neqs\nThe reactions defining the system.\niv\nIndependent variable (usually time).\nstates\nDependent (state) variables representing amount of each species.\nps\nParameter variables.\nobserved\nname\nThe name of the system\nsystems\nsystems: The internal systems\n\nExample\n\nContinuing from the example in the Reaction definition:\n\nrs = ReactionSystem(rxs, t, [A,B,C,D], k)\n\n\n\n\n\n","category":"type"},{"location":"api/catalyst_api/#Basic-properties","page":"Catalyst.jl API","title":"Basic properties","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"species\nspeciesmap\nparams\nparamsmap\nreactions\nnumspecies\nnumparams\nnumreactions","category":"page"},{"location":"api/catalyst_api/#Catalyst.species","page":"Catalyst.jl API","title":"Catalyst.species","text":"species(network)\n\nGiven a ReactionSystem, return a vector of species Variables.\n\nNotes:\n\nIf ModelingToolkit.get_systems(network) is not empty, may allocate. Otherwise returns ModelingToolkit.ModelingToolkit.get_states(network).\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.speciesmap","page":"Catalyst.jl API","title":"Catalyst.speciesmap","text":"speciesmap(network)\n\nGiven a ReactionSystem, return a Dictionary mapping from species to species indices. (Allocates)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.params","page":"Catalyst.jl API","title":"Catalyst.params","text":"params(network)\n\nGiven a ReactionSystem, return a vector of parameter Variables.\n\nNotes:\n\nIf ModelingToolkit.get_systems(network) is not empty, may allocate. Otherwise returns ModelingToolkit.get_ps(network).\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.paramsmap","page":"Catalyst.jl API","title":"Catalyst.paramsmap","text":"paramsmap(network)\n\nGiven a ReactionSystem, return a Dictionary mapping from parameters to parameter indices. (Allocates)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reactions","page":"Catalyst.jl API","title":"Catalyst.reactions","text":"reactions(network)\n\nGiven a ReactionSystem, return a vector of all Reactions in the system.\n\nNotes:\n\nIf ModelingToolkit.get_systems(network) is not empty, may allocate. Otherwise returns ModelingToolkit.get_eqs(network).\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.numspecies","page":"Catalyst.jl API","title":"Catalyst.numspecies","text":"numspecies(network)\n\nReturn the number of species within the given ReactionSystem.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.numparams","page":"Catalyst.jl API","title":"Catalyst.numparams","text":"numparams(network)\n\nReturn the number of parameters within the given ReactionSystem.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.numreactions","page":"Catalyst.jl API","title":"Catalyst.numreactions","text":"numreactions(network)\n\nReturn the number of reactions within the given ReactionSystem.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Reaction-Properties","page":"Catalyst.jl API","title":"Reaction Properties","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"ModelingToolkit.ismassaction\ndependents\ndependants\nsubstoichmat\nprodstoichmat\nnetstoichmat","category":"page"},{"location":"api/catalyst_api/#ModelingToolkit.ismassaction","page":"Catalyst.jl API","title":"ModelingToolkit.ismassaction","text":"ismassaction(rx, rs; rxvars = get_variables(rx.rate),\n                              haveivdep = any(var -> isequal(get_iv(rs),var), rxvars),\n                              stateset = Set(states(rs)))\n\nTrue if a given reaction is of mass action form, i.e. rx.rate does not depend on any chemical species that correspond to states of the system, and does not depend explicitly on the independent variable (usually time).\n\nArguments\n\nrx, the Reaction.\nrs, a ReactionSystem containing the reaction.\nOptional: rxvars, Variables which are not in rxvars are ignored as possible dependencies.\nOptional: haveivdep, true if the Reaction rate field explicitly depends on the independent variable.\nOptional: stateset, set of states which if the rxvars are within mean rx is non-mass action.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.dependents","page":"Catalyst.jl API","title":"Catalyst.dependents","text":"dependents(rx, network)\n\nGiven a Reaction and a ReactionSystem, return a vector of ModelingToolkit.Nums corresponding to species the reaction rate law depends on. E.g., for\n\nk*W, 2X + 3Y --> 5Z + W\n\nthe returned vector would be [W(t),X(t),Y(t)].\n\nNotes:\n\nAllocates\nDoes not check for dependents within any subsystems.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.dependants","page":"Catalyst.jl API","title":"Catalyst.dependants","text":"dependents(rx, network)\n\nSee documentation for dependents.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.substoichmat","page":"Catalyst.jl API","title":"Catalyst.substoichmat","text":"substoichmat(rn; smap=speciesmap(rn))\n\nReturns the substrate stoichiometry matrix\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.prodstoichmat","page":"Catalyst.jl API","title":"Catalyst.prodstoichmat","text":"prodstoichmat(rn; smap=speciesmap(rn))\n\nReturns the product stoichiometry matrix\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.netstoichmat","page":"Catalyst.jl API","title":"Catalyst.netstoichmat","text":"netstoichmat(rn; smap=speciesmap(rn))\n\nReturns the net stoichiometry matrix\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Functions-to-extend-a-Network","page":"Catalyst.jl API","title":"Functions to extend a Network","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"@add_reactions\naddspecies!\naddparam!\naddreaction!\nmerge!(network1::ReactionSystem, network2::ReactionSystem)\nmerge(network1::ReactionSystem, network2::ReactionSystem)","category":"page"},{"location":"api/catalyst_api/#Catalyst.@add_reactions","page":"Catalyst.jl API","title":"Catalyst.@add_reactions","text":"@add_reactions\n\nAdds the reactions declared to a preexisting ReactionSystem. All parameters used in the added reactions need to be declared after the reactions.\n\nSee the Catalyst.jl for Reaction Models documentation for details on parameters to the macro.\n\n\n\n\n\n","category":"macro"},{"location":"api/catalyst_api/#Catalyst.addspecies!","page":"Catalyst.jl API","title":"Catalyst.addspecies!","text":"addspecies!(network::ReactionSystem, s::Symbolic; disablechecks=false)\n\nGiven a ReactionSystem, add the species corresponding to the variable s to the network (if it is not already defined). Returns the integer id of the species within the system.\n\nNotes:\n\ndisablechecks will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. Do not disable checks unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.\n\n\n\n\n\naddspecies!(network::ReactionSystem, s::Num; disablechecks=false)\n\nGiven a ReactionSystem, add the species corresponding to the variable s to the network (if it is not already defined). Returns the integer id of the species within the system.\n\ndisablechecks will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. Do not disable checks unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.addparam!","page":"Catalyst.jl API","title":"Catalyst.addparam!","text":"addparam!(network::ReactionSystem, p::Symbolic; disablechecks=false)\n\nGiven a ReactionSystem, add the parameter corresponding to the variable p to the network (if it is not already defined). Returns the integer id of the parameter within the system.\n\ndisablechecks will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. Do not disable checks unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.\n\n\n\n\n\naddparam!(network::ReactionSystem, p::Num; disablechecks=false)\n\nGiven a ReactionSystem, add the parameter corresponding to the variable p to the network (if it is not already defined). Returns the integer id of the parameter within the system.\n\ndisablechecks will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. Do not disable checks unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.addreaction!","page":"Catalyst.jl API","title":"Catalyst.addreaction!","text":"addreaction!(network::ReactionSystem, rx::Reaction)\n\nAdd the passed in reaction to the ReactionSystem. Returns the integer id of rx in the list of Reactions within network.\n\nNotes:\n\nAny new species or parameters used in rx should be separately added to   network using addspecies! and addparam!.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Base.merge!-Tuple{ReactionSystem, ReactionSystem}","page":"Catalyst.jl API","title":"Base.merge!","text":"merge!(network1::ReactionSystem, network2::ReactionSystem)\n\nMerge network2 into network1.\n\nNotes:\n\nDuplicate reactions between the two networks are not filtered out.\nReactions are not deepcopied to minimize allocations, so both networks will share underlying data arrays.\nSubsystems are not deepcopied between the two networks and will hence be shared.\nReturns network1.\nDoes not currently handle pins.\n\n\n\n\n\n","category":"method"},{"location":"api/catalyst_api/#Base.merge-Tuple{ReactionSystem, ReactionSystem}","page":"Catalyst.jl API","title":"Base.merge","text":"merge(network1::ReactionSystem, network2::ReactionSystem)\n\nCreate a new network merging network1 and network2.\n\nNotes:\n\nDuplicate reactions between the two networks are not filtered out.\nReactions are not deepcopied to minimize allocations, so the new network will share underlying data arrays.\nSubsystems are not deepcopied between the two networks and will hence be shared.\nReturns the merged network.\nDoes not currently handle pins.\n\n\n\n\n\n","category":"method"},{"location":"api/catalyst_api/#Rate-Law-Expressions","page":"Catalyst.jl API","title":"Rate Law Expressions","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"As the underlying ReactionSystem is comprised of ModelingToolkit expressions, one can directly access the generated rate laws, and using ModelingToolkit tooling generate functions or Julia Exprs from them.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"ModelingToolkit.oderatelaw\nModelingToolkit.jumpratelaw","category":"page"},{"location":"api/catalyst_api/#ModelingToolkit.oderatelaw","page":"Catalyst.jl API","title":"ModelingToolkit.oderatelaw","text":"oderatelaw(rx; combinatoric_ratelaw=true)\n\nGiven a Reaction, return the reaction rate law Operation used in generated ODEs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X(t)^2*Y(t)*Z(t). For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe Operation that is returned will be k * (X(t)^2/2) * (Y(t)^3/6).\n\nNotes:\n\nAllocates\ncombinatoric_ratelaw=true uses factorial scaling factors in calculating the rate   law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If   combinatoric_ratelaw=false then the ratelaw is k*S^2, i.e. the scaling factor is   ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#ModelingToolkit.jumpratelaw","page":"Catalyst.jl API","title":"ModelingToolkit.jumpratelaw","text":"jumpratelaw(rx; rxvars=get_variables(rx.rate), combinatoric_ratelaw=true)\n\nGiven a Reaction, return the reaction rate law Operation used in generated stochastic chemical kinetics model SSAs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X^2*Y*Z. For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe Operation that is returned will be k * binomial(X,2) * binomial(Y,3).\n\nNotes:\n\nrxvars should give the Variables, i.e. species and parameters, the rate depends on.\nAllocates\ncombinatoric_ratelaw=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaw=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Network-Comparison-Functions","page":"Catalyst.jl API","title":"Network Comparison Functions","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"==(rn1::ReactionSystem, rn2::ReactionSystem)\n==(rn1::Reaction, rn2::Reaction)","category":"page"},{"location":"api/catalyst_api/#Base.:==-Tuple{ReactionSystem, ReactionSystem}","page":"Catalyst.jl API","title":"Base.:==","text":"==(rn1::ReactionSystem, rn2::ReactionSystem)\n\nTests whether the underlying species, parameters and reactions are the same in the two ReactionSystems. Ignores order network components were defined.\n\nNotes:\n\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\nFlattens subsystems, and hence may allocate, when checking equality.\n\n\n\n\n\n","category":"method"},{"location":"api/catalyst_api/#Base.:==-Tuple{Reaction, Reaction}","page":"Catalyst.jl API","title":"Base.:==","text":"==(rn1::Reaction, rn2::Reaction)\n\nTests whether two Reactions are identical.\n\nNotes:\n\nIgnores the order in which stoichiometry components are listed.\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\n\n\n\n\n\n","category":"method"},{"location":"api/catalyst_api/#Transformations","page":"Catalyst.jl API","title":"Transformations","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"Base.convert","category":"page"},{"location":"api/catalyst_api/#Base.convert","page":"Catalyst.jl API","title":"Base.convert","text":"Base.convert(::Type{<:ODESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ODESystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate\n\nlaw, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If combinatoric_ratelaws=false then the ratelaw is k*S^2, i.e. the scaling factor is ignored.\n\n\n\n\n\nBase.convert(::Type{<:NonlinearSystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an NonlinearSystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate\n\nlaw, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If combinatoric_ratelaws=false then the ratelaw is k*S^2, i.e. the scaling factor is ignored.\n\n\n\n\n\nBase.convert(::Type{<:SDESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an SDESystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate\n\nlaw, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If combinatoric_ratelaws=false then the ratelaw is k*S^2, i.e. the scaling factor is ignored.\n\nnoise_scaling=nothing::Union{Vector{Operation},Operation,Nothing} allows for linear\n\nscaling of the noise in the chemical Langevin equations. If nothing is given, the default value as in Gillespie 2000 is used. Alternatively, an Operation can be given, this is added as a parameter to the system (at the end of the parameter array). All noise terms are linearly scaled with this value. The parameter may be one already declared in the ReactionSystem. Finally, a Vector{Operation} can be provided (the length must be equal to the number of reactions). Here the noise for each reaction is scaled by the corresponding parameter in the input vector. This input may contain repeat parameters.\n\n\n\n\n\nBase.convert(::Type{<:JumpSystem},rs::ReactionSystem; combinatoric_ratelaws=true)\n\nConvert a ReactionSystem to an JumpSystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaws=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Displaying-Networks","page":"Catalyst.jl API","title":"Displaying Networks","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"Latexify can be used to convert networks to LaTeX mhchem equations by","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"using Latexify\nlatexify(rn)","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"If Graphviz is installed and commandline accessible, it can be used to create and save network diagrams using Graph and savegraph.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"Graph\nsavegraph","category":"page"},{"location":"api/catalyst_api/#Catalyst.Graph","page":"Catalyst.jl API","title":"Catalyst.Graph","text":"Graph(rn::ReactionSystem)\n\nConverts a ReactionSystem into a Graphviz graph. Reactions correspond to small green circles, and species to blue circles.\n\nNotes:\n\nBlack arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry.\nBlack arrows from reactions to species indicate products, and are labelled with their output stoichiometry.\nRed arrows from species to reactions indicate that species is used within the rate expression. For example, in the reaction k*A, B --> C, there would be a red arrow from A to the reaction node. In k*A, A+B --> C, there would be red and black arrows from A to the reaction node.\nRequires Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"type"},{"location":"api/catalyst_api/#Catalyst.savegraph","page":"Catalyst.jl API","title":"Catalyst.savegraph","text":"savegraph(g::Graph, fname, fmt=\"png\")\n\nGiven a Graph generated by Graph, save the graph to the file with name fname and extension fmt.\n\nNotes:\n\nfmt=\"png\" is the default output format.\nRequires Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/basics/#The-Reaction-DSL","page":"The Reaction DSL","title":"The Reaction DSL","text":"","category":"section"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"This tutorial covers some of the basic syntax for building chemical reaction network models. Examples showing how to both construct and solve ODE, SDE, and jump models are provided in Basic Chemical Reaction Network Examples.","category":"page"},{"location":"tutorials/basics/#Basic-syntax","page":"The Reaction DSL","title":"Basic syntax","text":"","category":"section"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The @reaction_network macro allows the (symbolic) specification of reaction networks with a simple format. Its input is a set of chemical reactions, and from them it generates a ReactionSystem reaction network object. The ReactionSystem can be used as input to ODEProblem, SteadyStateProblem, SDEProblem, JumpProblem, and more. ReactionSystems can also be incrementally extended as needed, allowing for programmatic construction of networks and network composition.","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The basic syntax is:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  2.0, X + Y --> XY               \n  1.0, XY --> Z1 + Z2            \nend","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"where each line corresponds to a chemical reaction. Each reaction consists of a reaction rate (the expression on the left hand side of  ,), a set of substrates (the expression in-between , and -->), and a set of products (the expression on the right hand side of -->). The substrates and the products may contain one or more reactants, separated by +. The naming convention for these are the same as for normal variables in Julia.","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The chemical reaction model is generated by the @reaction_network macro and stored in the rn variable (a normal Julia variable, which does not need to be called rn). The generated ReactionSystem can be converted to a differential equation model via","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"osys = convert(ODESystem, rn)\noprob = ODEProblem(osys, Pair.(species(rn),u0), tspan, Pair.(params(rn),p))","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"or more directly via","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"oprob = ODEProblem(rn, u0, tspan, p)","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"For more detailed examples, see the Basic Chemical Reaction Network Examples. The generated differential equations use the law of mass action. For the above example, the ODEs are then","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"fracdXdt = -2 X Y\nfracdYdt = -2 X Y\nfracdXYdt = 2 X Y - XY\nfracdZ1dt= XY\nfracdZ2dt = XY","category":"page"},{"location":"tutorials/basics/#Arrow-variants","page":"The Reaction DSL","title":"Arrow variants","text":"","category":"section"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"A variety of unicode arrows are accepted by the DSL in addition to -->. All of these work:  >, → ↣, ↦, ⇾, ⟶, ⟼, ⥟, ⥟, ⇀, ⇁. Backwards arrows can also be used to write the reaction in the opposite direction. For example, these three reactions are equivalent:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, X + Y --> XY               \n  1.0, X + Y → XY      \n  1.0, XY ← X + Y      \nend","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"On Julia 1.6 and up the plain text arrows <-- (for backward reactions) and <--> (for reversible reactions) also work. Note, these are not available on earlier Julia versions.","category":"page"},{"location":"tutorials/basics/#Using-bi-directional-arrows","page":"The Reaction DSL","title":"Using bi-directional arrows","text":"","category":"section"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Bi-directional unicode arrows can be used to designate a reaction that goes two ways. These three models are equivalent:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  2.0, X + Y → XY             \n  2.0, X + Y ← XY          \nend\nrn = @reaction_network begin\n  2.0, X + Y ↔ XY               \nend","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"If the reaction rates in the backward and forward directions are different, they can be designated in the following way:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  (2.0,1.0) X + Y ↔ XY               \nend","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"which is identical to","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  2.0, X + Y → XY             \n  1.0, X + Y ← XY          \nend","category":"page"},{"location":"tutorials/basics/#Combining-several-reactions-in-one-line","page":"The Reaction DSL","title":"Combining several reactions in one line","text":"","category":"section"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Several similar reactions can be combined in one line by providing a tuple of reaction rates and/or substrates and/or products. If several tuples are provided, they must all be of identical length. These pairs of reaction networks are all identical:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  1.0, S → (P1,P2)               \nend\nrn2 = @reaction_network begin\n  1.0, S → P1     \n  1.0, S → P2\nend","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  (1.0,2.0), (S1,S2) → P             \nend\nrn2 = @reaction_network begin\n  1.0, S1 → P     \n  2.0, S2 → P\nend","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  (1.0,2.0,3.0), (S1,S2,S3) → (P1,P2,P3)        \nend\nrn2 = @reaction_network begin\n  1.0, S1 → P1\n  2.0, S2 → P2   \n  3.0, S3 → P3  \nend","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"This can also be combined with bi-directional arrows, in which case separate tuples can be provided for the backward and forward reaction rates. These reaction networks are identical","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n (1.0,(1.0,2.0)), S ↔ (P1,P2)  \nend\nrn2 = @reaction_network begin\n  1.0, S → P1\n  1.0, S → P2\n  1.0, P1 → S   \n  2.0, P2 → S\nend","category":"page"},{"location":"tutorials/basics/#Production-and-Destruction-and-Stoichiometry","page":"The Reaction DSL","title":"Production and Destruction and Stoichiometry","text":"","category":"section"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Sometimes reactants are produced/destroyed from/to nothing. This can be designated using either 0 or ∅:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  2.0, 0 → X\n  1.0, X → ∅\nend","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"If several molecules of the same reactant are involved in a reaction, the stoichiometry of a reactant in a reaction can be set using a number. Here, two molecules of species X form the dimer X2:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, 2X → X2\nend","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"this corresponds to the differential equation:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"fracdXdt = -X^2\nfracdX2dt = frac12 X^2","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Other numbers than 2 can be used, and parenthesis can be used to reuse the same stoichiometry for several reactants:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, X + 2(Y + Z) → XY2Z2\nend","category":"page"},{"location":"tutorials/basics/#Variable-reaction-rates","page":"The Reaction DSL","title":"Variable reaction rates","text":"","category":"section"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Reaction rates do not need to be constant, but can also depend on the current concentration of the various reactants (when, for example, one reactant can activate the production of another). For instance, this is a valid notation:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  X, Y → ∅\nend","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"and will have Y degraded at rate","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"fracdYdt = -XY","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Note that this is actually equivalent to the reaction","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, X + Y → X\nend","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"except that the latter will be classified as ismassaction and the former will not, which can impact optimizations used in generating JumpSystems. For this reason, it is recommended to use the latter representation when possible.","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Most expressions and functions are valid reaction rates, e.g.:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  2.0*X^2, 0 → X + Y\n  gamma(Y)/5, X → ∅\n  pi*X/Y, Y → ∅\nend","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"but please note that user-defined functions cannot be called directly (see later section User defined functions in reaction rates).","category":"page"},{"location":"tutorials/basics/#Defining-parameters","page":"The Reaction DSL","title":"Defining parameters","text":"","category":"section"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Parameter values do not need to be set when the model is created. Components can be designated as symbolic parameters by declaring them at the end:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  p, ∅ → X\n  d, X → ∅\nend p d","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Parameters can only exist in the reaction rates (where they can be mixed with reactants). All variables not declared after end will be treated as a chemical species, and may lead to undefined behavior if unchanged by all reactions.","category":"page"},{"location":"tutorials/basics/#Pre-defined-functions","page":"The Reaction DSL","title":"Pre-defined functions","text":"","category":"section"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Hill functions and a Michaelis-Menten function are pre-defined and can be used as rate laws. Below, the pair of reactions within rn1 are equivalent, as are the pair of reactions within rn2:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  hill(X,v,K,n), ∅ → X\n  v*X^n/(X^n+K^n), ∅ → X\nend v K n\nrn2 = @reaction_network begin\n  mm(X,v,K), ∅ → X\n  v*X/(X+K), ∅ → X\nend v K","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Repressor Hill (hillr) and Michaelis-Menten (mmr) functions are also provided:","category":"page"},{"location":"tutorials/basics/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  hillr(X,v,K,n), ∅ → X\n  v*K^n/(X^n+K^n), ∅ → X\nend v K n\nrn2 = @reaction_network begin\n  mmr(X,v,K), ∅ → X\n  v*K/(X+K), ∅ → X\nend v K","category":"page"},{"location":"tutorials/bifurcation_diagram/#Bifurcation-Diagrams","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"","category":"section"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Bifurcation diagrams can be produced from Catalyst generated models through the use of the BifurcationKit.jl package. This tutorial gives a simple example of how to create such a bifurcation diagram.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"First, we declare our model. For our example we will use a bistable switch, but which also contains a Hopf bifurcation.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using Catalyst\nrn = @reaction_network begin\n    (v0+v*(S*X)^n/((S*X)^n+(D*A)^n+K^n),d), ∅ ↔ X\n    (τ*X,τ), ∅ ↔ A\nend S D τ v0 v K n d","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Next, BifurcationKit requires another form for the system function and Jacobian than what is used by the SciML ecosystem, so we need to declare these:","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"odefun = ODEFunction(convert(ODESystem,rn),jac=true)\nF = (u,p) -> odefun(u,p,0)      \nJ = (u,p) -> odefun.jac(u,p,0)","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"We also need to specify the system parameters for which we wish to plot the bifurcation diagram:","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"params = [1.,9.,0.001,0.01,2.,20.,3,0.05]","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Finally, we also need to set the input required to make the diagram. This is the index (in the parameter array) of the bifurcation parameter, the range over which we wish to plot the bifurcation diagram, as well as for which variable we wish to plot the steady state values in the diagram.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"p_idx = 1            # The index of the bifurcation parameter.\np_span = (0.1,20.)   # The parameter range for the bifurcation diagram.\nplot_var_idx = 1     # The index of the variable we plot in the bifurcation diagram.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Now we need to fetch the required packages to create the bifurcation diagram.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using BifurcationKit, Plots, LinearAlgebra, Setfield","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Next, we need to specify the input options for the pseudo-arclength continuation method which produces the diagram. We will use a deflated continuation.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"opts = ContinuationPar( dsmax = 0.05,        # Maximum arclength value of the pseudo-arc length continuation method.\n                        dsmin = 1e-4,        # Minimum arclength value of the pseudo-arc length continuation method.\n                        ds=0.001,            # Initial arclength value of the pseudo-arc length continuation method (should be positive).\n                        maxSteps = 100000,   # The maximum number of steps.\n                        pMin = p_span[1],    # Minimum p-vale (if hit, the method stops).\n                        pMax = p_span[2],    # Maximum p-vale (if hit, the method stops).\n                        detectBifurcation=3, # Value in {0,1,2,3} determening to what extent bofurcation points are detected (0 means nothing is done, 3 both them and there localisation are detected).\n                        newtonOptions = NewtonPar(tol = 1e-9, verbose = false, maxIter = 15)) #Parameters to the newton solver (when finding fixed points) see BifurcationKit documentation.\n                        \nDO = DeflationOperator( 2.0,    # Algorithm parameter required when using deflated continuation, see BifurcationKit documentation.\n                        dot,    # Algorithm parameter required when using deflated continuation, see BifurcationKit documentation.\n                        1.,     # Algorithm parameter required when using deflated continuation, see BifurcationKit documentation.\n                        [fill(0.,length(rn.states))]); # Guess(es) of the fixed point for the initial parameter set. Do not need to be exact.\n","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"With all this done, we can compute the bifurcations:","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"params_input = setindex!(copy(params),p_span[1],p_idx)                                # The input parameter values have to start at the first index of our parameter span.\nbranches, = continuation(F, J, params_input, (@lens _[p_idx]) ,opts , DO,             # Gives our input.\n    verbosity = 0, showplot=false,                                                    # We do not want to display, or plot, intermediary results.\n    printSolution=(x, p) -> x[plot_var_idx],                                          # How we wish to print the output in the diagram. Here we simply want the value of the target varriable.\n    perturbSolution = (x,p,id) -> (x  .+ 0.8 .* rand(length(x))),                     # Parameter for the continuation method, see BifurcationKit documentation.\n    callbackN = (x, f, J, res, iteration, itlinear, options; kwargs...) -> res <1e7)  # Parameter for the continuation method, see BifurcationKit documentation.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"which can then be plotted using","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"plot(branches...,xlabel=rn.ps[1],ylabel=Symbol(rn.states[1].f),markersize=4,\n     ylim=(0.,Inf),                                  # This ensures we do not display negative solutions.\n     color=:blue,                                    # Otherwise each individual branch will have their separate colors.\n     plotbifpoints = false, putbifptlegend = false,  # Plots the bifurcation point(s).\n     linewidthstable=4, linewidthunstable=1)         # Stable/unstable values are distinguised by line thickness.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"(Image: bifurcation_diagram1)","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Here the Hopf bifurcation is amrked with a blue square. The region with a thiner linewidth corresponds to unstable steady states. If one wishes to mark these differently it is possible to plot the individual brances separatly:","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"plot(branches[1],lw=4,color=map(i->(i==0) ? :blue : :red, getproperty.(branches[1].branch,:n_unstable)))\nplot!(branches[3],lw=4,color=map(i->(i==0) ? :blue : :red, getproperty.(branches[3].branch,:n_unstable)))\nplot!(branches[4],lw=4,color=map(i->(i==0) ? :blue : :red, getproperty.(branches[4].branch,:n_unstable)),plotbifpoints = false,xlabel=rn.ps[1],ylabel=Symbol(rn.states[1].f))","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"(Image: bifurcation_diagram2)","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"(Note that the second branch corresponds to a negative steady state, which is biological irrelevant, and we hence do not plot)","category":"page"},{"location":"tutorials/generating_reactions_programmatically/#Generating-ReactionSystems-Programmatically","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"","category":"section"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"This tutorial shows how to programmatically construct a ReactionSystem corresponding to the chemistry underlying the Smoluchowski coagulation model using ModelingToolkit/Catalyst. A jump process version of the model is then constructed from the ReactionSystem, and compared to the model's analytical solution obtained by the method of Scott (see also 3).","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"The Smoluchowski coagulation equation describes a system of reactions in which monomers may collide to form dimers, monomers and dimers may collide to form trimers, and so on. This models a variety of chemical/physical processes, including polymerization and flocculation.","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"We begin by importing some necessary packages.","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"using ModelingToolkit, Catalyst, LinearAlgebra\nusing DiffEqBase, DiffEqJump\nusing Plots, SpecialFunctions","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"Suppose the maximum cluster size is N. We assume an initial concentration of monomers, Nₒ, and let uₒ denote the initial number of monomers in the system. We have nr total reactions, and label by V the bulk volume of the system (which plays an important role in the calculation of rate laws since we have bimolecular reactions). Our basic parameters are then  ","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"## Parameter\nN = 10                       # maximum cluster size\nVₒ = (4π/3)*(10e-06*100)^3   # volume of a monomers in cm³\nNₒ = 1e-06/Vₒ                # initial conc. = (No. of init. monomers) / bulk volume\nuₒ = 10000                   # No. of monomers initially\nV = uₒ/Nₒ                    # Bulk volume of system in cm³\n\ninteg(x) = Int(floor(x))\nn        = integ(N/2)\nnr       = N%2 == 0 ? (n*(n + 1) - n) : (n*(n + 1)) # No. of forward reactions","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"The Smoluchowski coagulation equation Wikipedia page illustrates the set of possible reactions that can occur. We can easily enumerate the pairs of multimer reactants that can combine when allowing a maximal cluster size of N monomers. We initialize the volumes of the reactant multimers as volᵢ and volⱼ","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"# possible pairs of reactant multimers\npair = []\nfor i = 2:N\n    push!(pair,[1:integ(i/2)  i .- (1:integ(i/2))])\nend\npair = vcat(pair...)\nvᵢ = @view pair[:,1]   # Reactant 1 indices\nvⱼ = @view pair[:,2]   # Reactant 2 indices\nvolᵢ = Vₒ*vᵢ           # cm⁻³\nvolⱼ = Vₒ*vⱼ           # cm⁻³\nsum_vᵢvⱼ = @. vᵢ + vⱼ  # Product index","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"We next specify the rates (i.e. kernel) at which reactants collide to form products. For simplicity, we allow a user-selected additive kernel or constant kernel. The constants(B and C) are adopted from Scott's paper 2","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"# set i to  1 for additive kernel, 2  for constant\ni = 1\nif i==1\n    B = 1.53e03                # s⁻¹\n    kv = @. B*(volᵢ + volⱼ)/V  # dividing by volume as its a bi-molecular reaction chain\nelseif i==2\n    C = 1.84e-04               # cm³ s⁻¹\n    kv = fill(C/V, nr) \nend","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"We'll store the reaction rates in pars as Pairs, and set the initial condition that only monomers are present at t=0 in u₀map.","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"# state variables are X, pars stores rate parameters for each rx\n@parameters t       \n@variables k[1:nr]  X[collect(1:N)](t)\npars = Pair.(k, kv)\n\n# time-span\nif i == 1\n    tspan = (0. ,2000.)   \nelseif i == 2\n    tspan = (0. ,350.)\nend\n\n # initial condition of monomers\nu₀    = zeros(Int64, N)\nu₀[1] = uₒ  \nu₀map = Pair.(X, u₀)   # map variable to its initial value","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"Here we generate the reactions programmatically. We systematically create Catalyst Reactions for each possible reaction shown in the figure on Wikipedia. When vᵢ[n] == vⱼ[n], we set the stoichiometric coefficient of the reactant multimer to two.","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"# vector to store the Reactions in\nrx = []              \nfor n = 1:nr\n    # for clusters of the same size, double the rate\n    if (vᵢ[n] == vⱼ[n]) \n        push!(rx, Reaction(k[n], [X[vᵢ[n]]], [X[sum_vᵢvⱼ[n]]], [2], [1]))\n    else\n        push!(rx, Reaction(k[n], [X[vᵢ[n]], X[vⱼ[n]]], [X[sum_vᵢvⱼ[n]]], \n                           [1, 1], [1]))\n    end\nend\nrs = ReactionSystem(rx, t, X, k)","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"We now convert the ReactionSystem into a JumpSystem, and solve it using Gillespie's direct method. For details on other possible solvers (SSAs), see the DifferentialEquations.jl documentation ","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"# solving the system\njumpsys = convert(JumpSystem, rs)\ndprob   = DiscreteProblem(jumpsys, u₀map, tspan, pars)\njprob   = JumpProblem(jumpsys, dprob, Direct(), save_positions=(false,false))\njsol    = solve(jprob, SSAStepper(), saveat = tspan[2]/30)","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"Lets check the results for the first three polymers/cluster sizes. We compare to the analytical solution for this system:","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"# Results for first three polymers...i.e. monomers, dimers and trimers\nv_res = [1;2;3]\n\n# comparison with analytical solution\n# we only plot the stochastic solution at a small number of points\n# to ease distinguishing it from the exact solution\nt   = jsol.t\nsol = zeros(length(v_res), length(t))\nif i == 1\n    ϕ = @. 1 - exp(-B*Nₒ*Vₒ*t)    \n    for j in v_res\n        sol[j,:] = @. Nₒ*(1 - ϕ)*(((j*ϕ)^(j-1))/gamma(j+1))*exp(-j*ϕ)\n    end\nelseif i == 2\n    ϕ = @. (C*Nₒ*t)\n    for j in v_res\n        sol[j,:] = @. 4Nₒ*((ϕ^(j-1))/((ϕ + 2)^(j+1)))\n    end\nend\n\n# plotting normalised concentration vs analytical solution\ndefault(lw=2, xlabel=\"Time (sec)\")\nscatter(ϕ, jsol(t)[1,:]/uₒ, label=\"X1 (monomers)\", markercolor=:blue)\nplot!(ϕ, sol[1,:]/Nₒ, line = (:dot,4,:blue), label=\"Analytical sol--X1\")\n\nscatter!(ϕ, jsol(t)[2,:]/uₒ, label=\"X2 (dimers)\", markercolor=:orange)\nplot!(ϕ, sol[2,:]/Nₒ, line = (:dot,4,:orange), label=\"Analytical sol--X2\")\n\nscatter!(ϕ, jsol(t)[3,:]/uₒ, label=\"X3 (trimers)\", markercolor=:purple)\nplot!(ϕ, sol[3,:]/Nₒ, line = (:dot,4,:purple), label=\"Analytical sol--X3\", \n      ylabel = \"Normalized Concentration\")","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"For the additive kernel we find","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"(Image: additive_kernel)","category":"page"},{"location":"tutorials/generating_reactions_programmatically/#Sources","page":"Generating ReactionSystems Programmatically","title":"Sources","text":"","category":"section"},{"location":"tutorials/generating_reactions_programmatically/","page":"Generating ReactionSystems Programmatically","title":"Generating ReactionSystems Programmatically","text":"https://en.wikipedia.org/wiki/Smoluchowskicoagulationequation\nScott, W. T. (1968). Analytic Studies of Cloud Droplet Coalescence I, Journal of Atmospheric Sciences, 25(1), 54-65. Retrieved Feb 18, 2021, from https://journals.ametsoc.org/view/journals/atsc/25/1/1520-046919680250054asocdc20co2.xml\nIan J. Laurenzi, John D. Bartels, Scott L. Diamond, A General Algorithm for Exact Simulation of Multicomponent Aggregation Processes, Journal of Computational Physics, Volume 177, Issue 2, 2002, Pages 418-449, ISSN 0021-9991, https://doi.org/10.1006/jcph.2002.7017.","category":"page"},{"location":"tutorials/parameter_estimation/#Parameter-Estimation","page":"Parameter Estimation","title":"Parameter Estimation","text":"","category":"section"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"The parameters of a model, generated by Catalyst, can be estimated using various packages available in the Julia ecosystem. Refer here for more extensive information. Below follows a quick tutorial of how DiffEqFlux can be used to fit a parameter set to data.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"First, we fetch the required packages.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"using OrdinaryDiffEq\nusing DiffEqFlux, Flux\nusing Catalyst","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Next, we declare our model. For our example, we will use the Brusselator, a simple oscillator.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"brusselator = @reaction_network begin\n    A, ∅ → X\n    1, 2X + Y → 3X\n    B, X → Y\n    1, X → ∅\nend A B\np_real = [1., 2.]","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"We simulate our model, and from the simulation generate sampled data points (with added noise), to which we will attempt to fit a parameter et.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"u0 = [1.0, 1.0]\ntspan = (0.0, 30.0)\n\nsample_times = range(tspan[1],stop=tspan[2],length=100)\nprob = ODEProblem(brusselator, u0, tspan, p_real)\nsol_real = solve(prob, Rosenbrock23(), tstops=sample_times)\n\nsample_vals = [sol_real.u[findfirst(sol_real.t .>= ts)][var] * (1+(0.1rand()-0.05)) for var in 1:2, ts in sample_times];","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"We can plot the real solution, as well as the noisy samples.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"using Plots\nplot(sol_real,size=(1200,400),label=\"\",framestyle=:box,lw=3,color=[:darkblue :darkred])\nplot!(sample_times,sample_vals',seriestype=:scatter,color=[:blue :red],label=\"\")","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"(Image: parameter_estimation_plot1)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Next, we create an optimisation function. For a given initial estimate of the parameter values, p, this function will fit parameter values to our data samples. However, it will only do so on the interval [0,tend].","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"function optimise_p(p_init,tend)\n    function loss(p)\n        sol = solve(remake(prob,tspan=(0.,tend),p=p), Rosenbrock23(), tstops=sample_times)\n        vals = hcat(map(ts -> sol.u[findfirst(sol.t .>= ts)], sample_times[1:findlast(sample_times .<= tend)])...)    \n        loss = sum(abs2, vals .- sample_vals[:,1:size(vals)[2]])   \n        return loss, sol\n    end\n    return DiffEqFlux.sciml_train(loss,p_init,ADAM(0.1),maxiters = 100)\nend","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Next, we will fit a parameter set to the data on the interval [0,10].","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"p_estimate = optimise_p([5.,5.],10.).minimizer","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"We can compare this to the real solution, as well as the sample data","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"sol_estimate = solve(remake(prob,tspan=(0.,10.),p=p_estimate), Rosenbrock23())\nplot(sol_real,size=(1200,400),color=[:blue :red],framestyle=:box,lw=3,label=[\"X real\" \"Y real\"],linealpha=0.2)\nplot!(sample_times,sample_vals',seriestype=:scatter,color=[:blue :red],label=[\"Samples of X\" \"Samples of Y\"],alpha=0.4)\nplot!(sol_estimate,color=[:darkblue :darkred], linestyle=:dash,lw=3,label=[\"X estimated\" \"Y estimated\"],xlimit=tspan)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"(Image: parameter_estimation_plot2)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Next, we use this parameter estimation as the input to the next iteration of our fitting process, this time on the interval [0,20].","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"p_estimate = optimise_p(p_estimate,20.).minimizer\n\nsol_estimate = solve(remake(prob,tspan=(0.,20.),p=p_estimate), Rosenbrock23())\nplot(sol_real,size=(1200,400),color=[:blue :red],framestyle=:box,lw=3,label=[\"X real\" \"Y real\"],linealpha=0.2)\nplot!(sample_times,sample_vals',seriestype=:scatter,color=[:blue :red],label=[\"Samples of X\" \"Samples of Y\"],alpha=0.4)\nplot!(sol_estimate,color=[:darkblue :darkred], linestyle=:dash,lw=3,label=[\"X estimated\" \"Y estimated\"],xlimit=tspan)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"(Image: parameter_estimation_plot3)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Finally, we use this estimate as the input to fit a parameter set on the full interval of sampled data.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"p_estimate = optimise_p(p_estimate,30.).minimizer\n\nsol_estimate = solve(remake(prob,tspan=(0.,30.),p=p_estimate), Rosenbrock23())\nplot(sol_real,size=(1200,400),color=[:blue :red],framestyle=:box,lw=3,label=[\"X real\" \"Y real\"],linealpha=0.2)\nplot!(sample_times,sample_vals',seriestype=:scatter,color=[:blue :red],label=[\"Samples of X\" \"Samples of Y\"],alpha=0.4)\nplot!(sol_estimate,color=[:darkblue :darkred], linestyle=:dash,lw=3,label=[\"X estimated\" \"Y estimated\"],xlimit=tspan)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"(Image: parameter_estimation_plot4)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"The final parameter set becomes [0.9996559014056948, 2.005632696191224] (the real one was [1.0, 2.0]).","category":"page"},{"location":"tutorials/parameter_estimation/#Why-we-fit-the-parameters-in-iterations.","page":"Parameter Estimation","title":"Why we fit the parameters in iterations.","text":"","category":"section"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"The reason we chose to fit the model on a smaller interval to begin with, and then extend the interval, is to avoid getting stuck in a local minimum. Here specifically, we chose our initial interval to be smaller than a full cycle of the oscillation. If we had chosen to fit a parameter set on the full interval immediately we would have received an inferior solution.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"p_estimate = optimise_p([5.,5.],30.).minimizer\n\nsol_estimate = solve(remake(prob,tspan=(0.,30.),p=p_estimate), Rosenbrock23())\nplot(sol_real,size=(1200,400),color=[:blue :red],framestyle=:box,lw=3,label=[\"X real\" \"Y real\"],linealpha=0.2)\nplot!(sample_times,sample_vals',seriestype=:scatter,color=[:blue :red],label=[\"Samples of X\" \"Samples of Y\"],alpha=0.4)\nplot!(sol_estimate,color=[:darkblue :darkred], linestyle=:dash,lw=3,label=[\"X estimated\" \"Y estimated\"],xlimit=tspan)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"(Image: parameter_estimation_plot5)","category":"page"},{"location":"tutorials/generated_systems/#The-generated-[ReactionSystem](@ref)-and-[Reaction](@ref)s","page":"The generated ReactionSystem and Reactions","title":"The generated ReactionSystem and Reactions","text":"","category":"section"},{"location":"tutorials/generated_systems/","page":"The generated ReactionSystem and Reactions","title":"The generated ReactionSystem and Reactions","text":"The @reaction_network macro generates a ReactionSystem object, which has a number of fields that can be accessed directly or via the Catalyst.jl API (the recommended route). Below we list these components, with the recommended API method listed first:","category":"page"},{"location":"tutorials/generated_systems/","page":"The generated ReactionSystem and Reactions","title":"The generated ReactionSystem and Reactions","text":"species(rn) and states(rn) is a vector of all the chemical species within the system, each represented as a ModelingToolkit.Term.\nparams(rn) and parameters(rn) is a vector of all the parameters within the system, each represented as a ModelingToolkit.Sym.\nreactions(rn) and equations(rn) is a vector of all the Reactions within the system.\nindependent_variable(rn) and ModelingToolkit.get_iv(rn) are the independent variable of the system, usually t for time, represented as a ModelingToolkit.Sym.","category":"page"},{"location":"tutorials/generated_systems/","page":"The generated ReactionSystem and Reactions","title":"The generated ReactionSystem and Reactions","text":"Each Reaction within reactions(rn) has a number of subfields. For rx a Reaction we have:","category":"page"},{"location":"tutorials/generated_systems/","page":"The generated ReactionSystem and Reactions","title":"The generated ReactionSystem and Reactions","text":"rx.substrates, a vector of ModelingToolkit expressions storing each substrate variable.\nrx.products, a vector of ModelingToolkit expressions storing each product variable.\nrx.substoich, a vector storing the corresponding integer stoichiometry of each substrate species in rx.substrates.\nrx.prodstoich, a vector storing the corresponding integer stoichiometry of each product species in rx.products.\nrx.rate, a Number,ModelingToolkit.Symor ModelingToolkit expression representing the reaction rate. E.g., for a reaction likekX, Y –> X+Y, we'd haverate = kX`.\nrx.netstoich, a vector of pairs mapping the ModelingToolkit expression for each species that changes numbers by the reaction to how much it changes. E.g., for k, X + 2Y --> X + W, we'd have rx.netstoich = [Y(t) => -2, W(t) => 1].\nrx.only_use_rate, a boolean that is true if the reaction was made with non-filled arrows and should ignore mass action kinetics. false by default.","category":"page"},{"location":"tutorials/generated_systems/","page":"The generated ReactionSystem and Reactions","title":"The generated ReactionSystem and Reactions","text":"Empty ReactionSystems can be generated via make_empty_network or @reaction_network with no arguments (giving one argument to the latter will specify a system name). ReactionSystems can be programmatically extended using addspecies!, addparam!, addreaction!, @add_reactions, or composed using merge and merge!.","category":"page"},{"location":"#Catalyst.jl-for-Reaction-Models","page":"Home","title":"Catalyst.jl for Reaction Models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst.jl is a domain specific language (DSL) for high performance simulation and modeling of chemical reaction networks. Catalyst utilizes ModelingToolkit ReactionSystems, leveraging ModelingToolkit to enable large-scale simulations through auto-vectorization and parallelism. ReactionSystemss can be used to generate ModelingToolkit-based models, allowing the easy simulation and parameter estimation of mass action ODE models, Chemical Langevin SDE models, stochastic chemical kinetics jump process models, and more. Generated models can be used with solvers throughout the broader SciML ecosystem, including higher level SciML packages (e.g. for sensitivity analysis, parameter estimation, machine learning applications, etc).","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DSL provides a simple and readable format for manually specifying chemical reactions.\nThe Catalyst.jl API provides functionality for extending networks, building networks programmatically, and for composing multiple networks together.\nReactionSystems generated by the DSL can be converted to a variety of ModelingToolkit.AbstractSystems, including ODE, SDE and jump process representations.\nBy leveraging ModelingToolkit, users have a variety of options for generating optimized system representations to use in solvers. These include construction of dense or sparse Jacobians, multithreading or parallelization of generated derivative functions, automatic classification of reactions into optimized jump types for Gillespie type simulations, automatic construction of dependency graphs for jump systems, and more.\nGenerated systems can be solved using any DifferentialEquations.jl ODE/SDE/jump solver, and can be used within EnsembleProblems for carrying out GPU-parallelized parameter sweeps and statistical sampling. Plot recipes are available for visualizing the solutions.\nJulia Exprs can be obtained for all rate laws and functions determining the deterministic and stochastic terms within resulting ODE, SDE or jump models.\nLatexify can be used to generate LaTeX expressions corresponding to generated mathematical models or the underlying set of reactions.\nGraphviz can be used to generate and visualize reaction network graphs. (Reusing the Graphviz interface created in Catlab.jl.)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst can be installed through the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add Catalyst\nusing Catalyst","category":"page"},{"location":"#Illustrative-Example","page":"Home","title":"Illustrative Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a simple example of generating, visualizing and solving an SIR ODE model. We first define the SIR reaction model using Catalyst","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Catalyst\nrn = @reaction_network begin\n    α, S + I --> 2I\n    β, I --> R\nend α β","category":"page"},{"location":"","page":"Home","title":"Home","text":"Assuming Graphviz and is installed and command line accessible, the network can be visualized using the Graph command","category":"page"},{"location":"","page":"Home","title":"Home","text":"Graph(rn)","category":"page"},{"location":"","page":"Home","title":"Home","text":"which in Jupyter notebooks will give the figure","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: SIR Network Graph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To generate and solve a mass action ODE version of the model we use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DiffEqBase, OrdinaryDiffEq\np     = [.1/1000, .01]           # [α,β]\ntspan = (0.0,250.0)\nu0    = [999.0,1.0,0.0]          # [S,I,R] at t=0\nop    = ODEProblem(rn, u0, tspan, p)\nsol   = solve(op, Tsit5())       # use Tsit5 ODE solver","category":"page"},{"location":"","page":"Home","title":"Home","text":"which we can plot as","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nplot(sol, lw=2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: SIR Solution)","category":"page"},{"location":"tutorials/models/#Model-Simulation","page":"Model Simulation","title":"Model Simulation","text":"","category":"section"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"Once created, a reaction network can be used as input to various problem types, which can be solved by DifferentialEquations.jl, and more broadly used within SciML packages.","category":"page"},{"location":"tutorials/models/#Deterministic-simulations-using-ODEs","page":"Model Simulation","title":"Deterministic simulations using ODEs","text":"","category":"section"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"A reaction network can be used as input to an ODEProblem instead of a function, using","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"odeprob = ODEProblem(rn, args...; kwargs...)","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"E.g., a model can be created and solved using:","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"using DiffEqBase, OrdinaryDiffEq\nrn = @reaction_network begin\n  p, ∅ → X\n  d, X → ∅\nend p d\np = [1.0,2.0]\nu0 = [0.1]\ntspan = (0.,1.)\nprob = ODEProblem(rn,u0,tspan,p)\nsol = solve(prob, Tsit5())","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"Here, the order of unknowns in u0 and p matches the order that species and parameters first appear within the DSL. They can also be determined by examining the ordering within the species(rn) and params(rn) vectors, or accessed more explicitly through the speciesmap(rn) and paramsmap(rn) dictionaries, which map the ModelingToolkit Terms and/or Syms corresponding to each species or parameter to their integer id. Note, if no parameters are given in the @reaction_network, then p does not need to be provided.","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"We can then plot the solution using the solution plotting recipe:","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"using Plots\nplot(sol, lw=2)","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"(Image: models1)","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"To solve for a steady-state starting from the guess u0, one can use","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"using SteadyStateDiffEq\nprob = SteadyStateProblem(rn,u0,p)\nsol = solve(prob, SSRootfind())","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"or","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"prob = SteadyStateProblem(rn,u0,p)\nsol = solve(prob, DynamicSS(Tsit5()))","category":"page"},{"location":"tutorials/models/#Stochastic-simulations-using-SDEs","page":"Model Simulation","title":"Stochastic simulations using SDEs","text":"","category":"section"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"In a similar way an SDE can be created using","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"using StochasticDiffEq\nsdeprob = SDEProblem(rn, args...; kwargs...)","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"In this case the chemical Langevin equations (as derived in Gillespie, J. Chem. Phys. 2000) will be used to generate stochastic differential equations.","category":"page"},{"location":"tutorials/models/#Stochastic-simulations-using-discrete-stochastic-simulation-algorithms","page":"Model Simulation","title":"Stochastic simulations using discrete stochastic simulation algorithms","text":"","category":"section"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"Instead of solving SDEs, one can create a stochastic jump process model using integer copy numbers and a discrete stochastic simulation algorithm (i.e., Gillespie Method or Kinetic Monte Carlo). This can be done using:","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"using DiffEqJump\nrn = @reaction_network begin\n  p, ∅ → X\n  d, X → ∅\nend p d\np = [1.0,2.0]\nu0 = [10]\ntspan = (0.,1.)\ndiscrete_prob = DiscreteProblem(rn, u0, tspan, p)\njump_prob = JumpProblem(rn, discrete_prob, Direct())\nsol = solve(jump_prob, SSAStepper())","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"Here, we used Gillespie's Direct method as the underlying stochastic simulation algorithm. We get:","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"plot(sol, lw=2)","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"(Image: models2)","category":"page"},{"location":"tutorials/models/#Reaction-rate-laws-used-in-simulations","page":"Model Simulation","title":"Reaction rate laws used in simulations","text":"","category":"section"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"In generating mathematical models from a ReactionSystem, reaction rates are treated as microscopic rates. That is, for a general mass action reaction of the form n_1 S_1 + n_2 S_2 + dots n_M S_M to dots with stoichiometric substrate coefficients n_i_i=1^M and rate constant k, the corresponding ODE rate law is taken to be","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"k prod_i=1^M frac(S_i)^n_in_i","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"while the jump process transition rate (i.e., the propensity function) is","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"k prod_i=1^M fracS_i (S_i-1) dots (S_i-n_i+1)n_i","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"For example, the ODE model of the reaction 2X + 3Y to Z with rate constant k would be","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"fracdXdt =  -2 k fracX^22 fracY^33 = -k fracX^2 Y^33 \nfracdYdt =  -3 k fracX^22 fracY^33 = -k fracX^2 Y^34 \nfracdZdt = k fracX^22 fracY^33","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"This implicit rescaling of rate constants can be disabled through explicit conversion of a ReactionSystem to another system via Base.convert, and using the combinatoric_ratelaws=false kwarg.","category":"page"}]
}
