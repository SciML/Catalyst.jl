<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interfacing problems, integrators, and solutions · Catalyst.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/catalyst_applications/simulation_structure_interfacing/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Functionality</span><ul><li><a class="tocitem" href="../../catalyst_functionality/dsl_description/">The Reaction DSL</a></li><li><a class="tocitem" href="../../catalyst_functionality/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../catalyst_functionality/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../catalyst_functionality/network_analysis/">Network Analysis in Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Applications</span><ul><li class="is-active"><a class="tocitem" href>Interfacing problems, integrators, and solutions</a><ul class="internal"><li><a class="tocitem" href="#Interfacing-problem-objects"><span>Interfacing problem objects</span></a></li><li><a class="tocitem" href="#Interfacing-integrator-objects"><span>Interfacing integrator objects</span></a></li><li><a class="tocitem" href="#Interfacing-solution-objects"><span>Interfacing solution objects</span></a></li><li><a class="tocitem" href="#Interfacing-using-symbolic-representation"><span>Interfacing using symbolic representation</span></a></li></ul></li><li><a class="tocitem" href="../advanced_simulations/">Advanced Simulation Options</a></li><li><a class="tocitem" href="../homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../parameter_estimation/">Parameter Estimation</a></li></ul></li><li><span class="tocitem">Example Networks</span><ul><li><a class="tocitem" href="../../example_networks/basic_CRN_examples/">Basic Chemical Reaction Network Examples</a></li><li><a class="tocitem" href="../../example_networks/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../example_networks/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/catalyst_api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Catalyst Applications</a></li><li class="is-active"><a href>Interfacing problems, integrators, and solutions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interfacing problems, integrators, and solutions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/catalyst_applications/simulation_structure_interfacing.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="simulation_structure_interfacing"><a class="docs-heading-anchor" href="#simulation_structure_interfacing">Interfacing problems, integrators, and solutions</a><a id="simulation_structure_interfacing-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_structure_interfacing" title="Permalink"></a></h1><p>When simulating a model, one begins with creating a <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/problem/">problem</a>. Next, a simulation is performed on a problem, during which the state of the simulation is recorded through an <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/integrator/">integrator</a>. Finally, the simulation output is returned as a <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/solution/">solution</a>. This tutorial describes how to access, or modify the state, or parameter, values of problems, integrators, and solutions structures.</p><p>Generally, when we have a structure <code>simulation_struct</code> and want to interface with the state (or parameter) <code>G</code>, we use <code>simulation_struct[:G]</code> to access the value, and <code>simulation_struct[:G] = 5.0</code> to set it to a new value. However, see the following examples for full details.</p><h2 id="Interfacing-problem-objects"><a class="docs-heading-anchor" href="#Interfacing-problem-objects">Interfacing problem objects</a><a id="Interfacing-problem-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Interfacing-problem-objects" title="Permalink"></a></h2><p>We begin by demonstrating how we can interface with problem objects. We will demonstrate using a <code>ODEProblem</code>, however, it works similarily for other problem types.</p><pre><code class="language-julia hljs">using Catalyst
rn = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end

u0 = [:X1 =&gt; 1.0, :X2 =&gt; 5.0]
p = [:k1 =&gt; 5.0, :k2 =&gt; 2.0]
oprob = ODEProblem(rn, u0, (0.0,10.0), p)</code></pre><p>We can find the value of a state simply by interfacing with the corresponding symbol:</p><pre><code class="language-julia hljs">oprob[:X1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre><p>with the notation being identical for parameters:</p><pre><code class="language-julia hljs">oprob[:k1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.0</code></pre><p>If we want to change a state&#39;s initial condition value, we use the following notation</p><pre><code class="language-julia hljs">oprob[:X1] = 10.0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10.0</code></pre><p>with parameters using the same notation.</p><h4 id="Remaking-problems-using-the-remake-function"><a class="docs-heading-anchor" href="#Remaking-problems-using-the-remake-function">Remaking problems using the <code>remake</code> function</a><a id="Remaking-problems-using-the-remake-function-1"></a><a class="docs-heading-anchor-permalink" href="#Remaking-problems-using-the-remake-function" title="Permalink"></a></h4><p>Typically, when modifying problems, it is recommended to use the <code>remake</code> function. Unlike when we do <code>oprob[:X1] = 10.0</code> (which modifies the problem in question), <code>remake</code> creates a new problem object. The <code>remake</code> function takes a problem as input, and any fields you wish to modify (and their new values) as optional inputs. Thus, we can do:</p><pre><code class="language-julia hljs">using DifferentialEquations
@unpack X1, X2, k1, k2 = rn
oprob1 = ODEProblem(rn, u0, (0.0,10.0), p)
oprob2 = remake(oprob1; u0=[X1 =&gt; 10.0, X2 =&gt; 50.0], tspan=(0.0,100.0), p=[k1 =&gt; 50.0,k2 =&gt; 20.0])</code></pre><p>and we can now check the fields of <code>oprob2</code></p><pre><code class="language-julia hljs">oprob2.u0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 10.0
 50.0</code></pre><pre><code class="language-julia hljs">oprob2.tspan</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.0, 100.0)</code></pre><pre><code class="language-julia hljs">oprob2.p</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 50.0
 20.0</code></pre><p>Please note that, currently, <code>remake</code> does not work while giving <code>Symbol</code>s as input (e.g <code>[:X1 =&gt; 10.0, :X2 =&gt; 50.0]</code>), but we need to unpack the symbolic variables and use them instead (please see the end of this tutorial for more information on using symbolic variables rather than <code>Symbol</code>s).</p><p>When using <code>remake</code>, we only have to provide the fields that we actually wish to change, e.g.</p><pre><code class="language-julia hljs">oprob3 = remake(oprob1; u0=[X1 =&gt; 10.0, X2 =&gt; 50.0])</code></pre><p>will only update the initial conditions.</p><h2 id="Interfacing-integrator-objects"><a class="docs-heading-anchor" href="#Interfacing-integrator-objects">Interfacing integrator objects</a><a id="Interfacing-integrator-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Interfacing-integrator-objects" title="Permalink"></a></h2><p>During a simulation, the solution is stored in an integrator object, we will here describe how to interface with these. The primary circumstance under which a user may wish to do so is when using <a href="../advanced_simulations/#advanced_simulations_callbacks">callbacks</a>. We can create an integrator by calling <code>init</code> on our problem (<a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/integrator/#Initialization-and-Stepping">while circumstances where the user might want to use <code>init</code> function exist</a>, since integrators are automatically created during simulations, these are rare):</p><pre><code class="language-julia hljs">integrator = init(oprob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">t: 0.0
u: 2-element Vector{Float64}:
 10.0
  5.0</code></pre><p>Using a similar syntax to problems, we can get the current values of a state within the integrator:</p><pre><code class="language-julia hljs">integrator[:X1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10.0</code></pre><p>or a parameter:</p><pre><code class="language-julia hljs">integrator[:k1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.0</code></pre><p>Similarly, we can update their values using:</p><pre><code class="language-julia hljs">integrator[:X1] = 10.0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10.0</code></pre><p>Please read <a href="../advanced_simulations/#advanced_simulations_ssa_callbacks">this</a> with regards to updating integrators of <code>JumpProblem</code>s.</p><h2 id="Interfacing-solution-objects"><a class="docs-heading-anchor" href="#Interfacing-solution-objects">Interfacing solution objects</a><a id="Interfacing-solution-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Interfacing-solution-objects" title="Permalink"></a></h2><p>Finally, we consider solution objects. First, we simulate our problem:</p><pre><code class="language-julia hljs">sol = solve(oprob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: specialized 4th order &quot;free&quot; interpolation, specialized 2nd order &quot;free&quot; stiffness-aware interpolation
t: 27-element Vector{Float64}:
  0.0
  0.046858677346737466
  0.09783646548754715
  0.16547092835900873
  0.24254365807091088
  0.3348716497658275
  0.4405748511890152
  0.5640273219829025
  0.7072164633233734
  0.87613736364876
  ⋮
  4.9677657304135705
  5.449887343780637
  5.920501111510287
  6.3971702766925445
  6.8865034320581024
  7.3872547769185335
  8.40112239237716
  9.750060520521211
 10.0
u: 27-element Vector{Vector{Float64}}:
 [10.0, 5.0]
 [8.402030936149353, 6.5979690638506465]
 [7.166648315161162, 7.833351684838838]
 [6.0801232564193555, 8.919876743580645]
 [5.331922776195863, 9.668077223804136]
 [4.833922145380109, 10.166077854619889]
 [4.547308155942354, 10.452691844057645]
 [4.395972107382735, 10.604027892617264]
 [4.3262062907960175, 10.67379370920398]
 [4.298153590967085, 10.701846409032914]
 ⋮
 [4.289356508407056, 10.710643491592945]
 [4.288578917228969, 10.711421082771032]
 [4.287656576211248, 10.712343423788754]
 [4.287138369276938, 10.712861630723063]
 [4.28694271492913, 10.713057285070871]
 [4.286939205763843, 10.713060794236158]
 [4.28546360969763, 10.71453639030237]
 [4.285765750200234, 10.714234249799768]
 [4.285720479566514, 10.714279520433488]</code></pre><p>For solutions, when we access a state, we get its whole simulation vector:</p><pre><code class="language-julia hljs">sol[:X1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">27-element Vector{Float64}:
 10.0
  8.402030936149353
  7.166648315161162
  6.0801232564193555
  5.331922776195863
  4.833922145380109
  4.547308155942354
  4.395972107382735
  4.3262062907960175
  4.298153590967085
  ⋮
  4.289356508407056
  4.288578917228969
  4.287656576211248
  4.287138369276938
  4.28694271492913
  4.286939205763843
  4.28546360969763
  4.285765750200234
  4.285720479566514</code></pre><p>while when we access a parameter we only get a single value:</p><pre><code class="language-julia hljs">sol[:k1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.0</code></pre><p>Finally, we note that we cannot change the values of solution states or parameters (i.e. both <code>sol[:X1] = 0.0</code> and <code>sol[:k1] = 0.0</code> generate errors).</p><h2 id="Interfacing-using-symbolic-representation"><a class="docs-heading-anchor" href="#Interfacing-using-symbolic-representation">Interfacing using symbolic representation</a><a id="Interfacing-using-symbolic-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Interfacing-using-symbolic-representation" title="Permalink"></a></h2><p>Catalyst is built on an <em>intermediary representation</em> implemented by (ModelingToolkit.jl)[https://github.com/SciML/ModelingToolkit.jl]. ModelingToolkit is a modelling framework where one first declares a set of symbolic variables and parameters using e.g.</p><pre><code class="language-julia hljs">using ModelingToolkit
@parameters σ ρ β
@variables t x(t) y(t) z(t)</code></pre><p>and then uses these to build systems of equations. Here, these symbolic variables (<code>x</code>, <code>y</code>, and <code>z</code>) and parameters (<code>σ</code>, <code>ρ</code>, and <code>β</code>) can be used to interface a <code>problem</code>, <code>integrator</code>, and <code>solution</code> object (like we did previously, but using Symbols, e.g. <code>:X</code>). Since Catalyst models are built on ModelingToolkit, these models also contain similar symbolic variables and parameters.</p><pre><code class="language-julia hljs">using Catalyst
rn = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end

@unpack k1,k2,X1,X2 = rn</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X1} &amp;\xrightleftharpoons[k2]{k1} \mathrm{X2}  
 \end{align*}
 \]</p><p>Here, we first list the parameters and variables (for reaction systems the latter are typically species) we wish to import (in this case we select all, but we could select only a subset), next we denote from which model (here <code>rn</code>) from which we wish to import from. Next, these values can be used directly to interface with e.g. an <code>ODEProblem</code>:</p><pre><code class="language-julia hljs">u0 = [X1 =&gt; 1.0, X2 =&gt; 5.0]
p = [:k1 =&gt; 5.0, :k2 =&gt; 2.0]
oprob = ODEProblem(rn, u0, (0.0,10.0), p)

oprob[k1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.0</code></pre><p>To interface with integrators and solutions we use a similar syntax.</p><p>Finally, instead of using <code>@unpack</code> to access a symbolic variable or parameter, we can access it directly using <code>rn.X1</code>, and thus access a state of our <code>ODEProblem</code> using</p><pre><code class="language-julia hljs">oprob[rn.X1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../catalyst_functionality/network_analysis/">« Network Analysis in Catalyst</a><a class="docs-footer-nextpage" href="../advanced_simulations/">Advanced Simulation Options »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 5 October 2023 18:07">Thursday 5 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
