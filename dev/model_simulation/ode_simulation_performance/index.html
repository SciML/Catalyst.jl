<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advice for performant ODE simulations · Catalyst.jl</title><meta name="title" content="Advice for performant ODE simulations · Catalyst.jl"/><meta property="og:title" content="Advice for performant ODE simulations · Catalyst.jl"/><meta property="twitter:title" content="Advice for performant ODE simulations · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/model_simulation/ode_simulation_performance/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/model_simulation/ode_simulation_performance/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/model_simulation/ode_simulation_performance/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Introduction to Catalyst</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Model creation and properties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../model_creation/conservation_laws/">Working with conservation laws</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/reactionsystem_content_accessing/">Accessing model properties</a></li><li><a class="tocitem" href="../../model_creation/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Model simulation and visualization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li class="is-active"><a class="tocitem" href>Advice for performant ODE simulations</a><ul class="internal"><li><a class="tocitem" href="#ode_simulation_performance_stiffness"><span>Regarding stiff and non-stiff problems and solvers</span></a></li><li><a class="tocitem" href="#ode_simulation_performance_solvers"><span>ODE solver selection</span></a></li><li><a class="tocitem" href="#ode_simulation_performance_jacobian"><span>Jacobian computation options for implicit solvers</span></a></li><li><a class="tocitem" href="#ode_simulation_performance_conservation_laws"><span>Elimination of system conservation laws</span></a></li><li><a class="tocitem" href="#ode_simulation_performance_parallelisation"><span>Parallelisation on CPUs and GPUs</span></a></li><li><a class="tocitem" href="#Citation"><span>Citation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../sde_simulation_performance/">Advice for performant SDE simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/periodic_events_simulation/">Modelling a periodic event during ODE and jump simulations</a></li><li><a class="tocitem" href="../examples/interactive_brusselator_simulation/">Interactive Simulation and Plotting</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Steady state analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Inverse problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../../inverse_problems/petab_ode_param_fitting/">Parameter Fitting for ODEs using PEtab.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Spatial modelling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial jump simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../devdocs/dev_guide/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model simulation and visualization</a></li><li class="is-active"><a href>Advice for performant ODE simulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advice for performant ODE simulations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/model_simulation/ode_simulation_performance.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ode_simulation_performance"><a class="docs-heading-anchor" href="#ode_simulation_performance">Advice for performant ODE simulations</a><a id="ode_simulation_performance-1"></a><a class="docs-heading-anchor-permalink" href="#ode_simulation_performance" title="Permalink"></a></h1><p>We have previously described how to perform ODE simulations of <em>chemical reaction network</em> (CRN) models. These simulations are typically fast and require little additional consideration. However, when a model is simulated many times (e.g. as a part of solving an inverse problem), or is very large, simulation run times may become noticeable. Here we will give some advice on how to improve performance for these cases <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><p>Generally, there are few good ways to, before a simulation, determine the best options. Hence, while we below provide several options, if you face an application for which reducing run time is critical (e.g. if you need to simulate the same ODE many times), it might be required to manually trial these various options to see which yields the best performance (<a href="https://github.com/JuliaCI/BenchmarkTools.jl">BenchmarkTools.jl&#39;s</a> <code>@btime</code> macro is useful for this purpose). It should be noted that the default options typically perform well, and it is primarily for large models where investigating alternative options is worthwhile. All ODE simulations of Catalyst models are performed using the OrdinaryDiffEq.jl package, <a href="https://docs.sciml.ai/DiffEqDocs/stable/">which documentation</a> provides additional advice on performance.</p><p>Generally, this short checklist provides a quick guide for dealing with ODE performance:</p><ol><li>If performance is not critical, use <a href="#ode_simulation_performance_solvers">the default solver choice</a> and do not worry further about the issue.</li><li>If improved performance would be useful, read about solver selection (both in <a href="#ode_simulation_performance_solvers">this tutorial</a> and <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">OrdinaryDiffEq&#39;s documentation</a>) and then try a few different solvers to find one with good performance.</li><li>If you have a large ODE (approximately 100 variables or more), try the <a href="#ode_simulation_performance_jacobian">various options for efficient Jacobian computation</a> (noting that some are non-trivial to use, and should only be investigated if truly required).</li><li>If you plan to simulate your ODE many times, try <a href="#ode_simulation_performance_parallelisation">parallelise it on CPUs or GPUs</a> (with preference for the former, which is easier to use).</li></ol><h2 id="ode_simulation_performance_stiffness"><a class="docs-heading-anchor" href="#ode_simulation_performance_stiffness">Regarding stiff and non-stiff problems and solvers</a><a id="ode_simulation_performance_stiffness-1"></a><a class="docs-heading-anchor-permalink" href="#ode_simulation_performance_stiffness" title="Permalink"></a></h2><p>Generally, ODE problems can be categorised into <a href="https://en.wikipedia.org/wiki/Stiff_equation"><em>stiff ODEs</em> and <em>non-stiff ODEs</em></a>. This categorisation is important due to stiff ODEs requiring specialised solvers. A common cause of failure to simulate an ODE is the use of a non-stiff solver for a stiff problem. There is no exact way to determine whether a given ODE is stiff or not, however, systems with several different time scales (e.g. a CRN with both slow and fast reactions) typically generate stiff ODEs.</p><p>Here we simulate the (stiff) <a href="../../model_creation/examples/basic_CRN_library/#basic_CRN_library_brusselator">Brusselator</a> model using the <code>Tsit5</code> solver (which is designed for non-stiff ODEs):</p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEqTsit5, Plots

brusselator = @reaction_network begin
    A, ∅ --&gt; X
    1, 2X + Y --&gt; 3X
    B, X --&gt; Y
    1, X --&gt; ∅
end

u0 = [:X =&gt; 1.0, :Y =&gt; 0.0]
tspan = (0.0, 20.0)
ps = [:A =&gt; 400.0, :B =&gt; 2000.0]
oprob = ODEProblem(brusselator, u0, tspan, ps)

sol1 = solve(oprob, Tsit5())
plot(sol1)</code></pre><img src="29152804.png" alt="Example block output"/><p>We get a warning, indicating that the simulation was terminated. Furthermore, the resulting plot ends at <span>$t ≈ 12$</span>, meaning that the simulation was not completed (as the simulation&#39;s endpoint is <span>$t = 20$</span>). Indeed, we can confirm this by checking the <em>return code</em> of the solution object:</p><pre><code class="language-julia hljs">sol1.retcode</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ReturnCode.MaxIters = 4</code></pre><p>Next, we instead try the <code>Rodas5P</code> solver (which is designed for stiff problems):</p><pre><code class="language-julia hljs">using OrdinaryDiffEqRosenbrock
sol2 = solve(oprob, Rodas5P())
plot(sol2)</code></pre><img src="674cd4b4.svg" alt="Example block output"/><p>This time the simulation was successfully completed, which can be confirmed by checking the return code:</p><pre><code class="language-julia hljs">sol2.retcode</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ReturnCode.Success = 1</code></pre><p>Generally, ODE solvers can be divided into <a href="https://en.wikipedia.org/wiki/Explicit_and_implicit_methods"><em>explicit</em> and <em>implicit</em> solvers</a>. Roughly, explicit solvers are better for non-stiff problems, with implicit solvers being required for stiff problems. While we could use implicit solvers for all problems (to guarantee successful simulations irrespective of stiffness), these are typically less performant (as compared to the explicit solvers) on equations that are non-stiff. An important property of implicit solvers is that they require the <em>computation of a <a href="https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant">Jacobian</a></em> as part of their routine. This means that the various options for efficient Jacobian computation <a href="#ode_simulation_performance_jacobian">described later in this tutorial</a> are only relevant to implicit solvers.</p><p>Finally, we should note that stiffness is not tied to the model equations only. If we change the parameter values of our previous Brusselator model to <code>[:A =&gt; 1.0, :B =&gt; 4.0]</code>, the non-stiff <code>Tsit5</code> solver can successfully simulate it.</p><h2 id="ode_simulation_performance_solvers"><a class="docs-heading-anchor" href="#ode_simulation_performance_solvers">ODE solver selection</a><a id="ode_simulation_performance_solvers-1"></a><a class="docs-heading-anchor-permalink" href="#ode_simulation_performance_solvers" title="Permalink"></a></h2><p>OrdinaryDiffEq implements an unusually large number of ODE solvers, with the performance of the simulation heavily depending on which one is chosen. These are provided as the second argument to the <code>solve</code> command, e.g. here we use the <code>Tsit5</code> solver to simulate a simple <a href="../../model_creation/examples/basic_CRN_library/#basic_CRN_library_bd">birth-death process</a>:</p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEqTsit5

bd_model = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
u0 = [:X =&gt; 0.1]
tspan = (0.0, 1.0)
ps = [:p =&gt; 1.0, :d =&gt; 0.2]

oprob = ODEProblem(bd_model, u0, tspan, ps)
solve(oprob, Tsit5())</code></pre><p>If no solver argument is provided to <code>solve</code>, and the <code>OrdinaryDiffEqDefault</code> sub-library or meta <code>OrdinaryDiffEq</code> library are loaded, then one is automatically selected:</p><pre><code class="language-julia hljs">using OrdinaryDiffEqDefault
solve(oprob)</code></pre><p>While the default choice is typically enough for most single simulations, if performance is important, it can be worthwhile exploring the available solvers to find one that is especially suited for the given problem. A complete list of possible ODE solvers, with advice on optimal selection, can be found <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">here</a>. This section will give some general advice.</p><p>The most important part of solver selection is to select one appropriate for <a href="#ode_simulation_performance_stiffness">the problem&#39;s stiffness</a>. Generally, the <code>Tsit5</code> solver is good for non-stiff problems, and <code>Rodas5P</code> for stiff problems. For large stiff problems (with many species), <code>FBDF</code> can be a good choice. We can illustrate the impact of these choices by simulating our birth-death process using the <code>Tsit5</code>, <code>Vern7</code> (an explicit solver yielding <a href="#ode_simulation_performance_error">low error in the solution</a>), <code>Rodas5P</code>, and <code>FBDF</code> solvers (benchmarking their respective performance using <a href="https://github.com/JuliaCI/BenchmarkTools.jl">BenchmarkTools.jl</a>):</p><pre><code class="language-julia hljs">using BenchmarkTools 
using OrdinaryDiffEqTsit5, OrdinaryDiffEqRosenbrock, OrdinaryDiffEqVerner, OrdinaryDiffEqBDF
@btime solve(oprob, Tsit5())
@btime solve(oprob, Vern7())
@btime solve(oprob, Rodas5P())
@btime solve(oprob, FBDF())</code></pre><p>If you perform the above benchmarks on your machine, and check the results, you will note that the fastest solver is several times faster than the slowest one (<code>FBDF</code>, which is a poor choice for this ODE).</p><h3 id="ode_simulation_performance_error"><a class="docs-heading-anchor" href="#ode_simulation_performance_error">Simulation error, tolerance, and solver selection</a><a id="ode_simulation_performance_error-1"></a><a class="docs-heading-anchor-permalink" href="#ode_simulation_performance_error" title="Permalink"></a></h3><p>Numerical ODE simulations <a href="https://en.wikipedia.org/wiki/Discrete_time_and_continuous_time">approximate an ODEs&#39; continuous solutions as discrete vectors</a>. This introduces errors in the computed solution. The magnitude of these errors can be controlled by setting solver <em>tolerances</em>. By reducing the tolerance, solution errors will be reduced, however, this will also increase simulation run times. The (absolute and relative) tolerance of a solver can be tuned through the <code>abstol</code> and <code>reltol</code> arguments. Here we see how run time increases with larger tolerances:</p><pre><code class="language-julia hljs">@btime solve(oprob, Tsit5(); abstol=1e-6, reltol=1e-6)
@btime solve(oprob, Tsit5(); abstol=1e-12, reltol=1e-12)</code></pre><p>It should be noted, however, that the result of the second simulation is a lot more accurate. Thus, ODE solver performance cannot be determined solely from run time, but is a composite of run time and error. Benchmarks comparing solver performance (by plotting the run time as a function of the error) for various CRN models can be found in the <a href="https://docs.sciml.ai/SciMLBenchmarksOutput/stable/Bio/BCR/">SciMLBenchmarks repository</a>.</p><p>Generally, whether solution error is a consideration depends on the application. If you want to compute the trajectory of an expensive space probe as it is sent from Earth, to slingshot Jupiter, and then reach Pluto a few years later, ensuring a minimal error will be essential. However, if you want to simulate a simple CRN to determine whether it oscillates for a given parameter set, a small error will not constitute a problem. An important aspect with regard to error is that it affects the selection of the optimal solver. E.g. if tolerance is low (generating larger errors) the <code>Rosenbrock23</code> method performs well for small, stiff, problems (again, more details can be found in <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">OrdinaryDiffEq&#39;s documentation</a>).</p><h2 id="ode_simulation_performance_jacobian"><a class="docs-heading-anchor" href="#ode_simulation_performance_jacobian">Jacobian computation options for implicit solvers</a><a id="ode_simulation_performance_jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#ode_simulation_performance_jacobian" title="Permalink"></a></h2><p>As <a href="#ode_simulation_performance_stiffness">previously mentioned</a>, implicit ODE solvers require the computation of the system&#39;s <a href="https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant"><em>Jacobian</em></a>. The reason is (roughly) that, in each time step, these solvers need to solve a non-linear equation to find the simulation&#39;s value at the next timestep (unlike explicit solvers, which compute the value at the next time step directly). Typically this is done using <a href="https://en.wikipedia.org/wiki/Newton%27s_method">the Newton-Raphson method</a>, which requires the Jacobian. Especially for large systems, this can be computationally expensive (and a potential strain on available memory), in which case one might consider various Jacobian-computation options (as described below). A throughout tutorial on simulating a large, stiff, ODE can be found <a href="https://docs.sciml.ai/DiffEqDocs/stable/tutorials/advanced_ode_example/#stiff">here</a>.</p><h3 id="ode_simulation_performance_symbolic_jacobian"><a class="docs-heading-anchor" href="#ode_simulation_performance_symbolic_jacobian">Building the Jacobian symbolically</a><a id="ode_simulation_performance_symbolic_jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#ode_simulation_performance_symbolic_jacobian" title="Permalink"></a></h3><p>By default, OrdinaryDiffEq computes the Jacobian using <a href="https://en.wikipedia.org/wiki/Automatic_differentiation"><em>automatic differentiation</em></a> (however, using <a href="https://en.wikipedia.org/wiki/Finite_difference"><em>finite differences</em></a> is <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/performance_overloads/">also possible</a>). Since Catalyst builds its ODEs symbolically, it is able to <em>compute an analytic Jacobian symbolically</em>. Typically, this is only advantageous when you are also <a href="#ode_simulation_performance_sparse_jacobian">using a sparse Jacobian</a>.</p><p>To use this option, simply set <code>jac = true</code> when constructing an <code>ODEProblem</code>:</p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEqDefault

brusselator = @reaction_network begin
    A, ∅ --&gt; X
    1, 2X + Y --&gt; 3X
    B, X --&gt; Y
    1, X --&gt; ∅
end
u0 = [:X =&gt; 1.0, :Y =&gt; 0.0]
tspan = (0.0, 20.0)
ps = [:A =&gt; 10.0, :B =&gt; 40.0]

oprob = ODEProblem(brusselator, u0, tspan, ps; jac = true)</code></pre><h3 id="ode_simulation_performance_sparse_jacobian"><a class="docs-heading-anchor" href="#ode_simulation_performance_sparse_jacobian">Using a sparse Jacobian</a><a id="ode_simulation_performance_sparse_jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#ode_simulation_performance_sparse_jacobian" title="Permalink"></a></h3><p>For a system with <span>$n$</span> variables, the Jacobian will be an <span>$n\times n$</span> matrix. This means that, as <span>$n$</span> becomes large, the Jacobian can become <em>very</em> large, potentially causing a significant strain on memory. In these cases, most Jacobian entries are typically <span>$0$</span>. This means that a <a href="https://en.wikipedia.org/wiki/Sparse_matrix"><em>sparse</em></a> Jacobian (rather than a <em>dense</em> one, which is the default) can be advantageous. To designate sparse Jacobian usage, simply provide the <code>sparse = true</code> option when constructing an <code>ODEProblem</code>:</p><pre><code class="language-julia hljs">oprob = ODEProblem(brusselator, u0, tspan, ps; sparse = true)</code></pre><h3 id="ode_simulation_performance_symbolic_jacobian_linear_solver"><a class="docs-heading-anchor" href="#ode_simulation_performance_symbolic_jacobian_linear_solver">Linear solver selection</a><a id="ode_simulation_performance_symbolic_jacobian_linear_solver-1"></a><a class="docs-heading-anchor-permalink" href="#ode_simulation_performance_symbolic_jacobian_linear_solver" title="Permalink"></a></h3><p>When implicit solvers use e.g. the Newton-Raphson method to (at each simulation time step) solve a (typically non-linear) equation, they actually solve a linearised version of this equation. For this, they use a linear solver, the choice of which can impact performance. To specify one, we use the <code>linsolve</code> option (given to the solver function, <em>not</em> the <code>solve</code> command). E.g. to use the <code>KLUFactorization</code> linear solver (which requires loading the <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> package) we run</p><pre><code class="language-julia hljs">using LinearSolve, OrdinaryDiffEqRosenbrock
solve(oprob, Rodas5P(linsolve = KLUFactorization()))</code></pre><p>A full list of potential linear solvers can be found <a href="https://docs.sciml.ai/LinearSolve/dev/solvers/solvers/#Full-List-of-Methods">here</a>. Typically, the default choice performs well.</p><p>A unique approach to the linear solvers is to use a <em>matrix-free Newton-Krylov method</em>. These do not actually compute the Jacobian, but rather <em>the effect of multiplying it with a vector</em>. They are typically advantageous for large systems (with large Jacobians), and can be designated using the <code>KrylovJL_GMRES</code> linear solver:</p><pre><code class="language-julia hljs">solve(oprob, Rodas5P(linsolve = KrylovJL_GMRES()))</code></pre><p>Since these methods do not depend on a Jacobian, certain Jacobian options (such as <a href="#ode_simulation_performance_symbolic_jacobian">computing it symbolically</a>) are irrelevant to them.</p><h3 id="ode_simulation_performance_preconditioners"><a class="docs-heading-anchor" href="#ode_simulation_performance_preconditioners">Designating preconditioners for Jacobian-free linear solvers</a><a id="ode_simulation_performance_preconditioners-1"></a><a class="docs-heading-anchor-permalink" href="#ode_simulation_performance_preconditioners" title="Permalink"></a></h3><p>When an implicit method solves a linear equation through an (iterative) matrix-free Newton-Krylov method, the rate of convergence depends on the numerical properties of the matrix defining the linear system. To speed up convergence, a <a href="https://en.wikipedia.org/wiki/Preconditioner"><em>preconditioner</em></a> can be applied to both sides of the linear equation, attempting to create an equation that converges faster. Preconditioners are only relevant when using matrix-free Newton-Krylov methods.</p><p>In practice, preconditioners are implemented as functions with a specific set of arguments. How to implement these is non-trivial, and we recommend reading OrdinaryDiffEq&#39;s documentation pages <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/linear_nonlinear/#Preconditioners:-precs-Specification">here</a> and <a href="https://docs.sciml.ai/DiffEqDocs/stable/tutorials/advanced_ode_example/#Adding-a-Preconditioner">here</a>. In this example, we will define an <a href="https://en.wikipedia.org/wiki/Incomplete_LU_factorization">Incomplete LU</a> preconditioner (which requires the <a href="https://github.com/haampie/IncompleteLU.jl">IncompleteLU.jl</a> package):</p><pre><code class="language-julia hljs">using IncompleteLU
function incompletelu(W, du, u, p, t, newW, Plprev, Prprev, solverdata)
    if newW === nothing || newW
        Pl = ilu(convert(AbstractMatrix, W), τ = 50.0)
    else
        Pl = Plprev
    end
    Pl, nothing
end</code></pre><p>Next, <code>incompletelu</code> can be supplied to our solver using the <code>precs</code> argument:</p><pre><code class="language-julia hljs">solve(oprob, Rodas5P(linsolve = KrylovJL_GMRES(), precs = incompletelu, concrete_jac = true))</code></pre><p>Finally, we note that when using preconditioners with a matrix-free method (like <code>KrylovJL_GMRES</code>, which is also the only case when these are relevant), the <code>concrete_jac = true</code> argument is required.</p><p>Generally, the use of preconditioners is only recommended for advanced users who are familiar with the concepts. However, for large systems, if performance is essential, they can be worth looking into.</p><h2 id="ode_simulation_performance_conservation_laws"><a class="docs-heading-anchor" href="#ode_simulation_performance_conservation_laws">Elimination of system conservation laws</a><a id="ode_simulation_performance_conservation_laws-1"></a><a class="docs-heading-anchor-permalink" href="#ode_simulation_performance_conservation_laws" title="Permalink"></a></h2><p>Previously, we have described how Catalyst, when it generates ODEs, is able to <a href="../../model_creation/conservation_laws/#conservation_laws">detect and eliminate conserved quantities</a>. In certain cases, doing this can improve performance. E.g. in the following example we will eliminate the single conserved quantity in a <a href="../../model_creation/examples/basic_CRN_library/#basic_CRN_library_two_states">two-state model</a>. This results in a differential algebraic equation with a single differential equation and a single algebraic equation (as opposed to two differential equations). However, as the algebraic equation is fully determined by the ODE solution, Catalyst moves it to be an observable and our new system therefore only contains one ODE that must be solved numerically. Conservation laws can be eliminated by providing the <code>remove_conserved = true</code> option to <code>ODEProblem</code>:</p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEqTsit5

# Declare model.
rs = @reaction_network begin
    (k₁,k₂), X₁ &lt;--&gt; X₂
end

# Generate and simulate and ODE (while eliminating any conserved quantities).
u0 = [:X₁ =&gt; 2.0, :X₂ =&gt; 3.0]
ps = [:k₁ =&gt; 1.0, :k₂ =&gt; 2.0]
oprob = ODEProblem(rs, u0, (0.0, 10.0), ps; remove_conserved = true)
sol = solve(oprob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"><span class="sgr1">┌ Warning: </span></span>You are creating a system or problem while eliminating conserved quantities. Please note,
<span class="sgr33"><span class="sgr1">│ </span></span>        due to limitations / design choices in ModelingToolkit if you use the created system to
<span class="sgr33"><span class="sgr1">│ </span></span>        create a problem (e.g. an `ODEProblem`), or are directly creating a problem, you *should not*
<span class="sgr33"><span class="sgr1">│ </span></span>        modify that problem&#39;s initial conditions for species (e.g. using `remake`). Changing initial
<span class="sgr33"><span class="sgr1">│ </span></span>        conditions must be done by creating a new Problem from your reaction system or the
<span class="sgr33"><span class="sgr1">│ </span></span>        ModelingToolkit system you converted it into with the new initial condition map.
<span class="sgr33"><span class="sgr1">│ </span></span>        Modification of parameter values is still possible, *except* for the modification of any
<span class="sgr33"><span class="sgr1">│ </span></span>        conservation law constants (Γ), which is not possible. You might
<span class="sgr33"><span class="sgr1">│ </span></span>        get this warning when creating a problem directly.
<span class="sgr33"><span class="sgr1">│ </span></span>
<span class="sgr33"><span class="sgr1">│ </span></span>        You can remove this warning by setting `remove_conserved_warn = false`.
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ Catalyst ~/work/Catalyst.jl/Catalyst.jl/src/reactionsystem_conversions.jl:456</span></code></pre><p>Conservation law elimination is not expected to ever impact performance negatively; it simply results in a (possibly) lower-dimensional system of ODEs to solve. However, eliminating conserved species may have minimal performance benefits; it is model-dependent whether elimination results in faster ODE solving times and/or increased solution accuracy.</p><h2 id="ode_simulation_performance_parallelisation"><a class="docs-heading-anchor" href="#ode_simulation_performance_parallelisation">Parallelisation on CPUs and GPUs</a><a id="ode_simulation_performance_parallelisation-1"></a><a class="docs-heading-anchor-permalink" href="#ode_simulation_performance_parallelisation" title="Permalink"></a></h2><p>Whenever an ODE is simulated a large number of times (e.g. when investigating its behaviour for different parameter values), the best way to improve performance is to <a href="https://en.wikipedia.org/wiki/Parallel_computing">parallelise the simulation over multiple processing units</a>. Indeed, an advantage of the Julia programming language is that it was designed after the advent of parallel computing, making it well-suited for this task. Roughly, parallelisation can be divided into parallelisation on <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPUs</a> and on <a href="https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units">GPUs</a>. CPU parallelisation is most straightforward, while GPU parallelisation requires specialised ODE solvers (which Catalyst have access to).</p><p>Both CPU and GPU parallelisation require first building an <code>EnsembleProblem</code> (which defines the simulations you wish to perform) and then supplying this with the correct parallelisation options. <code>EnsembleProblem</code>s have <a href="../ensemble_simulations/#ensemble_simulations">previously been introduced in Catalyst&#39;s documentation</a> (but in the context of convenient bundling of similar simulations, rather than to improve performance), with a more throughout description being found in <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/ensemble/#ensemble">OrdinaryDiffEq&#39;s documentation</a>. Finally, a general documentation of parallel computing in Julia is available <a href="https://docs.julialang.org/en/v1/manual/parallel-computing/">here</a>.</p><h3 id="ode_simulation_performance_parallelisation_CPU"><a class="docs-heading-anchor" href="#ode_simulation_performance_parallelisation_CPU">CPU parallelisation</a><a id="ode_simulation_performance_parallelisation_CPU-1"></a><a class="docs-heading-anchor-permalink" href="#ode_simulation_performance_parallelisation_CPU" title="Permalink"></a></h3><p>For this example (and the one for GPUs), we will consider a modified <a href="../../model_creation/examples/basic_CRN_library/#basic_CRN_library_mm">Michaelis-Menten enzyme kinetics model</a>, which describes an enzyme (<span>$E$</span>) that converts a substrate (<span>$S$</span>) to a product (<span>$P$</span>):</p><pre><code class="language-julia hljs">using Catalyst
mm_model = @reaction_network begin
    kB, S + E --&gt; SE
    kD, SE --&gt; S + E
    kP, SE --&gt; P + E
    d, S --&gt; ∅
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{S} + \mathrm{E} &amp;\xrightleftharpoons[\mathtt{kD}]{\mathtt{kB}} \mathrm{\mathtt{SE}} \\
\mathrm{\mathtt{SE}} &amp;\xrightarrow{\mathtt{kP}} \mathrm{P} + \mathrm{E} \\
\mathrm{S} &amp;\xrightarrow{d} \varnothing  
 \end{align*}
 \]</p><p>The model can be simulated, showing how <span>$P$</span> is produced from <span>$S$</span>:</p><pre><code class="language-julia hljs">using OrdinaryDiffEqTsit5, Plots
u0 = [:S =&gt; 1.0, :E =&gt; 1.0, :SE =&gt; 0.0, :P =&gt; 0.0]
tspan = (0.0, 50.0)
ps = [:kB =&gt; 1.0, :kD =&gt; 0.1, :kP =&gt; 0.5, :d =&gt; 0.1]
oprob = ODEProblem(mm_model, u0, tspan, ps)
sol = solve(oprob, Tsit5())
plot(sol)</code></pre><img src="bc0fa31b.svg" alt="Example block output"/><p>Due to the degradation of <span>$S$</span>, if the production rate is not high enough, the total amount of <span>$P$</span> produced is reduced. For this tutorial, we will investigate this effect for a range of values of <span>$kP$</span>. This will require a large number of simulations (for various <span>$kP$</span> values), which we will parallelise on CPUs (this section) and GPUs (<a href="#ode_simulation_performance_parallelisation_GPU">next section</a>).</p><p>To parallelise our simulations, we first need to create an <code>EnsembleProblem</code>. These describe which simulations we wish to perform. The input to this is:</p><ul><li>The <code>ODEProblem</code> corresponds to the model simulation (<code>SDEProblem</code> and <code>JumpProblem</code>s can also be supplied, enabling the parallelisation of these problem types).</li><li>A function, <code>prob_func</code>, describing how to modify the problem for each simulation. If we wish to simulate the same, unmodified problem, in each simulation (primarily relevant for stochastic simulations), this argument is not required.</li></ul><p>Here, <code>prob_func</code> takes 3 arguments:</p><ul><li><code>prob</code>: The problem that it modifies at the start of each individual run (which will be the same as <code>EnsembleProblem</code>&#39;s first argument).</li><li><code>i</code>: The index of the specific simulation (in the array of all simulations that are performed).</li><li><code>repeat</code>: The repeat of a specific simulation in the array. We will not use this option in this example, however, it is discussed in more detail <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/ensemble/#Building-a-Problem">here</a>.</li></ul><p>and output the <code>ODEProblem</code> simulated in the i&#39;th simulation.</p><p>Let us assume that we wish to simulate our model 100 times, for <span>$kP = 0.01, 0.02, ..., 0.99, 1.0$</span>. We define our <code>prob_func</code> using <a href="../simulation_structure_interfacing/#simulation_structure_interfacing_problems_remake"><code>remake</code></a>:</p><pre><code class="language-julia hljs">function prob_func(prob, i, repeat)
    return remake(prob; p = [:kP =&gt; 0.01*i])
end</code></pre><p>Next, we can create our <code>EnsembleProblem</code>:</p><pre><code class="language-julia hljs">eprob = EnsembleProblem(oprob; prob_func)</code></pre><p>We can now solve our <code>ODEProblem</code> using the same syntax we would normally use to solve the original <code>ODEProblem</code>, with the exception that an additional argument, <code>trajectories</code>, is required (which denotes how many simulations should be performed).</p><pre><code class="language-julia hljs">esol = solve(eprob, Tsit5(); trajectories = 100)</code></pre><p>To access the i&#39;th solution we use <code>esol.u[i]</code>. To e.g. plot the 47&#39;th solution we use:</p><pre><code class="language-julia hljs">plot(esol.u[47])</code></pre><img src="e5f0706e.svg" alt="Example block output"/><p>To extract the amount of <span>$P$</span> produced in each simulation, and plot this against the corresponding <span>$kP$</span> value, we can use:</p><pre><code class="language-julia hljs">plot(0.01:0.01:1.0, map(sol -&gt; sol[:P][end], esol.u), xguide = &quot;kP&quot;, yguide = &quot;P produced&quot;, label=&quot;&quot;)</code></pre><img src="e3899ff1.svg" alt="Example block output"/><p>Above, we have simply used <code>EnsembleProblem</code> as a convenient interface to run a large number of similar simulations. However, these problems have the advantage that they allow the passing of an <em>ensemble algorithm</em> to the <code>solve</code> command, which describes a strategy for parallelising the simulations. By default, <code>EnsembleThreads</code> is used. This parallelises the simulations using <a href="https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)">multithreading</a> (parallelisation within a single process), which is typically advantageous for small problems on shared memory devices. An alternative is <code>EnsembleDistributed</code> which instead parallelises the simulations using <a href="https://en.wikipedia.org/wiki/Multiprocessing">multiprocessing</a> (parallelisation across multiple processes). To do this, we simply supply this additional solver to the solve command:</p><pre><code class="language-julia hljs">esol = solve(eprob, Tsit5(), EnsembleDistributed(); trajectories = 100)</code></pre><p>To utilise multiple processes, you must first give Julia access to these. You can check how many processes are available using the <code>nprocs</code> (which requires the <a href="https://github.com/JuliaLang/Distributed.jl">Distributed.jl</a> package):</p><pre><code class="language-julia hljs">using Distributed
nprocs()</code></pre><p>Next, more processes can be added using <code>addprocs</code>. E.g. here we add an additional 4 processes:</p><pre><code class="language-julia hljs">addprocs(4)</code></pre><p>Powerful personal computers and HPC clusters typically have a large number of available additional processes that can be added to improve performance.</p><p>While <code>EnsembleThreads</code> and <code>EnsembleDistributed</code> cover the main cases, additional ensemble algorithms exist. A more throughout description of these can be found <a href="https://docs.sciml.ai/DiffEqDocs/dev/features/ensemble/#EnsembleAlgorithms">here</a>.</p><p>Finally, it should be noted that OrdinaryDiffEq, if additional processes are available, automatically parallelises the <a href="#ode_simulation_performance_symbolic_jacobian_linear_solver">linear solve part of implicit simulations</a>. It is thus possible to see performance improvements from adding additional processes when running single simulations, not only multiple parallelised ones (this effect is primarily noticeable for large systems with many species).</p><h3 id="ode_simulation_performance_parallelisation_GPU"><a class="docs-heading-anchor" href="#ode_simulation_performance_parallelisation_GPU">GPU parallelisation</a><a id="ode_simulation_performance_parallelisation_GPU-1"></a><a class="docs-heading-anchor-permalink" href="#ode_simulation_performance_parallelisation_GPU" title="Permalink"></a></h3><p>GPUs are different from CPUs in that they are much more restricted in what computations they can carry out. However, unlike CPUs, they are typically available in far larger numbers. Their original purpose is for rendering graphics (which typically involves solving a large number of very simple computations, something CPUs with their few, but powerful, cores are unsuited for). Recently, they have also started to be applied to other problems, such as ODE simulations. Generally, GPU parallelisation is only worthwhile when you have a very large number of parallel simulations to run (and access to good GPU resources, either locally or on a cluster).</p><p>Generally, we can parallelise <code>EnsembleProblem</code>s across several GPUs in a very similar manner to how we parallelised them across several CPUs, but by using a different ensemble algorithm (such as <code>EnsembleGPUArray</code>). However, there are some additional requirements:</p><ul><li>GPU parallelisation requires the <a href="https://github.com/SciML/DiffEqGPU.jl">DiffEqGPU.jl</a> package.</li><li>Depending on which GPU hardware is used, a specific back-end package has to be installed and imported (e.g. CUDA for NVIDIA&#39;s GPUs or Metal for Apple&#39;s).</li><li>For some cases, we must use a special ODE solver supporting simulations on GPUs.</li></ul><p>Furthermore (while not required) to receive good performance, we should also make the following adaptations:</p><ul><li>By default, Julia&#39;s decimal numbers are implemented as <code>Float64</code>s, however, using <code>Float32</code>s is advantageous on GPUs. Ideally, all initial conditions and parameter values should be specified using these.</li><li>We should designate all our vectors (i.e. initial conditions and parameter values) as <a href="https://github.com/JuliaArrays/StaticArrays.jl">static vectors</a>.</li></ul><p>We will assume that we are using the CUDA GPU hardware, so we will first load the <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> backend package, as well as DiffEqGPU:</p><pre><code class="language-julia hljs">using CUDA, DiffEqGPU</code></pre><p>Which backend package you should use depends on your available hardware, with the alternatives being listed <a href="https://docs.sciml.ai/DiffEqGPU/stable/manual/backends/">here</a>.</p><p>Next, we declare our model and <code>ODEProblem</code>. However, we make all values <code>Float64</code> (by appending <code>f0</code> to them) and all vectors static (by adding <code>@SVector</code> before their declaration, something which requires the <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays</a> package).</p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEqDefault, StaticArrays

mm_model = @reaction_network begin
    kB, S + E --&gt; SE
    kD, SE --&gt; S + E
    kP, SE --&gt; P + E
    d, S --&gt; ∅
end
@unpack S, E, SE, P, kB, kD, kP, d = mm_model

using OrdinaryDiffEqDefault, Plots
u0 = @SVector [S =&gt; 1.0f0, E =&gt; 1.0f0, SE =&gt; 0.0f0, P =&gt; 0.0f0]
tspan = (0.0f0, 50.0f0)
p = @SVector [kB =&gt; 1.0f0, kD =&gt; 0.1f0, kP =&gt; 0.5f0, d =&gt; 0.1f0]
oprob = ODEProblem(mm_model, u0, tspan, p)</code></pre><p>When we declare our <code>prob_func</code> and <code>EnsembleProblem</code> we need to ensure that the updated <code>ODEProblem</code> uses <code>Float32</code>:</p><pre><code class="language-julia hljs">function prob_func(prob, i, repeat)
    return remake(prob; p = [:kP =&gt; 0.0001f0*i])
end
eprob = EnsembleProblem(oprob; prob_func = prob_func)</code></pre><p>Here have we increased the number of simulations to 10,000, since this is a more appropriate number for GPU parallelisation (as compared to the 100 simulations we performed in our CPU example).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently, declaration of static vectors requires symbolic, rather than symbol, form for species and parameters. Hence, we here first <code>@unpack</code> these before constructing <code>u0</code> and <code>ps</code> using <code>@SVector</code>.</p></div></div><p>We can now simulate our model using a GPU-based ensemble algorithm. Currently, two such algorithms are available, <code>EnsembleGPUArray</code> and <code>EnsembleGPUKernel</code>. Their differences are that</p><ul><li>Only <code>EnsembleGPUKernel</code> requires arrays to be static arrays (although it is still advantageous for <code>EnsembleGPUArray</code>).</li><li>While <code>EnsembleGPUArray</code> can use standard ODE solvers, <code>EnsembleGPUKernel</code> requires specialised versions (such as <code>GPUTsit5</code>). A list of available such solvers can be found <a href="https://docs.sciml.ai/DiffEqGPU/dev/manual/ensemblegpukernel/#specialsolvers">here</a>.</li></ul><p>Generally, it is recommended to use <code>EnsembleGPUArray</code> for large models (that have at least <span>$100$</span> variables), and <code>EnsembleGPUKernel</code> for smaller ones. Here we simulate our model using both approaches (noting that <code>EnsembleGPUKernel</code> requires <code>GPUTsit5</code>):</p><pre><code class="language-julia hljs">esol1 = solve(eprob, Tsit5(), EnsembleGPUArray(CUDA.CUDABackend()); trajectories = 10000)
esol2 = solve(eprob, GPUTsit5(), EnsembleGPUKernel(CUDA.CUDABackend()); trajectories = 10000)</code></pre><p>Note that we have to provide the <code>CUDA.CUDABackend()</code> argument to our ensemble algorithms (to designate our GPU backend, in this case, CUDA).</p><p>Just like OrdinaryDiffEq is able to utilise parallel CPU processes to speed up the linear solve part of ODE simulations, GPUs can also be used. More details on this can be found <a href="https://docs.sciml.ai/DiffEqGPU/stable/tutorials/within_method_gpu/">here</a>. This is only recommended when ODEs are very large (at least 1,000 species), which is typically not the case for CRNs.</p><p>For more information on differential equation simulations on GPUs in Julia, please read <a href="https://docs.sciml.ai/DiffEqGPU/stable/">DiffEqGPU&#39;s documentation</a>. Furthermore, if performance is critical, <a href="https://docs.sciml.ai/DiffEqGPU/stable/tutorials/lower_level_api/">this tutorial</a> provides information on how to redesign your simulation code to make it more suitable for GPU simulations.</p><hr/><h2 id="Citation"><a class="docs-heading-anchor" href="#Citation">Citation</a><a id="Citation-1"></a><a class="docs-heading-anchor-permalink" href="#Citation" title="Permalink"></a></h2><p>If you use GPU simulations in your research, please cite the following paper to support the authors of the DiffEqGPU package:</p><pre><code class="nohighlight hljs">@article{utkarsh2024automated,
  title={Automated translation and accelerated solving of differential equations on multiple GPU platforms},
  author={Utkarsh, Utkarsh and Churavy, Valentin and Ma, Yingbo and Besard, Tim and Srisuma, Prakitr and Gymnich, Tim and Gerlach, Adam R and Edelman, Alan and Barbastathis, George and Braatz, Richard D and others},
  journal={Computer Methods in Applied Mechanics and Engineering},
  volume={419},
  pages={116591},
  year={2024},
  publisher={Elsevier}
}</code></pre><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://link.springer.com/book/10.1007/978-3-642-05221-7">E. Hairer, G. Wanner, <em>Solving Ordinary Differential Equations II</em>, Springer (1996).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ensemble_simulations/">« Ensemble/Monte Carlo Simulations</a><a class="docs-footer-nextpage" href="../sde_simulation_performance/">Advice for performant SDE simulations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 24 November 2024 16:55">Sunday 24 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
