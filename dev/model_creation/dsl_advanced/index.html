<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Catalyst DSL - Advanced Features and Options · Catalyst.jl</title><meta name="title" content="The Catalyst DSL - Advanced Features and Options · Catalyst.jl"/><meta property="og:title" content="The Catalyst DSL - Advanced Features and Options · Catalyst.jl"/><meta property="twitter:title" content="The Catalyst DSL - Advanced Features and Options · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/model_creation/dsl_advanced/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/model_creation/dsl_advanced/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/model_creation/dsl_advanced/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li></ul></li><li><span class="tocitem">Model Creation and Properties</span><ul><li><a class="tocitem" href="../dsl_basics/">The Catalyst DSL - Introduction</a></li><li class="is-active"><a class="tocitem" href>The Catalyst DSL - Advanced Features and Options</a><ul class="internal"><li><a class="tocitem" href="#dsl_advanced_options_declaring_species_and_parameters"><span>Explicit specification of network species and parameters</span></a></li><li><a class="tocitem" href="#dsl_advanced_options_naming"><span>Naming reaction networks</span></a></li><li><a class="tocitem" href="#dsl_advanced_options_observables"><span>Creating observables</span></a></li><li><a class="tocitem" href="#dsl_advanced_options_ivs"><span>Specifying non-time independent variables</span></a></li><li><a class="tocitem" href="#dsl_advanced_options_reaction_metadata"><span>Setting reaction metadata</span></a></li></ul></li><li><a class="tocitem" href="../model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li></ul></li></ul></li><li><span class="tocitem">Model simulation</span><ul><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for performant ODE simulations</a></li></ul></li><li><span class="tocitem">Steady state analysis</span><ul><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><span class="tocitem">Spatial modelling</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model Creation and Properties</a></li><li class="is-active"><a href>The Catalyst DSL - Advanced Features and Options</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Catalyst DSL - Advanced Features and Options</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/model_creation/dsl_advanced.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="dsl_advanced_options"><a class="docs-heading-anchor" href="#dsl_advanced_options">The Catalyst DSL - Advanced Features and Options</a><a id="dsl_advanced_options-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_advanced_options" title="Permalink"></a></h1><p>Within the Catalyst DSL, each line can represent either <em>a reaction</em> or <em>an option</em>. The <a href="../dsl_basics/#dsl_description">previous DSL tutorial</a> described how to create reactions. This one will focus on options. These are typically used to supply a model with additional information. Examples include the declaration of initial condition/parameter default values, or the creation of observables. </p><p>All option designations begin with a declaration starting with <code>@</code>, followed by its input. E.g. the <code>@observables</code> option allows for the generation of observables. Each option can only be used once within each use of <code>@reaction_network</code>. A full list of options can be found <a href="@ref ref">here</a>, with most (but not all) being described in more detail below. This tutorial will also describe some additional advanced DSL features that do not involve using an option. </p><p>As a first step, we import Catalyst (which is required to run the tutorial):</p><pre><code class="language-julia hljs">using Catalyst</code></pre><h2 id="dsl_advanced_options_declaring_species_and_parameters"><a class="docs-heading-anchor" href="#dsl_advanced_options_declaring_species_and_parameters">Explicit specification of network species and parameters</a><a id="dsl_advanced_options_declaring_species_and_parameters-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_advanced_options_declaring_species_and_parameters" title="Permalink"></a></h2><p>Previously, we mentioned that the DSL automatically determines which symbols correspond to species and which to parameters. This is done by designating everything that appears as either a substrate or a product as a species, and all remaining quantities as parameters (i.e. those only appearing within rates or <a href="../dsl_basics/#dsl_description_stoichiometries_parameters">stoichiometric constants</a>). Sometimes, one might want to manually override this default behaviour for a given symbol. I.e. consider the following model, where the conversion of a protein <code>P</code> from its inactive form (<code>Pᵢ</code>) to its active form (<code>Pₐ</code>) is catalysed by an enzyme (<code>E</code>). Using the most natural description:</p><pre><code class="language-julia hljs">catalysis_sys = @reaction_network begin
    k*E, Pᵢ --&gt; Pₐ
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{P_i} &amp;\xrightarrow{E k} \mathrm{P_a}  
 \end{align*}
 \]</p><p><code>E</code> (as well as <code>k</code>) will be considered a parameter, something we can confirm directly:</p><pre><code class="language-julia hljs">parameters(catalysis_sys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Any}:
 k
 E</code></pre><p>If we want <code>E</code> to be considered a species, we can designate this using the <code>@species</code> option:</p><pre><code class="language-julia hljs">catalysis_sys = @reaction_network begin
    @species E(t)
    k*E, Pᵢ --&gt; Pₐ
end
parameters(catalysis_sys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Any}:
 k</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When declaring species using the <code>@species</code> option, the species symbol must be followed by <code>(t)</code>. The reason is that species are time-dependent variables, and this time-dependency must be explicitly specified (<a href="#dsl_advanced_options_ivs">designation of non-<code>t</code> dependant species is also possible</a>).</p></div></div><p>Similarly, the <code>@parameters</code> option can be used to explicitly designate something as a parameter:</p><pre><code class="language-julia hljs">catalysis_sys = @reaction_network begin
    @parameters k
    k*E, Pᵢ --&gt; Pₐ
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{P_i} &amp;\xrightarrow{E k} \mathrm{P_a}  
 \end{align*}
 \]</p><p>Here, while <code>k</code> is explicitly defined as a parameter, no information is provided about <code>E</code>. Hence, the default case will be used (setting <code>E</code> to a parameter). The <code>@species</code> and <code>@parameter</code> options can be used simultaneously (although a quantity cannot be declared <em>both</em> as a species and a parameter). They may be followed by a full list of all species/parameters, or just a subset.</p><p>While designating something which would default to a parameter as a species is straightforward, the reverse (creating a parameter which occurs as a substrate or product) is more involved. This is, however, possible, and described <a href="#dsl_advanced_options_constant_species">here</a>.</p><p>Rather than listing all species/parameters on a single line after the options, a <code>begin ... end</code> block can be used (listing one species/parameter on each line). E.g. in the following example we use this notation to explicitly designate all species and parameters of the system:</p><pre><code class="language-julia hljs">catalysis_sys = @reaction_network begin
    @species begin
        E(t)
        Pᵢ(t)
        Pₐ(t)
    end
    @parameters begin
        k
    end
    k*E, Pᵢ --&gt; Pₐ
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{P_i} &amp;\xrightarrow{E k} \mathrm{P_a}  
 \end{align*}
 \]</p><p>A side-effect of using the <code>@species</code> and <code>@parameter</code> options is that they specify <em>the order in which the species and parameters are stored</em>. I.e. lets check the order of the parameters in the parameters in the following dimerisation model:</p><pre><code class="language-julia hljs">dimerisation = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
    (kB,kD), 2X &lt;--&gt; X2
end
parameters(dimerisation)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Any}:
 p
 d
 kB
 kD</code></pre><p>The default order is typically equal to the order with which the parameters (or species) are encountered in the DSL (this is, however, not guaranteed). If we specify the parameters using <code>@parameters</code>, the order used within the option is used instead:</p><pre><code class="language-julia hljs">dimerisation = @reaction_network begin
    @parameters kB kD p d
    (p,d), 0 &lt;--&gt; X
    (kB,kD), 2X &lt;--&gt; X2
end
parameters(dimerisation)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Any}:
 kB
 kD
 p
 d</code></pre><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>Generally, Catalyst and the SciML ecosystem <em>do not</em> guarantee that parameter and species order are preserved throughout various operations on a model. Writing programs that depend on these orders is <em>strongly discouraged</em>. There are, however, some legacy packages which still depend on order (one example can be found <a href="../../inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_basics">here</a>). In these situations, this might be useful. However, in these cases, it is recommended that the user is extra wary, and also checks the order manually. </p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The syntax of the <code>@species</code> and <code>@parameters</code> options is identical to that used by the <code>@species</code> and <code>@parameters</code> macros <a href="@ref programmatic_CRN_construction">used in programmatic modelling in Catalyst</a> (for e.g. designating metadata or initial conditions). Hence, if one has learnt how to specify species/parameters using either approach, that knowledge can be transferred to the other one.</p></div></div><p>Generally, there are four main reasons for specifying species/parameters using the <code>@species</code> and <code>@parameters</code> options:</p><ol><li>To designate a quantity, that would otherwise have defaulted to a parameter, as a species.</li><li>To designate default values for parameters/species initial conditions (described <a href="#dsl_advanced_options_default_vals">here</a>).</li><li>To designate metadata for species/parameters (described <a href="#dsl_advanced_options_species_and_parameters_metadata">here</a>).</li><li>To designate a species or parameters that do not occur in reactions, but are still part of the model (e.g a <a href="#dsl_advanced_options_parametric_initial_conditions">parametric initial condition</a>)</li></ol><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>Catalyst&#39;s DSL automatically infer species and parameters from the input. However, it only does so for <em>quantities that appear in reactions</em>. Until now this has not been relevant. However, this tutorial will demonstrate cases where species/parameters that are not part of reactions are used. These <em>must</em> be designated using either the <code>@species</code> or <code>@parameters</code> options (or the <code>@variables</code> option, which is described <a href="@ref ref">later</a>).</p></div></div><h3 id="dsl_advanced_options_default_vals"><a class="docs-heading-anchor" href="#dsl_advanced_options_default_vals">Setting default values for species and parameters</a><a id="dsl_advanced_options_default_vals-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_advanced_options_default_vals" title="Permalink"></a></h3><p>When declaring species/parameters using the <code>@species</code> and <code>@parameters</code> options, one can also assign them default values (by appending them with <code>=</code> followed by the desired default value). E.g here we set <code>X</code>&#39;s default initial condition value to <span>$1.0$</span>, and <code>p</code> and <code>d</code>&#39;s default values to <span>$1.0$</span> and <span>$0.2$</span>, respectively:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    @species X(t)=1.0
    @parameters p=1.0 d=0.1
    (p,d), 0 &lt;--&gt; X
end</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightleftharpoons[d]{p} \mathrm{X}  
 \end{align*}
 \]</p><p>Next, if we simulate the model, we do not need to provide values for species or parameters that have default values. In this case all have default values, so both <code>u0</code> and <code>ps</code> can be empty vectors:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq, Plots
u0 = []
tspan = (0.0, 10.0)
p = []
oprob = ODEProblem(rn, u0, tspan, p)
sol = solve(oprob)
plot(sol)</code></pre><img src="cb632b86.svg" alt="Example block output"/><p>It is still possible to provide values for some (or all) initial conditions/parameters in <code>u0</code>/<code>ps</code> (in which case these overrides the default values):</p><pre><code class="language-julia hljs">u0 = [:X =&gt; 4.0]
p = [:d =&gt; 0.5]
oprob = ODEProblem(rn, u0, tspan, p)
sol = solve(oprob)
plot(sol)</code></pre><img src="3099f2a1.svg" alt="Example block output"/><p>It is also possible to declare a model with default values for only some initial conditions/parameters:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    @species X(t)=1.0
    (p,d), 0 &lt;--&gt; X
end

tspan = (0.0, 10.0)
p = [:p =&gt; 1.0, :d =&gt; 0.2]
oprob = ODEProblem(rn, u0, tspan, p)
sol = solve(oprob)
plot(sol)</code></pre><img src="44fe0776.svg" alt="Example block output"/><p>API for checking the default values of species and parameters can be found <a href="@ref ref">here</a>.</p><h3 id="dsl_advanced_options_parametric_initial_conditions"><a class="docs-heading-anchor" href="#dsl_advanced_options_parametric_initial_conditions">Setting parametric initial conditions</a><a id="dsl_advanced_options_parametric_initial_conditions-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_advanced_options_parametric_initial_conditions" title="Permalink"></a></h3><p>In the previous section, we designated default values for initial conditions and parameters. However, the right-hand side of the designation accepts any valid expression (not only numeric values). While this can be used to set up some advanced default values, the most common use case is to designate a species&#39;s initial condition as a parameter. E.g. in the following example we represent the initial condition of <code>X</code> using the parameter <code>X₀</code>. </p><pre><code class="language-julia hljs">rn = @reaction_network begin
    @species X(t)=X₀
    @parameters X₀
    (p,d), 0 &lt;--&gt; X
end</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightleftharpoons[d]{p} \mathrm{X}  
 \end{align*}
 \]</p><p>Please note that as the parameter <code>X₀</code> does not occur as part of any reactions, Catalyst&#39;s DSL cannot infer whether it is a species or a parameter. This must hence be explicitly declared. We can now simulate our model while providing <code>X</code>&#39;s value through the <code>X₀</code> parameter:</p><pre><code class="language-julia hljs">u0 = []
p = [:X₀ =&gt; 1.0, :p =&gt; 1.0, :d =&gt; 0.5]
oprob = ODEProblem(rn, u0, tspan, p)
sol = solve(oprob, Tsit5())
plot(sol)</code></pre><img src="2311793c.svg" alt="Example block output"/><p>It is still possible to designate <span>$X$</span>&#39;s value in <code>u0</code>, in which case this overrides the default value.</p><pre><code class="language-julia hljs">u0 = [:X =&gt; 0.5]
p = [:X₀ =&gt; 1.0, :p =&gt; 1.0, :d =&gt; 0.5]
oprob = ODEProblem(rn, u0, tspan, p)
sol = solve(oprob, Tsit5())
plot(sol)</code></pre><img src="a10ff2aa.svg" alt="Example block output"/><p>Please note that <code>X₀</code> is still a parameter of the system, and as such its value must still be designated to simulate the model (even if it is not actually used).</p><h3 id="dsl_advanced_options_species_and_parameters_metadata"><a class="docs-heading-anchor" href="#dsl_advanced_options_species_and_parameters_metadata">Designating metadata for species and parameters</a><a id="dsl_advanced_options_species_and_parameters_metadata-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_advanced_options_species_and_parameters_metadata" title="Permalink"></a></h3><p>Catalyst permits the user to define <em>metadata</em> for species and parameters. This permits the user to assign additional information to these, which can be used for a variety of purposes. Some Catalyst features depend on using metadata (with each such case describing specifically how this is done). Here we will introduce how to set metadata, and describe some common metadata types. </p><p>Whenever a species/parameter is declared using the <code>@species</code>/<code>@parameters</code> options, it can be followed by a <code>[]</code> within which the metadata is given. Each metadata entry consists of the metadata&#39;s name, followed by a <code>=</code>, followed by its value. E.g. the <code>description</code> metadata allows you to attach a <a href="https://docs.julialang.org/en/v1/base/strings/"><code>String</code></a> to a species/parameter. Here we create a simple model where we add descriptions to all species and parameters.</p><pre><code class="language-julia hljs">two_state_system = @reaction_network begin
    @species Xᵢ(t) [description=&quot;X&#39;s inactive form&quot;] Xₐ(t) [description=&quot; X&#39;s active form&quot;]
    @parameters kA [description=&quot;Activation rate&quot;] kD [description=&quot;Deactivation rate&quot;]
    (ka,kD), Xᵢ &lt;--&gt; Xₐ
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X_i} &amp;\xrightleftharpoons[kD]{ka} \mathrm{X_a}  
 \end{align*}
 \]</p><p>A metadata can be given to only a subset of a system&#39;s species/parameters, and a quantity can be given several metadata entries. To give several metadata, separate each by a <code>,</code>. Here we only provide a description for <code>kA</code>, for which we also provide a <a href="https://docs.sciml.ai/ModelingToolkit/dev/basics/Variable_metadata/#Bounds"><code>bounds</code> metadata</a>,</p><pre><code class="language-julia hljs">two_state_system = @reaction_network begin
    @parameters kA [description=&quot;Activation rate&quot;, bounds=(0.01,10.0)]
    (ka,kD), Xᵢ &lt;--&gt; Xₐ
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X_i} &amp;\xrightleftharpoons[kD]{ka} \mathrm{X_a}  
 \end{align*}
 \]</p><p>It is possible to add both default values and metadata to a parameter/species. In this case, first provide the default value, and next the metadata. I.e. to in the above example set <span>$kA$</span>&#39;s default value to <span>$1.0$</span> we use</p><pre><code class="language-julia hljs">two_state_system = @reaction_network begin
    @parameters kA=1.0 [description=&quot;Activation rate&quot;, bounds=(0.01,10.0)]
    (ka,kD), Xᵢ &lt;--&gt; Xₐ
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X_i} &amp;\xrightleftharpoons[kD]{ka} \mathrm{X_a}  
 \end{align*}
 \]</p><p>When designating metadata for species/parameters in <code>begin ... end</code> blocks the syntax changes slightly. Here, a <code>,</code> must be inserted before the metadata (but after any potential default value). I.e. a version of the previous example can be written as</p><pre><code class="language-julia hljs">two_state_system = @reaction_network begin
    @parameters begin
        kA, [description=&quot;Activation rate&quot;, bounds=(0.01,10.0)]
        kD = 1.0, [description=&quot;Deactivation rate&quot;]
    end
    (kA,kD), Xᵢ &lt;--&gt; Xₐ
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X_i} &amp;\xrightleftharpoons[kD]{kA} \mathrm{X_a}  
 \end{align*}
 \]</p><p>Each metadata has its own getter functions. E.g. we can get the description of the parameter <code>kA</code> using <code>ModelingToolkit.getdescription</code> (here we use <a href="@ref ref">system indexing</a> to access the parameter):</p><pre><code class="language-julia hljs">ModelingToolkit.getdescription(two_state_system.kA)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;Activation rate&quot;</code></pre><p>It is not possible for the user to directly designate their own metadata. These have to first be added to Catalyst. Doing so is somewhat involved, and described in detail <a href="@ref ref">here</a>. A full list of metadata that can be used for species and/or parameters can be found <a href="@ref ref">here</a>.</p><h3 id="dsl_advanced_options_constant_species"><a class="docs-heading-anchor" href="#dsl_advanced_options_constant_species">Designating constant-valued/fixed species parameters</a><a id="dsl_advanced_options_constant_species-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_advanced_options_constant_species" title="Permalink"></a></h3><p>Catalyst enables the designation of parameters as <code>constantspecies</code>. These parameters can be used as species in reactions, however, their values are not changed by the reaction and remain constant throughout the simulation (unless changed by e.g. the [occurrence of an event]@ref ref). Practically, this is done by setting the parameter&#39;s <code>isconstantspecies</code> metadata to <code>true</code>. Here, we create a simple reaction where the species <code>X</code> is converted to <code>Xᴾ</code> at rate <code>k</code>. By designating <code>X</code> as a constant species parameter, we ensure that its quantity is unchanged by the occurrence of the reaction.</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    @parameters X [isconstantspecies=true]
    k, X --&gt; Xᴾ
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X} &amp;\xrightarrow{k} \mathrm{X^P}  
 \end{align*}
 \]</p><p>We can confirm that <span>$Xᴾ$</span> is the only species of the system:</p><pre><code class="language-julia hljs">species(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 Xᴾ(t)</code></pre><p>Here, the produced model is actually identical to if <span>$X$</span> had simply been a parameter in the reaction&#39;s rate:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    k*X, 0 --&gt; Xᴾ
end</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightarrow{X k} \mathrm{X^P}  
 \end{align*}
 \]</p><p>A common use-case for constant species is when modelling systems where some species are present in such surplus that their amounts the reactions&#39; effect on it is negligible. A system which is commonly modelled this way is the <a href="https://en.wikipedia.org/wiki/Brusselator">Brusselator</a>.</p><h3 id="dsl_advanced_options_parameter_types"><a class="docs-heading-anchor" href="#dsl_advanced_options_parameter_types">Designating parameter types</a><a id="dsl_advanced_options_parameter_types-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_advanced_options_parameter_types" title="Permalink"></a></h3><p>Sometimes it is desired to designate that a parameter should have a specific <a href="https://docs.julialang.org/en/v1/manual/types/">type</a>. When supplying this parameter&#39;s value to e.g. an <code>ODEProblem</code>, that parameter will then be restricted to that specific type. Designating a type is done by appending the parameter with <code>::</code> followed by its type. E.g. in the following example we specify that the parameter <code>n</code> (the number of <code>X</code> molecules in the <code>Xn</code> polymer) must be an integer (<code>Int64</code>)</p><pre><code class="language-julia hljs">polymerisation_network = @reaction_network begin
    @parameters n::Int64
    (kB,kD), n*X &lt;--&gt; Xn
end</code></pre><p>Generally, when simulating models with mixed parameter types, it is recommended to <a href="../../model_simulation/simulation_introduction/#simulation_intro_ODEs_input_forms">declare parameter values as tuples, rather than vectors</a>, e.g.:</p><pre><code class="language-julia hljs">ps = (:kB =&gt; 0.2, :kD =&gt; 1.0, :n =&gt; 2)</code></pre><p>If a parameter has a type, metadata, and a default value, they are designated in the following order:</p><pre><code class="language-julia hljs">polymerisation_network = @reaction_network begin
    @parameters n::Int64 = 2 [description=&quot;Parameter n, an integer with defaults value 2.&quot;]
    (kB,kD), n*X &lt;--&gt; Xn
end</code></pre><h3 id="dsl_advanced_options_vector_variables"><a class="docs-heading-anchor" href="#dsl_advanced_options_vector_variables">Vector-valued species or parameters</a><a id="dsl_advanced_options_vector_variables-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_advanced_options_vector_variables" title="Permalink"></a></h3><p>Sometimes, one wishes to declare a large number of similar parameters or species. This can be done by <em>creating them as vectors</em>. E.g. below we create a <a href="../examples/basic_CRN_library/#basic_CRN_library_two_states">two-state system</a>. However, instead of declaring <code>X1</code> and <code>X2</code> (and <code>k1</code> and <code>k2</code>) as separate entities, we declare them as vectors:</p><pre><code class="language-julia hljs">two_state_model = @reaction_network begin
    @parameters k[1:2]
    @species X(t)[1:2]
    (k[1],k[2]), X[1] &lt;--&gt; X[2]
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X} &amp;\xrightleftharpoons[\mathrm{getindex}\left( k, 2 \right)]{\mathrm{getindex}\left( k, 1 \right)} \mathrm{X}  
 \end{align*}
 \]</p><p>Now, we can also declare our initial conditions and parameter values as vectors as well:</p><pre><code class="language-julia hljs">u0 = [:X =&gt; [0.0, 2.0]]
tspan = (0.0, 1.0)
ps = [:k =&gt; [1.0, 2.0]]
oprob = ODEProblem(two_state_model, u0, tspan, ps)
sol = solve(oprob)
plot(sol)</code></pre><img src="cbd72bf2.svg" alt="Example block output"/><h2 id="dsl_advanced_options_naming"><a class="docs-heading-anchor" href="#dsl_advanced_options_naming">Naming reaction networks</a><a id="dsl_advanced_options_naming-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_advanced_options_naming" title="Permalink"></a></h2><p>Each reaction network model has a name. It can be accessed using the <code>nameof</code> function. By default, some generic name is used:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
nameof(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Symbol(&quot;##ReactionSystem#499&quot;)</code></pre><p>A specific name can be given as an argument between the <code>@reaction_network</code> and the <code>begin</code>. E.g. to name a network <code>my_network</code> we can use:</p><pre><code class="language-julia hljs">rn = @reaction_network my_network begin
    (p,d), 0 &lt;--&gt; X
end
nameof(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">:my_network</code></pre><p>A consequence of generic names being used by default is that networks, even if seemingly identical, by default are not. E.g.</p><pre><code class="language-julia hljs">rn1 = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
rn2 = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
rn1 == rn2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><p>The reason can be confirmed by checking that their respective (randomly generated) names are different:</p><pre><code class="language-julia hljs">nameof(rn1) == nameof(rn2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><p>By designating the networks to have the same name, however, identity is achieved.</p><pre><code class="language-julia hljs">rn1 = @reaction_network my_network begin
    (p,d), 0 &lt;--&gt; X
end
rn2 = @reaction_network my_network begin
    (p,d), 0 &lt;--&gt; X
end
rn1 == rn2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>If you wish to check for identity, and wish that models that have different names but are otherwise identical, should be considered equal, you can use the <a href="@ref"><code>isequivalent</code></a> function.</p><p>Setting model names is primarily useful for <a href="@ref compositional_modeling">hierarchical modelling</a>, where network names are appended to the display names of subnetworks&#39; species and parameters.</p><h2 id="dsl_advanced_options_observables"><a class="docs-heading-anchor" href="#dsl_advanced_options_observables">Creating observables</a><a id="dsl_advanced_options_observables-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_advanced_options_observables" title="Permalink"></a></h2><p>Sometimes one might want to use observable variables. These are variables with values that can be computed directly from a system&#39;s state (rather than having their values implicitly given by reactions or equations). Observables can be designated using the <code>@observables</code> option. Here, the <code>@observables</code> option is followed by a <code>begin ... end</code> block with one line for each observable. Each line first gives the observable, followed by a <code>~</code> (<em>not</em> a <code>=</code>!), followed by an expression describing how to compute it.</p><p>Let us consider a model where two species (<code>X</code> and <code>Y</code>) can bind to form a complex (<code>XY</code>, which also can dissociate back into <code>X</code> and <code>Y</code>). If we wish to create a representation for the total amount of <code>X</code> and <code>Y</code> in the system, we can do this by creating observables <code>Xtot</code> and <code>Ytot</code>:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    @observables begin
        Xtot ~ X + XY
        Ytot ~ Y + XY
    end
    (kB,kD), X + Y &lt;--&gt; XY
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X} + \mathrm{Y} &amp;\xrightleftharpoons[kD]{kB} \mathrm{XY}  
 \end{align*}
 \]</p><p>We can now simulate our model using normal syntax (initial condition values for observables should not, and can not, be provided):</p><pre><code class="language-julia hljs">using OrdinaryDiffEq
u0 = [:X =&gt; 1.0, :Y =&gt; 2.0, :XY =&gt; 0.0]
tspan = (0.0, 10.0)
ps = [:kB =&gt; 1.0, :kD =&gt; 1.5]
oprob = ODEProblem(rn, u0, tspan, ps)
sol = solve(oprob, Tsit5())</code></pre><p>Next, we can use <a href="../../model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing">symbolic indexing</a> of our solution object, but with the observable as input. E.g. we can use </p><pre><code class="language-julia hljs">sol[:Xtot]</code></pre><p>to get a vector with <code>Xtot</code>&#39;s value throughout the simulation. We can also use</p><pre><code class="language-julia hljs">using Plots
plot(sol; idxs = :Xtot)</code></pre><img src="0bd6ede5.svg" alt="Example block output"/><p>to plot the observables (rather than the species).</p><p>Observables can be defined using complicated expressions containing species, parameters, and <a href="@ref ref">variables</a> (but not other observables). In the following example (which uses a <a href="../dsl_basics/#dsl_description_stoichiometries_parameters">parametric stoichiometry</a>) <code>X</code> polymerises to form a complex <code>Xn</code> containing <code>n</code> copies of <code>X</code>. Here, we create an observable describing the total number of <code>X</code> molecules in the system:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    @observables Xtot ~ X + n*Xn
    (kB,kD), n*X &lt;--&gt; Xn
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If only a single observable is declared, the <code>begin .. end</code> block is not required and the observable can be declared directly after the <code>@observables</code> option.</p></div></div><p><a href="#dsl_advanced_options_species_and_parameters_metadata">Metadata</a> can be supplied to an observable directly after its declaration (but before its formula). If so, the metadata must be separated from the observable with a <code>,</code>, and the observable plus the metadata encapsulated by <code>()</code>. E.g. to add a <a href="#dsl_advanced_options_species_and_parameters_metadata">description metadata</a> to our observable we can use</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    @observables (Xtot, [description=&quot;The total amount of X in the system.&quot;]) ~ X + n*Xn
    (kB,kD), n*X &lt;--&gt; Xn
end</code></pre><p>Observables are by default considered <a href="@ref ref">variables</a> (not species). To designate them as a species, they can be pre-declared using the <code>@species</code> option. I.e. Here <code>Xtot</code> becomes a species:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    @species Xtot(t)
    @observables Xtot ~ X + n*Xn
    (kB,kD), n*X &lt;--&gt; Xn
end</code></pre><p>Some final notes regarding observables:</p><ul><li>The left-hand side of the observable declaration must contain a single symbol only (with the exception of metadata, which can also be supplied).</li><li>All quantities appearing on the right-hand side must be declared elsewhere within the <code>@reaction_network</code> call (either by being part of a reaction, or through the <code>@species</code>, <code>@parameters</code>, or <code>@variables</code> options).</li><li>Observables may not depend on other observables.</li><li>Observables have their <a href="@ref ref">dependent variable(s)</a> automatically assigned as the union of the dependent variables of the species and variables on which it depends.</li></ul><h2 id="dsl_advanced_options_ivs"><a class="docs-heading-anchor" href="#dsl_advanced_options_ivs">Specifying non-time independent variables</a><a id="dsl_advanced_options_ivs-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_advanced_options_ivs" title="Permalink"></a></h2><p>As <a href="@ref ref">described elsewhere</a>, Catalyst&#39;s <code>ReactionSystem</code> models depend on a <em>time independent variable</em>, and potentially one or more <em>spatial independent variables</em>. By default, the independent variable <code>t</code> is used. We can declare another independent variable (which is automatically used as the default one) using the <code>@ivs</code> option. E.g. to use <code>τ</code> instead of <code>t</code> we can use</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    @ivs τ
    (ka,kD), Xᵢ &lt;--&gt; Xₐ
end</code></pre><p>We can confirm that <code>Xᵢ</code> and <code>Xₐ</code> depend on <code>τ</code> (and not <code>t</code>):</p><pre><code class="language-julia hljs">species(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 Xᵢ(τ)
 Xₐ(τ)</code></pre><p>It is possible to designate several independent variables using <code>@ivs</code>. If so, the first one is considered the default (time) independent variable, while the following one(s) are considered spatial independent variable(s). If we want some species to depend on a non-default independent variable, this has to be explicitly declared:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    @ivs τ x
    @species X(τ) Y(x)
    (p1,d1), 0 &lt;--&gt; X
    (p2,d2), 0 &lt;--&gt; Y
end
species(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 X(τ)
 Y(x)</code></pre><p>It is also possible to have species which depends on several independent variables:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    @ivs t x
    @species Xᵢ(t,x) Xₐ(t,x)
    (ka,kD), Xᵢ &lt;--&gt; Xₐ
end
species(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 Xᵢ(t, x)
 Xₐ(t, x)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Setting spatial independent variables is primarily intended for the modelling of spatial systems on continuous domains. Catalyst&#39;s support for this is currently under development. Hence, the utility of specifying spatial independent variables is limited.</p></div></div><h2 id="dsl_advanced_options_reaction_metadata"><a class="docs-heading-anchor" href="#dsl_advanced_options_reaction_metadata">Setting reaction metadata</a><a id="dsl_advanced_options_reaction_metadata-1"></a><a class="docs-heading-anchor-permalink" href="#dsl_advanced_options_reaction_metadata" title="Permalink"></a></h2><p>It is possible to supply reactions with <em>metadata</em>, containing some additional information of the reaction. A reaction&#39;s metadata follows after its declaration (first using the metadata&#39;s name, then a <code>=</code>, then its value) and is encapsulated by <code>[]</code> (where individual entries are separated by <code>,</code>). Here, we add a <code>description</code> metadata to the reactions of a birth-death process:</p><pre><code class="language-julia hljs">bd_model = @reaction_network begin
    p, 0 --&gt; X, [description=&quot;Production reaction&quot;]
    d, X --&gt; 0, [description=&quot;Degradation reaction&quot;]
end</code></pre><p>When <a href="../dsl_basics/#dsl_description_reaction_bundling">bundling reactions</a>, reaction metadata can be bundled using the same rules as rates. Bellow we re-declare our birth-death process, but on a single line:</p><pre><code class="language-julia hljs">bd_model = @reaction_network begin
    (p,d), 0 &lt;--&gt; X, ([description=&quot;Production reaction&quot;], [description=&quot;Degradation reaction&quot;])
end</code></pre><p>Here we declare a model where we also provide a <code>misc</code> metadata (which can hold any quantity we require) to our birth reaction:</p><pre><code class="language-julia hljs">bd_model = @reaction_network begin
    p, 0 --&gt; X, [description=&quot;Production reaction&quot;, misc=:value]
    d, X --&gt; 0, [description=&quot;Degradation reaction&quot;]
end</code></pre><p>A reaction&#39;s metadata can be accessed using specific functions, e.g. <code>Catalyst.hasdescription</code> and <code>Catalyst.getdescription</code> can be used to check if a reaction have a description metadata, and to retrieve it, respectively:</p><pre><code class="language-julia hljs">rx = @reaction p, 0 --&gt; X, [description=&quot;A production reaction&quot;]
Catalyst.getdescription(rx)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;A production reaction&quot;</code></pre><p>A list of all available reaction metadata can be found <a href="@ref ref">here</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dsl_basics/">« The Catalyst DSL - Introduction</a><a class="docs-footer-nextpage" href="../model_visualisation/">Model Visualisation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 3 June 2024 16:50">Monday 3 June 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
