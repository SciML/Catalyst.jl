<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Compositional Modeling of Reaction Systems · Catalyst.jl</title><meta name="title" content="Compositional Modeling of Reaction Systems · Catalyst.jl"/><meta property="og:title" content="Compositional Modeling of Reaction Systems · Catalyst.jl"/><meta property="twitter:title" content="Compositional Modeling of Reaction Systems · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/model_creation/compositional_modeling/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/model_creation/compositional_modeling/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/model_creation/compositional_modeling/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><span class="tocitem">Model creation and properties</span><ul><li><a class="tocitem" href="../dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li class="is-active"><a class="tocitem" href>Compositional Modeling of Reaction Systems</a><ul class="internal"><li><a class="tocitem" href="#completeness_note"><span>A note on <em>completeness</em></span></a></li><li><a class="tocitem" href="#Compositional-modeling-tooling"><span>Compositional modeling tooling</span></a></li><li><a class="tocitem" href="#Compositional-model-of-the-repressilator"><span>Compositional model of the repressilator</span></a></li><li><a class="tocitem" href="#Compartment-based-models"><span>Compartment-based models</span></a></li></ul></li><li><a class="tocitem" href="../constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../conservation_laws/">Working with conservation laws</a></li><li><a class="tocitem" href="../parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../reactionsystem_content_accessing/">Accessing model properties</a></li><li><a class="tocitem" href="../network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Model simulation and visualization</span><ul><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for performant ODE simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for performant SDE simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/examples/periodic_events_simulation/">Modelling a periodic event during ODE and jump simulations</a></li><li><a class="tocitem" href="../../model_simulation/examples/interactive_brusselator_simulation/">Interactive Simulation and Plotting</a></li></ul></li></ul></li><li><span class="tocitem">Steady state analysis</span><ul><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><span class="tocitem">Inverse problems</span><ul><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><span class="tocitem">Spatial modelling</span><ul><li><a class="tocitem" href="../../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial jump simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model creation and properties</a></li><li class="is-active"><a href>Compositional Modeling of Reaction Systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Compositional Modeling of Reaction Systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/model_creation/compositional_modeling.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="compositional_modeling"><a class="docs-heading-anchor" href="#compositional_modeling">Compositional Modeling of Reaction Systems</a><a id="compositional_modeling-1"></a><a class="docs-heading-anchor-permalink" href="#compositional_modeling" title="Permalink"></a></h1><p>Catalyst supports the construction of models in a compositional fashion, based on ModelingToolkit&#39;s subsystem functionality. In this tutorial we&#39;ll see how we can construct the earlier repressilator model by composing together three identically repressed genes, and how to use compositional modeling to create compartments.</p><h2 id="completeness_note"><a class="docs-heading-anchor" href="#completeness_note">A note on <em>completeness</em></a><a id="completeness_note-1"></a><a class="docs-heading-anchor-permalink" href="#completeness_note" title="Permalink"></a></h2><p>Catalyst <code>ReactionSystem</code> can either be <em>complete</em> or <em>incomplete</em>. When created using the <code>@reaction_network</code> DSL they are <em>created as complete</em>. Here, only complete <code>ReactionSystem</code>s can be used to create the various problem types (e.g. <code>ODEProblem</code>). However, only incomplete <code>ReactionSystem</code>s can be composed using the features described below. Hence, for compositional modeling, <code>ReactionSystem</code> must be created as incomplete, and later set to complete before simulation.</p><p>To create a <code>ReactionSystem</code>s for use in compositional modeling via the DSL, simply use the <code>@network_component</code> macro instead of <code>@reaction_network</code>:</p><pre><code class="language-julia hljs">using Catalyst
degradation_component = @network_component begin
  d, X --&gt; 0
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X} &amp;\xrightarrow{d} \varnothing  
 \end{align*}
 \]</p><p>Alternatively one can just build the <code>ReactionSystem</code> via the symbolic interface.</p><pre><code class="language-julia hljs">@parameters d
t = default_t()
@species X(t)
rx = Reaction(d, [X], nothing)
@named degradation_component = ReactionSystem([rx], t)</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X} &amp;\xrightarrow{d} \varnothing  
 \end{align*}
 \]</p><p>We can test whether a system is complete using the <code>ModelingToolkit.iscomplete</code> function:</p><pre><code class="language-julia hljs">ModelingToolkit.iscomplete(degradation_component)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><p>To mark a system as complete, after which it should be considered as representing a finalized model, use the <code>complete</code> function</p><pre><code class="language-julia hljs">degradation_component_complete = complete(degradation_component)
ModelingToolkit.iscomplete(degradation_component_complete)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h2 id="Compositional-modeling-tooling"><a class="docs-heading-anchor" href="#Compositional-modeling-tooling">Compositional modeling tooling</a><a id="Compositional-modeling-tooling-1"></a><a class="docs-heading-anchor-permalink" href="#Compositional-modeling-tooling" title="Permalink"></a></h2><p>Catalyst supports two ModelingToolkit interfaces for composing multiple <a href="../../api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>s together into a full model. The first mechanism allows for extending an existing system by merging in a second system via the <code>extend</code> command</p><pre><code class="language-julia hljs">using Catalyst
basern = @network_component rn1 begin
  k, A + B --&gt; C
end
newrn = @network_component rn2 begin
  r, C --&gt; A + B
end
@named rn = extend(newrn, basern)</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{A} + \mathrm{B} &amp;\xrightleftharpoons[r]{k} \mathrm{C}  
 \end{align*}
 \]</p><p>Here we extended <code>basern</code> with <code>newrn</code> giving a system with all the reactions. Note, if a name is not specified via <code>@named</code> or the <code>name</code> keyword then <code>rn</code> will have the same name as <code>newrn</code>.</p><p>The second main compositional modeling tool is the use of subsystems. Suppose we now add to <code>basern</code> two subsystems, <code>newrn</code> and <code>newestrn</code>, we get a different result:</p><pre><code class="language-julia hljs">newestrn = @network_component rn3 begin
  v, A + D --&gt; 2D
end
@named rn = compose(basern, [newrn, newestrn])</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{A} + \mathrm{B} &amp;\xrightarrow{k} \mathrm{C} \\
\mathrm{\mathtt{rn2.C}} &amp;\xrightarrow{\mathtt{rn2.r}} \mathrm{\mathtt{rn2.A}} + \mathrm{\mathtt{rn2.B}} \\
\mathrm{\mathtt{rn3.A}} + \mathrm{\mathtt{rn3.D}} &amp;\xrightarrow{\mathtt{rn3.v}} 2 \mathrm{\mathtt{rn3.D}}  
 \end{align*}
 \]</p><p>Here we have created a new <code>ReactionSystem</code> that adds <code>newrn</code> and <code>newestrn</code> as subsystems of <code>basern</code>. The variables and parameters in the sub-systems are considered distinct from those in other systems, and so are namespaced (i.e. prefaced) by the name of the system they come from.</p><p>We can see the subsystems of a given system by</p><pre><code class="language-julia hljs">ModelingToolkit.get_systems(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Any}:
 ReactionSystem{Catalyst.NetworkProperties{Int64, SymbolicUtils.BasicSymbolic{Real}}}(Union{Equation, Reaction}[r, C --&gt; A + B], Reaction[r, C --&gt; A + B], t, SymbolicUtils.BasicSymbolic{Real}[], SymbolicUtils.BasicSymbolic{Real}[C(t), A(t), B(t)], SymbolicUtils.BasicSymbolic{Real}[C(t), A(t), B(t)], Any[r], Dict{Symbol, Any}(:A =&gt; A(t), :B =&gt; B(t), :r =&gt; r, :C =&gt; C(t)), Equation[], :rn2, Any[], Dict{Any, Any}(), nothing, Conserved Equations: 
, true, ModelingToolkit.SymbolicContinuousCallback[], ModelingToolkit.SymbolicDiscreteCallback[], nothing, false)
 ReactionSystem{Catalyst.NetworkProperties{Int64, SymbolicUtils.BasicSymbolic{Real}}}(Union{Equation, Reaction}[v, A + D --&gt; 2*D], Reaction[v, A + D --&gt; 2*D], t, SymbolicUtils.BasicSymbolic{Real}[], SymbolicUtils.BasicSymbolic{Real}[A(t), D(t)], SymbolicUtils.BasicSymbolic{Real}[A(t), D(t)], Any[v], Dict{Symbol, Any}(:A =&gt; A(t), :D =&gt; D(t), :v =&gt; v), Equation[], :rn3, Any[], Dict{Any, Any}(), nothing, Conserved Equations: 
, true, ModelingToolkit.SymbolicContinuousCallback[], ModelingToolkit.SymbolicDiscreteCallback[], nothing, false)</code></pre><p>They naturally form a tree-like structure</p><pre><code class="language-julia hljs">using Plots, GraphRecipes
plot(TreePlot(rn), method=:tree, fontsize=12, nodeshape=:ellipse)</code></pre><p><img src="../../assets/rn_treeplot.svg" alt="rn network with subsystems"/></p><p>We could also have directly constructed <code>rn</code> using the same reaction as in <code>basern</code> as</p><pre><code class="language-julia hljs">t = default_t()
@parameters k
@species A(t), B(t), C(t)
rxs = [Reaction(k, [A,B], [C])]
@named rn = ReactionSystem(rxs, t; systems = [newrn, newestrn])</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{A} + \mathrm{B} &amp;\xrightarrow{k} \mathrm{C} \\
\mathrm{\mathtt{rn2.C}} &amp;\xrightarrow{\mathtt{rn2.r}} \mathrm{\mathtt{rn2.A}} + \mathrm{\mathtt{rn2.B}} \\
\mathrm{\mathtt{rn3.A}} + \mathrm{\mathtt{rn3.D}} &amp;\xrightarrow{\mathtt{rn3.v}} 2 \mathrm{\mathtt{rn3.D}}  
 \end{align*}
 \]</p><p>Catalyst provides several different accessors for getting information from a single system, or all systems in the tree. To get the species, parameters, and reactions <em>only</em> within a given system (i.e. ignoring subsystems), we can use</p><pre><code class="language-julia hljs">Catalyst.get_species(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 A(t)
 B(t)
 C(t)</code></pre><pre><code class="language-julia hljs">ModelingToolkit.get_ps(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Any}:
 k</code></pre><pre><code class="language-julia hljs">Catalyst.get_rxs(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Reaction}:
 k, A + B --&gt; C</code></pre><p>To see all the species, parameters and reactions in the tree we can use</p><pre><code class="language-julia hljs">species(rn)   # or unknowns(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 A(t)
 B(t)
 C(t)
 rn2₊C(t)
 rn2₊A(t)
 rn2₊B(t)
 rn3₊A(t)
 rn3₊D(t)</code></pre><pre><code class="language-julia hljs">parameters(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Any}:
 k
 rn2₊r
 rn3₊v</code></pre><pre><code class="language-julia hljs">reactions(rn)   # or equations(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Reaction}:
 k, A + B --&gt; C
 rn2₊r, rn2₊C --&gt; rn2₊A + rn2₊B
 rn3₊v, rn3₊A + rn3₊D --&gt; 2*rn3₊D</code></pre><p>If we want to collapse <code>rn</code> down to a single system with no subsystems we can use</p><pre><code class="language-julia hljs">flatrn = Catalyst.flatten(rn)</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{A} + \mathrm{B} &amp;\xrightarrow{k} \mathrm{C} \\
\mathrm{\mathtt{rn2.C}} &amp;\xrightarrow{\mathtt{rn2.r}} \mathrm{\mathtt{rn2.A}} + \mathrm{\mathtt{rn2.B}} \\
\mathrm{\mathtt{rn3.A}} + \mathrm{\mathtt{rn3.D}} &amp;\xrightarrow{\mathtt{rn3.v}} 2 \mathrm{\mathtt{rn3.D}}  
 \end{align*}
 \]</p><p>where</p><pre><code class="language-julia hljs">ModelingToolkit.get_systems(flatrn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Any[]</code></pre><p>More about ModelingToolkit&#39;s interface for compositional modeling can be found in the <a href="http://docs.sciml.ai/ModelingToolkit/stable/">ModelingToolkit docs</a>.</p><h2 id="Compositional-model-of-the-repressilator"><a class="docs-heading-anchor" href="#Compositional-model-of-the-repressilator">Compositional model of the repressilator</a><a id="Compositional-model-of-the-repressilator-1"></a><a class="docs-heading-anchor-permalink" href="#Compositional-model-of-the-repressilator" title="Permalink"></a></h2><p>Let&#39;s apply the tooling we&#39;ve just seen to create the repressilator in a more modular fashion. We start by defining a function that creates a negatively repressed gene, taking the repressor as input</p><pre><code class="language-julia hljs">function repressed_gene(; R, name)
  @network_component $name begin
    hillr($R,α,K,n), ∅ --&gt; m
    (δ,γ), m &lt;--&gt; ∅
    β, m --&gt; m + P
    μ, P --&gt; ∅
  end
end</code></pre><p>Here we assume the user will pass in the repressor species as a ModelingToolkit variable, and specify a name for the network. We use Catalyst&#39;s interpolation ability to substitute the value of these variables into the DSL (see <a href="../dsl_advanced/#dsl_advanced_options_symbolics_and_DSL_interpolation">Interpolation of Julia Variables</a>). To make the repressilator we now make three genes, and then compose them together</p><pre><code class="language-julia hljs">t = default_t()
@species G3₊P(t)
@named G1 = repressed_gene(; R=ParentScope(G3₊P))
@named G2 = repressed_gene(; R=ParentScope(G1.P))
@named G3 = repressed_gene(; R=ParentScope(G2.P))
@named repressilator = ReactionSystem(t; systems=[G1,G2,G3])</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightleftharpoons[\mathtt{G1.\delta}]{\mathrm{hillr}\left( \mathtt{G3.P}, \mathtt{G1.\alpha}, \mathtt{G1.K}, \mathtt{G1.n} \right)} \mathrm{\mathtt{G1.m}} \\
\varnothing &amp;\xrightarrow{\mathtt{G1.\gamma}} \mathrm{\mathtt{G1.m}} \\
\mathrm{\mathtt{G1.m}} &amp;\xrightarrow{\mathtt{G1.\beta}} \mathrm{\mathtt{G1.m}} + \mathrm{\mathtt{G1.P}} \\
\mathrm{\mathtt{G1.P}} &amp;\xrightarrow{\mathtt{G1.\mu}} \varnothing \\
\varnothing &amp;\xrightleftharpoons[\mathtt{G2.\delta}]{\mathrm{hillr}\left( \mathtt{G1.P}, \mathtt{G2.\alpha}, \mathtt{G2.K}, \mathtt{G2.n} \right)} \mathrm{\mathtt{G2.m}} \\
\varnothing &amp;\xrightarrow{\mathtt{G2.\gamma}} \mathrm{\mathtt{G2.m}} \\
\mathrm{\mathtt{G2.m}} &amp;\xrightarrow{\mathtt{G2.\beta}} \mathrm{\mathtt{G2.m}} + \mathrm{\mathtt{G2.P}} \\
\mathrm{\mathtt{G2.P}} &amp;\xrightarrow{\mathtt{G2.\mu}} \varnothing \\
\varnothing &amp;\xrightleftharpoons[\mathtt{G3.\delta}]{\mathrm{hillr}\left( \mathtt{G2.P}, \mathtt{G3.\alpha}, \mathtt{G3.K}, \mathtt{G3.n} \right)} \mathrm{\mathtt{G3.m}} \\
\varnothing &amp;\xrightarrow{\mathtt{G3.\gamma}} \mathrm{\mathtt{G3.m}} \\
\mathrm{\mathtt{G3.m}} &amp;\xrightarrow{\mathtt{G3.\beta}} \mathrm{\mathtt{G3.m}} + \mathrm{\mathtt{G3.P}} \\
\mathrm{\mathtt{G3.P}} &amp;\xrightarrow{\mathtt{G3.\mu}} \varnothing  
 \end{align*}
 \]</p><p>Notice, in this system each gene is a child node in the system graph of the repressilator</p><pre><code class="language-julia hljs">plot(TreePlot(repressilator), method=:tree, fontsize=12, nodeshape=:ellipse)</code></pre><p><img src="../../assets/repressilator_treeplot.svg" alt="repressilator tree plot"/></p><p>In building the repressilator we needed to use two new features. First, we needed to create a symbolic variable that corresponds to the protein produced by the third gene before we created the corresponding system. We did this via <code>@variables G3₊P(t)</code>. We also needed to set the scope where each repressor lived. Here <code>ParentScope(G3₊P)</code>, <code>ParentScope(G1.P)</code>, and <code>ParentScope(G2.P)</code> signal Catalyst that these variables will come from parallel systems in the tree that have the same parent as the system being constructed (in this case the top-level <code>repressilator</code> system).</p><h2 id="Compartment-based-models"><a class="docs-heading-anchor" href="#Compartment-based-models">Compartment-based models</a><a id="Compartment-based-models-1"></a><a class="docs-heading-anchor-permalink" href="#Compartment-based-models" title="Permalink"></a></h2><p>Finally, let&#39;s see how we can make a compartment-based model. Let&#39;s create a simple eukaryotic gene expression model with negative feedback by protein dimers. Transcription and gene inhibition by the protein dimer occurs in the nucleus, translation and dimerization occur in the cytosol, and nuclear import and export reactions couple the two compartments. We&#39;ll include volume parameters for the nucleus and cytosol, and assume we are working with species having units of number of molecules. Rate constants will have their common concentration units, i.e. if <span>$V$</span> denotes the volume of a compartment then</p><table><tr><th style="text-align: center">Reaction Type</th><th style="text-align: center">Example</th><th style="text-align: center">Rate Constant Units</th><th style="text-align: center">Effective rate constant (units of per time)</th></tr><tr><td style="text-align: center">Zero order</td><td style="text-align: center"><span>$\varnothing \overset{\alpha}{\to} A$</span></td><td style="text-align: center">concentration / time</td><td style="text-align: center"><span>$\alpha V$</span></td></tr><tr><td style="text-align: center">First order</td><td style="text-align: center"><span>$A \overset{\beta}{\to} B$</span></td><td style="text-align: center">(time)⁻¹</td><td style="text-align: center"><span>$\beta$</span></td></tr><tr><td style="text-align: center">Second order</td><td style="text-align: center"><span>$A + B \overset{\gamma}{\to} C$</span></td><td style="text-align: center">(concentration × time)⁻¹</td><td style="text-align: center"><span>$\gamma/V$</span></td></tr></table><p>In our model we&#39;ll therefore add the conversions of the last column to properly account for compartment volumes:</p><pre><code class="language-julia hljs"># transcription and regulation
nuc = @network_component nuc begin
  α, G --&gt; G + M
  (κ₊/V,κ₋), D + G &lt;--&gt; DG
end

# translation and dimerization
cyto = @network_component cyto begin
  β, M --&gt; M + P
  (k₊/V,k₋), 2P &lt;--&gt; D
  σ, P --&gt; 0
  μ, M --&gt; 0
end

# export reactions,
# γ,δ=probability per time to be exported/imported
model = @network_component model begin
  γ, $(nuc.M) --&gt; $(cyto.M)
  δ, $(cyto.D) --&gt; $(nuc.D)
end
@named model = compose(model, [nuc, cyto])</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{\mathtt{nuc.M}} &amp;\xrightarrow{\gamma} \mathrm{\mathtt{cyto.M}} \\
\mathrm{\mathtt{cyto.D}} &amp;\xrightarrow{\delta} \mathrm{\mathtt{nuc.D}} \\
\mathrm{\mathtt{nuc.G}} &amp;\xrightarrow{\mathtt{nuc.\alpha}} \mathrm{\mathtt{nuc.G}} + \mathrm{\mathtt{nuc.M}} \\
\mathrm{\mathtt{nuc.D}} + \mathrm{\mathtt{nuc.G}} &amp;\xrightleftharpoons[\mathtt{nuc.\kappa_-}]{\frac{\mathtt{nuc.\kappa.}}{\mathtt{nuc.V}}} \mathrm{\mathtt{nuc.DG}} \\
\mathrm{\mathtt{cyto.M}} &amp;\xrightarrow{\mathtt{cyto.\beta}} \mathrm{\mathtt{cyto.M}} + \mathrm{\mathtt{cyto.P}} \\
2 \mathrm{\mathtt{cyto.P}} &amp;\xrightleftharpoons[\mathtt{cyto.k_-}]{\frac{\mathtt{cyto.k.}}{\mathtt{cyto.V}}} \mathrm{\mathtt{cyto.D}} \\
\mathrm{\mathtt{cyto.P}} &amp;\xrightarrow{\mathtt{cyto.\sigma}} \varnothing \\
\mathrm{\mathtt{cyto.M}} &amp;\xrightarrow{\mathtt{cyto.\mu}} \varnothing  
 \end{align*}
 \]</p><p>A graph of the resulting network is</p><pre><code class="language-julia hljs">Graph(model)</code></pre><p><img src="../../assets/compartment_gene_regulation.svg" alt="graph of gene regulation model"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../programmatic_CRN_construction/">« Programmatic Construction of Symbolic Reaction Systems</a><a class="docs-footer-nextpage" href="../constraint_equations/">Constraint Equations and Events »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 25 October 2024 14:37">Friday 25 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
