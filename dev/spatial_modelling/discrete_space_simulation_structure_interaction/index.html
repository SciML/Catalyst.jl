<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interfacing with Lattice Problems, Integrators, and Solutions · Catalyst.jl</title><meta name="title" content="Interfacing with Lattice Problems, Integrators, and Solutions · Catalyst.jl"/><meta property="og:title" content="Interfacing with Lattice Problems, Integrators, and Solutions · Catalyst.jl"/><meta property="twitter:title" content="Interfacing with Lattice Problems, Integrators, and Solutions · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/spatial_modelling/discrete_space_simulation_structure_interaction/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/spatial_modelling/discrete_space_simulation_structure_interaction/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/spatial_modelling/discrete_space_simulation_structure_interaction/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Introduction to Catalyst</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Model creation and properties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/coupled_non_crn_models/">Coupled non-reaction network equations to models</a></li><li><a class="tocitem" href="../../model_creation/events/">Modelling Events</a></li><li><a class="tocitem" href="../../model_creation/conservation_laws/">Working with Conservation Laws</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stoichiometries</a></li><li><a class="tocitem" href="../../model_creation/functional_parameters/">Inputs and time-dependent (or functional) parameters</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/reactionsystem_content_accessing/">Accessing Model Properties</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related Functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-14" type="checkbox"/><label class="tocitem" for="menuitem-3-14"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, Generative, Modelling of a Linear Pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/noise_modelling_approaches/">Approaches for modelling system noise</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Model simulation and visualization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation Plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for Performant ODE Simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for Performant SDE Simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/examples/periodic_events_simulation/">Modelling a Periodic Event During ODE and Jump Simulations</a></li><li><a class="tocitem" href="../../model_simulation/examples/activation_time_distribution_measurement/">Measuring the Distribution of System Activation Times</a></li><li><a class="tocitem" href="../../model_simulation/examples/interactive_brusselator_simulation/">Interactive Simulation and Plotting</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Network Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../network_analysis/odes/">Decomposing the Reaction Network ODEs</a></li><li><a class="tocitem" href="../../network_analysis/crn_theory/">Chemical Reaction Network Theory</a></li><li><a class="tocitem" href="../../network_analysis/network_properties/">Caching of Network Properties in <code>ReactionSystems</code></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Steady state analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing Model Steady State Properties with DynamicalSystems.jl</a></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/examples/nullcline_plotting/">Plotting Nullclines and Steady States in Phase Space</a></li><li><a class="tocitem" href="../../steady_state_functionality/examples/bifurcationkit_periodic_orbits/">Computing Periodic Orbits (Oscillations) Using BifurcationKit.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/examples/bifurcationkit_codim2/">Tracking Bifurcation Point w.r.t. Secondary Parameters using BifurcationKit.jl</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Inverse problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for Non-data Fitting Purposes</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">Spatial modelling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../discrete_space_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li class="is-active"><a class="tocitem" href>Interfacing with Lattice Problems, Integrators, and Solutions</a><ul class="internal"><li><a class="tocitem" href="#dspace_simulation_structure_interaction_simulation_species"><span>Retrieving values from space simulations</span></a></li><li><a class="tocitem" href="#dspace_simulation_structure_interaction_prob_int_species"><span>Retrieving and updating species values in problems and integrators</span></a></li><li><a class="tocitem" href="#dspace_simulation_structure_interaction_prob_int_parameters"><span>Retrieving and updating parameter values in problems and integrators</span></a></li></ul></li><li><a class="tocitem" href="../discrete_space_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../spatial_jump_simulations/">Spatial Jump Simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/core_api/">Catalyst.jl API</a></li><li><a class="tocitem" href="../../api/network_analysis_api/">Network analysis and representations</a></li></ul></li><li><a class="tocitem" href="../../devdocs/dev_guide/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Spatial modelling</a></li><li class="is-active"><a href>Interfacing with Lattice Problems, Integrators, and Solutions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interfacing with Lattice Problems, Integrators, and Solutions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/spatial_modelling/discrete_space_simulation_structure_interaction.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="dspace_simulation_structure_interaction"><a class="docs-heading-anchor" href="#dspace_simulation_structure_interaction">Interfacing with Lattice Problems, Integrators, and Solutions</a><a id="dspace_simulation_structure_interaction-1"></a><a class="docs-heading-anchor-permalink" href="#dspace_simulation_structure_interaction" title="Permalink"></a></h1><p>We have <a href="../../model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing">previously described</a> how to retrieve species and parameter values stored in non-spatial problems, integrators, and solutions. This section describes similar workflows for simulations based on <a href="../../api/core_api/#Catalyst.DiscreteSpaceReactionSystem"><code>DiscreteSpaceReactionSystem</code></a>s.</p><p>Generally, while for non-spatial systems these operations can typically be done by indexing a structure directly, e.g. through</p><pre><code class="language-julia hljs">sol[:X]</code></pre><p>there are no equally straightforward interfaces for spatial simulations. Typically, helper functions have to be used, e.g</p><pre><code class="language-julia hljs">spat_getu(sol, :X, dsrs)</code></pre><p>Furthermore, there are some cases of interfacing which are currently not supported (e.g. updating parameter values in <code>JumpProblem</code>s). It is likely that these interfaces will be improved in the future (i.e. by introducing a similar syntax to the current non-spatial one). Finally, we note that many of the functions presented below have not been as extensively optimised for performance as other parts of the Catalyst package. Hence, you should take care when designing workflows which requires using them a large number of times.</p><div class="admonition is-info" id="Note-aafc6c72b93302a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-aafc6c72b93302a" title="Permalink"></a></header><div class="admonition-body"><p>Below we will describe various features using ODE simulations as examples. However, all interfaces (unless where else is stated) work identically for jump simulations.</p></div></div><h2 id="dspace_simulation_structure_interaction_simulation_species"><a class="docs-heading-anchor" href="#dspace_simulation_structure_interaction_simulation_species">Retrieving values from space simulations</a><a id="dspace_simulation_structure_interaction_simulation_species-1"></a><a class="docs-heading-anchor-permalink" href="#dspace_simulation_structure_interaction_simulation_species" title="Permalink"></a></h2><p>Let us consider a simulation of a <a href="../../api/core_api/#Catalyst.DiscreteSpaceReactionSystem"><code>DiscreteSpaceReactionSystem</code></a>:</p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEqDefault
two_state_model = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
diffusion_rx = @transport_reaction D X1
space = CartesianGrid((2,3))
dsrs = DiscreteSpaceReactionSystem(two_state_model, [diffusion_rx], space)

u0 = [:X1 =&gt; [0.0 0.0 0.0; 2.0 2.0 2.0], :X2 =&gt; 0.0]
tspan = (0.0, 1.0)
ps = [:k1 =&gt; 2.0, :k2 =&gt; 1.0, :D =&gt; 0.1]
oprob = ODEProblem(dsrs, u0, tspan, ps)
sol = solve(oprob)</code></pre><p>To retrieve the values of <span>$X1$</span> across the simulation we use the <code>spat_getu</code> function. It takes three arguments:</p><ul><li>The solution objects from which we wish to retrieve values.</li><li>The species which values we wish to retrieve.</li><li>The <a href="../../api/core_api/#Catalyst.DiscreteSpaceReactionSystem"><code>DiscreteSpaceReactionSystem</code></a> which was simulated.</li></ul><pre><code class="language-julia hljs">spat_getu(sol, :X1, dsrs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">13-element Vector{Matrix{Float64}}:
 [0.0 0.0 0.0; 2.0 2.0 2.0]
 [4.988650432250024e-5 4.988650432250024e-5 4.988650432250024e-5; 1.998952234018206 1.998952234018206 1.998952234018206]
 [0.0015994098596290472 0.0015994098596290468 0.0015994098596290468; 1.9662565141734996 1.9662565141734996 1.9662565141734996]
 [0.006741869491010844 0.006741869491010845 0.006741869491010842; 1.855502160116329 1.855502160116329 1.855502160116329]
 [0.01355081075481047 0.013550810754810462 0.013550810754810462; 1.702703357005269 1.7027033570052692 1.7027033570052692]
 [0.0204930381654264 0.020493038165426396 0.020493038165426396; 1.537824096293561 1.5378240962935612 1.5378240962935612]
 [0.02763175512173649 0.027631755121736486 0.027631755121736486; 1.355363254694714 1.3553632546947145 1.3553632546947143]
 [0.033988149343616804 0.033988149343616804 0.033988149343616804; 1.1772810888015772 1.1772810888015774 1.1772810888015774]
 [0.03926508463610621 0.03926508463610619 0.0392650846361062; 1.0136799749984404 1.0136799749984409 1.0136799749984406]
 [0.04330815246913715 0.043308152469137134 0.04330815246913714; 0.8779099376986549 0.8779099376986553 0.8779099376986551]
 [0.04646902281200698 0.046469022812006974 0.046469022812006974; 0.7743567480560556 0.7743567480560558 0.7743567480560557]
 [0.04931423791408972 0.04931423791408969 0.04931423791408971; 0.7024560846037331 0.7024560846037332 0.7024560846037332]
 [0.05042583464814037 0.05042583464814035 0.050425834648140364; 0.6826247254740523 0.6826247254740524 0.6826247254740524]</code></pre><p>Here, the output is a vector with <span>$X1$</span>&#39;s value at each simulation time step. How the species&#39;s value is represented at each time step depends on the space which was originally used to create the <a href="../../api/core_api/#Catalyst.DiscreteSpaceReactionSystem"><code>DiscreteSpaceReactionSystem</code></a>:</p><ul><li>For Cartesian spaces, an array of the same size as the Cartesian space is used. Each array element corresponds to the species&#39;s value in the corresponding compartment.</li><li>For masked spaces, a <a href="https://docs.julialang.org/en/v1/stdlib/SparseArrays/">sparse array</a> of the same size as the masked space is used. Each filled array element corresponds to the species&#39;s value in the corresponding compartment. Unfilled array elements correspond to positions without compartments.</li><li>For unstructured (graph) spaces, vectors are used. The i&#39;th element in the vectors corresponds to the species&#39;s value in the i&#39;th compartment.</li></ul><p>Unlike for non-spatial simulations, <code>spat_getu</code> does not take vector (e.g. <code>spat_getu(sol, [:X1, :X2], dsrs)</code>) or symbolic expression (e.g. <code>spat_getu(sol, [X1 + X2], dsrs)</code>) inputs. However, it is possible to use symbolic variables as input (e.g. <code>spat_getu(sol, two_state_model.X1, dsrs)</code>).</p><h3 id="dspace_simulation_structure_interaction_simulation_species_ts"><a class="docs-heading-anchor" href="#dspace_simulation_structure_interaction_simulation_species_ts">Retrieving space simulations values at specific time points</a><a id="dspace_simulation_structure_interaction_simulation_species_ts-1"></a><a class="docs-heading-anchor-permalink" href="#dspace_simulation_structure_interaction_simulation_species_ts" title="Permalink"></a></h3><p>Just like for non-spatial solutions, it is possible to access the simulation&#39;s values at designated time points. This is possible even if the simulation did not stop at those specific time points (in which case an interpolated value is returned). To do this, the desired time points to sample are provided as a vector to <code>spat_getu</code> using the optional argument <code>t</code>. E.g. here we retrieve the simulation&#39;s (interpolated) values at time points <code>0.5</code> and <code>0.75</code>:</p><pre><code class="language-julia hljs">spat_getu(sol, :X1, dsrs; t = [0.5, 0.75])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Matrix{Float64}}:
 [0.04200964753322919 0.04200964753322917 0.04200964753322918; 0.9221632149303303 0.9221632149303307 0.9221632149303305]
 [0.04694917305777516 0.04694917305777516 0.046949173057775156; 0.7602489262069799 0.7602489262069801 0.76024892620698]</code></pre><h2 id="dspace_simulation_structure_interaction_prob_int_species"><a class="docs-heading-anchor" href="#dspace_simulation_structure_interaction_prob_int_species">Retrieving and updating species values in problems and integrators</a><a id="dspace_simulation_structure_interaction_prob_int_species-1"></a><a class="docs-heading-anchor-permalink" href="#dspace_simulation_structure_interaction_prob_int_species" title="Permalink"></a></h2><p>Let us consider a spatial <code>ODEProblem</code></p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEqDefault
two_state_model = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
diffusion_rx = @transport_reaction D X1
space = CartesianGrid((2,3))
dsrs = DiscreteSpaceReactionSystem(two_state_model, [diffusion_rx], space)

u0 = [:X1 =&gt; [0.0 0.0 0.0; 2.0 2.0 2.0], :X2 =&gt; 0.0]
tspan = (0.0, 1.0)
ps = [:k1 =&gt; 2.0, :k2 =&gt; 1.0, :D =&gt; 0.1]
oprob = ODEProblem(dsrs, u0, tspan, ps)</code></pre><p>We can retrieve the species values stored in <code>oprob</code> using the <code>spat_getu</code> function. It uses <a href="#dspace_simulation_structure_interaction_simulation_species">identical syntax as for simulations</a> (except that you cannot specify a time point). However, it returns a single set of species values (while for simulations it returns a vector across different time steps):</p><pre><code class="language-julia hljs">spat_getu(oprob, :X1, dsrs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3 Matrix{Float64}:
 0.0  0.0  0.0
 2.0  2.0  2.0</code></pre><p>Again, the format used corresponds to the space used to create the original <a href="../../api/core_api/#Catalyst.DiscreteSpaceReactionSystem"><code>DiscreteSpaceReactionSystem</code></a>. Here, even if a species has homogeneous values, the full format is used.</p><pre><code class="language-julia hljs">spat_getu(oprob, :X2, dsrs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3 Matrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p>For both problems and integrators, species values can be updated using the <code>spat_setu!</code> function. It uses a similar syntax as <code>spat_getu</code>, but takes a fourth argument which is the new values to use for the designated species:</p><pre><code class="language-julia hljs">spat_setu!(oprob, :X1, dsrs, [1.0 2.0 3.0; 4.0 5.0 6.0])</code></pre><p>Here, the same format (which depends on the used space) is used for the species&#39;s new values, as which is used when initially designating their initial conditions. I.e. to make <span>$X1$</span>&#39;s initial condition values uniform we can call</p><pre><code class="language-julia hljs">spat_setu!(oprob, :X1, dsrs, 1.0)</code></pre><div class="admonition is-info" id="Note-aea19f2a693febe0"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-aea19f2a693febe0" title="Permalink"></a></header><div class="admonition-body"><p>It is currently not possible to change a species value at a single compartment only. To do so, you must first retrieve its values across all compartments using <code>spat_getu</code>, then modify this at the desired compartment, and then use the modified version as input to <code>spat_setu!</code>.</p></div></div><p>Species values in <a href="../../model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_integrators">integrators</a> can be interfaced with using identical syntax as for problems.</p><h2 id="dspace_simulation_structure_interaction_prob_int_parameters"><a class="docs-heading-anchor" href="#dspace_simulation_structure_interaction_prob_int_parameters">Retrieving and updating parameter values in problems and integrators</a><a id="dspace_simulation_structure_interaction_prob_int_parameters-1"></a><a class="docs-heading-anchor-permalink" href="#dspace_simulation_structure_interaction_prob_int_parameters" title="Permalink"></a></h2><p>Retrieval and updating of parameter values for problems and integrators works similarly as for species, but with the following differences:</p><ul><li>The <code>spat_getp</code> and <code>spat_setp!</code> functions are used.</li><li>It is currently not possible to interface with parameter values of <code>JumpProblem</code>s and their integrators.</li><li>After parameter values are modified, the <code>rebuild_spat_internals!</code> function must be applied before the problem/integrator can be used for further analysis.</li><li>Updating of <a href="../discrete_space_reaction_systems/#spatial_dspace_modelling_intro_simulation_edge_parameters">edge parameters</a> is limited and uses a different interface. </li></ul><p>Let us consider the spatial <code>ODEProblem</code> we previously declared. We can check the value of <span>$k1$</span> by using <code>spat_getp</code></p><pre><code class="language-julia hljs">spat_getp(oprob, :k1, dsrs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3 Matrix{Float64}:
 2.0  2.0  2.0
 2.0  2.0  2.0</code></pre><p>Next, we can update it using <code>spat_setp!</code> (here we also confirm that it now has the updated values):</p><pre><code class="language-julia hljs">spat_setp!(oprob, :k1, dsrs, [1.0 2.0 3.0; 4.0 5.0 6.0])
spat_getp(oprob, :k1, dsrs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3 Matrix{Float64}:
 1.0  2.0  3.0
 4.0  5.0  6.0</code></pre><p>If we now were to simulate <code>oprob</code>, the simulation would not take the updated value of <span>$k1$</span> into account. For our changes to take effect we might first need to call <code>rebuild_spat_internals!</code> with <code>oprob</code> as an input</p><pre><code class="language-julia hljs">rebuild_spat_internals!(oprob)</code></pre><p>There are two different circumstances when <code>rebuild_spat_internals!</code> must be called:</p><ul><li>When modifying the value of an <a href="../discrete_space_reaction_systems/#spatial_dspace_modelling_intro_simulation_edge_parameters">edge parameter</a>.</li><li>When changing a parameter from having spatially uniform values to spatially non-uniform values, or the other way around.</li></ul><p>Parameter values of integrators can be interfaced with just like for problems (this is primarily relevant when using <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/"><em>callbacks</em></a>). Again, after doing so, the <code>rebuild_spat_internals!</code> function might need to be applied to the integrator.</p><h3 id="dspace_simulation_structure_interaction_prob_int_parameters_edge_ps"><a class="docs-heading-anchor" href="#dspace_simulation_structure_interaction_prob_int_parameters_edge_ps">Retrieving and updatingedge  parameter values in problems and integrators</a><a id="dspace_simulation_structure_interaction_prob_int_parameters_edge_ps-1"></a><a class="docs-heading-anchor-permalink" href="#dspace_simulation_structure_interaction_prob_int_parameters_edge_ps" title="Permalink"></a></h3><p>The <code>spat_getp</code> and <code>spat_setp!</code> functions cannot currently be applied to <a href="../discrete_space_reaction_systems/#spatial_dspace_modelling_intro_simulation_edge_parameters">edge parameters</a>. Instead, to access the value of an edge parameter, use </p><pre><code class="language-julia hljs">oprob.ps[:D]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×1 SparseArrays.SparseMatrixCSC{Float64, Int64} with 1 stored entry:
 0.1</code></pre><p>To update an edge parameter&#39;s value, use</p><pre><code class="language-julia hljs">oprob.ps[:D] = [0.2]</code></pre><p>This interface is somewhat limited, and the following aspects should be noted:</p><ul><li>Edge parameter values can only be interfaced with if the edge parameter&#39;s value is spatially uniform.</li><li>When accessing an (spatially uniform) edge parameter&#39;s value, its single value will be encapsulated in a vector.</li><li>When setting an (spatially uniform) edge parameter&#39;s value, you must encapsulate the new value in a vector.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../discrete_space_reaction_systems/">« Introduction to Spatial Modelling with Catalyst</a><a class="docs-footer-nextpage" href="../discrete_space_simulation_plotting/">Plotting Spatial Simulations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Friday 27 February 2026 13:54">Friday 27 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
