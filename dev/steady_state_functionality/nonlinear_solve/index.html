<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl · Catalyst.jl</title><meta name="title" content="Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl · Catalyst.jl"/><meta property="og:title" content="Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl · Catalyst.jl"/><meta property="twitter:title" content="Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/steady_state_functionality/nonlinear_solve/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/steady_state_functionality/nonlinear_solve/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/steady_state_functionality/nonlinear_solve/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Introduction to Catalyst</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Model creation and properties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../model_creation/conservation_laws/">Working with conservation laws</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/reactionsystem_content_accessing/">Accessing model properties</a></li><li><a class="tocitem" href="../../model_creation/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Model simulation and visualization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for performant ODE simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for performant SDE simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/examples/periodic_events_simulation/">Modelling a periodic event during ODE and jump simulations</a></li><li><a class="tocitem" href="../../model_simulation/examples/interactive_brusselator_simulation/">Interactive Simulation and Plotting</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Steady state analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li class="is-active"><a class="tocitem" href>Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a><ul class="internal"><li><a class="tocitem" href="#steady_state_solving_nonlinear"><span>Steady state finding through nonlinear solving</span></a></li><li><a class="tocitem" href="#steady_state_solving_simulation"><span>Finding steady states through ODE simulations</span></a></li><li><a class="tocitem" href="#nonlinear_solve_citation"><span>Citations</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Inverse problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/petab_ode_param_fitting/">Parameter Fitting for ODEs using PEtab.jl</a></li><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Spatial modelling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial jump simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../devdocs/dev_guide/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Steady state analysis</a></li><li class="is-active"><a href>Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/steady_state_functionality/nonlinear_solve.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="steady_state_solving"><a class="docs-heading-anchor" href="#steady_state_solving">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a><a id="steady_state_solving-1"></a><a class="docs-heading-anchor-permalink" href="#steady_state_solving" title="Permalink"></a></h1><p>Catalyst <code>ReactionSystem</code> models can be converted to ODEs (through <a href="../../introduction_to_catalyst/introduction_to_catalyst/#introduction_to_catalyst_ratelaws">the reaction rate equation</a>). We have previously described how these ODEs&#39; steady states can be found through <a href="../homotopy_continuation/#homotopy_continuation">homotopy continuation</a>. Generally, homotopy continuation (due to its ability to find <em>all</em> of a system&#39;s steady states) is the preferred approach. However, Catalyst supports two additional approaches for finding steady states:</p><ul><li>Through solving the nonlinear system produced by setting all ODE differentials to 0<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</li><li>Through forward ODE simulation from an initial condition until a steady state has been reached.</li></ul><p>While these approaches only find a single steady state, they offer two advantages as compared to homotopy continuation:</p><ul><li>They are typically much faster.</li><li>They can find steady states for models that do not produce multivariate, rational, polynomial systems (which is a requirement for homotopy continuation to work). Examples include models with non-integer hill coefficients.</li></ul><p>In practice, model steady states are found through <a href="#steady_state_solving_nonlinear">nonlinear system solving</a> by creating a <code>NonlinearProblem</code>, and through forward ODE simulation by creating a <code>SteadyStateProblem</code>. These are then solved through solvers implemented in the <a href="https://github.com/SciML/NonlinearSolve.jl">NonlinearSolve.jl</a>, package (with the latter approach also requiring the <a href="https://github.com/SciML/SteadyStateDiffEq.jl">SteadyStateDiffEq.jl</a> package). This tutorial describes how to find steady states through these two approaches. More extensive descriptions of available solvers and options can be found in <a href="https://docs.sciml.ai/NonlinearSolve/stable/">NonlinearSolve&#39;s documentation</a>.</p><h2 id="steady_state_solving_nonlinear"><a class="docs-heading-anchor" href="#steady_state_solving_nonlinear">Steady state finding through nonlinear solving</a><a id="steady_state_solving_nonlinear-1"></a><a class="docs-heading-anchor-permalink" href="#steady_state_solving_nonlinear" title="Permalink"></a></h2><p>Let us consider a simple dimerisation system, where a protein (<span>$P$</span>) can exist in a monomer and a dimer form. The protein is produced at a constant rate from its mRNA, which is also produced at a constant rate.</p><pre><code class="language-julia hljs">using Catalyst
dimer_production = @reaction_network begin
    pₘ, 0 --&gt; mRNA
    pₚ, mRNA --&gt; mRNA + P
    (k₁, k₂), 2P &lt;--&gt; P₂
    d, (mRNA, P, P₂) --&gt; 0
end</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightarrow{\mathtt{p_m}} \mathrm{\mathtt{mRNA}} \\
\mathrm{\mathtt{mRNA}} &amp;\xrightarrow{\mathtt{p_p}} \mathrm{\mathtt{mRNA}} + \mathrm{P} \\
2 \mathrm{P} &amp;\xrightleftharpoons[\mathtt{k_2}]{\mathtt{k_1}} \mathrm{\mathtt{P_2}} \\
\mathrm{\mathtt{mRNA}} &amp;\xrightarrow{d} \varnothing \\
\mathrm{P} &amp;\xrightarrow{d} \varnothing \\
\mathrm{\mathtt{P_2}} &amp;\xrightarrow{d} \varnothing  
 \end{align*}
 \]</p><p>This system corresponds to the following ODE:</p><p class="math-container">\[\begin{aligned}
\frac{dmRNA}{dt} &amp;= pₘ - d \cdot mRNA \\
\frac{dP}{dt} &amp;= pₚ \cdot mRNA - k₁ \cdot P + 2k₂ \cdot P₂ - d \cdot P \\
\frac{dP₂}{dt} &amp;= k₁ \cdot P + 2k₂ \cdot P₂ \\
\end{aligned}\]</p><p>To find its steady states we need to solve:</p><p class="math-container">\[\begin{aligned}
0 &amp;= pₘ - d \cdot mRNA \\
0 &amp;= pₚ \cdot mRNA - k₁ \cdot P + 2k₂ \cdot P₂ - d \cdot P \\
0 &amp;= k₁ \cdot P + 2k₂ \cdot P₂ \\
\end{aligned}\]</p><p>To solve this problem, we must first designate our parameter values, and also make an initial guess of the solution. Generally, for problems with a single solution (like this one), most arbitrary guesses will work fine (the exception typically being <a href="#steady_state_solving_nonlinear_conservation_laws">systems with conservation laws</a>). Using these, we can create the <code>NonlinearProblem</code> that we wish to solve.</p><pre><code class="language-julia hljs">p = [:pₘ =&gt; 0.5, :pₚ =&gt; 2.0, :k₁ =&gt; 5.0, :k₂ =&gt; 1.0, :d =&gt; 1.0]
u_guess = [:mRNA =&gt; 1.0, :P =&gt; 1.0, :P₂ =&gt; 1.0]
nlprob = NonlinearProblem(dimer_production, u_guess, p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"><span class="sgr1">┌ Warning: </span></span>Ingored unsupported keyword arguments: check_length = false
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ HomotopyContinuation ~/.julia/packages/HomotopyContinuation/HdN5z/src/utils.jl:170</span></code></pre><p>Finally, we can solve it using the <code>solve</code> command, returning the steady state solution:</p><pre><code class="language-julia hljs">using NonlinearSolve
sol = solve(nlprob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 3-element Vector{Float64}:
 0.5
 0.46332495807108
 0.26833752096446</code></pre><p>Typically, a good default method is automatically selected for any problem. However, NonlinearSolve does provide <a href="https://docs.sciml.ai/NonlinearSolve/stable/solvers/NonlinearSystemSolvers/">a wide range of potential solvers</a>. If we wish to designate one, it can be supplied as a second argument to <code>solve</code>. Here, we use the <a href="https://en.wikipedia.org/wiki/Trust_region">Newton Trust Region method</a>, and then check that the solution is equal to the previous one.</p><pre><code class="language-julia hljs">sol_ntr = solve(nlprob, TrustRegion())
sol ≈ sol_ntr</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h3 id="steady_state_solving_nonlinear_conservation_laws"><a class="docs-heading-anchor" href="#steady_state_solving_nonlinear_conservation_laws">Systems with conservation laws</a><a id="steady_state_solving_nonlinear_conservation_laws-1"></a><a class="docs-heading-anchor-permalink" href="#steady_state_solving_nonlinear_conservation_laws" title="Permalink"></a></h3><p>As described in the section on homotopy continuation, when finding the steady states of systems with conservation laws, <a href="../homotopy_continuation/#homotopy_continuation_conservation_laws">additional considerations have to be taken</a>. E.g. consider the following <a href="../../model_creation/examples/basic_CRN_library/#basic_CRN_library_two_states">two-state system</a>:</p><pre><code class="language-julia hljs">two_state_model = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{\mathtt{X1}} &amp;\xrightleftharpoons[\mathtt{k2}]{\mathtt{k1}} \mathrm{\mathtt{X2}}  
 \end{align*}
 \]</p><p>It has an infinite number of steady states. To make steady state finding possible, information of the system&#39;s conserved quantities (here <span>$C = X1 + X2$</span>) must be provided. Since these can be computed from system initial conditions (<code>u0</code>, i.e. those provided when performing ODE simulations), designating an <code>u0</code> is often the best way. There are two ways to do this. First, one can perform <a href="#steady_state_solving_simulation">forward ODE simulation-based steady state finding</a>, using the initial condition as the initial <code>u</code> guess. Alternatively, any conserved quantities can be eliminated when the <code>NonlinearProblem</code> is created. This feature is supported by <a href="../../model_creation/conservation_laws/#conservation_laws">Catalyst&#39;s conservation law finding and elimination feature</a>.</p><p>To eliminate conservation laws we simply provide the <code>remove_conserved = true</code> argument to <code>NonlinearProblem</code>:</p><pre><code class="language-julia hljs">p = [:k1 =&gt; 2.0, :k2 =&gt; 3.0]
u_guess = [:X1 =&gt; 3.0, :X2 =&gt; 1.0]
nl_prob = NonlinearProblem(two_state_model, u_guess, p; remove_conserved = true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"><span class="sgr1">┌ Warning: </span></span>You are creating a system or problem while eliminating conserved quantities. Please note,
<span class="sgr33"><span class="sgr1">│ </span></span>        due to limitations / design choices in ModelingToolkit if you use the created system to
<span class="sgr33"><span class="sgr1">│ </span></span>        create a problem (e.g. an `ODEProblem`), or are directly creating a problem, you *should not*
<span class="sgr33"><span class="sgr1">│ </span></span>        modify that problem&#39;s initial conditions for species (e.g. using `remake`). Changing initial
<span class="sgr33"><span class="sgr1">│ </span></span>        conditions must be done by creating a new Problem from your reaction system or the
<span class="sgr33"><span class="sgr1">│ </span></span>        ModelingToolkit system you converted it into with the new initial condition map.
<span class="sgr33"><span class="sgr1">│ </span></span>        Modification of parameter values is still possible, *except* for the modification of any
<span class="sgr33"><span class="sgr1">│ </span></span>        conservation law constants (Γ), which is not possible. You might
<span class="sgr33"><span class="sgr1">│ </span></span>        get this warning when creating a problem directly.
<span class="sgr33"><span class="sgr1">│ </span></span>
<span class="sgr33"><span class="sgr1">│ </span></span>        You can remove this warning by setting `remove_conserved_warn = false`.
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ Catalyst ~/work/Catalyst.jl/Catalyst.jl/src/reactionsystem_conversions.jl:456</span>
<span class="sgr33"><span class="sgr1">┌ Warning: </span></span>Ingored unsupported keyword arguments: check_length = false
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ HomotopyContinuation ~/.julia/packages/HomotopyContinuation/HdN5z/src/utils.jl:170</span></code></pre><p>here it is important that the quantities used in <code>u_guess</code> correspond to the conserved quantities we wish to use. E.g. here the conserved quantity <span>$X1 + X2 = 3.0 + 1.0 = 4$</span> holds for the initial condition, and will hence also hold in the computed steady state as well. We can now find the steady states using <code>solve</code> like before: &lt;!– ```@example steady<em>state</em>solving<em>claws sol = solve(nl</em>prob)</p><pre><code class="language--- hljs">We note that the output only provides a single value. The reason is that the actual system solved only contains a single equation (the other being eliminated with the conserved quantity). To find the values of $X1$ and $X2$ we can [directly query the solution object for these species&#39; values, using the species themselves as inputs](@ref simulation_structure_interfacing_solutions):
&lt;!--```@example steady_state_solving_claws
sol[[:X1, :X2]]</code></pre><p>–&gt;</p><h2 id="steady_state_solving_simulation"><a class="docs-heading-anchor" href="#steady_state_solving_simulation">Finding steady states through ODE simulations</a><a id="steady_state_solving_simulation-1"></a><a class="docs-heading-anchor-permalink" href="#steady_state_solving_simulation" title="Permalink"></a></h2><p>The <code>NonlinearProblem</code>s generated by Catalyst corresponds to ODEs. A common method of solving these is to simulate the ODE from an initial condition until a steady state is reached. Here we do so for the dimerisation system considered in the previous section. First, we declare our model, initial condition, and parameter values.</p><pre><code class="language-julia hljs">dimer_production = @reaction_network begin
    pₘ, 0 --&gt; mRNA
    pₚ, mRNA --&gt; mRNA + P
    (k₁, k₂), 2P &lt;--&gt; P₂
    d, (mRNA, P, P₂) --&gt; 0
end
p = [:pₘ =&gt; 0.5, :pₚ =&gt; 2.0, :k₁ =&gt; 5.0, :k₂ =&gt; 1.0, :d =&gt; 1.0]
u0 = [:mRNA =&gt; 0.1, :P =&gt; 0.0, :P₂ =&gt; 0.0]</code></pre><p>Next, we provide these as an input to a <code>SteadyStateProblem</code></p><pre><code class="language-julia hljs">ssprob = SteadyStateProblem(dimer_production, u0, p)</code></pre><p>Finally, we can find the steady states using the <code>solver</code> command. Since <code>SteadyStateProblem</code>s are solved through forward ODE simulation, we must load the sublibrary of the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package that corresponds to the <a href="../../model_simulation/simulation_introduction/#simulation_intro_solver_options">selected ODE solver</a>. Any available ODE solver can be used, however, it has to be encapsulated by the <code>DynamicSS()</code> function. E.g. here we use the <code>Rodas5P</code> solver which is loaded from the <code>OrdinaryDiffEqRosenbrock</code> sublibrary:</p><p>(which requires loading the SteadyStateDiffEq package).</p><pre><code class="language-julia hljs">using SteadyStateDiffEq, OrdinaryDiffEqRosenbrock
solve(ssprob, DynamicSS(Rodas5P()))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 3-element Vector{Float64}:
 0.49999999427790315
 0.46332491715580854
 0.26833743088545675</code></pre><p>Note that, unlike for nonlinear system solving, <code>u0</code> is not just an initial guess of the solution, but the initial conditions from which the steady state simulation is carried out. This means that, for a system with multiple steady states, we can determine the steady states associated with specific initial conditions (which is not possible when the nonlinear solving approach is used). This also permits us to easily <a href="#steady_state_solving_nonlinear_conservation_laws">handle the presence of conservation laws</a>. The forward ODE simulation approach (unlike homotopy continuation and nonlinear solving) cannot find unstable steady states.</p><p>Generally, <code>SteadyStateProblem</code>s can be solved using the <a href="../../model_simulation/simulation_introduction/#simulation_intro_solver_options">same options that are available for ODE simulations</a>. E.g. here we designate a specific <code>dt</code> step size:</p><pre><code class="language-julia hljs">solve(ssprob, DynamicSS(Rodas5P()); dt = 0.01)</code></pre><p>It is possible to use solve <code>SteadyStateProblem</code>s using a nonlinear solver, and <code>NonlinearProblem</code>s using forward ODE simulation solvers:</p><pre><code class="language-julia hljs">using NonlinearSolve
solve(ssprob, TrustRegion())</code></pre><pre><code class="language-julia hljs">nlprob = NonlinearProblem(dimer_production, u0, p)
solve(nlprob, DynamicSS(Rodas5P()))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"><span class="sgr1">┌ Warning: </span></span>Ingored unsupported keyword arguments: check_length = false
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ HomotopyContinuation ~/.julia/packages/HomotopyContinuation/HdN5z/src/utils.jl:170</span></code></pre><p>However, especially when the forward ODE simulation approach is used, it is recommended to use the problem type which corresponds to the intended solver.</p><hr/><h2 id="nonlinear_solve_citation"><a class="docs-heading-anchor" href="#nonlinear_solve_citation">Citations</a><a id="nonlinear_solve_citation-1"></a><a class="docs-heading-anchor-permalink" href="#nonlinear_solve_citation" title="Permalink"></a></h2><p>If you use this functionality in your research, <a href="../../#doc_index_citation">in addition to Catalyst</a>, please cite the following paper to support the authors of the NonlinearSolve.jl package:</p><pre><code class="nohighlight hljs">@article{pal2024nonlinearsolve,
  title={NonlinearSolve. jl: High-Performance and Robust Solvers for Systems of Nonlinear Equations in Julia},
  author={Pal, Avik and Holtorf, Flemming and Larsson, Axel and Loman, Torkel and Schaefer, Frank and Qu, Qingyu and Edelman, Alan and Rackauckas, Chris and others},
  journal={arXiv preprint arXiv:2403.16341},
  year={2024}
}</code></pre><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://www.math.uci.edu/~qnie/Publications/NumericalOptimization.pdf">J. Nocedal, S. J. Wright, <em>Numerical Optimization</em>, Springer (2006).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../homotopy_continuation/">« Finding Steady States through Homotopy Continuation</a><a class="docs-footer-nextpage" href="../steady_state_stability_computation/">Steady state stability computation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 8 January 2025 16:58">Wednesday 8 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
