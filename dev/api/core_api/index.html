<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Catalyst.jl API · Catalyst.jl</title><meta name="title" content="Catalyst.jl API · Catalyst.jl"/><meta property="og:title" content="Catalyst.jl API · Catalyst.jl"/><meta property="twitter:title" content="Catalyst.jl API · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/api/core_api/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/api/core_api/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/api/core_api/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Introduction to Catalyst</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Model creation and properties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/coupled_non_crn_models/">Coupled non-reaction network equations to models</a></li><li><a class="tocitem" href="../../model_creation/events/">Modelling Events</a></li><li><a class="tocitem" href="../../model_creation/conservation_laws/">Working with Conservation Laws</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stoichiometries</a></li><li><a class="tocitem" href="../../model_creation/functional_parameters/">Inputs and time-dependent (or functional) parameters</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/reactionsystem_content_accessing/">Accessing Model Properties</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related Functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-14" type="checkbox"/><label class="tocitem" for="menuitem-3-14"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, Generative, Modelling of a Linear Pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/noise_modelling_approaches/">Approaches for modelling system noise</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Model simulation and visualization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation Plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for Performant ODE Simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for Performant SDE Simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/examples/periodic_events_simulation/">Modelling a Periodic Event During ODE and Jump Simulations</a></li><li><a class="tocitem" href="../../model_simulation/examples/activation_time_distribution_measurement/">Measuring the Distribution of System Activation Times</a></li><li><a class="tocitem" href="../../model_simulation/examples/interactive_brusselator_simulation/">Interactive Simulation and Plotting</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Network Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../network_analysis/odes/">Decomposing the Reaction Network ODEs</a></li><li><a class="tocitem" href="../../network_analysis/crn_theory/">Chemical Reaction Network Theory</a></li><li><a class="tocitem" href="../../network_analysis/network_properties/">Caching of Network Properties in <code>ReactionSystems</code></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Steady state analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing Model Steady State Properties with DynamicalSystems.jl</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/examples/nullcline_plotting/">Plotting Nullclines and Steady States in Phase Space</a></li><li><a class="tocitem" href="../../steady_state_functionality/examples/bifurcationkit_periodic_orbits/">Computing Periodic Orbits (Oscillations) Using BifurcationKit.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/examples/bifurcationkit_codim2/">Tracking Bifurcation Point w.r.t. Secondary Parameters using BifurcationKit.jl</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Inverse problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for Non-data Fitting Purposes</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Spatial modelling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../spatial_modelling/discrete_space_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/discrete_space_simulation_structure_interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/discrete_space_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial Jump Simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox" checked/><label class="tocitem" for="menuitem-10"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Catalyst.jl API</a><ul class="internal"><li><a class="tocitem" href="#Reaction-network-generation-and-representation"><span>Reaction network generation and representation</span></a></li><li><a class="tocitem" href="#api_dsl_options"><span>Options for the <code>@reaction_network</code> DSL</span></a></li><li><a class="tocitem" href="#api_accessor_functions"><span>ModelingToolkitBase and Catalyst accessor functions</span></a></li><li><a class="tocitem" href="#Basic-system-properties"><span>Basic system properties</span></a></li><li><a class="tocitem" href="#Coupled-reaction/equation-system-properties"><span>Coupled reaction/equation system properties</span></a></li><li><a class="tocitem" href="#Basic-species-properties"><span>Basic species properties</span></a></li><li><a class="tocitem" href="#Symbolic-variable-properties"><span>Symbolic variable properties</span></a></li><li><a class="tocitem" href="#Basic-reaction-properties"><span>Basic reaction properties</span></a></li><li><a class="tocitem" href="#api_rx_metadata"><span>Reaction metadata</span></a></li><li><a class="tocitem" href="#api_system_metadata"><span>System-level metadata</span></a></li><li><a class="tocitem" href="#api_network_extension_and_modification"><span>Functions to extend or modify a network</span></a></li><li><a class="tocitem" href="#network_visualization"><span>Network visualization</span></a></li><li><a class="tocitem" href="#api_rate_laws"><span>Rate laws</span></a></li><li><a class="tocitem" href="#Transformations"><span>Transformations</span></a></li><li><a class="tocitem" href="#Chemistry-related-functionalities"><span>Chemistry-related functionalities</span></a></li><li><a class="tocitem" href="#Unit-validation"><span>Unit validation</span></a></li><li><a class="tocitem" href="#api_dspace_simulations"><span>Spatial modelling</span></a></li></ul></li><li><a class="tocitem" href="../network_analysis_api/">Network analysis and representations</a></li></ul></li><li><a class="tocitem" href="../../devdocs/dev_guide/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Catalyst.jl API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Catalyst.jl API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/api/core_api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="api"><a class="docs-heading-anchor" href="#api">Catalyst.jl API</a><a id="api-1"></a><a class="docs-heading-anchor-permalink" href="#api" title="Permalink"></a></h1><h2 id="Reaction-network-generation-and-representation"><a class="docs-heading-anchor" href="#Reaction-network-generation-and-representation">Reaction network generation and representation</a><a id="Reaction-network-generation-and-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Reaction-network-generation-and-representation" title="Permalink"></a></h2><p>Catalyst provides the <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro for generating a complete network, stored as a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, which in turn is composed of <a href="#Catalyst.Reaction"><code>Reaction</code></a>s. <code>ReactionSystem</code>s can be converted to other <code>ModelingToolkitBase.AbstractSystem</code>s, specifically a <code>ModelingToolkitBase.System</code> representing an ODE, SDE, or jump model.</p><p>When using the <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro, Catalyst will automatically attempt to detect what is a species and what is a parameter. Everything that appear as a substrate or product in some reaction will be treated as a species, while all remaining symbols will be considered parameters (corresponding to those symbols that only appear within rate expressions and/or as stoichiometric coefficients). I.e. in</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    k*X, Y --&gt; W
end</code></pre><p><code>Y</code> and <code>W</code> will all be classified as chemical species, while <code>k</code> and <code>X</code> will be classified as parameters.</p><p>The <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> generated by the <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro is a <code>ModelingToolkitBase.AbstractSystem</code> that symbolically represents a system of chemical reactions. In some cases it can be convenient to bypass the macro and directly generate a collection of symbolic <a href="#Catalyst.Reaction"><code>Reaction</code></a>s and a corresponding <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> encapsulating them. Below we illustrate with a simple SIR example how a system can be directly constructed, and demonstrate how to then generate from the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and solve corresponding chemical reaction ODE models, chemical Langevin equation SDE models, and stochastic chemical kinetics jump process models.</p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEqTsit5, StochasticDiffEq, JumpProcesses, Plots
t = default_t()
@parameters β γ
@species S(t) I(t) R(t)

rxs = [Reaction(β, [S,I], [I], [1,1], [2])
       Reaction(γ, [I], [R])]
@named rs = ReactionSystem(rxs, t)
rs = complete(rs)

u₀map    = [S =&gt; 999.0, I =&gt; 1.0, R =&gt; 0.0]
parammap = [β =&gt; 1/10000, γ =&gt; 0.01]
tspan    = (0.0, 250.0)

# solve as ODEs
oprob = ODEProblem(rs, u₀map, tspan, parammap)
sol = solve(oprob, Tsit5())
p1 = plot(sol, title = &quot;ODE&quot;)

# solve as SDEs
sprob = SDEProblem(rs, u₀map, tspan, parammap)
sol = solve(sprob, EM(), dt=.01, saveat = 2.0)
p2 = plot(sol, title = &quot;SDE&quot;)

# solve as jump process
u₀map    = [S =&gt; 999, I =&gt; 1, R =&gt; 0]
jprob = JumpProblem(rs, u₀map, tspan, parammap)
sol = solve(jprob)
p3 = plot(sol, title = &quot;jump&quot;)
plot(p1, p2, p3; layout = (3,1))</code></pre><img src="375692cb.png" alt="Example block output"/><article><details class="docstring" open="true"><summary id="Catalyst.@reaction_network"><a class="docstring-binding" href="#Catalyst.@reaction_network"><code>Catalyst.@reaction_network</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@reaction_network</code></pre><p>Macro for generating chemical reaction network models (Catalyst <code>ReactionSystem</code>s). See the (<a href="https://docs.sciml.ai/Catalyst/stable/model_creation/dsl_basics/">DSL introduction</a> and <a href="https://docs.sciml.ai/Catalyst/stable/model_creation/dsl_advanced/">advantage usage</a>) sections of the Catalyst documentation for more details on the domain-specific language (DSL) that the macro implements. The macro&#39;s output (a <code>ReactionSystem</code> structure) is central to Catalyst and its functionality. How to e.g. simulate these is described in the <a href="https://docs.sciml.ai/Catalyst/stable/">Catalyst documentation</a>.</p><p>Returns:</p><ul><li>A Catalyst <code>ReactionSystem</code>, i.e. a symbolic model for the reaction network. The returned</li></ul><p>system is marked <code>complete</code>. To obtain a <code>ReactionSystem</code> that is not marked complete, for example to then use in compositional modelling, see the otherwise equivalent <code>@network_component</code> macro.</p><p>Examples: Here we create a basic SIR model. It contains two reactions (infection and recovery):</p><pre><code class="language-julia hljs">sir_model = @reaction_network begin
    c1, S + I --&gt; 2I
    c2, I --&gt; R
end</code></pre><p>Next, we create a self-activation loop. Here, a single component (<code>X</code>) activates its own production with a Michaelis-Menten function:</p><pre><code class="language-julia hljs">sa_loop = @reaction_network begin
    mm(X,v,K), 0 --&gt; X
    d, X --&gt; 0
end</code></pre><p>This model also contains production and degradation reactions, where <code>0</code> denotes that there are either no substrates or no products in a reaction.</p><p>Options: In addition to reactions, the macro also supports &quot;option&quot; inputs (permitting e.g. the addition of observables). Each option is designated by a tag starting with a <code>@</code> followed by its input. A list of options can be found <a href="https://docs.sciml.ai/Catalyst/stable/api/#api_dsl_options">here</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/dsl.jl#L24-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.@network_component"><a class="docstring-binding" href="#Catalyst.@network_component"><code>Catalyst.@network_component</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@network_component</code></pre><p>Equivalent to <code>@reaction_network</code> except the generated <code>ReactionSystem</code> is not marked as complete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/dsl.jl#L87-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.make_empty_network"><a class="docstring-binding" href="#Catalyst.make_empty_network"><code>Catalyst.make_empty_network</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">make_empty_network(; iv=DEFAULT_IV, name=gensym(:ReactionSystem))</code></pre><p>Construct an empty <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. <code>iv</code> is the independent variable, usually time, and <code>name</code> is the name to give the <code>ReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1481-L1486">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.@reaction"><a class="docstring-binding" href="#Catalyst.@reaction"><code>Catalyst.@reaction</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@reaction</code></pre><p>Macro for generating a single <a href="#Catalyst.Reaction"><code>Reaction</code></a> object using a similar syntax as the <code>@reaction_network</code> macro (but permitting only a single reaction). A more detailed introduction to the syntax can be found in the description of <code>@reaction_network</code>.</p><p>The <code>@reaction</code> macro is followed by a single line consisting of three parts:</p><ul><li>A rate (at which the reaction occurs).</li><li>Any number of substrates (which are consumed by the reaction).</li><li>Any number of products (which are produced by the reaction).</li></ul><p>The output is a reaction (just like created using the <code>Reaction</code> constructor).</p><p>Examples: Here we create a simple binding reaction and store it in the variable rx:</p><pre><code class="language-julia hljs">rx = @reaction k, X + Y --&gt; XY</code></pre><p>The macro will automatically deduce <code>X</code>, <code>Y</code>, and <code>XY</code> to be species (as these occur as reactants) and <code>k</code> as a parameter (as it does not occur as a reactant).</p><p>The <code>@reaction</code> macro provides a more concise notation to the <code>Reaction</code> constructor. I.e. here we create the same reaction using both approaches, and also confirm that they are identical.</p><pre><code class="language-julia hljs"># Creates a reaction using the `@reaction` macro.
rx = @reaction k*v, A + B --&gt; C + D

# Creates a reaction using the `Reaction` constructor.
t = default_t()
@parameters k v
@species A(t) B(t) C(t) D(t)
rx2 = Reaction(k*v, [A, B], [C, D])

# Confirms that the two approaches yield identical results:
rx1 == rx2</code></pre><p>Interpolation of already declared symbolic variables into <code>@reaction</code> is possible:</p><pre><code class="language-julia hljs">t = default_t()
@parameters k b
@species A(t)
ex = k*A^2 + t
rx = @reaction b*$ex*$A, $A --&gt; C</code></pre><p>Notes:</p><ul><li><code>@reaction</code> does not support bi-directional type reactions (using <code>&lt;--&gt;</code>) or reaction bundling</li></ul><p>(e.g. <code>d, (X,Y) --&gt; 0</code>).</p><ul><li>Interpolation of Julia variables into the macro works similarly to the <code>@reaction_network</code></li></ul><p>macro. See <a href="../../model_creation/dsl_basics/#dsl_description">The Reaction DSL</a> tutorial for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/dsl.jl#L1071-L1122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.Reaction"><a class="docstring-binding" href="#Catalyst.Reaction"><code>Catalyst.Reaction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Reaction{S, T}</code></pre><p>One chemical reaction.</p><p><strong>Fields</strong></p><ul><li><p><code>rate</code>: The rate function (excluding mass action terms).</p></li><li><p><code>substrates</code>: Reaction substrates.</p></li><li><p><code>products</code>: Reaction products.</p></li><li><p><code>substoich</code>: The stoichiometric coefficients of the reactants.</p></li><li><p><code>prodstoich</code>: The stoichiometric coefficients of the products.</p></li><li><p><code>netstoich</code>: The net stoichiometric coefficients of all species changed by the reaction.</p></li><li><p><code>only_use_rate</code>: <code>false</code> (default) if <code>rate</code> should be multiplied by mass action terms to give the rate law. <code>true</code> if <code>rate</code> represents the full reaction rate law.</p></li></ul><ul><li><code>metadata</code>: Contain additional data, such whenever the reaction have a specific noise-scaling expression for the chemical Langevin equation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Catalyst
t = default_t()
@parameters k[1:20]
@species A(t) B(t) C(t) D(t)
rxs = [Reaction(k[1], nothing, [A]),            # 0 -&gt; A
       Reaction(k[2], [B], nothing),            # B -&gt; 0
       Reaction(k[3],[A],[C]),                  # A -&gt; C
       Reaction(k[4], [C], [A,B]),              # C -&gt; A + B
       Reaction(k[5], [C], [A], [1], [2]),      # C -&gt; A + A
       Reaction(k[6], [A,B], [C]),              # A + B -&gt; C
       Reaction(k[7], [B], [A], [2], [1]),      # 2B -&gt; A
       Reaction(k[8], [A,B], [A,C]),            # A + B -&gt; A + C
       Reaction(k[9], [A,B], [C,D]),            # A + B -&gt; C + D
       Reaction(k[10], [A], [C,D], [2], [1,1]), # 2A -&gt; C + D
       Reaction(k[11], [A], [A,B], [2], [1,1]), # 2A -&gt; A + B
       Reaction(k[12], [A,B,C], [C,D], [1,3,4], [2, 3]),          # A+3B+4C -&gt; 2C + 3D
       Reaction(k[13], [A,B], nothing, [3,1], nothing),           # 3A+B -&gt; 0
       Reaction(k[14], nothing, [A], nothing, [2]),               # 0 -&gt; 2A
       Reaction(k[15]*A/(2+A), [A], nothing; only_use_rate=true), # A -&gt; 0 with custom rate
       Reaction(k[16], [A], [B]; only_use_rate=true),             # A -&gt; B with custom rate.
       Reaction(k[17]*A*exp(B), [C], [D], [2], [1]),              # 2C -&gt; D with non constant rate.
       Reaction(k[18]*B, nothing, [B], nothing, [2]),             # 0 -&gt; 2B with non constant rate.
       Reaction(k[19]*t, [A], [B]),                                # A -&gt; B with non constant rate.
       Reaction(k[20]*t*A, [B,C], [D],[2,1],[2])                  # 2A +B -&gt; 2C with non constant rate.
  ]</code></pre><p>Notes:</p><ul><li><code>nothing</code> can be used to indicate a reaction that has no reactants or no products. In this case the corresponding stoichiometry vector should also be set to <code>nothing</code>.</li><li>The three-argument form assumes all reactant and product stoichiometric coefficients are one.</li><li>Pass <code>unit_checks = true</code> to validate unit consistency at construction time. When enabled, checks that all substrates and products share the same units, and that the rate expression has internally consistent additive terms. Default is <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.ReactionSystem"><a class="docstring-binding" href="#Catalyst.ReactionSystem"><code>Catalyst.ReactionSystem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ReactionSystem{V&lt;:Catalyst.NetworkProperties} &lt;: ModelingToolkitBase.AbstractSystem</code></pre><p>A system of chemical reactions.</p><p><strong>Fields</strong></p><ul><li><p><code>eqs</code>: The equations (reactions and algebraic/differential) defining the system.</p></li><li><p><code>rxs</code>: The Reactions defining the system.</p></li><li><p><code>iv</code>: Independent variable (usually time).</p></li><li><p><code>sivs</code>: Spatial independent variables</p></li><li><p><code>unknowns</code>: All dependent (unknown) variables, species and non-species. Must not contain the independent variable.</p></li><li><p><code>species</code>: Dependent unknown variables representing species</p></li><li><p><code>ps</code>: Parameter variables. Must not contain the independent variable.</p></li><li><p><code>var_to_name</code>: Maps Symbol to corresponding variable.</p></li><li><p><code>observed</code>: Equations for observed variables.</p></li><li><p><code>name</code>: The name of the system</p></li><li><p><code>systems</code>: Internal sub-systems</p></li><li><p><code>initial_conditions</code>: The initial values to use when initial conditions and/or parameters are not supplied to problem constructors.</p></li></ul><ul><li><p><code>networkproperties</code>: <code>NetworkProperties</code> object that can be filled in by API functions. INTERNAL – not considered part of the public API.</p></li><li><p><code>combinatoric_ratelaws</code>: Sets whether to use combinatoric scalings in rate laws. true by default.</p></li><li><p><code>continuous_events</code>: continuous_events: A <code>Vector{SymbolicContinuousCallback}</code> that model events. The integrator will use root finding to guarantee that it steps at each zero crossing.</p></li></ul><ul><li><code>discrete_events</code>: discrete_events: A <code>Vector{SymbolicDiscreteCallback}</code> that models events. Symbolic analog to <code>SciMLBase.DiscreteCallback</code> that executes an affect when a given condition is true at the end of an integration step.</li></ul><ul><li><code>tstops</code>: tstops: A <code>Vector{Any}</code> of extra time points for the integrator to stop at. These can be numeric values or symbolic expressions of parameters and time.</li></ul><ul><li><p><code>brownians</code>: Brownian variables for non-reaction noise, created via @brownians.</p></li><li><p><code>poissonians</code>: Poissonian variables for Poisson jump noise, created via @poissonians.</p></li><li><p><code>jumps</code>: Non-reaction jumps (VariableRateJump, ConstantRateJump, MassActionJump).</p></li><li><p><code>metadata</code>: Metadata for the system, to be used by downstream packages.</p></li></ul><ul><li><code>complete</code>: complete: if a model <code>sys</code> is complete, then <code>sys.x</code> no longer performs namespacing.</li></ul><ul><li><code>parent</code>: The hierarchical parent system before simplification that MTK now seems to require for hierarchical namespacing to work in indexing.</li></ul><p><strong>Example</strong></p><p>Continuing from the example in the <a href="#Catalyst.Reaction"><code>Reaction</code></a> definition:</p><pre><code class="language-julia hljs"># simple constructor that infers species and parameters
@named rs = ReactionSystem(rxs, t)

# allows specification of species and parameters
@named rs = ReactionSystem(rxs, t, [A,B,C,D], k)</code></pre><p>Keyword Arguments:</p><ul><li><code>observed::Vector{Equation}</code>, equations specifying observed variables.</li><li><code>systems::Vector{ReactionSystem}</code>, vector of sub-<code>ReactionSystem</code>s.</li><li><code>name::Symbol</code>, the name of the system (must be provided, or <code>@named</code> must be used).</li><li><code>initial_conditions::SymmapT</code>, a dictionary mapping parameters and species to their initial values.</li><li><code>checks = true</code>, boolean for whether to run structural checks at construction time.</li><li><code>unit_checks = false</code>, boolean for whether to perform unit validation at construction time. Uses <a href="#Catalyst.validate_units-Tuple{Reaction}"><code>Catalyst.validate_units</code></a> / <a href="#Catalyst.assert_valid_units-Tuple{Reaction}"><code>Catalyst.assert_valid_units</code></a>. Units should be specified with symbolic units (<code>us&quot;...&quot;</code>) from DynamicQuantities.</li><li><code>networkproperties = NetworkProperties()</code>, cache for network properties calculated via API functions.</li><li><code>combinatoric_ratelaws = true</code>, sets the default value of <code>combinatoric_ratelaws</code> used in conversion functions (<a href="@ref"><code>ode_model</code></a>, <a href="@ref"><code>sde_model</code></a>, <a href="@ref"><code>jump_model</code></a>, <a href="@ref"><code>ss_ode_model</code></a>, <a href="@ref"><code>hybrid_model</code></a>) or when calling problem constructors with the <code>ReactionSystem</code>.</li><li><code>balanced_bc_check = true</code>, sets whether to check that BC species appearing in reactions are balanced (i.e appear as both a substrate and a product with the same stoichiometry).</li><li><code>tstops = []</code>, a vector of extra time points for the integrator to stop at. These can be numeric values or symbolic expressions of parameters and time.</li><li><code>brownians</code>, vector of Brownian variables for non-reaction SDE noise (created via <code>@brownians</code>). Auto-discovered from equations in the two-argument constructor.</li><li><code>poissonians</code>, vector of Poissonian variables for Poisson jump noise (created via <code>@poissonians</code>). Auto-discovered from equations in the two-argument constructor.</li><li><code>jumps</code>, vector of non-reaction jump processes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L260">source</a></section></details></article><h2 id="api_dsl_options"><a class="docs-heading-anchor" href="#api_dsl_options">Options for the <code>@reaction_network</code> DSL</a><a id="api_dsl_options-1"></a><a class="docs-heading-anchor-permalink" href="#api_dsl_options" title="Permalink"></a></h2><p>We have <a href="../../model_creation/dsl_advanced/#dsl_advanced_options">previously described</a> how options permit the user to supply non-reaction information to <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> created through the DSL. Here follows a list of all options currently available.</p><ul><li><a href="../../model_creation/dsl_advanced/#dsl_advanced_options_declaring_species_and_parameters"><code>parameters</code></a>: Allows the designation of a set of symbols as system parameters.</li><li><a href="../../model_creation/dsl_advanced/#dsl_advanced_options_declaring_species_and_parameters"><code>species</code></a>: Allows the designation of a set of symbols as system species.</li><li><a href="../../model_creation/dsl_advanced/#dsl_advanced_options_declaring_species_and_parameters"><code>variables</code></a>: Allows the designation of a set of symbols as system non-species variables.</li><li><a href="../../model_creation/dsl_advanced/#dsl_advanced_options_ivs"><code>ivs</code></a>: Allows the designation of a set of symbols as system independent variables.</li><li><a href="../../model_creation/chemistry_related_functionality/#chemistry_functionality_compounds"><code>compounds</code></a>: Allows the designation of compound species.</li><li><a href="../../model_creation/dsl_advanced/#dsl_advanced_options_observables"><code>observables</code></a>: Allows the designation of compound observables.</li><li><a href="../../model_simulation/simulation_introduction/#simulation_intro_SDEs_noise_saling"><code>default_noise_scaling</code></a>: Enables the setting of a default noise scaling expression.</li><li><a href="@ref constraint_equations_coupling_constraints"><code>differentials</code></a>: Allows the designation of differentials.</li><li><a href="@ref constraint_equations_coupling_constraints"><code>equations</code></a>: Allows the creation of algebraic and/or differential equations.</li><li><a href="../../model_creation/events/#events"><code>continuous_events</code></a>: Allows the creation of continuous events.</li><li><a href="../../model_creation/events/#events"><code>discrete_events</code></a>: Allows the creation of discrete events.</li><li><code>brownians</code>: Allows the creation of brownian processes that can be used to add noise to non-species variables.</li><li><code>poissonians</code>: Allows the creation of poissonian processes that can be used to add jump events to non-species variables.</li><li><code>discretes</code>: Creates <em>discrete parameters</em>, i.e. time-dependent parameters.</li><li><a href="../../faqs/#faq_combinatoric_ratelaws"><code>combinatoric_ratelaws</code></a>: Takes a single option (<code>true</code> or <code>false</code>), which sets whether to use combinatorial rate laws.</li><li><code>unit_checks</code>: Takes a single option (<code>true</code> or <code>false</code>) controlling whether unit validation runs during DSL construction (<code>false</code> by default).</li></ul><h2 id="api_accessor_functions"><a class="docs-heading-anchor" href="#api_accessor_functions">ModelingToolkitBase and Catalyst accessor functions</a><a id="api_accessor_functions-1"></a><a class="docs-heading-anchor-permalink" href="#api_accessor_functions" title="Permalink"></a></h2><p>A <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> is an instance of a <code>ModelingToolkitBase.AbstractSystem</code>, and has a number of fields that can be accessed using the Catalyst API and the <a href="https://docs.sciml.ai/ModelingToolkit/stable/basics/AbstractSystem/">ModelingToolkitBase.jl Abstract System Interface</a>. Below we overview these components.</p><p>There are three basic sets of convenience accessors that will return information either from a top-level system, the top-level system and all sub-systems that are also <code>ReactionSystem</code>s (i.e. the full reaction-network), or the top-level system, all subs-systems, and all constraint systems (i.e. the full model). To retrieve info from just a base <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> <code>rn</code>, ignoring sub-systems of <code>rn</code>, one can use the ModelingToolkit accessors (these provide direct access to the corresponding internal fields of the <code>ReactionSystem</code>)</p><ul><li><code>ModelingToolkitBase.get_unknowns(rn)</code> is a vector that collects all the species defined within <code>rn</code>, ordered by species and then non-species variables.</li><li><code>Catalyst.get_species(rn)</code> is a vector of all the species variables in the system. The entries in <code>get_species(rn)</code> correspond to the first <code>length(get_species(rn))</code> components in <code>get_unknowns(rn)</code>.</li><li><code>ModelingToolkitBase.get_ps(rn)</code> is a vector that collects all the parameters defined <em>within</em> reactions in <code>rn</code>.</li><li><code>ModelingToolkitBase.get_eqs(rn)</code> is a vector that collects all the <a href="#Catalyst.Reaction"><code>Reaction</code></a>s and <code>Symbolics.Equation</code> defined within <code>rn</code>, ordering all <code>Reaction</code>s before <code>Equation</code>s.</li><li><code>Catalyst.get_rxs(rn)</code> is a vector of all the <a href="#Catalyst.Reaction"><code>Reaction</code></a>s in <code>rn</code>, and corresponds to the first <code>length(get_rxs(rn))</code> entries in <code>get_eqs(rn)</code>.</li><li><code>ModelingToolkitBase.get_iv(rn)</code> is the independent variable used in the system (usually <code>t</code> to represent time).</li><li><code>ModelingToolkitBase.get_systems(rn)</code> is a vector of all sub-systems of <code>rn</code>.</li><li><code>ModelingToolkitBase.get_initial_conditions(rn)</code> is a dictionary of all the initial values for parameters and species in <code>rn</code>.</li></ul><p>The preceding accessors do not allocate, directly accessing internal fields of the <code>ReactionSystem</code>.</p><p>To retrieve information from the full reaction network represented by a system <code>rn</code>, which corresponds to information within both <code>rn</code> and all sub-systems, one can call:</p><ul><li><code>ModelingToolkitBase.unknowns(rn)</code> returns all species <em>and variables</em> across the system, <em>all sub-systems</em>. Species are ordered before non-species variables in <code>unknowns(rn)</code>, with the first <code>numspecies(rn)</code> entries in <code>unknowns(rn)</code> being the same as <code>species(rn)</code>.</li><li><a href="#Catalyst.species"><code>species(rn)</code></a> is a vector collecting all the chemical species within the system and any sub-systems that are also <code>ReactionSystems</code>.</li><li><code>ModelingToolkitBase.parameters(rn)</code> returns all parameters across the system, <em>all sub-systems</em>.</li><li><code>ModelingToolkitBase.equations(rn)</code> returns all <a href="#Catalyst.Reaction"><code>Reaction</code></a>s and all <code>Symbolics.Equations</code> defined across the system, <em>all sub-systems</em>. <code>Reaction</code>s  are ordered ahead of <code>Equation</code>s with the first <code>numreactions(rn)</code> entries in <code>equations(rn)</code> being the same as <code>reactions(rn)</code>.</li><li><a href="#Catalyst.reactions"><code>reactions(rn)</code></a> is a vector of all the <code>Reaction</code>s within the system and any sub-systems that are also <code>ReactionSystem</code>s.</li></ul><p>These accessors will generally allocate new arrays to store their output unless there are no subsystems. In the latter case the usually return the same vector as the corresponding <code>get_*</code> function.</p><p>Below we list the remainder of the Catalyst API accessor functions mentioned above.</p><h2 id="Basic-system-properties"><a class="docs-heading-anchor" href="#Basic-system-properties">Basic system properties</a><a id="Basic-system-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-system-properties" title="Permalink"></a></h2><p>See <a href="../../model_creation/programmatic_CRN_construction/#programmatic_CRN_construction">Programmatic Construction of Symbolic Reaction Systems</a> for examples and <a href="#api_accessor_functions">ModelingToolkitBase and Catalyst Accessor Functions</a> for more details on the basic accessor functions.</p><article><details class="docstring" open="true"><summary id="Catalyst.species"><a class="docstring-binding" href="#Catalyst.species"><code>Catalyst.species</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">species(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of all species defined in the system and any subsystems that are of type <code>ReactionSystem</code>. To get the species and non-species variables in the system and all subsystems, including non-<code>ReactionSystem</code> subsystems, uses <code>unknowns(network)</code>.</p><p>Notes:</p><ul><li>If <code>ModelingToolkitBase.get_systems(network)</code> is non-empty will allocate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L899-L909">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.get_species"><a class="docstring-binding" href="#Catalyst.get_species"><code>Catalyst.get_species</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_species(sys::ReactionSystem)</code></pre><p>Return the current dependent variables that represent species in <code>sys</code> (toplevel system only).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L826-L831">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.nonspecies"><a class="docstring-binding" href="#Catalyst.nonspecies"><code>Catalyst.nonspecies</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nonspecies(network)</code></pre><p>Return the non-species variables within the network, i.e. those unknowns for which <code>isspecies == false</code>.</p><p>Notes:</p><ul><li>Allocates a new array to store the non-species variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L931-L939">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.reactions"><a class="docstring-binding" href="#Catalyst.reactions"><code>Catalyst.reactions</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reactions(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of all <code>Reactions</code> in the system.</p><p>Notes:</p><ul><li>If <code>ModelingToolkitBase.get_systems(network)</code> is not empty, will allocate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1003-L1010">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.get_rxs"><a class="docstring-binding" href="#Catalyst.get_rxs"><code>Catalyst.get_rxs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_rxs(sys::ReactionSystem)</code></pre><p>Return the system&#39;s <code>Reaction</code> vector (toplevel system only).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L835-L839">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.nonreactions"><a class="docstring-binding" href="#Catalyst.nonreactions"><code>Catalyst.nonreactions</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nonreactions(network)</code></pre><p>Return the non-reaction equations within the network (i.e. algebraic and differential equations).</p><p>Notes:</p><ul><li>Allocates a new array to store the non-species variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1042-L1049">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.numspecies"><a class="docstring-binding" href="#Catalyst.numspecies"><code>Catalyst.numspecies</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">numspecies(network)</code></pre><p>Return the total number of species within the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and subsystems that are <code>ReactionSystem</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L917-L922">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.numparams"><a class="docstring-binding" href="#Catalyst.numparams"><code>Catalyst.numparams</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">numparams(network)</code></pre><p>Return the total number of parameters within the given system and all subsystems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L972-L976">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.numreactions"><a class="docstring-binding" href="#Catalyst.numreactions"><code>Catalyst.numreactions</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">numreactions(network)</code></pre><p>Return the total number of reactions within the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and subsystems that are <code>ReactionSystem</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1018-L1023">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.speciesmap"><a class="docstring-binding" href="#Catalyst.speciesmap"><code>Catalyst.speciesmap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">speciesmap(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a Dictionary mapping species that participate in <code>Reaction</code>s to their index within <a href="#Catalyst.species"><code>species(network)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L944-L949">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.paramsmap"><a class="docstring-binding" href="#Catalyst.paramsmap"><code>Catalyst.paramsmap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">paramsmap(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a Dictionary mapping from all parameters that appear within the system to their index within <code>parameters(network)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L985-L991">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.isautonomous"><a class="docstring-binding" href="#Catalyst.isautonomous"><code>Catalyst.isautonomous</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>isautonomous(rs::ReactionSystem)</p><p>Checks if a system is autonomous (i.e. no rate or equation depend on the independent variable(s)). Example:</p><pre><code class="language-julia hljs">rs1 = @reaction_system
    (p,d), 0 &lt;--&gt; X
end
isautonomous(rs1) # Returns `true`.

rs2 = @reaction_system
    (p/t,d), 0 &lt;--&gt; X
end
isautonomous(rs2) # Returns `false`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1360-L1376">source</a></section></details></article><h2 id="Coupled-reaction/equation-system-properties"><a class="docs-heading-anchor" href="#Coupled-reaction/equation-system-properties">Coupled reaction/equation system properties</a><a id="Coupled-reaction/equation-system-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Coupled-reaction/equation-system-properties" title="Permalink"></a></h2><p>The following system property accessor functions are primarily relevant to reaction system <a href="@ref constraint_equations">coupled to differential and/or algebraic equations</a>.</p><article><details class="docstring" open="true"><summary id="ModelingToolkitBase.has_alg_equations"><a class="docstring-binding" href="#ModelingToolkitBase.has_alg_equations"><code>ModelingToolkitBase.has_alg_equations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_alg_equations(sys::AbstractSystem)</code></pre><p>For a system, returns true if it contain at least one algebraic equation (i.e. that does not contain any differentials).</p><p>Example:</p><pre><code class="language-julia hljs">using ModelingToolkitBase
using ModelingToolkitBase: t_nounits as t, D_nounits as D
@parameters p d
@variables X(t)
eq1 = D(X) ~ p - d*X
eq2 = 0 ~ p - d*X
@named osys1 = System([eq1], t)
@named osys2 = System([eq2], t)

has_alg_equations(osys1) # returns `false`.
has_alg_equations(osys2) # returns `true`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v1.13.1/src/systems/abstractsystem.jl#L3542-L3562">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ModelingToolkitBase.alg_equations"><a class="docstring-binding" href="#ModelingToolkitBase.alg_equations"><code>ModelingToolkitBase.alg_equations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">alg_equations(sys::AbstractSystem)</code></pre><p>For a system, returns a vector of all its algebraic equations (i.e. that does not contain any differentials).</p><p>Example:</p><pre><code class="language-julia hljs">using ModelingToolkitBase
using ModelingToolkitBase: t_nounits as t, D_nounits as D
@parameters p d
@variables X(t)
eq1 = D(X) ~ p - d*X
eq2 = 0 ~ p - d*X
@named osys = System([eq1, eq2], t)

alg_equations(osys) # returns `[0 ~ p - d*X(t)]`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v1.13.1/src/systems/abstractsystem.jl#L3501-L3519">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ModelingToolkitBase.has_diff_equations"><a class="docstring-binding" href="#ModelingToolkitBase.has_diff_equations"><code>ModelingToolkitBase.has_diff_equations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_diff_equations(sys::AbstractSystem)</code></pre><p>For a system, returns true if it contain at least one differential equation (i.e. that contain a differential).</p><p>Example:</p><pre><code class="language-julia hljs">using ModelingToolkitBase
using ModelingToolkitBase: t_nounits as t, D_nounits as D
@parameters p d
@variables X(t)
eq1 = D(X) ~ p - d*X
eq2 = 0 ~ p - d*X
@named osys1 = System([eq1], t)
@named osys2 = System([eq2], t)

has_diff_equations(osys1) # returns `true`.
has_diff_equations(osys2) # returns `false`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v1.13.1/src/systems/abstractsystem.jl#L3565-L3584">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ModelingToolkitBase.diff_equations"><a class="docstring-binding" href="#ModelingToolkitBase.diff_equations"><code>ModelingToolkitBase.diff_equations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">diff_equations(sys::AbstractSystem)</code></pre><p>For a system, returns a vector of all its differential equations (i.e. that does contain a differential).</p><p>Example:</p><pre><code class="language-julia hljs">using ModelingToolkitBase
using ModelingToolkitBase: t_nounits as t, D_nounits as D
@parameters p d
@variables X(t)
eq1 = D(X) ~ p - d*X
eq2 = 0 ~ p - d*X
@named osys = System([eq1, eq2], t)

diff_equations(osys) # returns `[Differential(t)(X(t)) ~ p - d*X(t)]`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v1.13.1/src/systems/abstractsystem.jl#L3522-L3539">source</a></section></details></article><h2 id="Basic-species-properties"><a class="docs-heading-anchor" href="#Basic-species-properties">Basic species properties</a><a id="Basic-species-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-species-properties" title="Permalink"></a></h2><p>The following functions permits the querying of species properties.</p><article><details class="docstring" open="true"><summary id="Catalyst.isspecies"><a class="docstring-binding" href="#Catalyst.isspecies"><code>Catalyst.isspecies</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isspecies(s)</code></pre><p>Tests if the given symbolic variable corresponds to a chemical species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L35-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.isconstant"><a class="docstring-binding" href="#Catalyst.isconstant"><code>Catalyst.isconstant</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Catalyst.isconstant(s)</code></pre><p>Tests if the given symbolic variable corresponds to a constant species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L12-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.isbc"><a class="docstring-binding" href="#Catalyst.isbc"><code>Catalyst.isbc</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Catalyst.isbc(s)</code></pre><p>Tests if the given symbolic variable corresponds to a boundary condition species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L25-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.isvalidreactant"><a class="docstring-binding" href="#Catalyst.isvalidreactant"><code>Catalyst.isvalidreactant</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isvalidreactant(s)</code></pre><p>Test if a species is valid as a reactant (i.e. a species variable or a constant parameter).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L66-L70">source</a></section></details></article><h2 id="Symbolic-variable-properties"><a class="docs-heading-anchor" href="#Symbolic-variable-properties">Symbolic variable properties</a><a id="Symbolic-variable-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-variable-properties" title="Permalink"></a></h2><p>The following function from <a href="https://github.com/SciML/SymbolicIndexingInterface.jl">SymbolicIndexingInterface.jl</a> is useful for getting the name of individual symbolic variables (species, parameters, or non-species variables).</p><article><details class="docstring" open="true"><summary id="SymbolicIndexingInterface.getname"><a class="docstring-binding" href="#SymbolicIndexingInterface.getname"><code>SymbolicIndexingInterface.getname</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getname(x)::Symbol</code></pre><p>Get the name of a symbolic variable as a <code>Symbol</code>. Acts as the identity function for <code>x::Symbol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SymbolicIndexingInterface.jl/blob/v0.3.46/src/trait.jl#L57-L62">source</a></section></details></article><h2 id="Basic-reaction-properties"><a class="docs-heading-anchor" href="#Basic-reaction-properties">Basic reaction properties</a><a id="Basic-reaction-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-reaction-properties" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Catalyst.ismassaction"><a class="docstring-binding" href="#Catalyst.ismassaction"><code>Catalyst.ismassaction</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ismassaction(rx, rs; rxvars = get_variables(rx.rate),
                              haveivdep = nothing,
                              unknownset = Set(unknowns(rs)),
                              ivset = nothing)</code></pre><p>True if a given reaction is of mass action form, i.e. <code>rx.rate</code> does not depend on any chemical species that correspond to unknowns of the system, and does not depend explicitly on the independent variable (usually time).</p><p><strong>Arguments</strong></p><ul><li><code>rx</code>, the <a href="#Catalyst.Reaction"><code>Reaction</code></a>.</li><li><code>rs</code>, a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> containing the reaction.</li><li>Optional: <code>rxvars</code>, <code>Variable</code>s which are not in <code>rxvars</code> are ignored as possible dependencies.</li><li>Optional: <code>haveivdep</code>, <code>true</code> if the <a href="#Catalyst.Reaction"><code>Reaction</code></a> <code>rate</code> field explicitly depends on any independent variable (i.e. t or for spatial systems x,y,etc). If not set, will be automatically calculated.</li><li>Optional: <code>unknownset</code>, set of unknowns which if the rxvars are within mean rx is non-mass action.</li><li>Optional: <code>ivset</code>, a <code>Set</code> of the independent variables of the system. If not provided and the system is spatial, i.e. <code>isspatial(rs) == true</code>, it will be created with all the spatial variables and the time variable. If the rate expression contains any element of <code>ivset</code>, then <code>ismassaction(rx,rs) == false</code>. Pass a custom set to control this behavior.</li></ul><p>Notes:</p><ul><li>Non-integer stoichiometry is treated as non-mass action. This includes symbolic variables/terms or floating point numbers for stoichiometric coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem_conversions.jl#L285-L316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.dependents"><a class="docstring-binding" href="#Catalyst.dependents"><code>Catalyst.dependents</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dependents(rx, network)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a> and a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of the <em>non-constant</em> species and variables the reaction rate law depends on. e.g., for</p><p><code>k*W, 2X + 3Y --&gt; 5Z + W</code></p><p>the returned vector would be <code>[W(t),X(t),Y(t)]</code>.</p><p>Notes:</p><ul><li>Allocates</li><li>Does not check for dependents within any subsystems.</li><li>Constant species are not considered dependents since they are internally treated as parameters.</li><li>If the rate expression depends on a non-species unknown variable that will be included in the dependents, i.e. in<pre><code class="language-julia hljs">t = default_t()
@parameters k
@variables V(t)
@species A(t) B(t) C(t)
rx = Reaction(k*V, [A, B], [C])
@named rs = ReactionSystem([rx], t)
issetequal(dependents(rx, rs), [A,B,V]) == true</code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1315-L1341">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.dependants"><a class="docstring-binding" href="#Catalyst.dependants"><code>Catalyst.dependants</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dependents(rx, network)</code></pre><p>See documentation for <a href="#Catalyst.dependents"><code>dependents</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1351-L1355">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.substoichmat"><a class="docstring-binding" href="#Catalyst.substoichmat"><code>Catalyst.substoichmat</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">substoichmat(rn; sparse=false)</code></pre><p>Returns the substrate stoichiometry matrix, <span>$S$</span>, with <span>$S_{i j}$</span> the stoichiometric coefficient of the ith substrate within the jth reaction.</p><p>Note:</p><ul><li>Set sparse=true for a sparse matrix representation</li><li>Note that constant species are not considered substrates, but just components that modify the associated rate law.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1117-L1127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.prodstoichmat"><a class="docstring-binding" href="#Catalyst.prodstoichmat"><code>Catalyst.prodstoichmat</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">prodstoichmat(rn; sparse=false)</code></pre><p>Returns the product stoichiometry matrix, <span>$P$</span>, with <span>$P_{i j}$</span> the stoichiometric coefficient of the ith product within the jth reaction.</p><p>Note:</p><ul><li>Set sparse=true for a sparse matrix representation</li><li>Note that constant species are not treated as products, but just components that modify the associated rate law.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1167-L1177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.netstoichmat"><a class="docstring-binding" href="#Catalyst.netstoichmat"><code>Catalyst.netstoichmat</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">netstoichmat(rn, sparse=false)</code></pre><p>Returns the net stoichiometry matrix, <span>$N$</span>, with <span>$N_{i j}$</span> the net stoichiometric coefficient of the ith species within the jth reaction.</p><p>Notes:</p><ul><li>Set sparse=true for a sparse matrix representation</li><li>Caches the matrix internally within <code>rn</code> so subsequent calls are fast.</li><li>Note that constant species are not treated as reactants, but just components that modify the associated rate law. As such they do not contribute to the net stoichiometry matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1222-L1233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.reactionrates"><a class="docstring-binding" href="#Catalyst.reactionrates"><code>Catalyst.reactionrates</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reactionrates(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, returns a vector of the symbolic reaction rates for each reaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1054-L1059">source</a></section></details></article><h2 id="api_rx_metadata"><a class="docs-heading-anchor" href="#api_rx_metadata">Reaction metadata</a><a id="api_rx_metadata-1"></a><a class="docs-heading-anchor-permalink" href="#api_rx_metadata" title="Permalink"></a></h2><p>The following functions permits the retrieval of <a href="../../model_creation/dsl_advanced/#dsl_advanced_options_reaction_metadata">reaction metadata</a>.</p><article><details class="docstring" open="true"><summary id="Catalyst.hasnoisescaling"><a class="docstring-binding" href="#Catalyst.hasnoisescaling"><code>Catalyst.hasnoisescaling</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>hasnoisescaling(reaction::Reaction)</p><p>Returns <code>true</code> if the input reaction has the <code>noise_scaing</code> metadata field assigned, else <code>false</code>.</p><p>Arguments:</p><ul><li><code>reaction</code>: The reaction we wish to check for the <code>noise_scaing</code> metadata field.</li></ul><p>Example:</p><pre><code class="language-julia hljs">reaction = @reaction k, 0 --&gt; X, [noise_scaling=0.0]
hasnoisescaling(reaction)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L565-L578">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.getnoisescaling"><a class="docstring-binding" href="#Catalyst.getnoisescaling"><code>Catalyst.getnoisescaling</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>getnoisescaling(reaction::Reaction)</p><p>Returns <code>noise_scaing</code> metadata field for the input reaction.</p><p>Arguments:</p><ul><li><code>reaction</code>: The reaction we wish to retrieve the <code>noise_scaing</code> metadata field.</li></ul><p>Example:</p><pre><code class="language-julia hljs">reaction = @reaction k, 0 --&gt; X, [noise_scaling=0.0]
getnoisescaling(reaction)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L583-L596">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.hasdescription"><a class="docstring-binding" href="#Catalyst.hasdescription"><code>Catalyst.hasdescription</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>hasdescription(reaction::Reaction)</p><p>Returns <code>true</code> if the input reaction has the <code>description</code> metadata field assigned, else <code>false</code>.</p><p>Arguments:</p><ul><li><code>reaction</code>: The reaction we wish to check for the <code>description</code> metadata field.</li></ul><p>Example:</p><pre><code class="language-julia hljs">reaction = @reaction k, 0 --&gt; X, [description=&quot;A reaction&quot;]
hasdescription(reaction)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L606-L619">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.getdescription"><a class="docstring-binding" href="#Catalyst.getdescription"><code>Catalyst.getdescription</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>getdescription(reaction::Reaction)</p><p>Returns <code>description</code> metadata field for the input reaction.</p><p>Arguments:</p><ul><li><code>reaction</code>: The reaction we wish to retrieve the <code>description</code> metadata field.</li></ul><p>Example:</p><pre><code class="language-julia hljs">reaction = @reaction k, 0 --&gt; X, [description=&quot;A reaction&quot;]
getdescription(reaction)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L624-L637">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.hasmisc"><a class="docstring-binding" href="#Catalyst.hasmisc"><code>Catalyst.hasmisc</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>hasmisc(reaction::Reaction)</p><p>Returns <code>true</code> if the input reaction has the <code>misc</code> metadata field assigned, else <code>false</code>.</p><p>Arguments:</p><ul><li><code>reaction</code>: The reaction we wish to check for the <code>misc</code> metadata field.</li></ul><p>Example:</p><pre><code class="language-julia hljs">reaction = @reaction k, 0 --&gt; X, [misc=&quot;A reaction&quot;]
hasmisc(reaction)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L647-L660">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.getmisc"><a class="docstring-binding" href="#Catalyst.getmisc"><code>Catalyst.getmisc</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>getmisc(reaction::Reaction)</p><p>Returns <code>misc</code> metadata field for the input reaction.</p><p>Arguments:</p><ul><li><code>reaction</code>: The reaction we wish to retrieve the <code>misc</code> metadata field.</li></ul><p>Example:</p><pre><code class="language-julia hljs">reaction = @reaction k, 0 --&gt; X, [misc=&quot;A reaction&quot;]
getmisc(reaction)</code></pre><p>Notes:</p><ul><li>The <code>misc</code> field can contain any valid Julia structure. This mean that Catalyst cannot check it</li></ul><p>for symbolic variables that are added here. This means that symbolic variables (e.g. parameters of species) that are stored here are not accessible to Catalyst. This can cause troubles when e.g. creating a <code>ReactionSystem</code> programmatically (in which case any symbolic variables stored in the <code>misc</code> metadata field should also be explicitly provided to the <code>ReactionSystem</code> constructor).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L665-L686">source</a></section></details></article><h2 id="api_system_metadata"><a class="docs-heading-anchor" href="#api_system_metadata">System-level metadata</a><a id="api_system_metadata-1"></a><a class="docs-heading-anchor-permalink" href="#api_system_metadata" title="Permalink"></a></h2><p>The following types and functions allow storing and retrieving system-level metadata on a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. These are primarily intended for use by file parsers that need to attach extra mapping data (e.g., initial condition or parameter value maps) to a system.</p><article><details class="docstring" open="true"><summary id="Catalyst.U0Map"><a class="docstring-binding" href="#Catalyst.U0Map"><code>Catalyst.U0Map</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">U0Map</code></pre><p>Metadata key for storing initial condition / species value mappings on a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. Intended for use by file parsers that need to preserve mappings in a format different from <code>initial_conditions</code>.</p><p>See also: <a href="#Catalyst.has_u0_map"><code>has_u0_map</code></a>, <a href="#Catalyst.get_u0_map"><code>get_u0_map</code></a>, <a href="#Catalyst.set_u0_map"><code>set_u0_map</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem_metadata.jl#L8-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.ParameterMap"><a class="docstring-binding" href="#Catalyst.ParameterMap"><code>Catalyst.ParameterMap</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ParameterMap</code></pre><p>Metadata key for storing parameter value mappings on a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. Intended for use by file parsers that need to preserve parameter mappings in a format different from <code>initial_conditions</code>.</p><p>See also: <a href="#Catalyst.has_parameter_map"><code>has_parameter_map</code></a>, <a href="#Catalyst.get_parameter_map"><code>get_parameter_map</code></a>, <a href="#Catalyst.set_parameter_map"><code>set_parameter_map</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem_metadata.jl#L19-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.has_u0_map"><a class="docstring-binding" href="#Catalyst.has_u0_map"><code>Catalyst.has_u0_map</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_u0_map(rs::ReactionSystem)</code></pre><p>Returns <code>true</code> if the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> has a <code>U0Map</code> metadata entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem_metadata.jl#L30-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.get_u0_map"><a class="docstring-binding" href="#Catalyst.get_u0_map"><code>Catalyst.get_u0_map</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_u0_map(rs::ReactionSystem)</code></pre><p>Returns the <code>U0Map</code> metadata from the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, or <code>nothing</code> if no <code>U0Map</code> has been set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem_metadata.jl#L37-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.set_u0_map"><a class="docstring-binding" href="#Catalyst.set_u0_map"><code>Catalyst.set_u0_map</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_u0_map(rs::ReactionSystem, u0map)</code></pre><p>Returns a <strong>new</strong> <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> with the <code>U0Map</code> metadata set to <code>u0map</code>. The original system is not modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem_metadata.jl#L45-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.has_parameter_map"><a class="docstring-binding" href="#Catalyst.has_parameter_map"><code>Catalyst.has_parameter_map</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_parameter_map(rs::ReactionSystem)</code></pre><p>Returns <code>true</code> if the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> has a <code>ParameterMap</code> metadata entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem_metadata.jl#L53-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.get_parameter_map"><a class="docstring-binding" href="#Catalyst.get_parameter_map"><code>Catalyst.get_parameter_map</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_parameter_map(rs::ReactionSystem)</code></pre><p>Returns the <code>ParameterMap</code> metadata from the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, or <code>nothing</code> if no <code>ParameterMap</code> has been set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem_metadata.jl#L60-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.set_parameter_map"><a class="docstring-binding" href="#Catalyst.set_parameter_map"><code>Catalyst.set_parameter_map</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_parameter_map(rs::ReactionSystem, pmap)</code></pre><p>Returns a <strong>new</strong> <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> with the <code>ParameterMap</code> metadata set to <code>pmap</code>. The original system is not modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem_metadata.jl#L68-L73">source</a></section></details></article><h2 id="api_network_extension_and_modification"><a class="docs-heading-anchor" href="#api_network_extension_and_modification">Functions to extend or modify a network</a><a id="api_network_extension_and_modification-1"></a><a class="docs-heading-anchor-permalink" href="#api_network_extension_and_modification" title="Permalink"></a></h2><p><code>ReactionSystem</code>s can be programmatically extended using <a href="#ModelingToolkitBase.extend"><code>ModelingToolkitBase.extend</code></a> and <a href="#ModelingToolkitBase.compose"><code>ModelingToolkitBase.compose</code></a>.</p><article><details class="docstring" open="true"><summary id="ModelingToolkitBase.extend"><a class="docstring-binding" href="#ModelingToolkitBase.extend"><code>ModelingToolkitBase.extend</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extend(
    sys::ModelingToolkitBase.AbstractSystem,
    basesys::ModelingToolkitBase.AbstractSystem;
    name,
    description,
    gui_metadata
) -&gt; ReactionSystem{Catalyst.NetworkProperties{Int64, SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymReal}}}
</code></pre><p>Extend <code>basesys</code> with <code>sys</code>. This can be thought of as the <code>merge</code> operation on systems. Values in <code>sys</code> take priority over duplicates in <code>basesys</code> (for example, initial conditions).</p><p>By default, the resulting system inherits <code>sys</code>&#39;s name and description.</p><p>The <code>&amp;</code> operator can also be used for this purpose. <code>sys &amp; basesys</code> is equivalent to <code>extend(sys, basesys)</code>.</p><p>See also <a href="#ModelingToolkitBase.compose"><code>compose</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v1.13.1/src/systems/abstractsystem.jl#L3054">source</a></section><section><div><pre><code class="language-julia hljs">extend(
    sys,
    basesys::Array{T&lt;:ModelingToolkitBase.AbstractSystem, 1}
) -&gt; Any
</code></pre><p>Extend <code>sys</code> with all systems in <code>basesys</code> in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v1.13.1/src/systems/abstractsystem.jl#L3133-L3137">source</a></section><section><div><pre><code class="language-julia hljs">ModelingToolkitBase.extend(sys::ReactionSystem, rs::ReactionSystem; name::Symbol=nameof(sys))</code></pre><p>Extends the indicated <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> with another <code>ReactionSystem</code>.</p><p>Notes:</p><ul><li>Only <code>ReactionSystem</code>s can be used to extend a <code>ReactionSystem</code>.</li><li>Returns a new <code>ReactionSystem</code> and does not modify <code>rs</code>.</li><li>By default, the new <code>ReactionSystem</code> will have the same name as <code>sys</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1588-L1597">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ModelingToolkitBase.compose"><a class="docstring-binding" href="#ModelingToolkitBase.compose"><code>ModelingToolkitBase.compose</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compose(sys, systems; name)
</code></pre><p>Compose multiple systems together. This adds all of <code>systems</code> as subsystems of <code>sys</code>. The resulting system inherits the name of <code>sys</code> by default.</p><p>The <code>∘</code> operator can also be used for this purpose. <code>sys ∘ basesys</code> is equivalent to <code>compose(sys, basesys)</code>.</p><p>See also <a href="#ModelingToolkitBase.extend"><code>extend</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v1.13.1/src/systems/abstractsystem.jl#L3164">source</a></section><section><div><pre><code class="language-julia hljs">compose(syss...; name) -&gt; Any
</code></pre><p>Syntactic sugar for adding all systems in <code>syss</code> as the subsystems of <code>first(syss)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v1.13.1/src/systems/abstractsystem.jl#L3206-L3210">source</a></section><section><div><pre><code class="language-julia hljs">ModelingToolkitBase.compose(sys::ReactionSystem, systems::AbstractArray; name = nameof(sys))</code></pre><p>Compose the indicated <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> with one or more <code>ReactionSystem</code>s.</p><p>Notes:</p><ul><li>Only <code>ReactionSystem</code>s can be composed with a <code>ReactionSystem</code>.</li><li>Returns a new <code>ReactionSystem</code> and does not modify <code>sys</code>.</li><li>By default, the new <code>ReactionSystem</code> will have the same name as <code>sys</code>.</li><li>Brownians and jumps from subsystems are collected at flatten time via recursive accessors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1544-L1554">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ModelingToolkitBase.flatten"><a class="docstring-binding" href="#ModelingToolkitBase.flatten"><code>ModelingToolkitBase.flatten</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">flatten(sys::System) -&gt; System
flatten(sys::System, noeqs) -&gt; System
</code></pre><p>Flatten the hierarchical structure of a system, collecting all equations, unknowns, etc. into one top-level system after namespacing appropriately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v1.13.1/src/systems/system.jl#L1006-L1011">source</a></section><section><div><pre><code class="language-julia hljs">ModelingToolkitBase.flatten(rs::ReactionSystem)</code></pre><p>Merges all subsystems of the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> up into <code>rs</code>.</p><p>Notes:</p><ul><li>Returns a new <code>ReactionSystem</code> that represents the flattened system.</li><li>All <code>Reaction</code>s within subsystems are namespaced and merged into the list of <code>Reactions</code> of <code>rs</code>. The merged list is then available as <code>reactions(rs)</code>.</li><li>All algebraic and differential equations are merged in the equations of <code>rs</code>.</li><li>Only <code>ReactionSystem</code>s are supported as subsystems when flattening.</li><li><code>rs.networkproperties</code> is reset upon flattening.</li><li>The default value of <code>combinatoric_ratelaws</code> will be the logical or of all <code>ReactionSystem</code>s.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1496-L1510">source</a></section></details></article><h2 id="network_visualization"><a class="docs-heading-anchor" href="#network_visualization">Network visualization</a><a id="network_visualization-1"></a><a class="docs-heading-anchor-permalink" href="#network_visualization" title="Permalink"></a></h2><p><a href="https://korsbo.github.io/Latexify.jl/stable/">Latexify</a> can be used to convert networks to LaTeX equations by</p><pre><code class="language-julia hljs">using Latexify
latexify(rn)</code></pre><p>An optional argument, <code>form</code> allows using <code>latexify</code> to display a reaction network&#39;s ODE (as generated by the reaction rate equation) or SDE (as generated by the chemical Langevin equation) form:</p><pre><code class="language-julia hljs">latexify(rn; form=:ode)</code></pre><pre><code class="language-julia hljs">latexify(rn; form=:sde)</code></pre><p>(As of writing this, an upstream bug causes the SDE form to be erroneously displayed as the ODE form)</p><p>Finally, another optional argument (<code>expand_functions=true</code>) automatically expands functions defined by Catalyst (such as <code>mm</code>). To disable this, set <code>expand_functions=false</code>.</p><p>Reaction networks can be plotted using the <code>GraphMakie</code> extension, which is loaded whenever all of <code>Catalyst</code>, <code>GraphMakie</code>, and <code>NetworkLayout</code> are loaded (note that a Makie backend, like <code>CairoMakie</code>, must be loaded as well). The two functions for plotting networks are <code>plot_network</code> and <code>plot_complexes</code>, which are two distinct representations. </p><article><details class="docstring" open="true"><summary id="Catalyst.plot_network-Tuple{ReactionSystem}"><a class="docstring-binding" href="#Catalyst.plot_network-Tuple{ReactionSystem}"><code>Catalyst.plot_network</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_network(rn::ReactionSystem; kwargs...)</code></pre><p>Converts a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> into a GraphMakie plot of the species reaction graph (or Petri net representation). Reactions correspond to small green circles, and  species to blue circles.</p><p>Notes:</p><ul><li>Black arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry.</li><li>Black arrows from reactions to species indicate products, and are labelled with their output stoichiometry.</li><li>Red arrows from species to reactions indicate that species is used within the rate expression. For example, in the reaction <code>k*A, B --&gt; C</code>, there would be a red arrow from <code>A</code> to the reaction node. In <code>k*A, A+B --&gt; C</code>, there would be red and black arrows from <code>A</code> to the reaction node.</li></ul><p>For a list of accepted keyword arguments to the graph plot, please see the <a href="https://graph.makie.org/stable/#The-graphplot-Recipe">GraphMakie documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/ext/CatalystGraphMakieExtension/rn_graph_plot.jl#L156-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.plot_complexes-Tuple{ReactionSystem}"><a class="docstring-binding" href="#Catalyst.plot_complexes-Tuple{ReactionSystem}"><code>Catalyst.plot_complexes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot_complexes(rn::ReactionSystem; show_rate_labels = false, kwargs...)</code></pre><p>Creates a GraphMakie plot of the <a href="../network_analysis_api/#Catalyst.ReactionComplex"><code>Catalyst.ReactionComplex</code></a>s in <code>rn</code>. Reactions correspond to arrows and reaction complexes to blue circles.</p><p>Notes:</p><ul><li>Black arrows from complexes to complexes indicate reactions whose rate is a parameter or a <code>Number</code>. i.e. <code>k, A --&gt; B</code>.</li><li>Red arrows from complexes to complexes indicate reactions whose rate constants</li></ul><p>depends on species. i.e. <code>k*C, A --&gt; B</code> for <code>C</code> a species.</p><ul><li>The <code>show_rate_labels</code> keyword, if set to <code>true</code>, will annotate each edge</li></ul><p>with the rate constant for the reaction.</p><p>For a list of accepted keyword arguments to the graph plot, please see the <a href="https://graph.makie.org/stable/#The-graphplot-Recipe">GraphMakie documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/ext/CatalystGraphMakieExtension/rn_graph_plot.jl#L232-L247">source</a></section></details></article><h2 id="api_rate_laws"><a class="docs-heading-anchor" href="#api_rate_laws">Rate laws</a><a id="api_rate_laws-1"></a><a class="docs-heading-anchor-permalink" href="#api_rate_laws" title="Permalink"></a></h2><p>As the underlying <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> is comprised of <code>ModelingToolkitBase</code> expressions, one can directly access the generated rate laws, and using <code>ModelingToolkitBase</code> tooling generate functions or Julia <code>Expr</code>s from them.</p><article><details class="docstring" open="true"><summary id="Catalyst.oderatelaw"><a class="docstring-binding" href="#Catalyst.oderatelaw"><code>Catalyst.oderatelaw</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">oderatelaw(rx; combinatoric_ratelaw=true)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a>, return the symbolic reaction rate law used in generated ODEs for the reaction. Note, for a reaction defined by</p><p><code>k*X*Y, X+Z --&gt; 2X + Y</code></p><p>the expression that is returned will be <code>k*X(t)^2*Y(t)*Z(t)</code>. For a reaction of the form</p><p><code>k, 2X+3Y --&gt; Z</code></p><p>the expression that is returned will be <code>k * (X(t)^2/2) * (Y(t)^3/6)</code>.</p><p>Notes:</p><ul><li>Allocates</li><li><code>combinatoric_ratelaw=true</code> uses factorial scaling factors in calculating the   rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. If   <code>combinatoric_ratelaw=false</code> then the ratelaw is <code>k*S^2</code>, i.e. the scaling   factor is ignored.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem_conversions.jl#L3-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.jumpratelaw"><a class="docstring-binding" href="#Catalyst.jumpratelaw"><code>Catalyst.jumpratelaw</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">jumpratelaw(rx; combinatoric_ratelaw=true)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a>, return the symbolic reaction rate law used in generated stochastic chemical kinetics model SSAs for the reaction. Note, for a reaction defined by</p><p><code>k*X*Y, X+Z --&gt; 2X + Y</code></p><p>the expression that is returned will be <code>k*X^2*Y*Z</code>. For a reaction of the form</p><p><code>k, 2X+3Y --&gt; Z</code></p><p>the expression that is returned will be <code>k * binomial(X,2) * binomial(Y,3)</code>.</p><p>Notes:</p><ul><li>Allocates</li><li><code>combinatoric_ratelaw=true</code> uses binomials in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S*(S-1)/2</code>. If <code>combinatoric_ratelaw=false</code> then the ratelaw is <code>k*S*(S-1)</code>, i.e. the rate law is not normalized by the scaling factor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem_conversions.jl#L233-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.mm"><a class="docstring-binding" href="#Catalyst.mm"><code>Catalyst.mm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mm(X,v,K) = v*X / (X + K)</code></pre><p>A Michaelis-Menten rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/registered_functions.jl#L2-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.mmr"><a class="docstring-binding" href="#Catalyst.mmr"><code>Catalyst.mmr</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mmr(X,v,K) = v*K / (X + K)</code></pre><p>A repressive Michaelis-Menten rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/registered_functions.jl#L14-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.hill"><a class="docstring-binding" href="#Catalyst.hill"><code>Catalyst.hill</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hill(X,v,K,n) = v*(X^n) / (X^n + K^n)</code></pre><p>A Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/registered_functions.jl#L25-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.hillr"><a class="docstring-binding" href="#Catalyst.hillr"><code>Catalyst.hillr</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hillr(X,v,K,n) = v*(K^n) / (X^n + K^n)</code></pre><p>A repressive Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/registered_functions.jl#L37-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.hillar"><a class="docstring-binding" href="#Catalyst.hillar"><code>Catalyst.hillar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hillar(X,Y,v,K,n) = v*(X^n) / (X^n + Y^n + K^n)</code></pre><p>An activation/repressing Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/registered_functions.jl#L49-L53">source</a></section></details></article><h2 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ModelingToolkitBase.mtkcompile"><a class="docstring-binding" href="#ModelingToolkitBase.mtkcompile"><code>ModelingToolkitBase.mtkcompile</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mtkcompile(
    sys;
    additional_passes,
    inputs,
    outputs,
    disturbance_inputs,
    split,
    kwargs...
)
</code></pre><p>Compile the given system into a form that ModelingToolkitBase can generate code for. Also performs order reduction for ODEs and handles simple discrete/implicit-discrete systems.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>fully_determined=true</code> controls whether or not an error will be thrown if the number of equations don&#39;t match the number of inputs, outputs, and equations.</li><li><code>inputs</code>, <code>outputs</code> and <code>disturbance_inputs</code> are passed as keyword arguments.<code>All inputs</code> get converted to parameters and are allowed to be unconnected, allowing models where <code>n_unknowns = n_equations - n_inputs</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/v1.13.1/src/systems/systems.jl#L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.set_default_noise_scaling"><a class="docstring-binding" href="#Catalyst.set_default_noise_scaling"><code>Catalyst.set_default_noise_scaling</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>set<em>default</em>noise<em>scaling(rs::ReactionSystem, noise</em>scaling)</p><p>Creates an updated <code>ReactionSystem</code>. This is the old <code>ReactionSystem</code>, but each <code>Reaction</code> that does not have a <code>noise_scaling</code> metadata have its noise<em>scaling metadata updated. The input <code>ReactionSystem</code> is not mutated. Any subsystems of <code>rs</code> have their `noise</em>scaling` metadata updated as well.</p><p>Arguments:</p><ul><li><code>rs::ReactionSystem</code>: The <code>ReactionSystem</code> which you wish to remake.</li><li><code>noise_scaling</code>: The updated noise scaling terms</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1463-L1473">source</a></section></details></article><h2 id="Chemistry-related-functionalities"><a class="docs-heading-anchor" href="#Chemistry-related-functionalities">Chemistry-related functionalities</a><a id="Chemistry-related-functionalities-1"></a><a class="docs-heading-anchor-permalink" href="#Chemistry-related-functionalities" title="Permalink"></a></h2><p>Various functionalities primarily relevant to modelling of chemical systems (but potentially also in biology).</p><article><details class="docstring" open="true"><summary id="Catalyst.@compound"><a class="docstring-binding" href="#Catalyst.@compound"><code>Catalyst.@compound</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@compound</code></pre><p>Macro that creates a compound species, which is composed of smaller component species.</p><p>Example:</p><pre><code class="language-julia hljs">t = default_t()
@species C(t) O(t)
@compound CO2(t) ~ C + 2O</code></pre><p>Notes:</p><ul><li>The component species must be defined before using the <code>@compound</code> macro.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/chemistry_functionality.jl#L54-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.@compounds"><a class="docstring-binding" href="#Catalyst.@compounds"><code>Catalyst.@compounds</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@compounds</code></pre><p>Macro that creates several compound species, which each is composed of smaller component species. Uses the same syntax as <code>@compound</code>, but with one compound species per line.</p><p>Example:</p><pre><code class="language-julia hljs">t = default_t()
@species C(t) H(t) O(t)
@compounds
    CH4(t) = C + 4H
    O2(t) = 2O
    CO2(t) = C + 2O
    H2O(t) = 2H + O
end</code></pre><p>Notes:</p><ul><li>The component species must be defined before using the <code>@compound</code> macro.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/chemistry_functionality.jl#L155-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.iscompound"><a class="docstring-binding" href="#Catalyst.iscompound"><code>Catalyst.iscompound</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">iscompound(s)</code></pre><p>Returns <code>true</code> if the input is a compound species (else false).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/chemistry_functionality.jl#L12-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.components"><a class="docstring-binding" href="#Catalyst.components"><code>Catalyst.components</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">components(s)</code></pre><p>Returns a vector with a list of all the components of a compound species (created using e.g. the @compound macro).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/chemistry_functionality.jl#L22-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.coefficients"><a class="docstring-binding" href="#Catalyst.coefficients"><code>Catalyst.coefficients</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">coefficients(s)</code></pre><p>Returns a vector with a list of all the stoichiometric coefficients of the components of a compound species (created using e.g. the @compound macro).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/chemistry_functionality.jl#L32-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.component_coefficients"><a class="docstring-binding" href="#Catalyst.component_coefficients"><code>Catalyst.component_coefficients</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">component_coefficients(s)</code></pre><p>Returns a <code>Vector{Pair{Symbol,Int64}}</code> listing, for a compound species (created using e.g. the <code>@compound</code> macro), all the components and their stoichiometric coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/chemistry_functionality.jl#L42-L46">source</a></section></details></article><h2 id="Unit-validation"><a class="docs-heading-anchor" href="#Unit-validation">Unit validation</a><a id="Unit-validation-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-validation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Catalyst.validate_units-Tuple{Reaction}"><a class="docstring-binding" href="#Catalyst.validate_units-Tuple{Reaction}"><code>Catalyst.validate_units</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">validate_units(rx::Reaction; info::String = &quot;&quot;, warn::Bool = true)</code></pre><p>Check that all substrates and products within the given <a href="#Catalyst.Reaction"><code>Reaction</code></a> have the same units, and that the units of the reaction&#39;s rate expression are internally consistent (i.e. if the rate involves sums, each term in the sum has the same units).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L739-L747">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.validate_units-Tuple{ReactionSystem}"><a class="docstring-binding" href="#Catalyst.validate_units-Tuple{ReactionSystem}"><code>Catalyst.validate_units</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">validate_units(rs::ReactionSystem; info::String=&quot;&quot;, warn::Bool = true)</code></pre><p>Check that all species in the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> have the same units, and that the rate laws of all reactions reduce to units of (species units) / (time units). Also validates unit consistency of non-reaction equations. </p><p>Uses <a href="@ref"><code>catalyst_get_unit</code></a> for SymbolicDimensions-preserving unit inference, avoiding the floating-point precision loss that occurs with MTKBase&#39;s <code>get_unit</code> when using non-SI units like M or μM.</p><p>Notes:</p><ul><li>Correctly handles <code>only_use_rate=true</code> reactions (does not multiply substrate units into the rate).</li><li>Assumes reaction-local rate-expression checks (e.g. additive-term consistency) were already performed on each <code>Reaction</code> (for example via <code>unit_checks = true</code> at <code>Reaction</code> construction time, or by calling <code>validate_units(rx)</code> separately).</li><li>If all species/time/parameters are unitless, reaction-rate dimensional checks are skipped. This mode assumes rate/equation expressions do not include literal dimensional quantities (for example <code>us&quot;...&quot;</code> constants), which are currently unsupported model inputs.</li><li>Does not check subsystems, use <code>flatten(rs)</code> and then call <code>validate_units</code> on the flattened system if you want to check the full composed system.</li><li>Does not require that non-species variables have consistent units (outside of the equations in which they appear).</li><li>Does not handle events or user-provided jumps.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1646-L1671">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.assert_valid_units-Tuple{Reaction}"><a class="docstring-binding" href="#Catalyst.assert_valid_units-Tuple{Reaction}"><code>Catalyst.assert_valid_units</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assert_valid_units(rx::Reaction; info::String = &quot;&quot;)</code></pre><p>Run strict unit validation on a <a href="#Catalyst.Reaction"><code>Reaction</code></a>. Throws <a href="#Catalyst.UnitValidationError"><code>UnitValidationError</code></a> if any unit inconsistency is detected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L801-L806">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.assert_valid_units-Tuple{ReactionSystem}"><a class="docstring-binding" href="#Catalyst.assert_valid_units-Tuple{ReactionSystem}"><code>Catalyst.assert_valid_units</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assert_valid_units(rs::ReactionSystem; info::String = &quot;&quot;)</code></pre><p>Run strict unit validation on a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. Throws <a href="#Catalyst.UnitValidationError"><code>UnitValidationError</code></a> if any unit inconsistency is detected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1763-L1768">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.unit_validation_report-Tuple{Reaction}"><a class="docstring-binding" href="#Catalyst.unit_validation_report-Tuple{Reaction}"><code>Catalyst.unit_validation_report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unit_validation_report(rx::Reaction; info::String = &quot;&quot;)</code></pre><p>Run unit validation on a <a href="#Catalyst.Reaction"><code>Reaction</code></a> and return a <a href="#Catalyst.UnitValidationReport"><code>UnitValidationReport</code></a> containing both overall validity and structured issue diagnostics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reaction.jl#L754-L759">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.unit_validation_report-Tuple{ReactionSystem}"><a class="docstring-binding" href="#Catalyst.unit_validation_report-Tuple{ReactionSystem}"><code>Catalyst.unit_validation_report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unit_validation_report(rs::ReactionSystem; info::String = &quot;&quot;)</code></pre><p>Run unit validation on a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and return a <a href="#Catalyst.UnitValidationReport"><code>UnitValidationReport</code></a> containing both overall validity and structured issue diagnostics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/reactionsystem.jl#L1678-L1684">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.UnitValidationIssue"><a class="docstring-binding" href="#Catalyst.UnitValidationIssue"><code>Catalyst.UnitValidationIssue</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnitValidationIssue</code></pre><p>A single unit-validation diagnostic entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/unit_helpers.jl#L18-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.UnitValidationReport"><a class="docstring-binding" href="#Catalyst.UnitValidationReport"><code>Catalyst.UnitValidationReport</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnitValidationReport</code></pre><p>Structured output from unit validation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/unit_helpers.jl#L45-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.UnitValidationError"><a class="docstring-binding" href="#Catalyst.UnitValidationError"><code>Catalyst.UnitValidationError</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnitValidationError</code></pre><p>Exception thrown by strict unit-validation entrypoints (e.g. <code>assert_valid_units</code>). Wraps the full validation report.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/unit_helpers.jl#L57-L62">source</a></section></details></article><h2 id="api_dspace_simulations"><a class="docs-heading-anchor" href="#api_dspace_simulations">Spatial modelling</a><a id="api_dspace_simulations-1"></a><a class="docs-heading-anchor-permalink" href="#api_dspace_simulations" title="Permalink"></a></h2><p>The first step of spatial modelling is to create a so-called <code>DiscreteSpaceReactionSystem</code>:</p><article><details class="docstring" open="true"><summary id="Catalyst.DiscreteSpaceReactionSystem"><a class="docstring-binding" href="#Catalyst.DiscreteSpaceReactionSystem"><code>Catalyst.DiscreteSpaceReactionSystem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DiscreteSpaceReactionSystem{Q, R, S, T} &lt;: ModelingToolkitBase.AbstractSystem</code></pre><p>A representation of a spatial system of chemical reactions on a discrete space.</p><p><strong>Fields</strong></p><ul><li><p><code>reactionsystem</code>: The (non-spatial) reaction system within each vertex.</p></li><li><p><code>spatial_reactions</code>: The spatial reactions defined between individual vertices.</p></li><li><p><code>dspace</code>: The discrete space on which the (discrete) spatial system is defined.</p></li><li><p><code>num_verts</code>: The number of vertices (compartments).</p></li><li><p><code>num_edges</code>: The number of edges.</p></li><li><p><code>num_species</code>: The number of species.</p></li><li><p><code>spatial_species</code>: List of species that may move spatially.</p></li><li><p><code>parameters</code>: All parameters related to the discrete space reaction system (both those whose values are tied to vertices and edges).</p></li></ul><ul><li><code>vertex_parameters</code>: Parameters which values are tied to vertices, e.g. that possibly could have unique values at each vertex of the system.</li></ul><ul><li><code>edge_parameters</code>: Parameters whose values are tied to edges (adjacencies), e.g. that possibly could have unique values at each edge of the system.</li></ul><ul><li><code>edge_iterator</code>: An iterator over all the discrete space&#39;s edges. Currently, the format is always a Vector{Pair{Int64,Int64}}. However, in the future, different types could potentially be used for different types of discrete space (E.g. for a Cartesian grid, we do not technically need to enumerate each edge)</li></ul><ul><li><code>name</code>: The name of the discrete space reaction system. Typically taken directly from the base <code>ReactionSystem</code>.</li></ul><p>Arguments:</p><ul><li><code>rs</code>: The non-spatial <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> model that is expanded to a spatial model.</li><li><code>srs</code>: A vector of spatial reactions. These provide the rules for how species may move spatially.</li><li><code>dspace</code>: Either a Cartesian grid, a masked grid, or a graph. This describes the discrete space</li></ul><p>to which the non-spatial model is expanded.</p><p>Keyword Arguments:</p><ul><li><code>diagonal_connections = false</code>: Only relevant for Cartesian and masked spaces. If <code>true</code>,</li></ul><p>diagonally adjacent compartments are considered adjacent, and spatial reactions in between these are possible.</p><p>Example:</p><pre><code class="language-julia hljs"># Fetch packages.
using Catalyst, OrdinaryDiffEqDefault
import CairoMakie

# Creates the `DiscreteSpaceReactionSystem` model.
rs = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
diffusion_rx = @transport_reaction D X
space = CartesianGrid((5,5))
dsrs = DiscreteSpaceReactionSystem(rs, [diffusion_rx], space)

# Simulates the model (using ODE and jumps).
u0 = [:X =&gt; rand(5,5)]
tspan = (0.0, 1.0)
ps = [:p =&gt; 1.0, :d =&gt; 0.5, :D =&gt; 0.1]
oprob = ODEProblem(dsrs, u0, tspan, ps)
osol = solve(oprob)

# Saves an animation of the solution to the file &quot;dspace_animation.mp4&quot;.
dspace_animation(osol, :X, dsrs, &quot;dspace_animation.mp4&quot;)</code></pre><p>Notes:</p><ul><li>Spatial modelling in Catalyst is still a work in progress, any feedback (or contributions) to this</li></ul><p>is highly welcome.</p><ul><li><code>DiscreteSpaceReactionSystem</code>s are primarily intended to model systems in discrete space. Modelling</li></ul><p>continuous space systems with them is possible, but requires the user to determine the discretisation (the space). Better support for continuous space models is a work in progress.</p><ul><li>Catalyst contains extensive documentation on spatial modelling, which can be found <a href="https://docs.sciml.ai/Catalyst/stable/spatial_modelling/dspace_reaction_systems/">here</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L8">source</a></section></details></article><p>The following functions can be used to querying the properties of <code>DiscreteSpaceReactionSystem</code>s:</p><article><details class="docstring" open="true"><summary id="Catalyst.reactionsystem"><a class="docstring-binding" href="#Catalyst.reactionsystem"><code>Catalyst.reactionsystem</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reactionsystem(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns the non-spatial <code>ReactionSystem</code> stored in a <code>DiscreteSpaceReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L319-L323">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.spatial_reactions"><a class="docstring-binding" href="#Catalyst.spatial_reactions"><code>Catalyst.spatial_reactions</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">spatial_reactions(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns a vector with all the spatial reactions stored in a <code>DiscreteSpaceReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L326-L330">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.dspace"><a class="docstring-binding" href="#Catalyst.dspace"><code>Catalyst.dspace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dspace(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns the dspace (i.e. discrete space) stored in a <code>DiscreteSpaceReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L333-L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.num_verts"><a class="docstring-binding" href="#Catalyst.num_verts"><code>Catalyst.num_verts</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">num_verts(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns the number of vertices (i.e. compartments) in the discrete space stored in a <code>DiscreteSpaceReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L340-L344">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.num_edges"><a class="docstring-binding" href="#Catalyst.num_edges"><code>Catalyst.num_edges</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">num_edges(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns the number of edges (i.e. connections between vertices) in the discrete space stored in a <code>DiscreteSpaceReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L347-L352">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.num_species"><a class="docstring-binding" href="#Catalyst.num_species"><code>Catalyst.num_species</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">num_species(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns the number of species that a <code>DiscreteSpaceReactionSystem</code> contains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L355-L359">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.spatial_species"><a class="docstring-binding" href="#Catalyst.spatial_species"><code>Catalyst.spatial_species</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">spatial_species(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns the species that can move spatially in a <code>DiscreteSpaceReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L362-L366">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.vertex_parameters"><a class="docstring-binding" href="#Catalyst.vertex_parameters"><code>Catalyst.vertex_parameters</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">vertex_parameters(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns all the parameters of a <code>DiscreteSpaceReactionSystem</code> whose values are tied to vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L372-L376">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.edge_parameters"><a class="docstring-binding" href="#Catalyst.edge_parameters"><code>Catalyst.edge_parameters</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">edge_parameters(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns all the parameters of a <code>DiscreteSpaceReactionSystem</code> whose values are tied to edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L379-L383">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.edge_iterator"><a class="docstring-binding" href="#Catalyst.edge_iterator"><code>Catalyst.edge_iterator</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">edge_iterator(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns an iterator over all of the edges in the discrete space stored in a <code>DiscreteSpaceReactionSystem</code>. Each edge is a <code>Pair{Int64, Int64}</code>, taking the source vertex to the destination vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L386-L391">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.is_transport_system"><a class="docstring-binding" href="#Catalyst.is_transport_system"><code>Catalyst.is_transport_system</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_transport_system(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns <code>true</code> if all spatial reactions in <code>dsrs</code> are <code>TransportReaction</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L395-L399">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.has_cartesian_dspace"><a class="docstring-binding" href="#Catalyst.has_cartesian_dspace"><code>Catalyst.has_cartesian_dspace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_cartesian_dspace(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns <code>true</code> if <code>dsrs</code> was created using a cartesian grid discrete space (e.g. created via <code>CartesianGrid(5,5)</code>). Otherwise, returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L404-L409">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.has_masked_dspace"><a class="docstring-binding" href="#Catalyst.has_masked_dspace"><code>Catalyst.has_masked_dspace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_masked_dspace(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns <code>true</code> if <code>dsrs</code> was created using a masked grid discrete space (e.g. created via <code>[true true; true false]</code>). Otherwise, returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L414-L419">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.has_grid_dspace"><a class="docstring-binding" href="#Catalyst.has_grid_dspace"><code>Catalyst.has_grid_dspace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_grid_dspace(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns <code>true</code> if <code>dsrs</code> was created using a cartesian or masked grid discrete space. Otherwise, returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L422-L426">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.has_graph_dspace"><a class="docstring-binding" href="#Catalyst.has_graph_dspace"><code>Catalyst.has_graph_dspace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_graph_dspace(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns <code>true</code> if <code>dsrs</code> was created using a graph grid discrete space (e.g. created via <code>path_graph(5)</code>). Otherwise, returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L431-L436">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.grid_size"><a class="docstring-binding" href="#Catalyst.grid_size"><code>Catalyst.grid_size</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">grid_size(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns the size of <code>dsrs</code>&#39;s discrete space (only if it is a cartesian or masked grid discrete space). E.g. for a discrete space <code>CartesianGrid(4,6)</code>, <code>(4,6)</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L439-L444">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.grid_dims"><a class="docstring-binding" href="#Catalyst.grid_dims"><code>Catalyst.grid_dims</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">grid_dims(dsrs::DiscreteSpaceReactionSystem)</code></pre><p>Returns the number of dimensions of <code>dsrs</code>&#39;s discrete space (only if it is a cartesian or masked grid discrete space). The output is either <code>1</code>, <code>2</code>, or <code>3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L452-L457">source</a></section></details></article><p>In addition, most accessor functions for normal <code>ReactionSystem</code>s (such as <code>species</code> and <code>parameters</code>) works when applied to <code>DiscreteSpaceReactionSystem</code>s as well.</p><p>The following two helper functions can be used to create non-uniform parameter values.</p><article><details class="docstring" open="true"><summary id="Catalyst.make_edge_p_values"><a class="docstring-binding" href="#Catalyst.make_edge_p_values"><code>Catalyst.make_edge_p_values</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">make_edge_p_values(dsrs::DiscreteSpaceReactionSystem, make_edge_p_value::Function)</code></pre><p>Generates edge parameter values for a discrete space reaction system. Only works for (Cartesian or masked) grid discrete spaces (without diagonal adjacencies).</p><p>Input:</p><ul><li><code>dsrs</code>: The discrete space reaction system for which values should be generated.</li><li><code>make_edge_p_value</code>: a function describing a rule for generating the edge parameter values.</li></ul><p>Output:     - <code>ep_vals</code>: A sparse matrix of size (num<em>verts,num</em>verts) (where num<em>verts is the number of     vertices in <code>dsrs</code>). Here, <code>eps[i,j]</code> is filled only if there is an edge going from vertex i to     vertex j. The value of <code>eps[i,j]</code> is determined by `make</em>edge<em>p</em>value`.</p><p>Here, <code>make_edge_p_value</code> should take two arguments, <code>src_vert</code> and <code>dst_vert</code>, which correspond to the grid indices of an edge&#39;s source and destination vertices, respectively. It outputs a single value, which is the value assigned to that edge.</p><p>Example:     In the following example, we assign the value <code>0.1</code> to all edges, except for the one leading from     vertex (1,1) to vertex (1,2), to which we assign the value <code>1.0</code>.</p><pre><code class="language-julia hljs">using Catalyst
rn = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
tr = @transport_reaction D X
space = CartesianGrid((5,5))
dsrs = DiscreteSpaceReactionSystem(rn, [tr], space)

function make_edge_p_value(src_vert, dst_vert)
    if src_vert == (1,1) &amp;&amp; dst_vert == (1,2)
        return 1.0
    else
        return 0.1
    end
end

D_vals = make_edge_p_values(dsrs, make_edge_p_value)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L519-L560">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.make_directed_edge_values"><a class="docstring-binding" href="#Catalyst.make_directed_edge_values"><code>Catalyst.make_directed_edge_values</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">make_directed_edge_values(dsrs::DiscreteSpaceReactionSystem, x_vals::Tuple{T,T}, y_vals::Tuple{T,T} = (undef,undef),
                 z_vals::Tuple{T,T} = (undef,undef)) where {T}</code></pre><p>Generates edge parameter values for a discrete space reaction system. Only works for (Cartesian or masked) grid discrete spaces (without diagonal adjacencies). Each dimension (x, and possibly y and z), and direction has assigned its own constant edge parameter value.</p><p>Input:     - <code>dsrs</code>: The discrete space reaction system for which values should be generated.     - <code>x_vals::Tuple{T,T}</code>: The values in the increasing (from a lower x index to a higher x index)     and decreasing (from a higher x index to a lower x index) direction along the x dimension.     - <code>y_vals::Tuple{T,T}</code>: The values in the increasing and decreasing direction along the y dimension.     Should only be used for 2 and 3-dimensional grids.     - <code>z_vals::Tuple{T,T}</code>: The values in the increasing and decreasing direction along the z dimension.     Should only be used for 3-dimensional grids.</p><p>Output:     - <code>ep_vals</code>: A sparse matrix of size (num<em>verts,num</em>verts) (where num<em>verts is the number of     vertices in <code>dsrs</code>). Here, <code>eps[i,j]</code> is filled only if there is an edge going from vertex i to     vertex j. The value of <code>eps[i,j]</code> is determined by the `x</em>vals<code>,</code>y<em>vals<code>, and</code>z</em>vals` Tuples,     and vertices i and j&#39;s relative position in the grid.</p><p>It should be noted that two adjacent vertices will always be different in exactly a single dimension (x, y, or z). The corresponding tuple determines which value is assigned.</p><p>Example:     In the following example, we wish to have diffusion in the x dimension, but a constant flow from     low y values to high y values (so not transportation from high to low y). We achieve it in the     following manner:</p><pre><code class="language-julia hljs">using Catalyst
rn = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end
tr = @transport_reaction D X
space = CartesianGrid((5,5))
dsrs = DiscreteSpaceReactionSystem(rn, [tr], space)

D_vals = make_directed_edge_values(dsrs, (0.1, 0.1), (0.1, 0.0))</code></pre><p>Here, since we have a 2d grid, we only provide the first two Tuples to <code>make_directed_edge_values</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_reaction_systems.jl#L583-L625">source</a></section></details></article><p>The following functions can be used to access, or change, species or parameter values stored in problems, integrators, and solutions that are based on <code>DiscreteSpaceReactionSystem</code>s.</p><article><details class="docstring" open="true"><summary id="Catalyst.spat_getu"><a class="docstring-binding" href="#Catalyst.spat_getu"><code>Catalyst.spat_getu</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">spat_getu(sim_struct, sp, dsrs::DiscreteSpaceReactionSystem)</code></pre><p>For a problem or integrators, retrieves its <code>u</code> values. For non-discrete space models, this is can be done through direct interfacing (e.g. <code>prob[X]</code>). However, for <code>DiscreteSpaceReactionSystem</code>-based problems and integrators, this function must be used instead. The output format depends on the discrete space (a dense array for cartesian grid discrete spaces, a sparse array for masked grid discrete spaces, and a vector for graph discrete spaces). This format is similar to which is used to designate species initial conditions.</p><p>Arguments:</p><ul><li><code>sim_struct</code>: The simulation structure which <code>u</code> value we wish to retrieve. Can be either a <code>ODEProblem</code>, <code>JumpProblem</code>, or an integrator derived from either of these.</li><li><code>sp</code>: The species which value we wish to update. Can be provided either in its symbolic form (e.g. <code>X</code>) or as a symbol (e.g. <code>:X</code>).</li><li><code>dsrs</code>: The <code>DiscreteSpaceReactionSystem</code> which was used to generate the structure we wish to modify.</li></ul><p>Notes:</p><ul><li>Even if the species is spatially uniform, a full array with its values across all vertices will be retrieved.</li></ul><p>Example:</p><pre><code class="language-julia hljs"># Prepare `DiscreteSpaceReactionSystem`s.
using Catalyst
rs = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
tr = @transport_reaction D X1
dsrs = DiscreteSpaceReactionSystem(rs, [tr], CartesianGrid((2,3)))

# Prepares a corresponding ODEProblem.
u0 = [:X1 =&gt; [1.0 2.0 3.0; 4.0 5.0 6.0], :X2 =&gt; 2.0]
tspan = (0.0, 50.0)
ps = [:k1 =&gt; 2.0, :k2 =&gt; 1.0, :D =&gt; 0.01]
oprob = ODEProblem(dsrs, u0, tspan, ps)

# Updates the `ODEProblem`.
spat_getu(oprob, :X1, dsrs) # Retrieves the value of `X1`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_sim_struct_interfacing.jl#L223-L260">source</a></section><section><div><pre><code class="language-julia hljs">spat_getu(sol, sp, dsrs::DiscreteSpaceReactionSystem; t = nothing)</code></pre><p>A function for retrieving the solution of a <code>DiscreteSpaceReactionSystem</code>-based simulation on various desired forms. Generally, for <code>DiscreteSpaceReactionSystem</code>s, the values in <code>sol</code> is ordered in a way which is not directly interpretable by the user. Furthermore, the normal Catalyst interface for solutions (e.g. <code>sol[:X]</code>) does not work for these solutions. Hence this function is used instead.</p><p>The output is a vector, which in each position contains sp&#39;s value (either at a time step of time, depending on the input <code>t</code>). Its shape depends on the discrete space (using a similar form as heterogeneous initial conditions). I.e. for a NxM cartesian grid, the values are NxM matrices. For a masked grid, the values are sparse matrices. For a graph discrete space, the values are vectors (where the value in the n&#39;th position corresponds to sp&#39;s value in the n&#39;th vertex).</p><p>Arguments:</p><ul><li><code>sol</code>: The solution from which we wish to retrieve some values.</li><li><code>sp</code>: The species which value we wish to update. Can be provided either in its symbolic form (e.g. <code>X</code>) or as a symbol (e.g. <code>:X</code>).</li><li><code>dsrs</code>: The <code>DiscreteSpaceReactionSystem</code> which was simulated to generate the solution.</li><li><code>t = nothing</code>: If <code>nothing</code>, we simply return the solution across all saved time steps (default). If <code>t</code> instead is a vector (or range of values), returns the solution interpolated at these time points.</li></ul><p>Notes:</p><ul><li>The <code>spat_getu</code> is not optimised for performance. However, it should still be quite performant, but there might be some limitations if called a very large number of times.</li><li>Long-term it is likely that this function gets replaced with a sleeker interface.</li></ul><p>Example:</p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEqDefault

# Prepare `DiscreteSpaceReactionSystem`s.
rs = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
tr = @transport_reaction D X1
dsrs = DiscreteSpaceReactionSystem(rs, [tr], CartesianGrid((2,2)))

# Create problems.
u0 = [:X1 =&gt; 1, :X2 =&gt; 2]
tspan = (0.0, 10.0)
ps = [:k1 =&gt; 1, :k2 =&gt; 2.0, :D =&gt; 0.1]

oprob = ODEProblem(dsrs1, u0, tspan, ps)
osol = solve(oprob)
spat_getu(osol, :X1, dsrs) # Returns the value of X1 at each time step.
spat_getu(osol, :X1, dsrs; t = 0.0:10.0) # Returns the value of X1 at times 0.0, 1.0, ..., 10.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_sim_struct_interfacing.jl#L284-L329">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.spat_setu!"><a class="docstring-binding" href="#Catalyst.spat_setu!"><code>Catalyst.spat_setu!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">spat_setu!(sim_struct, sp, dsrs::DiscreteSpaceReactionSystem, u)</code></pre><p>For a problem or integrators, update its <code>u</code> vector with the input <code>u</code>. For non-discrete space models, this is can be done through direct interfacing (e.g. <code>prob[X] = 1.0</code>). However, for <code>DiscreteSpaceReactionSystem</code>-based problems and integrators, this function must be used instead.</p><p>Arguments:</p><ul><li><code>sim_struct</code>: The simulation structure which <code>u</code> value we wish to update. Can be either a <code>ODEProblem</code>, <code>JumpProblem</code>, or an integrator derived from either of these.</li><li><code>sp</code>: The species which value we wish to update. Can be provided either in its symbolic form (e.g. <code>X</code>) or as a symbol (e.g. <code>:X</code>).</li><li><code>dsrs</code>: The <code>DiscreteSpaceReactionSystem</code> which was used to generate the structure we wish to modify.</li><li><code>u</code>: The species&#39;s new values. Must be given in a form which is also a valid initial input to the <code>ODEProblem</code>/<code>JumpProblem</code>.</li></ul><p>Example:</p><pre><code class="language-julia hljs"># Prepare `DiscreteSpaceReactionSystem`s.
using Catalyst
rs = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
tr = @transport_reaction D X1
dsrs = DiscreteSpaceReactionSystem(rs, [tr], CartesianGrid((2,3)))

# Prepares a corresponding ODEProblem.
u0 = [:X1 =&gt; [1.0 2.0 3.0; 4.0 5.0 6.0], :X2 =&gt; 2.0]
tspan = (0.0, 50.0)
ps = [:k1 =&gt; 2.0, :k2 =&gt; 1.0, :D =&gt; 0.01]
oprob = ODEProblem(dsrs, u0, tspan, ps)

# Updates the `ODEProblem`.
spat_setu!(oprob, :X1, dsrs, 0.0) # Sets `X1` to uniformly 0 across the discrete space.
spat_setu!(oprob, :X2, dsrs, [1.0 0.0 0.0; 0.0 0.0 0.0]) # Sets `X2` to `1.0` in one vertex, and 0 elsewhere.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_sim_struct_interfacing.jl#L144-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.spat_getp"><a class="docstring-binding" href="#Catalyst.spat_getp"><code>Catalyst.spat_getp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">spat_getp(sim_struct, p, dsrs::DiscreteSpaceReactionSystem)</code></pre><p>For a problem or integrators, retrieves its <code>p</code> values. For non-discrete space models, this is can be done through direct interfacing (e.g. <code>prob[p]</code>). However, for <code>DiscreteSpaceReactionSystem</code>-based problems and integrators, this function must be used instead. The output format depends on the discrete space (a dense array for cartesian grid discrete spaces, a sparse array for masked grid discrete spaces, and a vector for graph discrete spaces). This format is similar to what is used to designate parameter initial values.</p><p>Arguments:</p><ul><li><code>sim_struct</code>: The simulation structure which <code>p</code> value we wish to retrieve. Can be either a <code>ODEProblem</code>,</li></ul><p><code>JumpProblem</code>, or an integrator derived from either of these.</p><ul><li><code>p</code>: The species which value we wish to update. Can be provided either in its symbolic form (e.g. <code>k</code>) or as a symbol (e.g. <code>:k</code>).</li><li><code>dsrs</code>: The <code>DiscreteSpaceReactionSystem</code> which was used to generate the structure we wish to modify.</li></ul><p>Notes:</p><ul><li>Even if the parameter is spatially uniform, a full array with its values across all vertices will be retrieved.</li></ul><p>Example:</p><pre><code class="language-julia hljs"># Prepare `DiscreteSpaceReactionSystem`s.
using Catalyst
rs = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
tr = @transport_reaction D X1
dsrs = DiscreteSpaceReactionSystem(rs, [tr], CartesianGrid((2,3)))

# Prepares a corresponding ODEProblem.
u0 = [:X1 =&gt; 1.0, :X2 =&gt; 2.0]
tspan = (0.0, 50.0)
ps = [:k1 =&gt; [1.0 2.0 3.0; 4.0 5.0 6.0], :k2 =&gt; 1.0, :D =&gt; 0.01]
oprob = ODEProblem(dsrs, u0, tspan, ps)

# Updates the `ODEProblem`.
spat_getp(oprob, :k1, dsrs) # Retrieves the value of `k1`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_sim_struct_interfacing.jl#L81-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.spat_setp!"><a class="docstring-binding" href="#Catalyst.spat_setp!"><code>Catalyst.spat_setp!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">spat_setp!(sim_struct, p, dsrs::DiscreteSpaceReactionSystem, p_val)</code></pre><p>For a problem or integrators, update its <code>p</code> vector with the input <code>p_val</code>. For non-discrete space models, this is can be done through direct interfacing (e.g. <code>prob[p] = 1.0</code>). However, for <code>DiscreteSpaceReactionSystem</code>-based problems and integrators, this function must be used instead.</p><p>Arguments:</p><ul><li><code>sim_struct</code>: The simulation structure which <code>u</code> value we wish to update. Can be either a <code>ODEProblem</code>, <code>JumpProblem</code>, or an integrator derived from either of these.</li><li><code>p</code>: The species which value we wish to update. Can be provided either in its symbolic form (e.g. <code>k</code>) or as a symbol (e.g. <code>:k</code>).</li><li><code>dsrs</code>: The <code>DiscreteSpaceReactionSystem</code> which was used to generate the structure we wish to modify.</li><li><code>p_val</code>: The parameter&#39;s new values. Must be given in a form which is also a valid initial input to the <code>ODEProblem</code>/<code>JumpProblem</code>.</li></ul><p>Example:</p><pre><code class="language-julia hljs"># Prepare `DiscreteSpaceReactionSystem`s.
using Catalyst
rs = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
tr = @transport_reaction D X1
dsrs = DiscreteSpaceReactionSystem(rs, [tr], CartesianGrid((2,3)))

# Prepares a corresponding ODEProblem.
u0 = [:X1 =&gt; 1.0, :X2 =&gt; 2.0]
tspan = (0.0, 50.0)
ps = [:k1 =&gt; [1.0 2.0 3.0; 4.0 5.0 6.0], :k2 =&gt; 1.0, :D =&gt; 0.01]
oprob = ODEProblem(dsrs, u0, tspan, ps)

# Updates the `ODEProblem`.
spat_setp!(oprob, :k1, dsrs, 0.0) # Sets `k1` to uniformly 0 across the discrete space.
spat_setp!(oprob, :k2, dsrs, [1.0 0.0 0.0; 0.0 0.0 0.0]) # Sets `k2` to `1.0` in one vertex, and 0 elsewhere.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_sim_struct_interfacing.jl#L3-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.rebuild_spat_internals!"><a class="docstring-binding" href="#Catalyst.rebuild_spat_internals!"><code>Catalyst.rebuild_spat_internals!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rebuild_spat_internals!(sciml_struct)</code></pre><p>Rebuilds the internal functions for simulating a DiscreteSpaceReactionSystem. Whenever a problem or integrator has had its parameter values updated, this function should be called for the update to be taken into account. For ODE simulations, <code>rebuild_spat_internals!</code> needs only to be called when</p><ul><li>An edge parameter has been updated.</li><li>When a parameter with spatially homogeneous values has been given spatially heterogeneous values (or vice versa).</li></ul><p>Arguments:</p><ul><li><code>sciml_struct</code>: The problem (e.g. an <code>ODEProblem</code>) or an integrator which we wish to rebuild.</li></ul><p>Notes:</p><ul><li>Currently does not work for <code>DiscreteProblem</code>s, <code>JumpProblem</code>s, or their integrators.</li><li>The function is not built with performance in mind, so avoid calling it multiple times in performance-critical applications.</li></ul><p>Example:</p><pre><code class="language-julia hljs"># Creates an initial `ODEProblem`
rs = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
tr = @transport_reaction D X1
grid = CartesianGrid((2,2))
dsrs = DiscreteSpaceReactionSystem(rs, [tr], grid)

u0 = [:X1 =&gt; 2, :X2 =&gt; [5 6; 7 8]]
tspan = (0.0, 10.0)
ps = [:k1 =&gt; 1.5, :k2 =&gt; [1.0 1.5; 2.0 3.5], :D =&gt; 0.1]

oprob = ODEProblem(dsrs, u0, tspan, ps)

# Updates parameter values.
oprob.ps[:ks] = [2.0 2.5; 3.0 4.5]
oprob.ps[:D] = 0.05

# Rebuilds `ODEProblem` to make changes have an effect.
rebuild_spat_internals!(oprob)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_sim_struct_interfacing.jl#L374-L413">source</a></section></details></article><p>Finally, we provide the following helper functions to plot and animate spatial discrete space simulations.</p><article><details class="docstring" open="true"><summary id="Catalyst.dspace_plot"><a class="docstring-binding" href="#Catalyst.dspace_plot"><code>Catalyst.dspace_plot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dspace_plot(sol, sp, dsrs::DiscreteSpaceReactionSystem, filename::String; t = sol.tspan[2], kwargs...)</code></pre><p>Creates a plot of a <code>DiscreteSpaceReactionSystem</code> simulation. The plot is created at the time point specified by <code>t</code> (defaults to the simulation&#39;s final time point).</p><p>Arguments (all spaces):</p><ul><li><code>sol</code>: The simulation we wish to plot.</li><li><code>sp</code>: The species whose values we wish to plot. Can be provided either in its symbolic form or as a symbol.</li><li><code>dsrs</code>: The <code>DiscreteSpaceReactionSystem</code> which was simulated.</li><li><code>t = sol.t[end]</code>: The time point at which we wish to plot the solution</li></ul><p>In addition, depending on the type of space used, the following optional arguments might be relevant.</p><p>Arguments (1d spaces):</p><ul><li><code>markersize = 20</code>: The size of the markers marking each compartment&#39;s value.</li></ul><p>Arguments (Graph &amp; 2d spaces):</p><ul><li><code>colormap = :BuGn_7</code>: The colour map with which we display the species amounts in the animation.</li><li><code>plot_min = nothing</code>: The minimum value for the colour scale (values less than this will be set at this value when the colour scale is computed). If <code>nothing</code>, use the simulation&#39;s minimum value (across the entire simulation, not just at the plotted time value).</li><li><code>plot_max = nothing</code>: The maximum value for the colour scale (values more than this will be set at this value when the colour scale is computed). If <code>nothing</code>, use the simulation&#39;s minimum value (across the entire simulation, not just at the plotted time value).</li></ul><p>Arguments (Graph spaces):</p><ul><li><code>node_size = 50</code>: The size of the compartments in the plot.</li><li><code>layout = Spring()</code>: The layout for the graph nodes in the plot. Can be provided as a vector, where the i&#39;th element is a 2-valued tuple (determining the i&#39;th compartment&#39;s y and x positions, respectively).</li></ul><p>Notes: </p><ul><li>For masked spaces, there are no value displayed for grid points which do not correspond to a compartments.</li><li>The current plotting interface is a work in progress, and modifications are expected. if you have any feedback, please contact the package authors.</li><li>Additional arguments can be passed to <code>dspace_plot</code>, which then will be passed to Makie&#39;s <code>lines</code> plotting command.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_simulation_plotting.jl#L6-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.dspace_animation"><a class="docstring-binding" href="#Catalyst.dspace_animation"><code>Catalyst.dspace_animation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dspace_animation(sol, sp, dsrs::DiscreteSpaceReactionSystem, filename::String; kwargs...)</code></pre><p>Creates an animation of a <code>DiscreteSpaceReactionSystem</code> simulation. The animation is saved to a file,  whose name is provided in the <code>filename</code> argument.</p><p>Arguments (all spaces):</p><ul><li><code>sol</code>: The simulation we wish to animate.</li><li><code>sp</code>: The species which values we wish to animate. Can be provided either in its symbolic form or as a symbol.</li><li><code>dsrs</code>: The <code>DiscreteSpaceReactionSystem</code> which was simulated.</li><li><code>filename</code>: The name of the file to which we wish to save the animation.</li><li><code>nframes = 200</code>: The number of frames in the animation (these are evenly samples across the simulation).</li><li><code>framerate = 20</code>: The frame rate of the animation.</li><li><code>ttitle = true</code>: Whether to add a title showing the simulation&#39;s time throughout the animation.</li></ul><p>In addition, depending on the type of space used, the following optional arguments might be relevant.</p><p>Arguments (1d spaces):</p><ul><li><code>markersize = 20</code>: The size of the markers marking each compartment&#39;s value.</li><li><code>plot_min = nothing</code>: The y-scale&#39;s minimum. If <code>nothing</code>, use the simulation&#39;s minimum value.</li><li><code>plot_max = nothing</code>: The y-scale&#39;s maximum. If <code>nothing</code>, use the simulation&#39;s maximum value.</li></ul><p>Arguments (Graph &amp; 2d spaces):</p><ul><li><code>colormap = :BuGn_7</code>: The colour map with which we display the species amounts in the animation.</li><li><code>plot_min = nothing</code>: The minimum value for the colour scale (values less than this will be set at this value when the colour scale is computed). If <code>nothing</code>, use the simulation&#39;s minimum value.</li><li><code>plot_max = nothing</code>: The maximum value for the colour scale (values more than this will be set at this value when the colour scale is computed). If <code>nothing</code>, use the simulation&#39;s minimum value.</li></ul><p>Arguments (Graph spaces):</p><ul><li><code>node_size = 50</code>: The size of the compartments in the plot.</li><li><code>layout = Spring()</code>: The layout for the graph nodes in the plot. Can be provided as a vector, where the i&#39;th element is a 2-valued tuple (determining the i&#39;th compartment&#39;s y and x positions, respectively).</li></ul><p>Notes: </p><ul><li>For masked spaces, there are no value displayed for grid points which do not correspond to a compartments.</li><li>The current animation interface if a work in progress, and modifications are expected. if you have any feedback, please contact the package authors.</li><li>Additional arguments can be passed to <code>dspace_animation</code>, which then will be passed to Makie&#39;s <code>heatmap</code> plotting command.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_simulation_plotting.jl#L39-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Catalyst.dspace_kymograph"><a class="docstring-binding" href="#Catalyst.dspace_kymograph"><code>Catalyst.dspace_kymograph</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dspace_kymograph(sol, sp, dsrs::DiscreteSpaceReactionSystem, kwargs...)</code></pre><p>Creates a kymograph of a <code>DiscreteSpaceReactionSystem</code> simulation based on a Cartesian or masked space.  The plot shows the compartments on the y-axis, and the time development of the system&#39;s state along the x-axis. Species amounts are shown as a heatmap.</p><p>Arguments (all spaces):</p><ul><li><code>sol</code>: The simulation we wish to plot.</li><li><code>sp</code>: The species whose values we wish to plot. Can be provided either in its symbolic form or as a symbol.</li><li><code>dsrs</code>: The <code>DiscreteSpaceReactionSystem</code> which was simulated.</li><li><code>colormap = :BuGn_7</code>: The colour map with which we display the species amounts in the kymograph.</li><li><code>nframes = 200</code>: The number of time samples which the time series is sampled with.</li><li><code>plot_min = nothing</code>: The minimum value for the colour scale (values less than this will be set at this value when the colour scale is computed). If <code>nothing</code>, use the simulation&#39;s minimum value.</li><li><code>plot_max = nothing</code>: The maximum value for the colour scale (values more than this will be set at this value when the colour scale is computed). If <code>nothing</code>, use the simulation&#39;s minimum value.</li></ul><p>Notes: </p><ul><li>For masked spaces, there are no value displayed for grid points which do not correspond to a compartments.</li><li>The current plotting interface is a work in progress, and modifications are expected. if you have any feedback, please contact the package authors.</li><li>Additional arguments can be passed to <code>dspace_plot</code>, which then will be passed to Makie&#39;s <code>heatmap</code> plotting command.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/b3bbaa48f65fa595732fdd9d9a8b5969433c85e8/src/spatial_reaction_systems/discrete_space_simulation_plotting.jl#L77-L97">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../faqs/">« FAQs</a><a class="docs-footer-nextpage" href="../network_analysis_api/">Network analysis and representations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 18 February 2026 15:31">Wednesday 18 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
