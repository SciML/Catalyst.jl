<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interfacing with Lattice Problems, Integrators, and Solutions · Catalyst.jl</title><meta name="title" content="Interfacing with Lattice Problems, Integrators, and Solutions · Catalyst.jl"/><meta property="og:title" content="Interfacing with Lattice Problems, Integrators, and Solutions · Catalyst.jl"/><meta property="twitter:title" content="Interfacing with Lattice Problems, Integrators, and Solutions · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/spatial_modelling/lattice_simulation_structure_ interaction/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/spatial_modelling/lattice_simulation_structure_ interaction/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/spatial_modelling/lattice_simulation_structure_ interaction/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><span class="tocitem">Model Creation and Properties</span><ul><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../model_creation/conservation_laws/">Working with conservation laws</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/reactionsystem_content_accessing/">Accessing model properties</a></li><li><a class="tocitem" href="../../model_creation/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Model simulation</span><ul><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for performant ODE simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for performant SDE simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Model simulation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/examples/periodic_events_simulation/">Modelling a periodic event during ODE and jump simulations</a></li></ul></li></ul></li><li><span class="tocitem">Steady state analysis</span><ul><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><span class="tocitem">Spatial Modelling</span><ul><li><a class="tocitem" href="../lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li class="is-active"><a class="tocitem" href>Interfacing with Lattice Problems, Integrators, and Solutions</a><ul class="internal"><li><a class="tocitem" href="#lattice_simulation_structure_interaction_simulation_species"><span>Retrieving values from lattice simulations</span></a></li><li><a class="tocitem" href="#lattice_simulation_structure_interaction_prob_int_species"><span>Retrieving and updating species values in problems and integrators</span></a></li><li><a class="tocitem" href="#lattice_simulation_structure_interaction_prob_int_parameters"><span>Retrieving and updating parameter values in problems and integrators</span></a></li></ul></li><li><a class="tocitem" href="../lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../spatial_jump_simulations/">Spatial jump simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Spatial Modelling</a></li><li class="is-active"><a href>Interfacing with Lattice Problems, Integrators, and Solutions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interfacing with Lattice Problems, Integrators, and Solutions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/spatial_modelling/lattice_simulation_structure_ interaction.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="lattice_simulation_structure_interaction"><a class="docs-heading-anchor" href="#lattice_simulation_structure_interaction">Interfacing with Lattice Problems, Integrators, and Solutions</a><a id="lattice_simulation_structure_interaction-1"></a><a class="docs-heading-anchor-permalink" href="#lattice_simulation_structure_interaction" title="Permalink"></a></h1><p>We have <a href="../../model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing">previously described</a> how to retrieve species and parameter values stored in non-spatial problems, integrators, and solutions. This section describes similar workflows for simulations based on <a href="../../api/#Catalyst.LatticeReactionSystem"><code>LatticeReactionSystem</code></a>s.</p><p>Generally, while for non-spatial systems these operations can typically be done by indexing a structure directly, e.g. through</p><pre><code class="language-julia hljs">sol[:X]</code></pre><p>there are no equally straightforward interfaces for spatial simulations. Typically, helper functions have to be used, e.g</p><pre><code class="language-julia hljs">lat_getu(sol, :X, lrs)</code></pre><p>Furthermore, there are some cases of interfacing which are currently not supported (e.g. updating parameter values in <code>JumpProblem</code>s). It is likely that these interfaces will be improved in the future (i.e. by introducing a similar syntax to the current non-spatial one). Finally, we note that many of the functions presented below have not been as extensively optimised for performance as other parts of the Catalyst package. Hence, you should take care when designing workflows which requires using them a large number of times.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Below we will describe various features using ODE simulations as examples. However, all interfaces (unless where else is stated) work identically for jump simulations.</p></div></div><h2 id="lattice_simulation_structure_interaction_simulation_species"><a class="docs-heading-anchor" href="#lattice_simulation_structure_interaction_simulation_species">Retrieving values from lattice simulations</a><a id="lattice_simulation_structure_interaction_simulation_species-1"></a><a class="docs-heading-anchor-permalink" href="#lattice_simulation_structure_interaction_simulation_species" title="Permalink"></a></h2><p>Let us consider a simulation of a <a href="../../api/#Catalyst.LatticeReactionSystem"><code>LatticeReactionSystem</code></a>:</p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEq
two_state_model = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
diffusion_rx = @transport_reaction D X1
lattice = CartesianGrid((2,3))
lrs = LatticeReactionSystem(two_state_model, [diffusion_rx], lattice)

u0 = [:X1 =&gt; [0.0 0.0 0.0; 2.0 2.0 2.0], :X2 =&gt; 0.0]
tspan = (0.0, 1.0)
ps = [:k1 =&gt; 2.0, :k2 =&gt; 1.0, :D =&gt; 0.1]
oprob = ODEProblem(lrs, u0, tspan, ps)
sol = solve(oprob)</code></pre><p>To retrieve the values of <span>$X1$</span> across the simulation we use the <code>lat_getu</code> function. It takes three arguments:</p><ul><li>The solution objects from which we wish to retrieve values.</li><li>The species which values we wish to retrieve.</li><li>The <a href="../../api/#Catalyst.LatticeReactionSystem"><code>LatticeReactionSystem</code></a> which was simulated.</li></ul><pre><code class="language-julia hljs">lat_getu(sol, :X1, lrs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">13-element Vector{Matrix{Float64}}:
 [0.0 0.0 0.0; 2.0 2.0 2.0]
 [4.988650432250024e-5 4.988650432250024e-5 4.988650432250024e-5; 1.998952234018206 1.998952234018206 1.998952234018206]
 [0.0005458858864143923 0.0005458858864143923 0.0005458858864143925; 1.9885184230183552 1.9885184230183552 1.9885184230183552]
 [0.004183579828857829 0.004183579828857828 0.00418357982885783; 1.9110504561482833 1.911050456148283 1.911050456148283]
 [0.010555124726328287 0.010555124726328285 0.01055512472632829; 1.7708833969447644 1.7708833969447644 1.7708833969447642]
 [0.017511304872910794 0.01751130487291079 0.017511304872910798; 1.6099324579069696 1.6099324579069696 1.6099324579069694]
 [0.024754700546314776 0.02475470054631478 0.024754700546314793; 1.430770729145339 1.430770729145339 1.4307707291453389]
 [0.03151854171188027 0.03151854171188027 0.031518541711880274; 1.2486002566932275 1.2486002566932273 1.248600256693227]
 [0.03729771707546165 0.03729771707546164 0.03729771707546163; 1.0766135810926567 1.0766135810926565 1.0766135810926565]
 [0.04182477814628239 0.041824778146282354 0.04182477814628237; 0.9284335395829308 0.9284335395829311 0.9284335395829306]
 [0.04528546489031367 0.04528546489031363 0.045285464890313654; 0.8115561619802181 0.8115561619802182 0.8115561619802181]
 [0.04818220768970433 0.04818220768970431 0.04818220768970431; 0.7274839229254508 0.7274839229254508 0.7274839229254508]
 [0.05042586336227638 0.05042586336227639 0.05042586336227637; 0.682624481884696 0.6826244818846958 0.6826244818846958]</code></pre><p>Here, the output is a vector with <span>$X1$</span>&#39;s value at each simulation time step. How the species&#39;s value is represented at each time step depends on the lattice which was originally used to create the <a href="../../api/#Catalyst.LatticeReactionSystem"><code>LatticeReactionSystem</code></a>:</p><ul><li>For Cartesian lattices, an array of the same size as the Cartesian lattice is used. Each array element corresponds to the species&#39;s value in the corresponding compartment.</li><li>For masked lattices, a <a href="https://docs.julialang.org/en/v1/stdlib/SparseArrays/">sparse array</a> of the same size as the masked lattice is used. Each filled array element corresponds to the species&#39;s value in the corresponding compartment. Unfilled array elements correspond to positions without compartments.</li><li>For unstructured (graph) lattices, vectors are used. The i&#39;th element in the vectors corresponds to the species&#39;s value in the i&#39;th compartment.</li></ul><p>Unlike for non-spatial simulations, <code>lat_getu</code> does not take vector (e.g. <code>lat_getu(sol, [:X1, :X2], lrs)</code>) or symbolic expression (e.g. <code>lat_getu(sol, [X1 + X2], lrs)</code>) inputs. However, it is possible to use symbolic variables as input (e.g. <code>lat_getu(sol, two_state_model.X1, lrs)</code>).</p><h3 id="lattice_simulation_structure_interaction_simulation_species_ts"><a class="docs-heading-anchor" href="#lattice_simulation_structure_interaction_simulation_species_ts">Retrieving lattice simulations values at specific time points</a><a id="lattice_simulation_structure_interaction_simulation_species_ts-1"></a><a class="docs-heading-anchor-permalink" href="#lattice_simulation_structure_interaction_simulation_species_ts" title="Permalink"></a></h3><p>Just like for non-spatial solutions, it is possible to access the simulation&#39;s values at designated time points. This is possible even if the simulation did not stop at those specific time points (in which case an interpolated value is returned). To do this, the desired time points to sample are provided as a vector to <code>lat_getu</code> using the optional argument <code>t</code>. E.g. here we retrieve the simulation&#39;s (interpolated) values at time points <code>0.5</code> and <code>0.75</code>:</p><pre><code class="language-julia hljs">lat_getu(sol, :X1, lrs; t = [0.5, 0.75])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Matrix{Float64}}:
 [0.04200952741606882 0.04200952741606879 0.0420095274160688; 0.922164154320254 0.9221641543202542 0.9221641543202538]
 [0.04694938927966384 0.04694938927966381 0.04694938927966383; 0.7602471207321428 0.7602471207321431 0.7602471207321428]</code></pre><h2 id="lattice_simulation_structure_interaction_prob_int_species"><a class="docs-heading-anchor" href="#lattice_simulation_structure_interaction_prob_int_species">Retrieving and updating species values in problems and integrators</a><a id="lattice_simulation_structure_interaction_prob_int_species-1"></a><a class="docs-heading-anchor-permalink" href="#lattice_simulation_structure_interaction_prob_int_species" title="Permalink"></a></h2><p>Let us consider a spatial <code>ODEProblem</code></p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEq
two_state_model = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
diffusion_rx = @transport_reaction D X1
lattice = CartesianGrid((2,3))
lrs = LatticeReactionSystem(two_state_model, [diffusion_rx], lattice)

u0 = [:X1 =&gt; [0.0 0.0 0.0; 2.0 2.0 2.0], :X2 =&gt; 0.0]
tspan = (0.0, 1.0)
ps = [:k1 =&gt; 2.0, :k2 =&gt; 1.0, :D =&gt; 0.1]
oprob = ODEProblem(lrs, u0, tspan, ps)</code></pre><p>We can retrieve the species values stored in <code>oprob</code> using the <code>lat_getu</code> function. It uses <a href="#lattice_simulation_structure_interaction_simulation_species">identical syntax as for simulations</a> (except that you cannot specify a time point). However, it returns a single set of species values (while for simulations it returns a vector across different time steps):</p><pre><code class="language-julia hljs">lat_getu(oprob, :X1, lrs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3 Matrix{Float64}:
 0.0  0.0  0.0
 2.0  2.0  2.0</code></pre><p>Again, the format used corresponds to the lattice used to create the original <a href="../../api/#Catalyst.LatticeReactionSystem"><code>LatticeReactionSystem</code></a>. Here, even if a species has homogeneous values, the full format is used.</p><pre><code class="language-julia hljs">lat_getu(oprob, :X2, lrs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3 Matrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p>For both problems and integrators, species values can be updated using the <code>lat_setu!</code> function. It uses a similar syntax as <code>lat_getu</code>, but takes a fourth argument which is the new values to use for the designated species:</p><pre><code class="language-julia hljs">lat_setu!(oprob, :X1, lrs, [1.0 2.0 3.0; 4.0 5.0 6.0])</code></pre><p>Here, the same format (which depends on the used lattice) is used for the species&#39;s new values, as which is used when initially designating their initial conditions. I.e. to make <span>$X1$</span>&#39;s initial condition values uniform we can call</p><pre><code class="language-julia hljs">lat_setu!(oprob, :X1, lrs, 1.0)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is currently not possible to change a species value at a single compartment only. To do so, you must first retrieve its values across all compartments using <code>lat_getu</code>, then modify this at the desired compartment, and then use the modified version as input to <code>lat_setu!</code>.</p></div></div><p>Species values in <a href="../../model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_integrators">integrators</a> can be interfaced with using identical syntax as for problems.</p><h2 id="lattice_simulation_structure_interaction_prob_int_parameters"><a class="docs-heading-anchor" href="#lattice_simulation_structure_interaction_prob_int_parameters">Retrieving and updating parameter values in problems and integrators</a><a id="lattice_simulation_structure_interaction_prob_int_parameters-1"></a><a class="docs-heading-anchor-permalink" href="#lattice_simulation_structure_interaction_prob_int_parameters" title="Permalink"></a></h2><p>Retrieval and updating of parameter values for problems and integrators works similarly as for species, but with the following differences:</p><ul><li>The <code>lat_getp</code> and <code>lat_setp!</code> functions are used.</li><li>It is currently not possible to interface with parameter values of <code>JumpProblem</code>s and their integrators.</li><li>After parameter values are modified, the <code>rebuild_lat_internals!</code> function must be applied before the problem/integrator can be used for further analysis.</li><li>Updating of <a href="../lattice_reaction_systems/#spatial_lattice_modelling_intro_simulation_edge_parameters">edge parameters</a> is limited and uses a different interface. </li></ul><p>Let us consider the spatial <code>ODEProblem</code> we previously declared. We can check the value of <span>$k1$</span> by using <code>lat_getp</code></p><pre><code class="language-julia hljs">lat_getp(oprob, :k1, lrs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3 Matrix{Float64}:
 2.0  2.0  2.0
 2.0  2.0  2.0</code></pre><p>Next, we can update it using <code>lat_setp!</code> (here we also confirm that it now has the updated values):</p><pre><code class="language-julia hljs">lat_setp!(oprob, :k1, lrs, [1.0 2.0 3.0; 4.0 5.0 6.0])
lat_getp(oprob, :k1, lrs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3 Matrix{Float64}:
 1.0  2.0  3.0
 4.0  5.0  6.0</code></pre><p>If we now were to simulate <code>oprob</code>, the simulation would not take the updated value of <span>$k1$</span> into account. For our changes to take effect we might first need to call <code>rebuild_lat_internals!</code> with <code>oprob</code> as an input</p><pre><code class="language-julia hljs">rebuild_lat_internals!(oprob)</code></pre><p>There are two different circumstances when <code>rebuild_lat_internals!</code> must be called:</p><ul><li>When modifying the value of an <a href="../lattice_reaction_systems/#spatial_lattice_modelling_intro_simulation_edge_parameters">edge parameter</a>.</li><li>When changing a parameter from having spatially uniform values to spatially non-uniform values, or the other way around.</li></ul><p>Parameter values of integrators can be interfaced with just like for problems (this is primarily relevant when using <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/"><em>callbacks</em></a>). Again, after doing so, the <code>rebuild_lat_internals!</code> function might need to be applied to the integrator.</p><h3 id="lattice_simulation_structure_interaction_prob_int_parameters_edge_ps"><a class="docs-heading-anchor" href="#lattice_simulation_structure_interaction_prob_int_parameters_edge_ps">Retrieving and updatingedge  parameter values in problems and integrators</a><a id="lattice_simulation_structure_interaction_prob_int_parameters_edge_ps-1"></a><a class="docs-heading-anchor-permalink" href="#lattice_simulation_structure_interaction_prob_int_parameters_edge_ps" title="Permalink"></a></h3><p>The <code>lat_getp</code> and <code>lat_setp!</code> functions cannot currently be applied to <a href="../lattice_reaction_systems/#spatial_lattice_modelling_intro_simulation_edge_parameters">edge parameters</a>. Instead, to access the value of an edge parameter, use </p><pre><code class="language-julia hljs">oprob.ps[:D]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×1 SparseArrays.SparseMatrixCSC{Float64, Int64} with 1 stored entry:
 0.1</code></pre><p>To update an edge parameter&#39;s value, use</p><pre><code class="language-julia hljs">oprob.ps[:D] = [0.2]</code></pre><p>This interface is somewhat limited, and the following aspects should be noted:</p><ul><li>Edge parameter values can only be interfaced with if the edge parameter&#39;s value is spatially uniform.</li><li>When accessing an (spatially uniform) edge parameter&#39;s value, its single value will be encapsulated in a vector.</li><li>When setting an (spatially uniform) edge parameter&#39;s value, you must encapsulate the new value in a vector.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lattice_reaction_systems/">« Introduction to Spatial Modelling with Catalyst</a><a class="docs-footer-nextpage" href="../lattice_simulation_plotting/">Plotting Spatial Simulations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 8 August 2024 22:33">Thursday 8 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
