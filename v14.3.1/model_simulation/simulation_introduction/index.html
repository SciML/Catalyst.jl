<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Simulation Introduction · Catalyst.jl</title><meta name="title" content="Model Simulation Introduction · Catalyst.jl"/><meta property="og:title" content="Model Simulation Introduction · Catalyst.jl"/><meta property="twitter:title" content="Model Simulation Introduction · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/model_simulation/simulation_introduction/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/model_simulation/simulation_introduction/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/model_simulation/simulation_introduction/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><span class="tocitem">Model Creation and Properties</span><ul><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../model_creation/conservation_laws/">Working with conservation laws</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/reactionsystem_content_accessing/">Accessing model properties</a></li><li><a class="tocitem" href="../../model_creation/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Model simulation</span><ul><li class="is-active"><a class="tocitem" href>Model Simulation Introduction</a><ul class="internal"><li><a class="tocitem" href="#simulation_intro_ODEs"><span>Performing (ODE) simulations</span></a></li><li><a class="tocitem" href="#simulation_intro_SDEs"><span>Performing SDE simulations</span></a></li><li><a class="tocitem" href="#simulation_intro_jumps"><span>Performing jump simulations using stochastic chemical kinetics</span></a></li><li><a class="tocitem" href="#simulation_intro_citation"><span>Citation</span></a></li></ul></li><li><a class="tocitem" href="../simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../ode_simulation_performance/">Advice for performant ODE simulations</a></li><li><a class="tocitem" href="../sde_simulation_performance/">Advice for performant SDE simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Model simulation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/periodic_events_simulation/">Modelling a periodic event during ODE and jump simulations</a></li></ul></li></ul></li><li><span class="tocitem">Steady state analysis</span><ul><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><span class="tocitem">Spatial Modelling</span><ul><li><a class="tocitem" href="../../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial jump simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model simulation</a></li><li class="is-active"><a href>Model Simulation Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model Simulation Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/model_simulation/simulation_introduction.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="simulation_intro"><a class="docs-heading-anchor" href="#simulation_intro">Model Simulation Introduction</a><a id="simulation_intro-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_intro" title="Permalink"></a></h1><p>Catalyst&#39;s core functionality is the creation of <em>chemical reaction network</em> (CRN) models that can be simulated using ODE, SDE, and jump simulations. How such simulations are carried out has already been described in <a href="../../introduction_to_catalyst/introduction_to_catalyst/#introduction_to_catalyst">Catalyst&#39;s introduction</a>. This page provides a deeper introduction, giving some additional background and introducing various simulation-related options.</p><p>Here we will focus on the basics, with other sections of the simulation documentation describing various specialised features, or giving advice on performance. Anyone who plans on using Catalyst&#39;s simulation functionality extensively is recommended to also read the documentation on <a href="../simulation_plotting/#simulation_plotting">solution plotting</a>, and on how to <a href="../simulation_structure_interfacing/#simulation_structure_interfacing">interact with simulation problems, integrators, and solutions</a>. Anyone with an application for which performance is critical should consider reading the corresponding page on performance advice for <a href="../ode_simulation_performance/#ode_simulation_performance">ODEs</a> or <a href="../sde_simulation_performance/#sde_simulation_performance">SDEs</a>.</p><h3 id="simulation_intro_theory"><a class="docs-heading-anchor" href="#simulation_intro_theory">Background to CRN simulations</a><a id="simulation_intro_theory-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_intro_theory" title="Permalink"></a></h3><p>This section provides some brief theory on CRN simulations. For details on how to carry out these simulations in actual code, please skip to the following sections.</p><p>CRNs are defined by a set of <em>species</em> (with the amounts of these determining the system&#39;s state during simulations) and a set of <em>reaction events</em> (rules for how the state of the system changes). In real systems, the species amounts are <em>discrete copy-numbers</em>, describing the exact numbers of each species type present in the system (in systems biology this can e.g. be the number of a specific molecule present in a cell). Given rates for these reaction events, <em>stochastic chemical kinetics</em> provides a formula for simulating the system that recreates its real reaction process. During stochastic chemical kinetics simulations, the system&#39;s state is defined by discrete copy-numbers (denoting the number of each species present in the system). Next, at the occurrence of individual <em>reaction events</em>, the system&#39;s state is updated according to the occurred reaction. The result is a stochastic process. The most well-known approach for simulating stochastic chemical kinetics is <a href="https://en.wikipedia.org/wiki/Gillespie_algorithm">Gillespie&#39;s algorithm</a>.</p><p>In practice, these jump simulations are computationally expensive. In many cases, copy-numbers are so large that they can be approximated as <em>continuous concentrations</em>, and the time-development of the system as a <em>deterministic process</em>. This creates an ordinary differential equation (ODE), and is the chemical reaction network form most people are most familiar with. The rule for how ODEs are generated from CRNs is called the <a href="https://en.wikipedia.org/wiki/Rate_equation"><em>reaction rate equation</em></a> (RRE).</p><p>Here, the RRE enables fast, approximate, and deterministic simulations of CRNs, while stochastic chemical kinetics enables exact, stochastic, simulations of the true process. An intermediary approach is to use the <a href="https://pubs.aip.org/aip/jcp/article/113/1/297/184125/The-chemical-Langevin-equation"><em>chemical Langevin equation</em></a> (CLE) to formulate a stochastic differential equation (SDE). This approximates the system&#39;s state as continuous concentrations, but <em>does not</em> assume that its time development is deterministic. Generally, the CLE is used when copy-numbers are large enough that the continuous approximation holds, but not so large that the system&#39;s behaviour is deterministic. Generally, the advantage of SDE simulations (compared to jump ones) is that they are faster. Also, since the system state is continuous, interpretation of e.g. stability and steady state results from the deterministic (also continuous) domain is easier for SDEs (however one <em>should be careful</em> when making such interpretations).</p><p>These three different approaches are summed up in the following table:</p><style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0pky">Interpretation</th>
    <th class="tg-0pky">Reaction rate equation</th>
    <th class="tg-0pky">Chemical Langevin equation</th>
    <th class="tg-0pky">Stochastic chemical kinetics</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">Simulation form</td>
    <td class="tg-0pky">ODE simulations</td>
    <td class="tg-0pky">SDE simulations</td>
    <td class="tg-0pky">Jump simulations</td>
  </tr>
  <tr>
    <td class="tg-0pky">Example simulation methods</td>
    <td class="tg-0pky"><a href="https://en.wikipedia.org/wiki/Euler_method">Euler</a>, <a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">Runge-Kutta</a></td>
    <td class="tg-0pky"><a href="https://en.wikipedia.org/wiki/Euler%E2%80%93Maruyama_method">Euler-Maruyama</a>, <a href="https://en.wikipedia.org/wiki/Milstein_method">Milstein</a></td>
    <td class="tg-0pky"><a href="https://en.wikipedia.org/wiki/Gillespie_algorithm">Gillespie</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/16321569/">Sorting direct</a></td>
  </tr>
  <tr>
    <td class="tg-0pky">Species units</td>
    <td class="tg-0pky">Concentration</td>
    <td class="tg-0pky">Concentration</td>
    <td class="tg-0pky">Copy-numbers</td>
  </tr>
  <tr>
    <td class="tg-0pky">Deterministic/Stochastic</td>
    <td class="tg-0pky">Deterministic</td>
    <td class="tg-0pky">Stochastic</td>
    <td class="tg-0pky">Stochastic</td>
  </tr>
  <tr>
    <td class="tg-0pky">Applicability</td>
    <td class="tg-0pky">Large species amounts</td>
    <td class="tg-0pky"><span style="font-weight:400;font-style:normal">Non-small species amounts</span></td>
    <td class="tg-0pky">Any species amounts</td>
  </tr>
  <tr>
    <td class="tg-0pky">Speed</td>
    <td class="tg-0pky">Typically fast</td>
    <td class="tg-0pky">Typically intermediate</td>
    <td class="tg-0pky">Typically slow</td>
  </tr>
  <tr>
    <td class="tg-0pky">Simulation package</td>
    <td class="tg-0pky"><a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a></td>
    <td class="tg-0pky"><a href="https://github.com/SciML/StochasticDiffEq.jl">StochasticDiffEq.jl</a></td>
    <td class="tg-0pky"><a href="https://github.com/SciML/JumpProcesses.jl">JumpProcesses.jl</a></td>
  </tr>
</tbody>
</table><h2 id="simulation_intro_ODEs"><a class="docs-heading-anchor" href="#simulation_intro_ODEs">Performing (ODE) simulations</a><a id="simulation_intro_ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_intro_ODEs" title="Permalink"></a></h2><p>The following section gives a (more throughout than [previous]) introduction of how to simulate Catalyst models. This is exemplified using ODE simulations (some ODE-specific options will also be discussed). Later on, we will describe things specific to <a href="#simulation_intro_SDEs">SDE</a> and <a href="#simulation_intro_jumps">jump</a> simulations. All ODE simulations are performed using the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package, which full documentation can be found <a href="https://docs.sciml.ai/OrdinaryDiffEq/stable/">here</a>. A dedicated section giving advice on how to optimise ODE simulation performance can be found <a href="../ode_simulation_performance/#ode_simulation_performance">here</a></p><p>To perform any simulation, we must first define our model, as well as the simulation&#39;s initial conditions, time span, and parameter values. Here we will use a simple <a href="../../model_creation/examples/basic_CRN_library/#basic_CRN_library_two_states">two-state model</a>:</p><pre><code class="language-julia hljs">using Catalyst
two_state_model = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 100.0, :X2 =&gt; 200.0]
tspan = (0.0, 5.0)
ps = [:k1 =&gt; 2.0, :k2 =&gt; 5.0]</code></pre><p>To simulate the model we first bundle these up into an <code>ODEProblem</code>:</p><pre><code class="language-julia hljs">oprob = ODEProblem(two_state_model, u0, tspan, ps)</code></pre><p>Next, we can simulate the model (requires loading the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package). Simulations are performed using the <code>solve</code> function.</p><pre><code class="language-julia hljs">using OrdinaryDiffEq
sol = solve(oprob)</code></pre><p>Finally, the result can be plotted using the <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> package&#39;s <code>plot</code> function:</p><pre><code class="language-julia hljs">using Plots
plot(sol)</code></pre><img src="b184d4c6.svg" alt="Example block output"/><p>More information on how to interact with solution structures is provided <a href="../simulation_structure_interfacing/#simulation_structure_interfacing">here</a> and on how to plot them <a href="../simulation_plotting/#simulation_plotting">here</a>.</p><p>Some additional considerations:</p><ul><li>If a model without parameters has been declared, only the first three arguments must be provided to <code>ODEProblem</code>.</li><li>While the first value of <code>tspan</code> will almost always be <code>0.0</code>, other starting times (both negative and positive) are possible.</li></ul><h3 id="simulation_intro_solver_options"><a class="docs-heading-anchor" href="#simulation_intro_solver_options">Designating solvers and solver options</a><a id="simulation_intro_solver_options-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_intro_solver_options" title="Permalink"></a></h3><p>While good defaults are generally selected, OrdinaryDiffEq enables the user to customise simulations through a long range of options that can be provided to the <code>solve</code> function. This includes specifying a <a href="https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations">solver algorithm</a>, which can be provided as a second argument to <code>solve</code> (if none is provided, a suitable choice is automatically made). E.g. here we specify that the <code>Rodas5P</code> method should be used:</p><pre><code class="language-julia hljs">sol = solve(oprob, Rodas5P())</code></pre><p>A full list of available solvers is provided <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">here</a>, and a discussion on optimal solver choices <a href="../ode_simulation_performance/#ode_simulation_performance_solvers">here</a>.</p><p>Additional options can be provided as keyword arguments. E.g. the <code>maxiters</code> arguments determines the maximum number of simulation time steps (before the simulation is terminated). This defaults to <code>1e5</code>, but can be modified through:</p><pre><code class="language-julia hljs">sol = solve(oprob; maxiters = 1e4)</code></pre><p>Here follows a list of solver options which might be of interest to the user.</p><ul><li><code>adaptive</code>: Toggles adaptive time stepping for valid methods. Default to <code>true</code>.</li><li><code>dt</code>: For non-adaptive simulations, sets the step size (also sets the initial step size for adaptive methods).</li><li><code>saveat</code>: Determines the time points at which the simulation is saved. E.g. for <code>saveat = 2.0</code> the simulation is saved every second time unit. If not given, the solution is saved after each time step.</li><li><code>save_idxs</code>: Provides a vector of species whose values should be saved during the simulation. E.g. for <code>save_idxs = [:X1]</code>, only the value of species <span>$X1$</span> is saved.</li><li><code>maxiters</code>: The maximum number of time steps of the simulation. If this number is reached, the simulation is terminated.</li><li><code>seed</code>: Sets a seed for stochastic simulations. Stochastic simulations with the same seed generate identical results.</li></ul><p>A full list of solver options can be found <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/">here</a>.</p><h3 id="simulation_intro_ODEs_input_forms"><a class="docs-heading-anchor" href="#simulation_intro_ODEs_input_forms">Alternative problem input forms</a><a id="simulation_intro_ODEs_input_forms-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_intro_ODEs_input_forms" title="Permalink"></a></h3><p>Throughout Catalyst&#39;s documentation, we typically provide initial condition and parameter values as vectors. However, these can also be provided as tuples:</p><pre><code class="language-julia hljs">u0 = (:X1 =&gt; 100.0, :X2 =&gt; 200.0)
tspan = (0.0, 5.0)
ps = (:k1 =&gt; 2.0, :k2 =&gt; 5.0)
oprob = ODEProblem(two_state_model, u0, tspan, ps)</code></pre><p>or dictionaries:</p><pre><code class="language-julia hljs">u0 = Dict([:X1 =&gt; 100.0, :X2 =&gt; 200.0])
tspan = (0.0, 5.0)
ps = Dict([:k1 =&gt; 2.0, :k2 =&gt; 5.0])
oprob = ODEProblem(two_state_model, u0, tspan, ps)</code></pre><p>The forms used for <code>u0</code> and <code>ps</code> does not need to be the same (but can e.g. be a vector and a tuple).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is possible to <a href="../../model_creation/dsl_advanced/#dsl_advanced_options_parameter_types">designate specific types for parameters</a>. When this is done, the tuple form for providing parameter values should be preferred.</p></div></div><p>Throughout Catalyst&#39;s documentation, we typically provide the time span as a tuple. However, if the first time point is <code>0.0</code> (which is typically the case), this can be omitted. Here, we supply only the simulation endpoint to our <code>ODEProblem</code>:</p><pre><code class="language-julia hljs">tend = 5.0
oprob = ODEProblem(two_state_model, u0, tend, ps)</code></pre><h2 id="simulation_intro_SDEs"><a class="docs-heading-anchor" href="#simulation_intro_SDEs">Performing SDE simulations</a><a id="simulation_intro_SDEs-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_intro_SDEs" title="Permalink"></a></h2><p>Catalyst uses the <a href="https://github.com/SciML/StochasticDiffEq.jl">StochasticDiffEq.jl</a> package to perform SDE simulations. This section provides a brief introduction, with <a href="https://docs.sciml.ai/StochasticDiffEq/stable/">StochasticDiffEq&#39;s documentation</a> providing a more extensive description. By default, Catalyst generates SDEs from CRN models using the chemical Langevin equation. A dedicated section giving advice on how to optimise SDE simulation performance can be found <a href="../sde_simulation_performance/#sde_simulation_performance">here</a>.</p><p>SDE simulations are performed in a similar manner to ODE simulations. The only exception is that an <code>SDEProblem</code> is created (rather than an <code>ODEProblem</code>). Furthermore, the <a href="https://github.com/SciML/StochasticDiffEq.jl">StochasticDiffEq.jl</a> package (rather than the OrdinaryDiffEq package) is required for performing simulations. Here we simulate the two-state model for the same parameter set as previously used:</p><pre><code class="language-julia hljs">using Catalyst, StochasticDiffEq, Plots
two_state_model = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 100.0, :X2 =&gt; 200.0]
tspan = (0.0, 1.0)
ps = [:k1 =&gt; 2.0, :k2 =&gt; 5.0]

sprob = SDEProblem(two_state_model, u0, tspan, ps)
sol = solve(sprob, STrapezoid())
plot(sol)</code></pre><img src="6f54b067.svg" alt="Example block output"/><p>we can see that while this simulation (unlike the ODE ones) exhibits some fluctuations.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Unlike for ODE and jump simulations, there are no good heuristics for automatically selecting suitable SDE solvers. Hence, for SDE simulations a solver must be provided. <code>STrapezoid</code> will work for a large number of cases. When this is not the case, however, please check the list of <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/sde_solve/">available SDE solvers</a> for a suitable alternative (making sure to select one compatible with non-diagonal noise and the [Ito interpretation]https://en.wikipedia.org/wiki/It%C3%B4_calculus).</p></div></div><h3 id="simulation_intro_SDEs_pitfalls"><a class="docs-heading-anchor" href="#simulation_intro_SDEs_pitfalls">Common SDE simulation pitfalls</a><a id="simulation_intro_SDEs_pitfalls-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_intro_SDEs_pitfalls" title="Permalink"></a></h3><p>Next, let us reduce species amounts (using <a href="../simulation_structure_interfacing/#simulation_structure_interfacing_problems_remake"><code>remake</code></a>), thereby also increasing the relative amount of noise, we encounter a problem when the model is simulated:</p><pre><code class="language-julia hljs">sprob = remake(sprob; u0 = [:X1 =&gt; 0.33, :X2 =&gt; 0.66])
sol = solve(sprob, STrapezoid())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: dt(2.220446049250313e-16) &lt;= dtmin(2.220446049250313e-16) at t=0.7083659582194852, and step error estimate = 2.5886839790622096. Aborting. There is either an error in your model specification or the true solution is unstable.
└ @ SciMLBase ~/.julia/packages/SciMLBase/vhP5T/src/integrator_interface.jl:589</code></pre><p>Here, we receive a warning that the simulation was terminated. next, if we plot the solution:</p><pre><code class="language-julia hljs">plot(sol)</code></pre><img src="578e9d52.svg" alt="Example block output"/><p>we note that the simulation didn&#39;t reach the designated final time point (<span>$t = 1.0$</span>). In this case we also note that species concentrations are very low (and sometimes, due to the relatively high amount of noise, even negative). This, combined with the early termination, suggests that we are simulating our model for too low species concentration for the assumptions of the CLE to hold. Instead, <a href="#simulation_intro_jumps">jump simulations</a> should be used.</p><p>Next, let us consider a simulation for another parameter set:</p><pre><code class="language-julia hljs">sprob = remake(sprob; u0 = [:X1 =&gt; 100.0, :X2 =&gt; 200.0], p = [:k1 =&gt; 200.0, :k2 =&gt; 500.0])
sol = solve(sprob, STrapezoid())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: dt(2.220446049250313e-16) &lt;= dtmin(2.220446049250313e-16) at t=0.04165033066372962, and step error estimate = 21.130145891170756. Aborting. There is either an error in your model specification or the true solution is unstable.
└ @ SciMLBase ~/.julia/packages/SciMLBase/vhP5T/src/integrator_interface.jl:589</code></pre><pre><code class="language-julia hljs">plot(sol)</code></pre><img src="c1eacc38.svg" alt="Example block output"/><p>Again, the simulation is aborted. This time, however, species concentrations are relatively large, so the CLE might still hold. What has happened this time is that the accuracy of the simulations has not reached its desired threshold. This can be deal with <a href="../ode_simulation_performance/#ode_simulation_performance_error">by reducing simulation tolerances</a>:</p><pre><code class="language-julia hljs">sol = solve(sprob, STrapezoid(), abstol = 1e-1, reltol = 1e-1)
plot(sol)</code></pre><img src="58e4829b.svg" alt="Example block output"/><h3 id="simulation_intro_SDEs_fixed_dt"><a class="docs-heading-anchor" href="#simulation_intro_SDEs_fixed_dt">SDE simulations with fixed time stepping</a><a id="simulation_intro_SDEs_fixed_dt-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_intro_SDEs_fixed_dt" title="Permalink"></a></h3><p>StochasticDiffEq implements SDE solvers with adaptive time stepping. However, when using a non-adaptive solver (or using the <code>adaptive = false</code> argument to turn adaptive time stepping off for an adaptive solver) a fixed time step <code>dt</code> must be designated. Here we simulate the same <code>SDEProblem</code> which we struggled with previously, but using the non-adaptive <a href="https://en.wikipedia.org/wiki/Euler%E2%80%93Maruyama_method"><code>EM</code></a> solver and a fixed <code>dt</code>:</p><pre><code class="language-julia hljs">sol = solve(sprob, EM(); dt = 0.001)
plot(sol)</code></pre><img src="24ca0fcd.svg" alt="Example block output"/><p>We note that this approach also enables us to successfully simulate the SDE we previously struggled with.</p><p>Generally, using a smaller fixed <code>dt</code> provides a more exact simulation, but also increases simulation runtime.</p><h3 id="simulation_intro_SDEs_noise_saling"><a class="docs-heading-anchor" href="#simulation_intro_SDEs_noise_saling">Scaling the noise in the chemical Langevin equation</a><a id="simulation_intro_SDEs_noise_saling-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_intro_SDEs_noise_saling" title="Permalink"></a></h3><p>When using the CLE to generate SDEs from a CRN, it can sometimes be desirable to scale the magnitude of the noise. This can be done by introducing a <em>noise scaling term</em>, with each noise term generated by the CLE being multiplied with this term. A noise scaling term can be set using the <code>@default_noise_scaling</code> option:</p><pre><code class="language-julia hljs">two_state_model = @reaction_network begin
    @default_noise_scaling 0.1
    (k1,k2), X1 &lt;--&gt; X2
end</code></pre><p>Here, we set the noise scaling term to <code>0.1</code>, reducing the noise with a factor <span>$10$</span> (noise scaling terms <span>$&gt;1.0$</span> increase the noise, while terms <span>$&lt;1.0$</span> reduce the noise). If we re-simulate the model using the low-concentration settings used previously, we see that the noise has been reduced (in fact by so much that the model can now be simulated without issues):</p><pre><code class="language-julia hljs">u0 = [:X1 =&gt; 100.0, :X2 =&gt; 200.0]
tspan = (0.0, 1.0)
ps = [:k1 =&gt; 200.0, :k2 =&gt; 500.0]
sprob = SDEProblem(two_state_model, u0, tspan, ps)
sol = solve(sprob, STrapezoid())
plot(sol)</code></pre><img src="efebb737.svg" alt="Example block output"/><p>The <code>@default_noise_scaling</code> option can take any expression. This can be used to e.g. designate a <em>noise scaling parameter</em>:</p><pre><code class="language-julia hljs">two_state_model = @reaction_network begin
    @parameters η
    @default_noise_scaling η
    (k1,k2), X1 &lt;--&gt; X2
end</code></pre><p>Now we can tune the noise through <span>$η$</span>&#39;s value. E.g. here we remove the noise entirely by setting <span>$η = 0.0$</span> (thereby recreating an ODE simulation&#39;s behaviour):</p><pre><code class="language-julia hljs">u0 = [:X1 =&gt; 0.33, :X2 =&gt; 0.66, :η =&gt; 0.0]
tspan = (0.0, 1.0)
ps = [:k1 =&gt; 2.0, :k2 =&gt; 5.0]
sprob = SDEProblem(two_state_model, u0, tspan, ps)
sol = solve(sprob, STrapezoid())
plot(sol)</code></pre><img src="e9ae8321.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Above, Catalyst is unable to infer that <span>$η$</span> is a parameter from the <code>@default_noise_scaling η</code> option only. Hence, <code>@parameters η</code> is used to explicitly declare <span>$η$</span> to be a parameter (as discussed in more detail <a href="../../model_creation/dsl_advanced/#dsl_advanced_options_declaring_species_and_parameters">here</a>).</p></div></div><p>It is possible to designate specific noise scaling terms for individual reactions through the <code>noise_scaling</code> <a href="../../model_creation/dsl_advanced/#dsl_advanced_options_reaction_metadata">reaction metadata</a>. Here, CLE noise terms associated with a specific reaction are multiplied by that reaction&#39;s noise scaling term. Here we use this to turn off the noise in the <span>$X1 \to X2$</span> reaction:</p><pre><code class="language-julia hljs">two_state_model = @reaction_network begin
    k1, X1 --&gt; X2, [noise_scaling = 0.0]
    k2, X2 --&gt; X1
end</code></pre><p>If the <code>@default_noise_scaling</code> option is used, that term is only applied to reactions <em>without</em> <code>noise_scaling</code> metadata.</p><p>While the <code>@default_noise_scaling</code> option is unavailable for <a href="../../model_creation/programmatic_CRN_construction/#programmatic_CRN_construction">programmatically created models</a>, the <code>set_default_noise_scaling</code> function can be used to achieve a similar effect.</p><h2 id="simulation_intro_jumps"><a class="docs-heading-anchor" href="#simulation_intro_jumps">Performing jump simulations using stochastic chemical kinetics</a><a id="simulation_intro_jumps-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_intro_jumps" title="Permalink"></a></h2><p>Catalyst uses the <a href="https://github.com/SciML/JumpProcesses.jl">JumpProcesses.jl</a> package to perform jump simulations. This section provides a brief introduction, with <a href="https://docs.sciml.ai/JumpProcesses/stable/">JumpProcesses&#39;s documentation</a> providing a more extensive description.</p><p>Jump simulations are performed using so-called <code>JumpProblem</code>s. Unlike ODEs and SDEs (for which the corresponding problem types can be created directly), jump simulations require first processing inputs into a correct format creating an intermediary <code>JumpInputs</code>. In this example, we first declare our two-state model and its initial conditions, time span, and parameter values.</p><pre><code class="language-julia hljs">using Catalyst, JumpProcesses, Plots
two_state_model = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
u0 = [:X1 =&gt; 5, :X2 =&gt; 10]
tspan = (0.0, 5.0)
ps = [:k1 =&gt; 2.0, :k2 =&gt; 5.0]</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Since jump simulations typically simulate the integer copy-numbers of each species present in the system, we designate our initial conditions for jump simulations as integers. Decimal-numbered initial conditions (and thus jump simulations) are, however, also possible. While ODE and SDE simulations accept integer initial conditions, these will be converted to decimal numbers.</p></div></div><p>Next, we process these into a <code>JumpInputs</code>:</p><pre><code class="language-julia hljs">jinput = JumpInputs(two_state_model, u0, tspan, ps)</code></pre><p>This is then used as input to a <code>JumpProblem</code>:</p><pre><code class="language-julia hljs">jprob = JumpProblem(jinput)</code></pre><p>The <code>JumpProblem</code> can now be simulated using <code>solve</code> (just like any other problem type).</p><pre><code class="language-julia hljs">sol = solve(jprob)</code></pre><p>If we plot the solution we can see how the system&#39;s state does not change continuously, but instead in discrete jumps (due to the occurrence of the individual reactions of the system).</p><pre><code class="language-julia hljs">using Plots
plot(sol)</code></pre><img src="7000fe37.svg" alt="Example block output"/><h3 id="simulation_intro_jumps_solver_designation"><a class="docs-heading-anchor" href="#simulation_intro_jumps_solver_designation">Designating aggregators and simulation methods for jump simulations</a><a id="simulation_intro_jumps_solver_designation-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_intro_jumps_solver_designation" title="Permalink"></a></h3><p>Jump simulations (just like ODEs and SDEs) are performed using stochastic simulation algorithms (SSAs) to generate exact samples of the underlying jump process. In JumpProcesses.jl and Catalyst, we call SSAs <em>aggregators</em>. These methods determine the time until, and type of, the next reaction in a system. A separate time-stepping method is then used to actually step from one reaction instance to the next.</p><p>Several different aggregators are available (a full list is provided <a href="https://docs.sciml.ai/JumpProcesses/stable/jump_types/#Jump-Aggregators-for-Exact-Simulation">here</a>). To designate a specific one, provide it as the second argument to the <code>JumpProblem</code>. E.g. to designate that the sorting direct method (<code>SortingDirect</code>) should be used, use:</p><pre><code class="language-julia hljs">jprob = JumpProblem(jinput, SortingDirect())</code></pre><p>Especially for large systems, the choice of aggregator can dramatically impact simulation performance.</p><h3 id="simulation_intro_jumps_variableratejumps"><a class="docs-heading-anchor" href="#simulation_intro_jumps_variableratejumps">Jump simulations where some rate depends on time</a><a id="simulation_intro_jumps_variableratejumps-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_intro_jumps_variableratejumps" title="Permalink"></a></h3><p>For some models, the rate terms of reactions may explicitly depend on time. E.g. consider the following <a href="https://en.wikipedia.org/wiki/Circadian_rhythm">circadian clock (inspired) model</a>, where the production rate of some protein (<span>$P$</span>) depends on a sinusoid function:</p><pre><code class="language-julia hljs">circadian_model = @reaction_network begin
    A*(sin(2π*f*t - ϕ)+1)/2, 0 --&gt; P
    d, P --&gt; 0
end</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightleftharpoons[d]{\frac{1}{2} A \left( 1 + \sin\left(  - \phi + 6.283185307179586 f t \right) \right)} \mathrm{P}  
 \end{align*}
 \]</p><p>This type of model will generate so called <em>variable rate jumps</em> (<code>VariableRateJump</code>s in JumpProcesses.jl). Such models can be simulated in Catalyst too, but note that now a method for time-stepping the solver must be provided to <code>solve</code>. Here ODE solvers should be given as they are used to handle integrating the explicitly time-dependent propensities for problems with variable rates, i.e. the proceeding example can be solved like</p><pre><code class="language-julia hljs">using OrdinaryDiffEq
u0map = [:P =&gt; 0]
pmap = [:f =&gt; 1.0, :A =&gt; 2.0, :ϕ =&gt; 0.0, :d =&gt; 1.0]
tspan = (0.0, 24.0)
jinputs = JumpInputs(circadian_model, u0map, tspan, pmap)
jprob = JumpProblem(jinputs)
sol = solve(jprob, Tsit5())  # use the Tsit5 ODE solver to time-step
plot(sol; idxs = :P, lw = 2)</code></pre><img src="eac5dff8.svg" alt="Example block output"/><hr/><h2 id="simulation_intro_citation"><a class="docs-heading-anchor" href="#simulation_intro_citation">Citation</a><a id="simulation_intro_citation-1"></a><a class="docs-heading-anchor-permalink" href="#simulation_intro_citation" title="Permalink"></a></h2><p>When you simulate Catalyst models in your research, please cite the corresponding paper(s) to support the simulation package authors. For ODE simulations:</p><pre><code class="nohighlight hljs">@article{DifferentialEquations.jl-2017,
 author = {Rackauckas, Christopher and Nie, Qing},
 doi = {10.5334/jors.151},
 journal = {The Journal of Open Research Software},
 keywords = {Applied Mathematics},
 note = {Exported from https://app.dimensions.ai on 2019/05/05},
 number = {1},
 pages = {},
 title = {DifferentialEquations.jl – A Performant and Feature-Rich Ecosystem for Solving Differential Equations in Julia},
 url = {https://app.dimensions.ai/details/publication/pub.1085583166 and http://openresearchsoftware.metajnl.com/articles/10.5334/jors.151/galley/245/download/},
 volume = {5},
 year = {2017}
}</code></pre><p>For SDE simulations:</p><pre><code class="nohighlight hljs">@article{rackauckas2017adaptive,
  title={Adaptive methods for stochastic differential equations via natural embeddings and rejection sampling with memory},
  author={Rackauckas, Christopher and Nie, Qing},
  journal={Discrete and continuous dynamical systems. Series B},
  volume={22},
  number={7},
  pages={2731},
  year={2017},
  publisher={NIH Public Access}
}</code></pre><p>For jump simulations:</p><pre><code class="nohighlight hljs">@misc{2022JumpProcesses,
  author       = {Isaacson, S. A. and Ilin, V. and Rackauckas, C. V.},
  title        = {{JumpProcesses.jl}},
  howpublished = {\url{https://github.com/SciML/JumpProcesses.jl/}},
  year         = {2022}
}
@misc{zagatti_extending_2023,
	title = {Extending {JumpProcess}.jl for fast point process simulation with time-varying intensities},
	url = {http://arxiv.org/abs/2306.06992},
	doi = {10.48550/arXiv.2306.06992},
	publisher = {arXiv},
	author = {Zagatti, Guilherme Augusto and Isaacson, Samuel A. and Rackauckas, Christopher and Ilin, Vasily and Ng, See-Kiong and Bressan, Stéphane},
	year = {2023},
}</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../model_creation/examples/smoluchowski_coagulation_equation/">« Smoluchowski Coagulation Equation</a><a class="docs-footer-nextpage" href="../simulation_plotting/">Simulation plotting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 13 August 2024 21:06">Tuesday 13 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
