var documenterSearchIndex = {"docs":
[{"location":"tutorials/advanced/#The-Reaction-DSL-Advanced","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"","category":"section"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"This section covers some of the more advanced syntax and features for building chemical reaction network models (still not very complicated!).","category":"page"},{"location":"tutorials/advanced/#User-defined-functions-in-reaction-rates","page":"The Reaction DSL - Advanced","title":"User defined functions in reaction rates","text":"","category":"section"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"The reaction network DSL can \"see\" user defined functions that work with ModelingToolkit. E.g., this is should work","category":"page"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"myHill(x) = 2.0*x^3/(x^3+1.5^3)\nrn = @reaction_network begin\n  myHill(X), ∅ → X\nend","category":"page"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"In some cases, it may be necessary or desirable to register functions with Symbolics.jl before their use in Catalyst, see the discussion here.","category":"page"},{"location":"tutorials/advanced/#Ignoring-mass-action-kinetics","page":"The Reaction DSL - Advanced","title":"Ignoring mass action kinetics","text":"","category":"section"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"While generally one wants the reaction rate to use the law of mass action, so the reaction","category":"page"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"rn = @reaction_network begin\n  k, X → ∅\nend k","category":"page"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"occurs at the rate dXdt = -kX, it is possible to ignore this by using any of the following non-filled arrows when declaring the reaction: ⇐, ⟽, ⇒, ⟾, ⇔, ⟺. This means that the reaction","category":"page"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"rn = @reaction_network begin\n  k, X ⇒ ∅\nend k","category":"page"},{"location":"tutorials/advanced/","page":"The Reaction DSL - Advanced","title":"The Reaction DSL - Advanced","text":"will occur at rate dXdt = -k (which might become a problem since X will be degraded at a constant rate even when very small or equal to 0).","category":"page"},{"location":"tutorials/basic_examples/#Basic-Chemical-Reaction-Network-Examples","page":"Basic Chemical Reaction Network Examples","title":"Basic Chemical Reaction Network Examples","text":"","category":"section"},{"location":"tutorials/basic_examples/#Example:-Birth-Death-Process","page":"Basic Chemical Reaction Network Examples","title":"Example: Birth-Death Process","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Chemical Reaction Network Examples","title":"Basic Chemical Reaction Network Examples","text":"rs = @reaction_network begin\n  c1, X --> 2X\n  c2, X --> 0\n  c3, 0 --> X\nend c1 c2 c3\np = (:c1 => 1.0, :c2 => 2.0, :c3 => 50.) \ntspan = (0.,4.)\nu0 = [:X => 5.]\n\n# solve ODEs\noprob = ODEProblem(rs, u0, tspan, p)\nosol  = solve(oprob, Tsit5())\n\n# solve for Steady-States\nssprob = SteadyStateProblem(rs, u0, p)\nsssol  = solve(ssprob, SSRootfind())\n\n# solve SDEs\nsprob = SDEProblem(rs, u0, tspan, p)\nssol  = solve(sprob, EM(), dt=.01)\n\n# solve JumpProblem\nu0 = [:X => 5]\ndprob = DiscreteProblem(rs, u0, tspan, p)\njprob = JumpProblem(rs, dprob, Direct())\njsol = solve(jprob, SSAStepper())","category":"page"},{"location":"tutorials/basic_examples/#Example:-Michaelis-Menten-Enzyme-Kinetics","page":"Basic Chemical Reaction Network Examples","title":"Example: Michaelis-Menten Enzyme Kinetics","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Chemical Reaction Network Examples","title":"Basic Chemical Reaction Network Examples","text":"rs = @reaction_network begin\n  c1, S + E --> SE\n  c2, SE --> S + E\n  c3, SE --> P + E\nend c1 c2 c3\np = (:c1 => 0.00166, :c2 => 0.0001, :c3 => 0.1) \ntspan = (0., 100.)\nu0 = [:S => 301., :E => 100., :SE => 0., :P => 0.]  \n\n# solve ODEs\noprob = ODEProblem(rs, u0, tspan, p)\nosol  = solve(oprob, Tsit5())\n\n# solve JumpProblem\nu0 = [:S => 301, :E => 100, :SE => 0, :P => 0] \ndprob = DiscreteProblem(rs, u0, tspan, p)\njprob = JumpProblem(rs, dprob, Direct())\njsol = solve(jprob, SSAStepper())","category":"page"},{"location":"tutorials/dsl/#The-Reaction-DSL","page":"The Reaction DSL","title":"The Reaction DSL","text":"","category":"section"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"This tutorial covers some of the basic syntax for building chemical reaction network models using Catalyst's domain specific language (DSL). Examples showing how to both construct and solve ODE, SDE, and jump models are provided in Basic Chemical Reaction Network Examples. To learn more about the symbolic ReactionSystems generated by the DSL, and how to use them directly, see the tutorial on Programmatic Construction of Symbolic Reaction Systems.","category":"page"},{"location":"tutorials/dsl/#Basic-syntax","page":"The Reaction DSL","title":"Basic syntax","text":"","category":"section"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The @reaction_network macro allows the (symbolic) specification of reaction networks with a simple format. Its input is a set of chemical reactions, and from them it generates a symbolic ReactionSystem reaction network object. The ReactionSystem can be used as input to ModelingToolkit ODEProblem, NonlinearProblem, SteadyStateProblem, SDEProblem, JumpProblem, and more. ReactionSystems can also be incrementally extended as needed, allowing for programmatic construction of networks and network composition.","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The basic syntax is:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  2.0, X + Y --> XY\n  1.0, XY --> Z1 + Z2\nend","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"where each line corresponds to a chemical reaction. Each reaction consists of a reaction rate (the expression on the left hand side of  ,), a set of substrates (the expression in-between , and -->), and a set of products (the expression on the right hand side of -->). The substrates and the products may contain one or more reactants, separated by +. The naming convention for these are the same as for normal variables in Julia.","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The chemical reaction model is generated by the @reaction_network macro and stored in the rn variable (a normal Julia variable, which does not need to be called rn). It corresponds to a ReactionSystem, a symbolic representation of the chemical network.  The generated ReactionSystem can be converted to a symbolic differential equation model via","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"osys  = convert(ODESystem, rn)","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"We can then convert the symbolic ODE model into a compiled, optimized representation for use in the SciML ODE solvers by constructing an ODEProblem. Creating an ODEProblem also requires our specifying the initial conditions for the model. We do this by creating a mapping from each symbolic variable representing a chemical species to its initial value","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"# define the symbolic variables\n@variables t, X(t), Y(t), Z(t), XY(t), Z1(t), Z2(t)\n\n# create the mapping\nu0 = [X => 1.0, Y => 1.0, XY => 1.0, Z1 => 1.0, Z2 => 1.0]","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Alternatively, we can create a mapping use Julia Symbols for each variable, and then convert them to a mapping involving symbolic variables like","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"u0 = symmap_to_varmap(rn, [:X => 1.0, :Y => 1.0, :XY => 1.0, :Z1 => 1.0, :Z2 => 1.0])","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Given the mapping, we can then create an ODEProblem from our symbolic ODESystem","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"oprob = ODEProblem(osys, u0, tspan, [])","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Catalyst provides a shortcut to avoid having to explicitly convert to an ODESystem and/or use symmap_to_varmap, allowing direct construction of the ODEProblem like","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"u0 = [:X => 1.0, :Y => 1.0, :XY => 1.0, :Z1 => 1.0, :Z2 => 1.0]\noprob = ODEProblem(rn, u0, tspan, [])","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"For more detailed examples, see the Basic Chemical Reaction Network Examples. The generated differential equations use the law of mass action. For the above example, the ODEs are then","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"fracdXdt = -2 X Y\nfracdYdt = -2 X Y\nfracdXYdt = 2 X Y - XY\nfracdZ1dt= XY\nfracdZ2dt = XY","category":"page"},{"location":"tutorials/dsl/#Defining-parameters-and-species","page":"The Reaction DSL","title":"Defining parameters and species","text":"","category":"section"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Parameter values do not need to be set when the model is created. Components can be designated as symbolic parameters by declaring them at the end:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  p, ∅ --> X\n  d, X --> ∅\nend p d","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Parameters can only exist in the reaction rates (where they can be mixed with reactants). All variables not declared after end will be treated as a chemical species.","category":"page"},{"location":"tutorials/dsl/#Production,-Destruction-and-Stoichiometry","page":"The Reaction DSL","title":"Production, Destruction and Stoichiometry","text":"","category":"section"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Sometimes reactants are produced/destroyed from/to nothing. This can be designated using either 0 or ∅:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  2.0, 0 --> X\n  1.0, X --> ∅\nend","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"If several molecules of the same reactant are involved in a reaction, the stoichiometry of a reactant in a reaction can be set using a number. Here, two molecules of species X form the dimer X2:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, 2X --> X2\nend","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"this corresponds to the differential equation:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"fracdXdt = -X^2\nfracdX2dt = frac12 X^2","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Other numbers than 2 can be used, and parenthesis can be used to reuse the same stoichiometry for several reactants:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, X + 2(Y + Z) --> XY2Z2\nend","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Note, one can explicitly multiply by integer coefficients too, i.e.","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, X + 2*(Y + Z) --> XY2Z2\nend","category":"page"},{"location":"tutorials/dsl/#Arrow-variants","page":"The Reaction DSL","title":"Arrow variants","text":"","category":"section"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"A variety of unicode arrows are accepted by the DSL in addition to -->. All of these work:  >, → ↣, ↦, ⇾, ⟶, ⟼, ⥟, ⥟, ⇀, ⇁. Backwards arrows can also be used to write the reaction in the opposite direction. For example, these reactions are equivalent:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  1.0, X + Y --> XY\n  1.0, X + Y → XY\n  1.0, XY ← X + Y\n  1.0, XY <-- X + Y\nend","category":"page"},{"location":"tutorials/dsl/#Bi-directional-arrows-for-reversible-reactions","page":"The Reaction DSL","title":"Bi-directional arrows for reversible reactions","text":"","category":"section"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Bi-directional arrows, including bidirectional unicode arrows like ↔, can be used to designate a reversible reaction. For example, these two models are equivalent:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  2.0, X + Y --> XY\n  2.0, X + Y <-- XY\nend\nrn = @reaction_network begin\n  (2.0,2.0), X + Y <--> XY\nend","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"If the reaction rates in the backward and forward directions are different, they can be designated in the following way:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  (2.0,1.0) X + Y <--> XY\nend","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"which is identical to","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  2.0, X + Y --> XY\n  1.0, X + Y <-- XY\nend","category":"page"},{"location":"tutorials/dsl/#Combining-several-reactions-in-one-line","page":"The Reaction DSL","title":"Combining several reactions in one line","text":"","category":"section"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Several similar reactions can be combined in one line by providing a tuple of reaction rates and/or substrates and/or products. If several tuples are provided, they must all be of identical length. These pairs of reaction networks are all identical:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  1.0, S --> (P1,P2)\nend\nrn2 = @reaction_network begin\n  1.0, S --> P1\n  1.0, S --> P2\nend","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  (1.0,2.0), (S1,S2) --> P\nend\nrn2 = @reaction_network begin\n  1.0, S1 --> P\n  2.0, S2 --> P\nend","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  (1.0,2.0,3.0), (S1,S2,S3) → (P1,P2,P3)\nend\nrn2 = @reaction_network begin\n  1.0, S1 --> P1\n  2.0, S2 --> P2\n  3.0, S3 --> P3\nend","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"This can also be combined with bi-directional arrows, in which case separate tuples can be provided for the backward and forward reaction rates. These reaction networks are identical","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n (1.0,(1.0,2.0)), S <--> (P1,P2)\nend\nrn2 = @reaction_network begin\n  1.0, S --> P1\n  1.0, S --> P2\n  1.0, P1 --> S\n  2.0, P2 --> S\nend","category":"page"},{"location":"tutorials/dsl/#Variable-reaction-rates","page":"The Reaction DSL","title":"Variable reaction rates","text":"","category":"section"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Reaction rates do not need to be a single parameter or a number, but can also be expressions depending on time or the current concentration of other species (when, for example, one species can activate the production of another). For instance, this is a valid notation:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  k*X, Y --> ∅\nend k","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"and will have Y degraded at rate","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"fracdYdt = -kXY","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Note, this is actually equivalent to the reaction","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network begin\n  k, X + Y --> X\nend k","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"in the resulting generated ODESystem, however, the latter Reaction will be classified as ismassaction and the former will not, which can impact optimizations used in generating JumpSystems. For this reason, it is recommended to use the latter representation when possible.","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Most expressions and functions are valid reaction rates, e.g.:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"using SpecialFunctions\nrn = @reaction_network begin\n  2.0*X^2, 0 --> X + Y\n  t*gamma(Y), X --> ∅\n  pi*X/Y, Y → ∅\nend","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"where here t always denotes Catalyst's time variable. Please note that many user-defined functions can be called directly, but others will require registration with Symbolics.jl (see the faq).","category":"page"},{"location":"tutorials/dsl/#Naming-the-generated-ReactionSystem","page":"The Reaction DSL","title":"Naming the generated ReactionSystem","text":"","category":"section"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"ModelingToolkit uses system names to allow for compositional and hierarchical models. To specify a name for the generated ReactionSystem via the reaction_network macro, just place the name before begin:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn = @reaction_network production_degradation begin\n  p, ∅ --> X\n  d, X --> ∅\nend p d\nModelingToolkit.nameof(rn) == :production_degradation","category":"page"},{"location":"tutorials/dsl/#Pre-defined-functions","page":"The Reaction DSL","title":"Pre-defined functions","text":"","category":"section"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Hill functions and a Michaelis-Menten function are pre-defined and can be used as rate laws. Below, the pair of reactions within rn1 are equivalent, as are the pair of reactions within rn2:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  hill(X,v,K,n), ∅ --> X\n  v*X^n/(X^n+K^n), ∅ --> X\nend v K n\nrn2 = @reaction_network begin\n  mm(X,v,K), ∅ --> X\n  v*X/(X+K), ∅ --> X\nend v K","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Repressor Hill (hillr) and Michaelis-Menten (mmr) functions are also provided:","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"rn1 = @reaction_network begin\n  hillr(X,v,K,n), ∅ --> X\n  v*K^n/(X^n+K^n), ∅ --> X\nend v K n\nrn2 = @reaction_network begin\n  mmr(X,v,K), ∅ --> X\n  v*K/(X+K), ∅ --> X\nend v K","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Please see the API Rate Laws section for more details.","category":"page"},{"location":"tutorials/dsl/#Interpolation-of-Julia-Variables","page":"The Reaction DSL","title":"Interpolation of Julia Variables","text":"","category":"section"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"The DSL allows Julia variables to be interpolated for the network name, within rate constant expressions, or for species within the reaction. For example,","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"@parameters k\n@variables t, A(t)\nspec = A\nrate = k*A\nname = :network\nrn = @reaction_network $name begin\n    $rate*B, 2*$spec + B --> $spec + C\n  end","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"gives","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Model network with 1 equations\nStates (3):\n  A(t)\n  B(t)\n  C(t)\nParameters (1):\n  k","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"with","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"reactions(rn)","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"giving","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"1-element Vector{Reaction}:\n k*A(t)*B(t), 2A + B --> A + C","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"As the parameter k was pre-defined and appears via interpolation, we did not need to declare it at the end of the @reaction_network macro.","category":"page"},{"location":"tutorials/dsl/","page":"The Reaction DSL","title":"The Reaction DSL","text":"Note, when using interpolation expressions like 2$spec won't work; the multiplication symbol must be explicitly included like 2*$spec.","category":"page"},{"location":"tutorials/advanced_examples/#Advanced-Chemical-Reaction-Network-Examples","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"","category":"section"},{"location":"tutorials/advanced_examples/","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"For additional flexibility, we can convert the generated ReactionSystem first to another ModelingToolkit.AbstractSystem, e.g., an ODESystem, SDESystem, JumpSystem, etc. These systems can then be used in problem generation. Please also see the ModelingToolkit docs, which give many options for optimized problem generation (i.e., generating dense or sparse Jacobians with or without threading and/or parallelization), creating LaTeX representations for systems, etc.","category":"page"},{"location":"tutorials/advanced_examples/","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"Note, when generating problems from other system types, u0 and p must provide vectors, tuples or dictionaries of Pairs that map each the symbolic variables for each species or parameter to their numerical value. E.g., for the Michaelis-Menten example above we'd use","category":"page"},{"location":"tutorials/advanced_examples/","page":"Advanced Chemical Reaction Network Examples","title":"Advanced Chemical Reaction Network Examples","text":"rs = @reaction_network begin\n  c1, X --> 2X\n  c2, X --> 0\n  c3, 0 --> X\nend c1 c2 c3\np     = (:c1 => 1.0, :c2 => 2.0, :c3 => 50.)\npmap  = symmap_to_varmap(rs,p)   # convert Symbol map to symbolic variable map\ntspan = (0.,4.)\nu0    = [:X => 5.]   \nu0map = symmap_to_varmap(rs,u0)  # convert Symbol map to symbolic variable map\nosys  = convert(ODESystem, rs)\noprob = ODEProblem(osys, u0map, tspan, pmap)\nsol   = solve(oprob, Tsit5())","category":"page"},{"location":"tutorials/using_catalyst/#Using-Catalyst","page":"Using Catalyst","title":"Using Catalyst","text":"","category":"section"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"In this tutorial we provide an introduction to using Catalyst to specify chemical reaction networks, and then to solve ODE, jump, and SDE models generated from them. At the end we show what mathematical rate laws and transition rate functions (i.e. intensities or propensities) are generated by Catalyst for ODE, SDE and jump process models.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Let's start by using the Catalyst @reaction_network macro to specify a simple chemical reaction network: the well-known repressilator.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We first import the basic packages we'll need:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"# If not already installed, first hit \"]\" within a Julia REPL. Then type:\n# add Catalyst DifferentialEquations Plots Latexify\n\nusing Catalyst, DifferentialEquations, Plots, Latexify","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We now construct the reaction network. The basic types of arrows and predefined rate laws one can use are discussed in detail within the tutorial, The Reaction DSL. Here, we use a mix of first order, zero order, and repressive Hill function rate laws. Note, varnothing corresponds to the empty state, and is used for zeroth order production and first order degradation reactions:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"repressilator = @reaction_network Repressilator begin\n    hillr(P₃,α,K,n), ∅ --> m₁\n    hillr(P₁,α,K,n), ∅ --> m₂\n    hillr(P₂,α,K,n), ∅ --> m₃\n    (δ,γ), m₁ <--> ∅\n    (δ,γ), m₂ <--> ∅\n    (δ,γ), m₃ <--> ∅\n    β, m₁ --> m₁ + P₁\n    β, m₂ --> m₂ + P₂\n    β, m₃ --> m₃ + P₃\n    μ, P₁ --> ∅\n    μ, P₂ --> ∅\n    μ, P₃ --> ∅\nend α K n δ γ β μ","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"which gives","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Model Repressilator with 15 equations\nStates (6):\n  m₁(t)\n  m₂(t)\n  m₃(t)\n  P₁(t)\n  P₂(t)\n  P₃(t)\nParameters (7):\n  α\n  K\n  n\n  δ\n  γ\n  β\n  μ","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"showing that we've created a new network model named Repressilator with the listed chemical species and states. @reaction_network returns a ReactionSystem, which we saved in the repressilator variable. It can be converted to a variety of other mathematical models represented as ModelingToolkit.AbstractSystems, or analyzed in various ways using the Catalyst.jl API. For example, to see the chemical species, parameters, and reactions we can use","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"species(repressilator)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"which gives","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"6-element Array{Term{Real},1}:\n m₁(t)\n m₂(t)\n m₃(t)\n P₁(t)\n P₂(t)\n P₃(t)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"parameters(repressilator)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"which gives","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"7-element Array{Sym{ModelingToolkit.Parameter{Real}},1}:\n α\n K\n n\n δ\n γ\n β\n μ","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"and","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"reactions(repressilator)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"which gives","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"15-element Vector{Reaction}:\n Catalyst.hillr(P₃(t), α, K, n), ∅ --> m₁\n Catalyst.hillr(P₁(t), α, K, n), ∅ --> m₂\n Catalyst.hillr(P₂(t), α, K, n), ∅ --> m₃\n δ, m₁ --> ∅\n γ, ∅ --> m₁\n δ, m₂ --> ∅\n γ, ∅ --> m₂\n δ, m₃ --> ∅\n γ, ∅ --> m₃\n β, m₁ --> m₁ + P₁\n β, m₂ --> m₂ + P₂\n β, m₃ --> m₃ + P₃\n μ, P₁ --> ∅\n μ, P₂ --> ∅\n μ, P₃ --> ∅","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We can also use Latexify to see the corresponding reactions, which shows what the hillr terms correspond to mathematically","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"latexify(repressilator, starred=true)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"beginalign*\nrequiremhchem\nce varnothing -fracalpha K^nK^n + P_3^n m_1\nce varnothing -fracalpha K^nK^n + P_1^n m_2\nce varnothing -fracalpha K^nK^n + P_2^n m_3\nce m_1 =deltagamma varnothing\nce m_2 =deltagamma varnothing\nce m_3 =deltagamma varnothing\nce m_1 -beta m_1 + P_1\nce m_2 -beta m_2 + P_2\nce m_3 -beta m_3 + P_3\nce P_1 -mu varnothing\nce P_2 -mu varnothing\nce P_3 -mu varnothing\nendalign*","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Assuming Graphviz is installed and commandline accessible, within a Jupyter notebook we can also graph the reaction network by","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"g = Graph(repressilator)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"giving","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"(Image: Repressilator solution)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"The network graph shows a variety of information, representing each species as a blue node, and each reaction as an orange dot. Black arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry. Similarly, black arrows from reactions to species indicate products, and are labelled with their output stoichiometry. In contrast, red arrows from a species to reactions indicate the species is used within the reactions' rate expressions. For the repressilator, the reactions","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"hillr(P₃,α,K,n), ∅ --> m₁\nhillr(P₁,α,K,n), ∅ --> m₂\nhillr(P₂,α,K,n), ∅ --> m₃","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"have rates that depend on the proteins, and hence lead to red arrows from each Pᵢ.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Note, from the REPL or scripts one can always use savegraph to save the graph (assuming Graphviz is installed).","category":"page"},{"location":"tutorials/using_catalyst/#Mass-Action-ODE-Models","page":"Using Catalyst","title":"Mass Action ODE Models","text":"","category":"section"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Let's now use our ReactionSystem to generate and solve a corresponding mass action ODE model. We first convert the system to a ModelingToolkit.ODESystem by","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"odesys = convert(ODESystem, repressilator)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We can once again use Latexify to look at the corresponding ODE model","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"latexify(odesys)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"beginaligned\nfracdm_1(t)dt = fracalpha K^nK^n + left( mathrmP_3left( t right) right)^n - delta mathrmm_1left( t right) + gamma \nfracdm_2(t)dt = fracalpha K^nK^n + left( mathrmP_1left( t right) right)^n - delta mathrmm_2left( t right) + gamma \nfracdm_3(t)dt = fracalpha K^nK^n + left( mathrmP_2left( t right) right)^n - delta mathrmm_3left( t right) + gamma \nfracdP_1(t)dt = beta mathrmm_1left( t right) - mu mathrmP_1left( t right) \nfracdP_2(t)dt = beta mathrmm_2left( t right) - mu mathrmP_2left( t right) \nfracdP_3(t)dt = beta mathrmm_3left( t right) - mu mathrmP_3left( t right)\nendaligned","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"(Note, there is currently a Latexify bug that causes different fonts to be used for the species symbols on each side of the equations.)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Before we can solve the ODEs, we need to specify the values of the parameters in the model, the initial condition, and the time interval to solve the model on. To do this we need to build mappings from the symbolic parameters and the species to the corresponding numerical values for parameters and initial conditions. We can build such mappings in several ways. One is to use Julia Symbols to specify the values like","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"pmap  = (:α => .5, :K => 40, :n => 2, :δ => log(2)/120,\n         :γ => 5e-3, :β => log(2)/6, :μ => log(2)/60)\nu₀map = [:m₁ => 0., :m₂ => 0., :m₃ => 0., :P₁ => 20., :P₂ => 0., :P₃ => 0.]","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Alternatively, we can use ModelingToolkit symbolic variables to specify these mappings like","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"@parameters  α K n δ γ β μ\n@variables t m₁(t) m₂(t) m₃(t) P₁(t) P₂(t) P₃(t)\npmap  = (α => .5, K => 40, n => 2, δ => log(2)/120,\n         γ => 5e-3, β => 20*log(2)/120, μ => log(2)/60)\nu₀map = [m₁ => 0., m₂ => 0., m₃ => 0., P₁ => 20., P₂ => 0., P₃ => 0.]\n","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Knowing these mappings we can set up the ODEProblem we want to solve:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"# time interval to solve on\ntspan = (0., 10000.)\n\n# create the ODEProblem we want to solve\noprob = ODEProblem(repressilator, u₀map, tspan, pmap)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Note, by passing repressilator directly to the ODEProblem, Catalyst has to (internally) call convert(ODESystem, repressilator) again to generate the symbolic ODEs. We could instead pass odesys directly like","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"oprob2 = ODEProblem(odesys, u₀map, tspan, pmap)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"oprob and oprob2 are functionally equivalent, each representing the same underlying problem.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"At this point we are all set to solve the ODEs. We can now use any ODE solver from within the DifferentialEquations.jl package. We'll use the recommended default explicit solver, Tsit5(), and then plot the solutions:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"sol = solve(oprob, Tsit5(), saveat=10.)\nplot(sol)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"(Image: Repressilator ODE Solutions)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We see the well-known oscillatory behavior of the repressilator! For more on the choices of ODE solvers, see the DifferentialEquations.jl documentation.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"","category":"page"},{"location":"tutorials/using_catalyst/#Stochastic-Simulation-Algorithms-(SSAs)-for-Stochastic-Chemical-Kinetics","page":"Using Catalyst","title":"Stochastic Simulation Algorithms (SSAs) for Stochastic Chemical Kinetics","text":"","category":"section"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Let's now look at a stochastic chemical kinetics model of the repressilator, modeling it with jump processes. Here, we will construct a JumpProcesses JumpProblem that uses Gillespie's Direct method, and then solve it to generate one realization of the jump process:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"# redefine the initial condition to be integer valued\nu₀map = [:m₁ => 0, :m₂ => 0, :m₃ => 0, :P₁ => 20, :P₂ => 0, :P₃ => 0]\n\n# next we create a discrete problem to encode that our species are integer valued:\ndprob = DiscreteProblem(repressilator, u₀map, tspan, pmap)\n\n# now, we create a JumpProblem, and specify Gillespie's Direct Method as the solver:\njprob = JumpProblem(repressilator, dprob, Direct(), save_positions=(false,false))\n\n# now, let's solve and plot the jump process:\nsol = solve(jprob, SSAStepper(), saveat=10.)\nplot(sol)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"(Image: Repressilator SSA Solutions)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We see that oscillations remain, but become much noisier. Note, in constructing the JumpProblem we could have used any of the SSAs that are part of JumpProcesses instead of the Direct method, see the list of SSAs (i.e., constant rate jump aggregators) in the documentation.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"Common questions that arise in using the JumpProcesses SSAs (i.e. Gillespie methods) are collated in the JumpProcesses FAQ.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"","category":"page"},{"location":"tutorials/using_catalyst/#Chemical-Langevin-Equation-(CLE)-Stochastic-Differential-Equation-(SDE)-Models","page":"Using Catalyst","title":"Chemical Langevin Equation (CLE) Stochastic Differential Equation (SDE) Models","text":"","category":"section"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"At an intermediate physical scale between macroscopic ODE models and microscopic stochastic chemical kinetics models lies the CLE, given by a system of SDEs that add to each ODE above a noise term. As the repressilator has species that get very close to zero in size, it is not a good candidate to model with the CLE (where solutions can then go negative and become unphysical). Let's create a simpler reaction network for a birth-death process that will stay non-negative:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"bdp = @reaction_network begin\n  c₁, X --> 2X\n  c₂, X --> 0\n  c₃, 0 --> X\nend c₁ c₂ c₃\np = (:c₁ => 1.0, :c₂ => 2.0, :c₃ => 50.)\nu₀ = [:X => 5.]\ntspan = (0.,4.)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"The corresponding Chemical Langevin Equation SDE is then","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"dX(t) = left( c_1 Xleft( t right) - c_2 Xleft( t right) + c_3 right) dt + sqrtc_1 X(t) dW_1(t) - sqrtc_2 X(t) dW_2(t) + sqrtc_3 dW_3(t)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"where each W_i(t) denotes an independent Brownian Motion. We can solve the CLE model by creating an SDEProblem and solving it similarly to what we did for ODEs above:","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"# SDEProblem for CLE\nsprob = SDEProblem(bdp, u₀, tspan, p)\n\n# solve and plot, tstops is used to specify enough points\n# that the plot looks well-resolved\nsol = solve(sprob, LambaEM(), tstops=range(0., step=4e-3, length=1001))\nplot(sol)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"(Image: CLE Solution)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"We again have complete freedom to select any of the StochasticDiffEq.jl SDE solvers, see the documentation.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"","category":"page"},{"location":"tutorials/using_catalyst/#Reaction-rate-laws-used-in-simulations","page":"Using Catalyst","title":"Reaction rate laws used in simulations","text":"","category":"section"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"In generating mathematical models from a ReactionSystem, reaction rates are treated as microscopic rates. That is, for a general mass action reaction of the form n_1 S_1 + n_2 S_2 + dots n_M S_M to dots with stoichiometric substrate coefficients n_i_i=1^M and rate constant k, the corresponding ODE and SDE rate laws are taken to be","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"k prod_i=1^M frac(S_i)^n_in_i","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"while the jump process transition rate (i.e., the propensity or intensity function) is","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"k prod_i=1^M fracS_i (S_i-1) dots (S_i-n_i+1)n_i","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"For example, the rate law of the reaction 2X + 3Y to Z with rate constant k would be","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"k fracX^22 fracY^33 ","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"giving the ODE model","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"beginalign*\nfracdXdt =  -2 k fracX^22 fracY^33 \nfracdYdt =  -3 k fracX^22 fracY^33 \nfracdZdt = k fracX^22 fracY^33\nendalign*","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"This implicit rescaling of rate constants can be disabled through explicit conversion of a ReactionSystem to another system via Base.convert using the combinatoric_ratelaws=false keyword argument, i.e.","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"rn = @reaction_network ...\nconvert(ODESystem, rn; combinatoric_ratelaws=false)","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"For the previous example using this keyword argument would give the rate law","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"k X^2 Y^3","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"and the ODE model","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"beginalign*\nfracdXdt =  -2 k X^2 Y^3 \nfracdYdt =  -3 k X^2 Y^3 \nfracdZdt = k X^2 Y^3\nendalign*","category":"page"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"","category":"page"},{"location":"tutorials/using_catalyst/#Notes","page":"Using Catalyst","title":"Notes","text":"","category":"section"},{"location":"tutorials/using_catalyst/","page":"Using Catalyst","title":"Using Catalyst","text":"For each of the preceding models we converted the ReactionSystem to, i.e., ODEs, jumps, or SDEs, we had two paths for conversion:\na. Convert to the corresponding ModelingToolkit system and then use it in     creating the corresponding problem.\nb. Directly create the desired problem type from the ReactionSystem.\nThe latter is more convenient, however, the former will be more efficient if one needs to repeatedly create the associated Problem.\nModelingToolkit offers many options for optimizing the generated ODEs and SDEs, including options to build functions for evaluating Jacobians and/or multithreaded versions of derivative evaluation functions. See the options for ODEProblems and SDEProblems.","category":"page"},{"location":"api/catalyst_api/#Catalyst.jl-API","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"CurrentModule = Catalyst","category":"page"},{"location":"api/catalyst_api/#Reaction-Network-Generation-and-Representation","page":"Catalyst.jl API","title":"Reaction Network Generation and Representation","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"Catalyst provides the @reaction_network macro for generating a complete network, stored as a ReactionSystem, which in turn is composed of Reactions. ReactionSystems can be converted to other ModelingToolkit.AbstractSystems, including a ModelingToolkit.ODESystem, ModelingToolkit.SDESystem, or ModelingToolkit.JumpSystem.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"An empty network can be generated using @reaction_network with no arguments (or one argument to name the system), or the make_empty_network function. These can then be extended programmatically using addspecies!, addparam!, and addreaction!.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"It is important to note for @reaction_network that any variable not declared to be a parameter after end will be treated as a chemical species of the system. i.e. in","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"rn = @reaction_network begin\n    k*X, Y --> W\nend k","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"X, Y and W will all be classified as chemical species.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"The ReactionSystem generated by the @reaction_network macro is a ModelingToolkit.AbstractSystem that symbolically represents a system of chemical reactions. In some cases it can be convenient to bypass the macro and directly generate a collection of Reactions and a corresponding ReactionSystem encapsulating them. Below we illustrate with a simple SIR example how a system can be directly constructed, and demonstrate how to then generate from the ReactionSystem and solve corresponding chemical reaction ODE models, chemical Langevin equation SDE models, and stochastic chemical kinetics jump process models.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"using Catalyst, OrdinaryDiffEq, StochasticDiffEq, JumpProcesses\n@parameters β γ t\n@variables S(t) I(t) R(t)\n\nrxs = [Reaction(β, [S,I], [I], [1,1], [2])\n       Reaction(γ, [I], [R])]\n@named rs = ReactionSystem(rxs, t)\n\nu₀map    = [S => 999.0, I => 1.0, R => 0.0]\nparammap = [β => 1/10000, γ => 0.01]\ntspan    = (0.0, 250.0)\n\n# solve as ODEs\nodesys = convert(ODESystem, rs)\noprob = ODEProblem(odesys, u₀map, tspan, parammap)\nsol = solve(oprob, Tsit5())\n\n# solve as SDEs\nsdesys = convert(SDESystem, rs)\nsprob = SDEProblem(sdesys, u₀map, tspan, parammap)\nsol = solve(sprob, EM(), dt=.01)\n\n# solve as jump process\njumpsys = convert(JumpSystem, rs)\nu₀map    = [S => 999, I => 1, R => 0]\ndprob = DiscreteProblem(jumpsys, u₀map, tspan, parammap)\njprob = JumpProblem(jumpsys, dprob, Direct())\nsol = solve(jprob, SSAStepper())","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"@reaction_network\nmake_empty_network\n@reaction\nReaction\nReactionSystem","category":"page"},{"location":"api/catalyst_api/#Catalyst.@reaction_network","page":"Catalyst.jl API","title":"Catalyst.@reaction_network","text":"@reaction_network\n\nGenerates a ReactionSystem that encodes a chemical reaction network.\n\nSee The Reaction DSL documentation for details on parameters to the macro.\n\nExamples:\n\n# a basic SIR model, with name SIR\nsir_model = @reaction_network SIR begin\n    c1, s + i --> 2i\n    c2, i --> r\nend c1 c2\n\n# a basic SIR model, with random generated name\nsir_model = @reaction_network begin\n    c1, s + i --> 2i\n    c2, i --> r\nend c1 c2\n\n# an empty network with name empty\nemptyrn = @reaction_network empty\n\n# an empty network with random generated name\nemptyrn = @reaction_network\n\n\n\n\n\n","category":"macro"},{"location":"api/catalyst_api/#Catalyst.make_empty_network","page":"Catalyst.jl API","title":"Catalyst.make_empty_network","text":"make_empty_network(; iv=DEFAULT_IV, name=gensym(:ReactionSystem))\n\nConstruct an empty ReactionSystem. iv is the independent variable, usually time, and name is the name to give the ReactionSystem.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.@reaction","page":"Catalyst.jl API","title":"Catalyst.@reaction","text":"@reaction\n\nGenerates a single Reaction object.\n\nExamples:\n\nrx = @reaction k*v, A + B --> C + D\n\n# is equivalent to\n@parameters k v\n@variables t A(t) B(t) C(t) D(t)\nrx == Reaction(k*v, [A,B], [C,D])\n\nHere k and v will be parameters and A, B, C and D will be variables. Interpolation of existing parameters/variables also works\n\n@parameters k b\n@variables t A(t)\nex = k*A^2 + t\nrx = @reaction b*$ex*$A, $A --> C\n\nNotes:\n\nAny symbols arising in the rate expression that aren't interpolated are treated as parameters. In the reaction part (α*A + B --> C + D), coefficients are treated as parameters, e.g. α, and rightmost symbols as species, e.g. A,B,C,D.\nWorks with any single arrow types supported by @reaction_network.\nInterpolation of Julia variables into the macro works similar to the @reaction_network macro. See The Reaction DSL tutorial for more details.\n\n\n\n\n\n","category":"macro"},{"location":"api/catalyst_api/#Catalyst.Reaction","page":"Catalyst.jl API","title":"Catalyst.Reaction","text":"struct Reaction{S, T}\n\nOne chemical reaction.\n\nFields\n\nrate\nThe rate function (excluding mass action terms).\nsubstrates\nReaction substrates.\nproducts\nReaction products.\nsubstoich\nThe stoichiometric coefficients of the reactants.\nprodstoich\nThe stoichiometric coefficients of the products.\nnetstoich\nThe net stoichiometric coefficients of all species changed by the reaction.\nonly_use_rate\nfalse (default) if rate should be multiplied by mass action terms to give the rate law. true if rate represents the full reaction rate law.\n\nExamples\n\nusing Catalyst\n@parameters k[1:20]\n@variables t A(t) B(t) C(t) D(t)\nrxs = [Reaction(k[1], nothing, [A]),            # 0 -> A\n       Reaction(k[2], [B], nothing),            # B -> 0\n       Reaction(k[3],[A],[C]),                  # A -> C\n       Reaction(k[4], [C], [A,B]),              # C -> A + B\n       Reaction(k[5], [C], [A], [1], [2]),      # C -> A + A\n       Reaction(k[6], [A,B], [C]),              # A + B -> C\n       Reaction(k[7], [B], [A], [2], [1]),      # 2B -> A\n       Reaction(k[8], [A,B], [A,C]),            # A + B -> A + C\n       Reaction(k[9], [A,B], [C,D]),            # A + B -> C + D\n       Reaction(k[10], [A], [C,D], [2], [1,1]), # 2A -> C + D\n       Reaction(k[11], [A], [A,B], [2], [1,1]), # 2A -> A + B\n       Reaction(k[12], [A,B,C], [C,D], [1,3,4], [2, 3]),          # A+3B+4C -> 2C + 3D\n       Reaction(k[13], [A,B], nothing, [3,1], nothing),           # 3A+B -> 0\n       Reaction(k[14], nothing, [A], nothing, [2]),               # 0 -> 2A\n       Reaction(k[15]*A/(2+A), [A], nothing; only_use_rate=true), # A -> 0 with custom rate\n       Reaction(k[16], [A], [B]; only_use_rate=true),             # A -> B with custom rate.\n       Reaction(k[17]*A*exp(B), [C], [D], [2], [1]),              # 2C -> D with non constant rate.\n       Reaction(k[18]*B, nothing, [B], nothing, [2]),             # 0 -> 2B with non constant rate.\n       Reaction(k[19]*t, [A], [B]),                                # A -> B with non constant rate.\n       Reaction(k[20]*t*A, [B,C], [D],[2,1],[2])                  # 2A +B -> 2C with non constant rate.\n  ]\n\nNotes:\n\nnothing can be used to indicate a reaction that has no reactants or no products. In this case the corresponding stoichiometry vector should also be set to nothing.\nThe three-argument form assumes all reactant and product stoichiometric coefficients are one.\n\n\n\n\n\n","category":"type"},{"location":"api/catalyst_api/#Catalyst.ReactionSystem","page":"Catalyst.jl API","title":"Catalyst.ReactionSystem","text":"struct ReactionSystem{U<:Union{Nothing, ModelingToolkit.AbstractSystem}, V<:Catalyst.NetworkProperties} <: AbstractTimeDependentSystem\n\nA system of chemical reactions.\n\nFields\n\neqs\nThe reactions defining the system.\niv\nIndependent variable (usually time).\nstates\nDependent (state) variables representing amount of each species. Must not contain the independent variable.\nps\nParameter variables. Must not contain the independent variable.\nvar_to_name\nMaps Symbol to corresponding variable.\nobserved\nEquations for observed variables.\nname\nThe name of the system\nsystems\nInternal sub-systems\ndefaults\nThe default values to use when initial conditions and/or parameters are not supplied in ODEProblem.\n\nconnection_type\nType of the system\nconstraints\nNon-Reaction equations that further constrain the system\nnetworkproperties\nNetworkProperties object that can be filled in by API functions. INTERNAL – not considered part of the public API.\ncombinatoric_ratelaws\nSets whether to use combinatoric scalings in rate laws. true by default.\n\nExample\n\nContinuing from the example in the Reaction definition:\n\n# simple constructor that infers species and parameters\n@named rs = ReactionSystem(rxs, t)\n\n# allows specification of species and parameters\n@named rs = ReactionSystem(rxs, t, [A,B,C,D], k)\n\nKeyword Arguments:\n\nobserved::Vector{Equation}, equations specifying observed variables.\nsystems::Vector{AbstractSystems}, vector of sub-systems. Can be ReactionSystems, ODESystems, or NonlinearSystems.\nname::Symbol, the name of the system (must be provided, or @named must be used).\ndefaults::Dict, a dictionary mapping parameters to their default values and species to their default initial values.\nchecks = true, boolean for whether to check units.\nconstraints = nothing, a NonlinearSystem or ODESystem of coupled constraint equations.\nnetworkproperties = NetworkProperties(), cache for network properties calculated via API functions.\ncombinatoric_ratelaws = true, sets the default value of combinatoric_ratelaws used in calls to convert or calling various problem types with the ReactionSystem.\nbalanced_bc_check = true, sets whether to check that BC species appearing in reactions are balanced (i.e appear as both a substrate and a product with the same stoichiometry).\n\nNotes:\n\nReactionSystems currently do rudimentary unit checking, requiring that all species have the same units, and all reactions have rate laws with units of (species units) / (time units). Unit checking can be disabled by passing the keyword argument checks=false.\n\n\n\n\n\n","category":"type"},{"location":"api/catalyst_api/#ModelingToolkit-and-Catalyst-Accessor-Functions","page":"Catalyst.jl API","title":"ModelingToolkit and Catalyst Accessor Functions","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"A ReactionSystem is an instance of a ModelingToolkit.AbstractTimeDependentSystem, and has a number of fields that can be accessed using the Catalyst API and the ModelingToolkit.jl Abstract System Interface. Below we overview these components.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"There are three basic sets of convenience accessors that will return information either from a top-level system, the top-level system and all sub-systems that are also ReactionSystems (i.e. the full reaction-network), or the top-level system, all subs-systems, and all constraint systems (i.e. the full model). To retrieve info from just a base ReactionSystem rn, ignoring sub-systems of rn, one can use the ModelingToolkit accessors (these provide direct access to the corresponding internal fields of the ReactionSystem)","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"get_states(rn) is a vector that collects all the species defined within rn.\nget_ps(rn) is a vector that collects all the parameters defined within reactions in rn.\nget_eqs(rn) is a vector that collects all the Reactions defined within rn.\nget_iv(rn) is the independent variable used in the system (usually t to represent time).\nget_systems(rn) is a vector of all sub-systems of rn.\nget_defaults(rn) is a dictionary of all the default values for parameters and species in rn.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"These are complemented by the Catalyst accessor","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"Catalyst.get_constraints(sys) is the constraint system of rn. If none is defined will return nothing.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"The preceding accessors do not allocate, directly accessing internal fields of the ReactionSystem.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"To retrieve information from the full reaction network represented by a system rn, which corresponds to information within both rn and all sub-systems of type ReactionSystem, one can call:","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"species(rn) is a vector collecting all the chemical species within the system and any sub-systems that are also ReactionSystems.\nreactionparams(rn) is a vector of all the parameters within the system and any sub-systems that are also ReactionSystems. These include all parameters that appear within some Reaction.\nreactions(rn) is a vector of all the Reactions within the system and any sub-systems that are also ReactionSystems.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"These accessors will allocate unless there are no subsystems. In the latter case they are equivalent to the corresponding get_* functions.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"Finally, as some sub-systems may be other system types, for example specifying algebraic constraints with a NonlinearSystem, it can also be convenient to collect all state variables (e.g. species and algebraic variables) and such. The following ModelingToolkit functions provide this information","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"ModelingToolkit.states(rn) returns all species and variables across the system, all sub-systems, and all constraint systems.\nModelingToolkit.parameters(rn) returns all parameters across the system, all sub-systems, and all constraint systems.\nModelingToolkit.equations(rn) returns all Reactions and all Equations defined across the system, all sub-systems, and all constraint systems.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"states and parameters should be assumed to always allocate, while equations will allocate unless there are no subsystems or constraint systems. In the latter case equations is equivalent to get_eqs.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"Below we list the remainder of the Catalyst API accessor functions mentioned above.","category":"page"},{"location":"api/catalyst_api/#Basic-System-Properties","page":"Catalyst.jl API","title":"Basic System Properties","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"See Programmatic Construction of Symbolic Reaction Systems for examples and ModelingToolkit and Catalyst Accessor Functions for more details on the basic accessor functions.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"species\nreactionparams\nreactions\nnumspecies\nnumreactions\nnumreactionparams\nspeciesmap\nparamsmap\nreactionparamsmap\nCatalyst.isconstant\nCatalyst.isbc","category":"page"},{"location":"api/catalyst_api/#Catalyst.species","page":"Catalyst.jl API","title":"Catalyst.species","text":"species(network)\n\nGiven a ReactionSystem, return a vector of all species defined in the system and any subsystems that are of type ReactionSystem. To get the variables in the system and all subsystems, including non-ReactionSystem subsystems, uses states(network).\n\nNotes:\n\nIf ModelingToolkit.get_systems(network) is non-empty will allocate.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reactionparams","page":"Catalyst.jl API","title":"Catalyst.reactionparams","text":"reactionparams(network)\n\nGiven a ReactionSystem, return a vector of all parameters defined within the system and any subsystems that are of type ReactionSystem. To get the parameters in the system and all subsystems, including non-ReactionSystem subsystems, use parameters(network).\n\nNotes:\n\nIf ModelingToolkit.get_systems(network) is non-empty will allocate.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reactions","page":"Catalyst.jl API","title":"Catalyst.reactions","text":"reactions(network)\n\nGiven a ReactionSystem, return a vector of all Reactions in the system.\n\nNotes:\n\nIf ModelingToolkit.get_systems(network) is not empty, will allocate.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.numspecies","page":"Catalyst.jl API","title":"Catalyst.numspecies","text":"numspecies(network)\n\nReturn the total number of species within the given ReactionSystem and subsystems that are ReactionSystems.\n\nNotes\n\nIf there are no subsystems this will be fast.\nAs this calls species, it can be slow and will allocate if there are any subsystems.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.numreactions","page":"Catalyst.jl API","title":"Catalyst.numreactions","text":"numreactions(network)\n\nReturn the total number of reactions within the given ReactionSystem and subsystems that are ReactionSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.numreactionparams","page":"Catalyst.jl API","title":"Catalyst.numreactionparams","text":"numreactionparams(network)\n\nReturn the total number of parameters within the given ReactionSystem and subsystems that are ReactionSystems.\n\nNotes\n\nIf there are no subsystems this will be fast.\nAs this calls reactionparams, it can be slow and will allocate if there are any subsystems.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.speciesmap","page":"Catalyst.jl API","title":"Catalyst.speciesmap","text":"speciesmap(network)\n\nGiven a ReactionSystem, return a Dictionary mapping species that participate in Reactions to their index within species(network).\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.paramsmap","page":"Catalyst.jl API","title":"Catalyst.paramsmap","text":"paramsmap(network)\n\nGiven a ReactionSystem, return a Dictionary mapping from all parameters that appear within the system to their index within parameters(network).\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reactionparamsmap","page":"Catalyst.jl API","title":"Catalyst.reactionparamsmap","text":"reactionparamsmap(network)\n\nGiven a ReactionSystem, return a Dictionary mapping from parameters that appear within Reactions to their index within reactionparams(network).\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.isconstant","page":"Catalyst.jl API","title":"Catalyst.isconstant","text":"Catalyst.isconstant(s)\n\nTests if the given symbolic variable corresponds to a constant species.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.isbc","page":"Catalyst.jl API","title":"Catalyst.isbc","text":"Catalyst.isbc(s)\n\nTests if the given symbolic variable corresponds to a boundary condition species.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Basic-Reaction-Properties","page":"Catalyst.jl API","title":"Basic Reaction Properties","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"ismassaction\ndependents\ndependants\nsubstoichmat\nprodstoichmat\nnetstoichmat\nreactionrates","category":"page"},{"location":"api/catalyst_api/#Catalyst.ismassaction","page":"Catalyst.jl API","title":"Catalyst.ismassaction","text":"ismassaction(rx, rs; rxvars = get_variables(rx.rate),\n                              haveivdep = any(var -> isequal(get_iv(rs),var), rxvars),\n                              stateset = Set(states(rs)))\n\nTrue if a given reaction is of mass action form, i.e. rx.rate does not depend on any chemical species that correspond to states of the system, and does not depend explicitly on the independent variable (usually time).\n\nArguments\n\nrx, the Reaction.\nrs, a ReactionSystem containing the reaction.\nOptional: rxvars, Variables which are not in rxvars are ignored as possible dependencies.\nOptional: haveivdep, true if the Reaction rate field explicitly depends on the independent variable.\nOptional: stateset, set of states which if the rxvars are within mean rx is non-mass action.\n\nNotes:\n\nNon-integer stoichiometry is treated as non-mass action. This includes symbolic variables/terms or floating point numbers for stoichiometric coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.dependents","page":"Catalyst.jl API","title":"Catalyst.dependents","text":"dependents(rx, network)\n\nGiven a Reaction and a ReactionSystem, return a vector of the non-constant species the reaction rate law depends on. e.g., for\n\nk*W, 2X + 3Y --> 5Z + W\n\nthe returned vector would be [W(t),X(t),Y(t)].\n\nNotes:\n\nAllocates\nDoes not check for dependents within any subsystems.\nConstant species are not considered dependents since they are internally treated as parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.dependants","page":"Catalyst.jl API","title":"Catalyst.dependants","text":"dependents(rx, network)\n\nSee documentation for dependents.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.substoichmat","page":"Catalyst.jl API","title":"Catalyst.substoichmat","text":"substoichmat(rn; sparse=false)\n\nReturns the substrate stoichiometry matrix, S, with S_i j the stoichiometric coefficient of the ith substrate within the jth reaction.\n\nNote:\n\nSet sparse=true for a sparse matrix representation\nNote that constant species are not considered substrates, but just components that modify the associated rate law.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.prodstoichmat","page":"Catalyst.jl API","title":"Catalyst.prodstoichmat","text":"prodstoichmat(rn; sparse=false)\n\nReturns the product stoichiometry matrix, P, with P_i j the stoichiometric coefficient of the ith product within the jth reaction.\n\nNote:\n\nSet sparse=true for a sparse matrix representation\nNote that constant species are not treated as products, but just components that modify the associated rate law.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.netstoichmat","page":"Catalyst.jl API","title":"Catalyst.netstoichmat","text":"netstoichmat(rn, sparse=false)\n\nReturns the net stoichiometry matrix, N, with N_i j the net stoichiometric coefficient of the ith species within the jth reaction.\n\nNotes:\n\nSet sparse=true for a sparse matrix representation\nCaches the matrix internally within rn so subsequent calls are fast.\nNote that constant species are not treated as reactants, but just components that modify the associated rate law. As such they do not contribute to the net stoichiometry matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reactionrates","page":"Catalyst.jl API","title":"Catalyst.reactionrates","text":"reactionrates(network)\n\nGiven a ReactionSystem, returns a vector of the symbolic reaction rates for each reaction.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Functions-to-Extend-or-Modify-a-Network","page":"Catalyst.jl API","title":"Functions to Extend or Modify a Network","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"ReactionSystems can be programmatically extended using addspecies!, addparam!, addreaction!, @add_reactions, or composed using ModelingToolkit.extend and ModelingToolkit.compose.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"@add_reactions\naddspecies!\nreorder_states!\naddparam!\naddreaction!\nsetdefaults!\nModelingToolkit.extend\nModelingToolkit.compose\nCatalyst.flatten\nmerge!(network1::ReactionSystem, network2::ReactionSystem)","category":"page"},{"location":"api/catalyst_api/#Catalyst.@add_reactions","page":"Catalyst.jl API","title":"Catalyst.@add_reactions","text":"@add_reactions\n\nAdds the reactions declared to a preexisting ReactionSystem. All parameters used in the added reactions need to be declared after the reactions.\n\nSee the Catalyst.jl for Reaction Network Modeling documentation for details on parameters to the macro.\n\n\n\n\n\n","category":"macro"},{"location":"api/catalyst_api/#Catalyst.addspecies!","page":"Catalyst.jl API","title":"Catalyst.addspecies!","text":"addspecies!(network::ReactionSystem, s::Symbolic; disablechecks=false)\n\nGiven a ReactionSystem, add the species corresponding to the variable s to the network (if it is not already defined). Returns the integer id of the species within the system.\n\nNotes:\n\ndisablechecks will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. Do not disable checks unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.\n\n\n\n\n\naddspecies!(network::ReactionSystem, s::Num; disablechecks=false)\n\nGiven a ReactionSystem, add the species corresponding to the variable s to the network (if it is not already defined). Returns the integer id of the species within the system.\n\ndisablechecks will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. Do not disable checks unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reorder_states!","page":"Catalyst.jl API","title":"Catalyst.reorder_states!","text":"reorder_states!(rn, neworder)\n\nGiven a ReactionSystem and a vector neworder, orders the states of rn accordingly to neworder.\n\nNotes:\n\nCurrently only supports ReactionSystems without constraints or subsystems.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.addparam!","page":"Catalyst.jl API","title":"Catalyst.addparam!","text":"addparam!(network::ReactionSystem, p::Symbolic; disablechecks=false)\n\nGiven a ReactionSystem, add the parameter corresponding to the variable p to the network (if it is not already defined). Returns the integer id of the parameter within the system.\n\ndisablechecks will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. Do not disable checks unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.\n\n\n\n\n\naddparam!(network::ReactionSystem, p::Num; disablechecks=false)\n\nGiven a ReactionSystem, add the parameter corresponding to the variable p to the network (if it is not already defined). Returns the integer id of the parameter within the system.\n\ndisablechecks will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. Do not disable checks unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.addreaction!","page":"Catalyst.jl API","title":"Catalyst.addreaction!","text":"addreaction!(network::ReactionSystem, rx::Reaction)\n\nAdd the passed in reaction to the ReactionSystem. Returns the integer id of rx in the list of Reactions within network.\n\nNotes:\n\nAny new species or parameters used in rx should be separately added to   network using addspecies! and addparam!.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.setdefaults!","page":"Catalyst.jl API","title":"Catalyst.setdefaults!","text":"setdefaults!(rn, newdefs)\n\nSets the default (initial) values of parameters and species in the ReactionSystem, rn.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend β ν\nsetdefaults!(sir, [:S => 999.0, :I => 1.0, :R => 1.0, :β => 1e-4, :ν => .01])\n\n# or\n@parameter β ν\n@variables t S(t) I(t) R(t)\nsetdefaults!(sir, [S => 999.0, I => 1.0, R => 0.0, β => 1e-4, ν => .01])\n\ngives initial/default values to each of S, I and β\n\nNotes:\n\nCan not be used to set default values for species, variables or parameters of subsystems or constraint systems. Either set defaults for those systems directly, or flatten to collate them into one system before setting defaults.\nDefaults can be specified in any iterable container of symbols to value pairs or symbolics to value pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#ModelingToolkit.extend","page":"Catalyst.jl API","title":"ModelingToolkit.extend","text":"extend(sys::ModelingToolkit.AbstractSystem, basesys::ModelingToolkit.AbstractSystem; name) -> ReactionSystem\n\n\nextend the basesys with sys, the resulting system would inherit sys's name by default.\n\n\n\n\n\nModelingToolkit.extend(sys::Union{NonlinearSystem,ODESystem}, rs::ReactionSystem; name::Symbol=nameof(sys))\n\nExtends the indicated ReactionSystem with a ModelingToolkit.NonlinearSystem or ModelingToolkit.ODESystem, which will be stored internally as constraint equations.\n\nNotes:\n\nReturns a new ReactionSystem and does not modify rs.\nBy default, the new ReactionSystem will have the same name as sys.\n\n\n\n\n\nModelingToolkit.extend(sys::ReactionSystem, rs::ReactionSystem; name::Symbol=nameof(sys))\n\nExtends the indicated ReactionSystem with another ReactionSystem. Similar to calling merge! except constraint systems are allowed (and will also be merged together).\n\nNotes:\n\nReturns a new ReactionSystem and does not modify rs.\nBy default, the new ReactionSystem will have the same name as sys.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#ModelingToolkit.compose","page":"Catalyst.jl API","title":"ModelingToolkit.compose","text":"compose(sys, systems; name)\n\n\ncompose multiple systems together. The resulting system would inherit the first system's name.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#ModelingToolkit.flatten","page":"Catalyst.jl API","title":"ModelingToolkit.flatten","text":"Catalyst.flatten(rs::ReactionSystem)\n\nMerges all subsystems of the given ReactionSystem up into rs.\n\nNotes:\n\nReturns a new ReactionSystem that represents the flattened system.\nAll Reactions within subsystems are namespaced and merged into the list of Reactions of rs. The merged list is then available as reactions(rs) or get_eqs(rs).\nAll algebraic equations are merged into a NonlinearSystem or ODESystem stored as get_constraints(rs). If get_constraints !== nothing then the algebraic equations are merged with the current constraints in a system of the same type as the current constraints, otherwise the new constraint system is an ODESystem.\nCurrently only ReactionSystems, NonlinearSystems and ODESystems are supported as sub-systems when flattening.\nrs.networkproperties is reset upon flattening.\nThe default value of combinatoric_ratelaws will be the logical or of all ReactionSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Base.merge!-Tuple{ReactionSystem, ReactionSystem}","page":"Catalyst.jl API","title":"Base.merge!","text":"merge!(network1::ReactionSystem, network2::ReactionSystem)\n\nMerge network2 into network1.\n\nNotes:\n\nDuplicate reactions between the two networks are not filtered out.\nReactions are not deepcopied to minimize allocations, so both networks will share underlying data arrays.\nSubsystems are not deepcopied between the two networks and will hence be shared.\nReturns network1.\ncombinatoric_ratelaws is the value of network1.\n\n\n\n\n\n","category":"method"},{"location":"api/catalyst_api/#Network-Analysis-and-Representations","page":"Catalyst.jl API","title":"Network Analysis and Representations","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"Note, currently API functions for network analysis and conservation law analysis do not work with constant species (currently only generated by SBMLToolkit).","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"conservationlaws\nconservedquantities\nconservedequations\nconservationlaw_constants\nReactionComplexElement\nReactionComplex\nreactioncomplexmap\nreactioncomplexes\nincidencemat\ncomplexstoichmat\ncomplexoutgoingmat\nincidencematgraph\nlinkageclasses\ndeficiency\nsubnetworks\nlinkagedeficiencies\nisreversible\nisweaklyreversible\nreset_networkproperties!","category":"page"},{"location":"api/catalyst_api/#Catalyst.conservationlaws","page":"Catalyst.jl API","title":"Catalyst.conservationlaws","text":"conservationlaws(netstoichmat::AbstractMatrix)::Matrix\n\nGiven the net stoichiometry matrix of a reaction system, computes a matrix of conservation laws, each represented as a row in the output.\n\n\n\n\n\nconservationlaws(rs::ReactionSystem)\n\nReturn the conservation law matrix of the given ReactionSystem, calculating it if it is not already stored within the system, or returning an alias to it.\n\nNotes:\n\nThe first time being called it is calculated and cached in rn, subsequent calls should be fast.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.conservedquantities","page":"Catalyst.jl API","title":"Catalyst.conservedquantities","text":"conservedquantities(state, cons_laws)\n\nCompute conserved quantities for a system with the given conservation laws.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.conservedequations","page":"Catalyst.jl API","title":"Catalyst.conservedequations","text":"conservedequations(rn::ReactionSystem)\n\nCalculate symbolic equations from conservation laws, writing dependent variables as functions of independent variables and the conservation law constants.\n\nNotes:\n\nCaches the resulting equations in rn, so will be fast on subsequent calls.\n\nExamples:\n\nrn = @reaction_network begin\n    k, A + B --> C\n    k2, C --> A + B\n    end k k2\nconservedequations(rn)\n\ngives\n\n2-element Vector{Equation}:\n B(t) ~ A(t) + _ConLaw[1]\n C(t) ~ _ConLaw[2] - A(t)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.conservationlaw_constants","page":"Catalyst.jl API","title":"Catalyst.conservationlaw_constants","text":"conservationlaw_constants(rn::ReactionSystem)\n\nCalculate symbolic equations from conservation laws, writing the conservation law constants in terms of the dependent and independent variables.\n\nNotes:\n\nCaches the resulting equations in rn, so will be fast on subsequent calls.\n\nExamples:\n\nrn = @reaction_network begin\n    k, A + B --> C\n    k2, C --> A + B\n    end k k2\nconservationlaw_constants(rn)\n\ngives\n\n2-element Vector{Equation}:\n _ConLaw[1] ~ B(t) - A(t)\n _ConLaw[2] ~ A(t) + C(t)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.ReactionComplexElement","page":"Catalyst.jl API","title":"Catalyst.ReactionComplexElement","text":"struct ReactionComplexElement{T}\n\nOne reaction complex element\n\nFields\n\nspeciesid\nThe integer id of the species representing this element.\nspeciesstoich\nThe stoichiometric coefficient of this species.\n\n\n\n\n\n","category":"type"},{"location":"api/catalyst_api/#Catalyst.ReactionComplex","page":"Catalyst.jl API","title":"Catalyst.ReactionComplex","text":"struct ReactionComplex{V<:Integer} <: AbstractArray{Catalyst.ReactionComplexElement{V<:Integer}, 1}\n\nOne reaction complex.\n\nFields\n\nspeciesids\nThe integer ids of all species participating in this complex.\nspeciesstoichs\nThe stoichiometric coefficients of all species participating in this complex.\n\n\n\n\n\n","category":"type"},{"location":"api/catalyst_api/#Catalyst.reactioncomplexmap","page":"Catalyst.jl API","title":"Catalyst.reactioncomplexmap","text":"reactioncomplexmap(rn::ReactionSystem)\n\nFind each ReactionComplex within the specified system, constructing a mapping from the complex to vectors that indicate which reactions it appears in as substrates and products.\n\nNotes:\n\nEach ReactionComplex is mapped to a vector of pairs, with each pair having the form reactionidx => ± 1, where -1 indicates the complex appears as a substrate and +1 as a product in the reaction with integer label reactionidx.\nConstant species are ignored as part of a complex. i.e. if species A is constant then the reaction A + B --> C + D is considered to consist of the complexes B and C + D. Likewise A --> B would be treated as the same as 0 --> B.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reactioncomplexes","page":"Catalyst.jl API","title":"Catalyst.reactioncomplexes","text":"reactioncomplexes(network::ReactionSystem; sparse=false)\n\nCalculate the reaction complexes and complex incidence matrix for the given ReactionSystem.\n\nNotes:\n\nreturns a pair of a vector of ReactionComplexs and the complex incidence matrix.\nAn empty ReactionComplex denotes the null (∅) state (from reactions like ∅ -> A or A -> ∅).\nConstant species are ignored in generating a reaction complex. i.e. if A is constant then A –> B consists of the complexes ∅ and B.\nThe complex incidence matrix, B, is number of complexes by number of reactions with\n\nB_i j = begincases\n-1 textif the ith complex is the substrate of the jth reaction\n1 textif the ith complex is the product of the jth reaction\n0 textotherwise\nendcases\n\nSet sparse=true for a sparse matrix representation of the incidence matrix\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.incidencemat","page":"Catalyst.jl API","title":"Catalyst.incidencemat","text":"incidencemat(rn::ReactionSystem; sparse=false)\n\nCalculate the incidence matrix of rn, see reactioncomplexes.\n\nNotes:\n\nIs cached in rn so that future calls, assuming the same sparsity, will also be fast.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.complexstoichmat","page":"Catalyst.jl API","title":"Catalyst.complexstoichmat","text":"complexstoichmat(network::ReactionSystem; sparse=false)\n\nGiven a ReactionSystem and vector of reaction complexes, return a matrix with positive entries of size number of species by number of complexes, where the non-zero positive entries in the kth column denote stoichiometric coefficients of the species participating in the kth reaction complex.\n\nNotes:\n\nSet sparse=true for a sparse matrix representation\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.complexoutgoingmat","page":"Catalyst.jl API","title":"Catalyst.complexoutgoingmat","text":"complexoutgoingmat(network::ReactionSystem; sparse=false)\n\nGiven a ReactionSystem and complex incidence matrix, B, return a matrix of size num of complexes by num of reactions that identifies substrate complexes.\n\nNotes:\n\nThe complex outgoing matrix, Delta, is defined by\n\nDelta_i j = begincases\n    = 0    textif  B_i j = 1 \n    = B_i j textotherwise\nendcases\n\nSet sparse=true for a sparse matrix representation\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.incidencematgraph","page":"Catalyst.jl API","title":"Catalyst.incidencematgraph","text":"incidencematgraph(rn::ReactionSystem)\n\nConstruct a directed simple graph where nodes correspond to reaction complexes and directed edges to reactions converting between two complexes.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend β ν\ncomplexes,incidencemat = reactioncomplexes(sir)\nincidencematgraph(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.linkageclasses","page":"Catalyst.jl API","title":"Catalyst.linkageclasses","text":"linkageclasses(rn::ReactionSystem)\n\nGiven the incidence graph of a reaction network, return a vector of the connected components of the graph (i.e. sub-groups of reaction complexes that are connected in the incidence graph).\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend β ν\ncomplexes,incidencemat = reactioncomplexes(sir)\nlinkageclasses(sir)\n\ngives\n\n2-element Vector{Vector{Int64}}:\n [1, 2]\n [3, 4]\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.deficiency","page":"Catalyst.jl API","title":"Catalyst.deficiency","text":"deficiency(rn::ReactionSystem)\n\nCalculate the deficiency of a reaction network.\n\nHere the deficiency, delta, of a network with n reaction complexes, ell linkage classes and a rank s stoichiometric matrix is\n\ndelta = n - ell - s\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend β ν\nrcs,incidencemat = reactioncomplexes(sir)\nδ = deficiency(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.subnetworks","page":"Catalyst.jl API","title":"Catalyst.subnetworks","text":"subnetworks(rn::ReactionSystem)\n\nFind subnetworks corresponding to each linkage class of the reaction network.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend β ν\ncomplexes,incidencemat = reactioncomplexes(sir)\nsubnetworks(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.linkagedeficiencies","page":"Catalyst.jl API","title":"Catalyst.linkagedeficiencies","text":"linkagedeficiencies(network::ReactionSystem)\n\nCalculates the deficiency of each sub-reaction network within network.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend β ν\nrcs,incidencemat = reactioncomplexes(sir)\nlinkage_deficiencies = linkagedeficiencies(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.isreversible","page":"Catalyst.jl API","title":"Catalyst.isreversible","text":"isreversible(rn::ReactionSystem)\n\nGiven a reaction network, returns if the network is reversible or not.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend β ν\nrcs,incidencemat = reactioncomplexes(sir)\nisreversible(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.isweaklyreversible","page":"Catalyst.jl API","title":"Catalyst.isweaklyreversible","text":"isweaklyreversible(rn::ReactionSystem, subnetworks)\n\nDetermine if the reaction network with the given subnetworks is weakly reversible or not.\n\nNotes:\n\nRequires the incidencemat to already be cached in rn by a previous call to reactioncomplexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend β ν\nrcs,incidencemat = reactioncomplexes(sir)\nsubnets = subnetworks(rn)\nisweaklyreversible(rn, subnets)\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.reset_networkproperties!","page":"Catalyst.jl API","title":"Catalyst.reset_networkproperties!","text":"reset_networkproperties!(rn::ReactionSystem)\n\nClears the cache of various properties (like the netstoichiometry matrix). Use if such properties need to be recalculated for some reason.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Network-Comparison","page":"Catalyst.jl API","title":"Network Comparison","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"==(rn1::Reaction, rn2::Reaction)\nisequal_ignore_names\n==(rn1::ReactionSystem, rn2::ReactionSystem)","category":"page"},{"location":"api/catalyst_api/#Base.:==-Tuple{Reaction, Reaction}","page":"Catalyst.jl API","title":"Base.:==","text":"==(rx1::Reaction, rx2::Reaction)\n\nTests whether two Reactions are identical.\n\nNotes:\n\nIgnores the order in which stoichiometry components are listed.\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\n\n\n\n\n\n","category":"method"},{"location":"api/catalyst_api/#Catalyst.isequal_ignore_names","page":"Catalyst.jl API","title":"Catalyst.isequal_ignore_names","text":"isequal_ignore_names(rn1::ReactionSystem, rn2::ReactionSystem)\n\nTests whether the underlying species, parameters and reactions are the same in the two ReactionSystems. Ignores the names of the systems in testing equality.\n\nNotes:\n\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\nDoes not include defaults in determining equality.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Base.:==-Tuple{ReactionSystem, ReactionSystem}","page":"Catalyst.jl API","title":"Base.:==","text":"==(rn1::ReactionSystem, rn2::ReactionSystem)\n\nTests whether the underlying species, parameters and reactions are the same in the two ReactionSystems. Requires the systems to have the same names too.\n\nNotes:\n\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\nDoes not include defaults in determining equality.\n\n\n\n\n\n","category":"method"},{"location":"api/catalyst_api/#Network-Visualization","page":"Catalyst.jl API","title":"Network Visualization","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"Latexify can be used to convert networks to LaTeX mhchem equations by","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"using Latexify\nlatexify(rn)","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"If Graphviz is installed and commandline accessible, it can be used to create and save network diagrams using Graph and savegraph.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"Graph\ncomplexgraph\nsavegraph","category":"page"},{"location":"api/catalyst_api/#Catalyst.Graph","page":"Catalyst.jl API","title":"Catalyst.Graph","text":"Graph(rn::ReactionSystem)\n\nConverts a ReactionSystem into a Graphviz graph. Reactions correspond to small green circles, and species to blue circles.\n\nNotes:\n\nBlack arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry.\nBlack arrows from reactions to species indicate products, and are labelled with their output stoichiometry.\nRed arrows from species to reactions indicate that species is used within the rate expression. For example, in the reaction k*A, B --> C, there would be a red arrow from A to the reaction node. In k*A, A+B --> C, there would be red and black arrows from A to the reaction node.\nRequires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"type"},{"location":"api/catalyst_api/#Catalyst.complexgraph","page":"Catalyst.jl API","title":"Catalyst.complexgraph","text":"complexgraph(rn::ReactionSystem; complexdata=reactioncomplexes(rn))\n\nCreates a Graphviz graph of the ReactionComplexs in rn. Reactions correspond to arrows and reaction complexes to blue circles. \n\nNotes:\n\nBlack arrows from complexes to complexes indicate reactions whose rate is a parameter or a Number. i.e. k, A --> B.\nRed dashed arrows from complexes to complexes indicate reactions whose rate depends on species. i.e. k*C, A --> B for C a species.\nRequires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.savegraph","page":"Catalyst.jl API","title":"Catalyst.savegraph","text":"savegraph(g::Graph, fname, fmt=\"png\")\n\nGiven a Graph generated by Graph, save the graph to the file with name fname and extension fmt.\n\nNotes:\n\nfmt=\"png\" is the default output format.\nRequires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Rate-Laws","page":"Catalyst.jl API","title":"Rate Laws","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"As the underlying ReactionSystem is comprised of ModelingToolkit expressions, one can directly access the generated rate laws, and using ModelingToolkit tooling generate functions or Julia Exprs from them.","category":"page"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"oderatelaw\njumpratelaw\nmm\nmmr\nhill\nhillr\nhillar","category":"page"},{"location":"api/catalyst_api/#Catalyst.oderatelaw","page":"Catalyst.jl API","title":"Catalyst.oderatelaw","text":"oderatelaw(rx; combinatoric_ratelaw=true)\n\nGiven a Reaction, return the symbolic reaction rate law used in generated ODEs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X(t)^2*Y(t)*Z(t). For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe expression that is returned will be k * (X(t)^2/2) * (Y(t)^3/6).\n\nNotes:\n\nAllocates\ncombinatoric_ratelaw=true uses factorial scaling factors in calculating the   rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If   combinatoric_ratelaw=false then the ratelaw is k*S^2, i.e. the scaling   factor is ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.jumpratelaw","page":"Catalyst.jl API","title":"Catalyst.jumpratelaw","text":"jumpratelaw(rx; combinatoric_ratelaw=true)\n\nGiven a Reaction, return the symbolic reaction rate law used in generated stochastic chemical kinetics model SSAs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X^2*Y*Z. For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe expression that is returned will be k * binomial(X,2) * binomial(Y,3).\n\nNotes:\n\nAllocates\ncombinatoric_ratelaw=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaw=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.mm","page":"Catalyst.jl API","title":"Catalyst.mm","text":"mm(X,v,K) = v*X / (X + K)\n\nA Michaelis-Menten rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.mmr","page":"Catalyst.jl API","title":"Catalyst.mmr","text":"mmr(X,v,K) = v*K / (X + K)\n\nA repressive Michaelis-Menten rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.hill","page":"Catalyst.jl API","title":"Catalyst.hill","text":"hill(X,v,K,n) = v*(X^n) / (X^n + K^n)\n\nA Hill rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.hillr","page":"Catalyst.jl API","title":"Catalyst.hillr","text":"hillr(X,v,K,n) = v*(K^n) / (X^n + K^n)\n\nA repressive Hill rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Catalyst.hillar","page":"Catalyst.jl API","title":"Catalyst.hillar","text":"hillar(X,Y,v,K,n) = v*(X^n) / (X^n + Y^n + K^n)\n\nAn activation/repressing Hill rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Transformations","page":"Catalyst.jl API","title":"Transformations","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"Base.convert\nModelingToolkit.structural_simplify","category":"page"},{"location":"api/catalyst_api/#Base.convert","page":"Catalyst.jl API","title":"Base.convert","text":"Base.convert(::Type{<:ODESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ModelingToolkit.ODESystem.\n\nKeyword args and default values:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. Set combinatoric_ratelaws=false for a ratelaw of k*S^2, i.e. the scaling factor is ignored. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nremove_conserved=false, if set to true will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.\n\n\n\n\n\nBase.convert(::Type{<:NonlinearSystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ModelingToolkit.NonlinearSystem.\n\nKeyword args and default values:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. Set combinatoric_ratelaws=false for a ratelaw of k*S^2, i.e. the scaling factor is ignored. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nremove_conserved=false, if set to true will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.\n\n\n\n\n\nBase.convert(::Type{<:SDESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ModelingToolkit.SDESystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. Set combinatoric_ratelaws=false for a ratelaw of k*S^2, i.e. the scaling factor is ignored. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nnoise_scaling=nothing::Union{Vector{Num},Num,Nothing} allows for linear scaling of the noise in the chemical Langevin equations. If nothing is given, the default value as in Gillespie 2000 is used. Alternatively, a Num can be given, this is added as a parameter to the system (at the end of the parameter array). All noise terms are linearly scaled with this value. The parameter may be one already declared in the ReactionSystem. Finally, a Vector{Num} can be provided (the length must be equal to the number of reactions). Here the noise for each reaction is scaled by the corresponding parameter in the input vector. This input may contain repeat parameters.\nremove_conserved=false, if set to true will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.\n\n\n\n\n\nBase.convert(::Type{<:JumpSystem},rs::ReactionSystem; combinatoric_ratelaws=true)\n\nConvert a ReactionSystem to an ModelingToolkit.JumpSystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaws=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#ModelingToolkit.structural_simplify","page":"Catalyst.jl API","title":"ModelingToolkit.structural_simplify","text":"structural_simplify(sys)\nstructural_simplify(sys, io; simplify, kwargs...)\n\n\nStructurally simplify algebraic equations in a system and compute the topological sort of the observed equations. When simplify=true, the simplify function will be applied during the tearing process. It also takes kwargs allow_symbolic=false and allow_parameter=true which limits the coefficient types during tearing.\n\nThe optional argument io may take a tuple (inputs, outputs). This will convert all inputs to parameters and allow them to be unconnected, i.e., simplification will allow models where n_states = n_equations - n_inputs.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Unit-Validation","page":"Catalyst.jl API","title":"Unit Validation","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"validate(rx::Reaction; info::String = \"\")\nvalidate(rs::ReactionSystem, info::String=\"\")","category":"page"},{"location":"api/catalyst_api/#ModelingToolkit.validate-Tuple{Reaction}","page":"Catalyst.jl API","title":"ModelingToolkit.validate","text":"validate(rx::Reaction; info::String = \"\")\n\nCheck that all substrates and products within the given Reaction have the same units, and that the units of the reaction's rate expression are internally consistent (i.e. if the rate involves sums, each term in the sum has the same units).\n\n\n\n\n\n","category":"method"},{"location":"api/catalyst_api/#ModelingToolkit.validate","page":"Catalyst.jl API","title":"ModelingToolkit.validate","text":"validate(rs::ReactionSystem, info::String=\"\")\n\nCheck that all species in the ReactionSystem have the same units, and that the rate laws of all reactions reduce to units of (species units) / (time units).\n\nNotes:\n\nDoes not check subsystems too.\n\n\n\n\n\n","category":"function"},{"location":"api/catalyst_api/#Utility-Functions","page":"Catalyst.jl API","title":"Utility Functions","text":"","category":"section"},{"location":"api/catalyst_api/","page":"Catalyst.jl API","title":"Catalyst.jl API","text":"symmap_to_varmap","category":"page"},{"location":"api/catalyst_api/#Catalyst.symmap_to_varmap","page":"Catalyst.jl API","title":"Catalyst.symmap_to_varmap","text":"symmap_to_varmap(sys, symmap)\n\nGiven a system and map of Symbols to values, generates a map from corresponding symbolic variables/parameters to the values that can be used to pass initial conditions and parameter mappings.\n\nFor example,\n\nsir = @reaction_network sir begin\n    β, S + I --> 2I\n    ν, I --> R\nend β ν\nsubsys = @reaction_network subsys begin\n    k, A --> B\nend k\n@named sys = compose(sir, [subsys])\n\ngives\n\nModel sys with 3 equations\nStates (5):\n  S(t)\n  I(t)\n  R(t)\n  subsys₊A(t)\n  subsys₊B(t)\nParameters (3):\n  β\n  ν\n  subsys₊k\n\nto specify initial condition and parameter mappings from symbols we can use\n\nsymmap = [:S => 1.0, :I => 1.0, :R => 1.0, :subsys₊A => 1.0, :subsys₊B => 1.0]\nu0map  = symmap_to_varmap(sys, symmap)\npmap   = symmap_to_varmap(sys, [:β => 1.0, :ν => 1.0, :subsys₊k => 1.0])\n\nu0map and pmap can then be used as input to various problem types.\n\nNotes:\n\nAny Symbol, sym, within symmap must be a valid field of sys. i.e. sys.sym must be defined.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/bifurcation_diagram/#Bifurcation-Diagrams","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"","category":"section"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Bifurcation diagrams can be produced from Catalyst generated models through the use of the BifurcationKit.jl package. This tutorial gives a simple example of how to create such a bifurcation diagram.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"First, we declare our reaction model. For this example we will use a bistable switch, but one which also contains a Hopf bifurcation.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using Catalyst\nrn = @reaction_network begin\n    (v0 + v*(S * X)^n / ((S*X)^n + (D*A)^n + K^n), d), ∅ ↔ X\n    (X/τ, 1/τ), ∅ ↔ A\nend S D τ v0 v K n d","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Next, we specify the system parameters for which we wish to plot the bifurcation diagram. We also set the parameter we wish to vary in our bifurcation diagram, as well as the interval to vary it over. Finally, we set which variable we wish to plot the steady state values of in the bifurcation plot.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"p = Dict(:S => 1., :D => 9., :τ => 1000., :v0 => 0.01,\n         :v => 2., :K => 20., :n => 3, :d => 0.05)\nbif_par = :S           # bifurcation parameter\np_span = (0.1, 20.)    # interval to vary S over\nplot_var = :X          # we will plot X vs S","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"When creating a bifurcation diagram, we typically start at some point in parameter phase-space. We will simply select the beginning of the interval over which we wish to compute the bifurcation diagram, p_span[1]. We thus create a modified parameter set where S = .1. For this parameter set, we also make a guess for the steady-state of the system. While a good estimate could be provided through an ODE simulation, BifurcationKit does not require the guess to be very accurate.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"p_bstart = copy(p)\np_bstart[bif_par] = p_span[1]\nu0 = [:X => 1.0, :A => 1.0]","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Finally, we extract the ODE derivative function and its jacobian in a form that BifurcationKit can use:","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"oprob = ODEProblem(rn, u0, (0.0,0.0), p_bstart; jac = true)\nF = (u,p) -> oprob.f(u, p, 0)\nJ = (u,p) -> oprob.f.jac(u, p, 0)","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"In creating an ODEProblem an ordering is chosen for the initial condition and parameters, and regular Float64 vectors of their numerical values are created as oprob.u0 and oprob.p respectively. BifurcationKit needs to know the index in oprob.p of our bifurcation parameter, :S, and the index in oprob.u0 of the variable we wish to plot, :X. We calculate these as","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"# get S and X as a symbolic variables\n@unpack S, X = rn\n\n# find their indices in oprob.p and oprob.u0 respectively\nbif_idx  = findfirst(isequal(S), parameters(rn))\nplot_idx = findfirst(isequal(X), species(rn))","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Now, we load the required packages to create and plot the bifurcation diagram. We also bundle the information we have compiled so far into a BifurcationProblem.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using BifurcationKit, Plots, LinearAlgebra, Setfield\n\nbprob = BifurcationProblem(F, oprob.u0, oprob.p, (@lens _[bif_idx]);\n                           recordFromSolution = (x, p) -> x[plot_idx], J = J)","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Next, we need to specify the input options for the pseudo-arclength continuation method (PACM) which produces the diagram.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"bopts = ContinuationPar(dsmax = 0.05,          # Max arclength in PACM.\n                        dsmin = 1e-4,          # Min arclength in PACM.\n                        ds=0.001,              # Initial (positive) arclength in PACM.\n                        maxSteps = 100000,     # Max number of steps.\n                        pMin = p_span[1],      # Min p-val (if hit, the method stops).\n                        pMax = p_span[2],      # Max p-val (if hit, the method stops).\n                        detectBifurcation = 3) # Value in {0,1,2,3}","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Here detectBifurcation determines to what extent bifurcation points are detected and how accurately their values are determined. Three indicates to use the most accurate method for calculating their values.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"We are now ready to compute the bifurcation diagram:","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"bf = bifurcationdiagram(bprob, PALC(), 2, (args...) -> bopts)","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Finally, we can plot it:","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"plot(bf, xlabel = string(bif_par), ylabel = string(plot_var))","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Here, the Hopf bifurcation is marked with a red dot and the fold bifurcations with blue dots. The region with a thinner line width corresponds to unstable steady states.","category":"page"},{"location":"tutorials/bifurcation_diagram/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"This tutorial demonstrated how to make a simple bifurcation diagram where all branches are connected. However, BifurcationKit.jl is a very powerful package capable of a lot more. For more details, please see that package's documentation: BifurcationKit.jl.","category":"page"},{"location":"tutorials/generating_reactions_programmatically/#Smoluchowski-Coagulation-Equation","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"","category":"section"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"This tutorial shows how to programmatically construct a ReactionSystem corresponding to the chemistry underlying the Smoluchowski coagulation model using ModelingToolkit/Catalyst. A jump process version of the model is then constructed from the ReactionSystem, and compared to the model's analytical solution obtained by the method of Scott (see also 3).","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"The Smoluchowski coagulation equation describes a system of reactions in which monomers may collide to form dimers, monomers and dimers may collide to form trimers, and so on. This models a variety of chemical/physical processes, including polymerization and flocculation.","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"We begin by importing some necessary packages.","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"using ModelingToolkit, Catalyst, LinearAlgebra\nusing DiffEqBase, JumpProcesses\nusing Plots, SpecialFunctions","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"Suppose the maximum cluster size is N. We assume an initial concentration of monomers, Nₒ, and let uₒ denote the initial number of monomers in the system. We have nr total reactions, and label by V the bulk volume of the system (which plays an important role in the calculation of rate laws since we have bimolecular reactions). Our basic parameters are then","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"## Parameter\nN = 10                       # maximum cluster size\nVₒ = (4π/3)*(10e-06*100)^3   # volume of a monomers in cm³\nNₒ = 1e-06/Vₒ                # initial conc. = (No. of init. monomers) / bulk volume\nuₒ = 10000                   # No. of monomers initially\nV = uₒ/Nₒ                    # Bulk volume of system in cm³\n\ninteg(x) = Int(floor(x))\nn        = integ(N/2)\nnr       = N%2 == 0 ? (n*(n + 1) - n) : (n*(n + 1)) # No. of forward reactions","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"The Smoluchowski coagulation equation Wikipedia page illustrates the set of possible reactions that can occur. We can easily enumerate the pairs of multimer reactants that can combine when allowing a maximal cluster size of N monomers. We initialize the volumes of the reactant multimers as volᵢ and volⱼ","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# possible pairs of reactant multimers\npair = []\nfor i = 2:N\n    push!(pair,[1:integ(i/2)  i .- (1:integ(i/2))])\nend\npair = vcat(pair...)\nvᵢ = @view pair[:,1]   # Reactant 1 indices\nvⱼ = @view pair[:,2]   # Reactant 2 indices\nvolᵢ = Vₒ*vᵢ           # cm⁻³\nvolⱼ = Vₒ*vⱼ           # cm⁻³\nsum_vᵢvⱼ = @. vᵢ + vⱼ  # Product index","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"We next specify the rates (i.e. kernel) at which reactants collide to form products. For simplicity, we allow a user-selected additive kernel or constant kernel. The constants(B and C) are adopted from Scott's paper 2","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# set i to  1 for additive kernel, 2  for constant\ni = 1\nif i==1\n    B = 1.53e03                # s⁻¹\n    kv = @. B*(volᵢ + volⱼ)/V  # dividing by volume as its a bi-molecular reaction chain\nelseif i==2\n    C = 1.84e-04               # cm³ s⁻¹\n    kv = fill(C/V, nr)\nend","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"We'll store the reaction rates in pars as Pairs, and set the initial condition that only monomers are present at t=0 in u₀map.","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# state variables are X, pars stores rate parameters for each rx\n@parameters t\n@variables k[1:nr]  X[1:N](t)\npars = Pair.(collect(k), kv)\n\n# time-span\nif i == 1\n    tspan = (0. ,2000.)\nelseif i == 2\n    tspan = (0. ,350.)\nend\n\n # initial condition of monomers\nu₀    = zeros(Int64, N)\nu₀[1] = uₒ\nu₀map = Pair.(collect(X), u₀)   # map variable to its initial value","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"Here we generate the reactions programmatically. We systematically create Catalyst Reactions for each possible reaction shown in the figure on Wikipedia. When vᵢ[n] == vⱼ[n], we set the stoichiometric coefficient of the reactant multimer to two.","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# vector to store the Reactions in\nrx = []\nfor n = 1:nr\n    # for clusters of the same size, double the rate\n    if (vᵢ[n] == vⱼ[n])\n        push!(rx, Reaction(k[n], [X[vᵢ[n]]], [X[sum_vᵢvⱼ[n]]], [2], [1]))\n    else\n        push!(rx, Reaction(k[n], [X[vᵢ[n]], X[vⱼ[n]]], [X[sum_vᵢvⱼ[n]]],\n                           [1, 1], [1]))\n    end\nend\n@named rs = ReactionSystem(rx, t, collect(X), collect(k))","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"We now convert the ReactionSystem into a ModelingToolkit.JumpSystem, and solve it using Gillespie's direct method. For details on other possible solvers (SSAs), see the DifferentialEquations.jl documentation","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# solving the system\njumpsys = convert(JumpSystem, rs)\ndprob   = DiscreteProblem(jumpsys, u₀map, tspan, pars)\njprob   = JumpProblem(jumpsys, dprob, Direct(), save_positions=(false,false))\njsol    = solve(jprob, SSAStepper(), saveat = tspan[2]/30)","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"Lets check the results for the first three polymers/cluster sizes. We compare to the analytical solution for this system:","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# Results for first three polymers...i.e. monomers, dimers and trimers\nv_res = [1;2;3]\n\n# comparison with analytical solution\n# we only plot the stochastic solution at a small number of points\n# to ease distinguishing it from the exact solution\nt   = jsol.t\nsol = zeros(length(v_res), length(t))\nif i == 1\n    ϕ = @. 1 - exp(-B*Nₒ*Vₒ*t)\n    for j in v_res\n        sol[j,:] = @. Nₒ*(1 - ϕ)*(((j*ϕ)^(j-1))/gamma(j+1))*exp(-j*ϕ)\n    end\nelseif i == 2\n    ϕ = @. (C*Nₒ*t)\n    for j in v_res\n        sol[j,:] = @. 4Nₒ*((ϕ^(j-1))/((ϕ + 2)^(j+1)))\n    end\nend\n\n# plotting normalised concentration vs analytical solution\ndefault(lw=2, xlabel=\"Time (sec)\")\nscatter(ϕ, jsol(t)[1,:]/uₒ, label=\"X1 (monomers)\", markercolor=:blue)\nplot!(ϕ, sol[1,:]/Nₒ, line = (:dot,4,:blue), label=\"Analytical sol--X1\")\n\nscatter!(ϕ, jsol(t)[2,:]/uₒ, label=\"X2 (dimers)\", markercolor=:orange)\nplot!(ϕ, sol[2,:]/Nₒ, line = (:dot,4,:orange), label=\"Analytical sol--X2\")\n\nscatter!(ϕ, jsol(t)[3,:]/uₒ, label=\"X3 (trimers)\", markercolor=:purple)\nplot!(ϕ, sol[3,:]/Nₒ, line = (:dot,4,:purple), label=\"Analytical sol--X3\",\n      ylabel = \"Normalized Concentration\")","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"For the additive kernel we find","category":"page"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"(Image: additive_kernel)","category":"page"},{"location":"tutorials/generating_reactions_programmatically/#Sources","page":"Smoluchowski Coagulation Equation","title":"Sources","text":"","category":"section"},{"location":"tutorials/generating_reactions_programmatically/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"https://en.wikipedia.org/wiki/Smoluchowskicoagulationequation\nScott, W. T. (1968). Analytic Studies of Cloud Droplet Coalescence I, Journal of Atmospheric Sciences, 25(1), 54-65. Retrieved Feb 18, 2021, from https://journals.ametsoc.org/view/journals/atsc/25/1/1520-046919680250054asocdc20co2.xml\nIan J. Laurenzi, John D. Bartels, Scott L. Diamond, A General Algorithm for Exact Simulation of Multicomponent Aggregation Processes, Journal of Computational Physics, Volume 177, Issue 2, 2002, Pages 418-449, ISSN 0021-9991, https://doi.org/10.1006/jcph.2002.7017.","category":"page"},{"location":"tutorials/compositional_modeling/#Compositional-Modeling-of-Reaction-Systems","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"","category":"section"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst supports the construction of models in a compositional fashion, based on ModelingToolkit's subsystem functionality. In this tutorial we'll see how we can construct the earlier repressilator model by composing together three identically repressed genes, and how to use compositional modeling to create compartments.","category":"page"},{"location":"tutorials/compositional_modeling/#Compositional-Modeling-Tooling","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling Tooling","text":"","category":"section"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst supports two ModelingToolkit interfaces for composing multiple ReactionSystems together into a full model. The first mechanism for extending a system is the extend command","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"using Catalyst\nbasern = @reaction_network rn1 begin\n           k, A + B --> C\n         end k\nnewrn = @reaction_network rn2 begin\n        r, C --> A + B\n      end r\n@named rn = extend(newrn, basern)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Here we extended basern with newrn giving a system with all the reactions. Note, if a name is not specified via @named or the name keyword then rn will have the same name as newrn.","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"The second main compositional modeling tool is the use of subsystems. Suppose we now add to basern two subsystems, newrn and newestrn, we get a different result:","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"newestrn = @reaction_network rn3 begin\n            v, A + D --> 2D\n           end v\n@named rn = compose(basern, [newrn, newestrn])","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Here we have created a new ReactionSystem that adds newrn and newestrn as subsystems of basern. The variables and parameters in the sub-systems are considered distinct from those in other systems, and so are namespaced (i.e. prefaced) by the name of the system they come from.","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"We can see the subsystems of a given system by","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"ModelingToolkit.get_systems(rn)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"They naturally form a tree-like structure","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"using Plots, GraphRecipes\nplot(TreePlot(rn), method=:tree, fontsize=12, nodeshape=:ellipse)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"(Image: rn network with subsystems)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"We could also have directly constructed rn using the same reaction as in basern as","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"@parameters k\n@variables t, A(t), B(t), C(t)\nrxs = [Reaction(k, [A,B], [C])]\n@named rn  = ReactionSystem(rxs, t; systems = [newrn, newestrn])","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst provides several different accessors for getting information from a single system, or all systems in the tree. To get the species, parameters, and equations only within a given system (i.e. ignoring subsystems), we can use","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"ModelingToolkit.get_states(rn)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"ModelingToolkit.get_ps(rn)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"ModelingToolkit.get_eqs(rn)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"To see all the species, parameters and reactions in the tree we can use","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"species(rn)   # or states(rn)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"parameters(rn)  # or reactionparameters(rn)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"reactions(rn)   # or equations(rn)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"If we want to collapse rn down to a single system with no subsystems we can use","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"flatrn = Catalyst.flatten(rn)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"where","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"ModelingToolkit.get_systems(flatrn)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"More about ModelingToolkit's interface for compositional modeling can be found in the ModelingToolkit docs.","category":"page"},{"location":"tutorials/compositional_modeling/#Compositional-Model-of-the-Repressilator","page":"Compositional Modeling of Reaction Systems","title":"Compositional Model of the Repressilator","text":"","category":"section"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Let's apply the tooling we've just seen to create the repressilator in a more modular fashion. We start by defining a function that creates a negatively repressed gene, taking the repressor as input","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"function repressed_gene(; R, name)\n    @reaction_network $name begin\n        hillr($R,α,K,n), ∅ --> m\n        (δ,γ), m <--> ∅\n        β, m --> m + P\n        μ, P --> ∅\n    end α K n δ γ β μ\nend","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Here we assume the user will pass in the repressor species as a ModelingToolkit variable, and specify a name for the network. We use Catalyst's interpolation ability to substitute the value of these variables into the DSL (see Interpolation of Julia Variables). To make the repressilator we now make three genes, and then compose them together","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"@variables t, G3₊P(t)\n@named G1 = repressed_gene(; R=ParentScope(G3₊P))\n@named G2 = repressed_gene(; R=ParentScope(G1.P))\n@named G3 = repressed_gene(; R=ParentScope(G2.P))\n@named repressilator = ReactionSystem(t; systems=[G1,G2,G3])","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Notice, in this system each gene is a child node in the system graph of the repressilator","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"plot(TreePlot(repressilator), method=:tree, fontsize=12, nodeshape=:ellipse)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"(Image: repressilator tree plot)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"In building the repressilator we needed to use two new features. First, we needed to create a symbolic variable that corresponds to the protein produced by the third gene before we created the corresponding system. We did this via @variables t, G3₊P(t). We also needed to set the scope where each repressor lived. Here ParentScope(G3₊P), ParentScope(G1.P), and ParentScope(G2.P) signal Catalyst that these variables will come from parallel systems in the tree that have the same parent as the system being constructed (in this case the top-level repressilator system).","category":"page"},{"location":"tutorials/compositional_modeling/#Compartment-based-Models","page":"Compositional Modeling of Reaction Systems","title":"Compartment-based Models","text":"","category":"section"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Finally, let's see how we can make a compartment-based model. Let's create a simple eukaryotic gene expression model with negative feedback by protein dimers. Transcription and gene inhibition by the protein dimer occur in the nucleus, translation and dimerization occur in the cytosol, and nuclear import and export reactions couple the two compartments. We'll include volume parameters for the nucleus and cytosol, and assume we are working with species having units of number of molecules. Rate constants will have their common concentration units, i.e. if V denotes the volume of a compartment then","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Reaction Type Example Rate Constant Units Effective rate constant (units of per time)\nZero order varnothing oversetalphato A concentration / time alpha V\nFirst order A oversetbetato B (time)⁻¹ beta\nSecond order A + B oversetgammato C (concentration × time)⁻¹ gammaV","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"In our model we'll therefore add the conversions of the last column to properly account for compartment volumes:","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"# transcription and regulation\nnuc = @reaction_network nuc begin\n        α, G --> G + M\n        (κ₊/V,κ₋), D + G <--> DG\n      end α V κ₊ κ₋\n\n# translation and dimerization\ncyto = @reaction_network cyto begin\n            β, M --> M + P\n            (k₊/V,k₋), 2P <--> D\n            σ, P --> 0\n            μ, M --> 0\n        end β k₊ k₋ V σ μ\n\n# export reactions,\n# γ,δ=probability per time to be exported/imported\nmodel = @reaction_network model begin\n       γ, $(nuc.M) --> $(cyto.M)\n       δ, $(cyto.D) --> $(nuc.D)\n    end γ δ\n@named model = compose(model, [nuc, cyto])","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"A graph of the resulting network is","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Graph(model)","category":"page"},{"location":"tutorials/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"(Image: graph of gene regulation model)","category":"page"},{"location":"tutorials/reaction_network_representation/#Network-Analysis-in-Catalyst","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"","category":"section"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"In this tutorial we introduce several of the Catalyst API functions for network analysis. A complete summary of the exported functions is given in the API section Network-Analysis-and-Representations.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Note, currently API functions for network analysis and conservation law analysis do not work with constant species (currently only generated by SBMLToolkit).","category":"page"},{"location":"tutorials/reaction_network_representation/#Network-representation-of-the-Repressilator-ReactionSystem","page":"Network Analysis in Catalyst","title":"Network representation of the Repressilator ReactionSystem","text":"","category":"section"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We first load Catalyst and construct our model of the repressilator","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"using Catalyst\nrepressilator = @reaction_network Repressilator begin\n       hillr(P₃,α,K,n), ∅ --> m₁\n       hillr(P₁,α,K,n), ∅ --> m₂\n       hillr(P₂,α,K,n), ∅ --> m₃\n       (δ,γ), m₁ <--> ∅\n       (δ,γ), m₂ <--> ∅\n       (δ,γ), m₃ <--> ∅\n       β, m₁ --> m₁ + P₁\n       β, m₂ --> m₂ + P₂\n       β, m₃ --> m₃ + P₃\n       μ, P₁ --> ∅\n       μ, P₂ --> ∅\n       μ, P₃ --> ∅\nend α K n δ γ β μ","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"In the Using Catalyst tutorial we showed how the above network could be visualized as a species-reaction graph. There species are represented by the nodes of the graph and edges show the reactions in which a given species is a substrate or product.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"g = Graph(repressilator)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: Repressilator solution)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We also showed in the Using Catalyst tutorial that the reaction rate equation ODE model for the repressilator is","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"beginaligned\nfracdm_1(t)dt = fracalpha K^nK^n + left( P_3left( t right) right)^n - delta m_1left( t right) + gamma \nfracdm_2(t)dt = fracalpha K^nK^n + left( P_1left( t right) right)^n - delta m_2left( t right) + gamma \nfracdm_3(t)dt = fracalpha K^nK^n + left( P_2left( t right) right)^n - delta m_3left( t right) + gamma \nfracdP_1(t)dt = beta m_1left( t right) - mu P_1left( t right) \nfracdP_2(t)dt = beta m_2left( t right) - mu P_2left( t right) \nfracdP_3(t)dt = beta m_3left( t right) - mu P_3left( t right)\nendaligned","category":"page"},{"location":"tutorials/reaction_network_representation/#Matrix-Vector-Reaction-Rate-Equation-Representation","page":"Network Analysis in Catalyst","title":"Matrix-Vector Reaction Rate Equation Representation","text":"","category":"section"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"In general, reaction rate equation (RRE) ODE models for chemical reaction networks can be represented as a first order system of ODEs in a compact matrix-vector notation. Suppose we have a reaction network with K reactions and M species, labelled by the state vector","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"mathbfx(t) = beginpmatrix x_1(t)  vdots  x_M(t)) endpmatrix","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"For the repressilator, mathbfx(t) is just","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"x = species(repressilator)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The RRE ODEs satisfied by mathbfx(t) are then","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"fracdmathbfxdt = N mathbfv(mathbfx(t)t)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"where N is a constant M by K matrix with N_m k the net stoichiometric coefficient of species m in reaction k. mathbfv(mathbfx(t)t) is the rate law vector, with v_k(mathbfx(t)t) the rate law for the kth reaction. For example, for the first reaction of the repressilator above, the rate law is","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"v_1(mathbfx(t)t) = fracalpha K^nK^n + left( P_3(t) right)^n","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can calculate each of these in Catalyst via","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"N = netstoichmat(repressilator)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"and by using the oderatelaw function","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rxs = reactions(repressilator)\nν = oderatelaw.(rxs)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Note, as oderatelaw takes just one reaction as input we use broadcasting to apply it to each element of rxs.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Let's check this really gives the same ODEs as Catalyst. Here is what Catalyst generates by converting to an ODESystem","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"osys = convert(ODESystem, repressilator)\n\n# for display purposes we just pull out the right side of the equations\nodes = [eq.rhs for eq in equations(osys)]","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"whereas our matrix-vector representation gives","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"odes2 = N * ν","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Let's check these are equal symbolically","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"isequal(odes, odes2)","category":"page"},{"location":"tutorials/reaction_network_representation/#Reaction-Complex-Representation","page":"Network Analysis in Catalyst","title":"Reaction Complex Representation","text":"","category":"section"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We now introduce a further decomposition of the RRE ODEs, which has been used to facilitate analysis of a variety of reaction network properties. Consider a simple reaction system like","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n k*A, 2*A + 3*B --> A + 2*C + D\n b, C + D --> 2*A + 3*B\nend k b","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can think of the first reaction as converting the reaction complex, 2A+3B to the complex A+2C+D with rate kA. Suppose we order our species the same way as Catalyst does, i.e.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"beginpmatrix\nx_1(t)\nx_2(t)\nx_3(t)\nx_4(t)\nendpmatrix =\nbeginpmatrix\nA(t)\nB(t)\nC(t)\nD(t)\nendpmatrix","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"which should be the same as","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"species(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can describe a given reaction complex by the stoichiometric coefficients of each species within the complex. For the reactions in rn these vectors would be","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"beginalign*\n2A+3B = beginpmatrix\n2\n3\n0\n0\nendpmatrix \nA+2C+D = beginpmatrix\n1\n0\n2\n1\nendpmatrix\n \nC+D = beginpmatrix\n0\n0\n1\n1\nendpmatrix\nendalign*","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Catalyst can calculate these representations as the columns of the complex stoichiometry matrix,","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Z = complexstoichmat(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"If we have C complexes, Z is a M by C matrix with Z_m c giving the stoichiometric coefficient of species m within complex c.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can use this representation to provide another representation of the RRE ODEs. The net stoichiometry matrix can be factored as N = Z B, where B is called the incidence matrix of the reaction network,","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"B = incidencemat(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Here B is a C by K matrix with B_c k = 1 if complex c appears as a product of reaction k, and B_c k = -1 if complex c is a substrate of reaction k.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Using our decomposition of N, the RRE ODEs become","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"fracdxdt = Z B mathbfv(mathbfx(t)t)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Let's verify that N = Z B,","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"N = netstoichmat(rn)\nN == Z*B","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Reaction complexes give an alternative way to visualize a reaction network graph. Catalyst's complexgraph command will calculate the complexes of a network and then show how they are related. For example,","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"complexgraph(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"gives","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: Simple example complex graph)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"while for the repressilator we find","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"complexgraph(repressilator)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: Repressilator complex)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Here ∅ represents the empty complex, black arrows show reactions converting substrate complexes into product complexes where the rate is just a number or parameter, and red arrows indicate conversion of substrate complexes into product complexes where the rate is an expression involving chemical species.","category":"page"},{"location":"tutorials/reaction_network_representation/#Aspects-of-Reaction-Network-Structure","page":"Network Analysis in Catalyst","title":"Aspects of Reaction Network Structure","text":"","category":"section"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The reaction complex representation can be exploited via Chemical Reaction Network Theory to provide insight into possible steady-state and time-dependent properties of RRE ODE models and  stochastic chemical kinetics models. We'll now illustrate some of the types of network properties that Catalyst can determine, using the reaction complex representation in these calculations.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Consider the following reaction network.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n     (k1,k2), A + B <--> C\n     k3, C --> D+E\n     (k4,k5), D+E <--> F\n     (k6,k7), 2A <--> B+G\n     k8, B+G --> H\n     k9, H --> 2A\nend k1 k2 k3 k4 k5 k6 k7 k8 k9","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"with graph","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"complexgraph(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: network_1)","category":"page"},{"location":"tutorials/reaction_network_representation/#Linkage-classes-and-sub-networks-of-the-reaction-network","page":"Network Analysis in Catalyst","title":"Linkage classes and sub-networks of the reaction network","text":"","category":"section"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The preceding reaction complex graph shows that rn is composed of two disconnected sub-graphs, one containing the complexes A+B, C, D+E, and F, the other containing the complexes 2A, B + G, and H. These sets, A+B C D+E F and 2A B + GH are called the \"linkage classes\" of the reaction network. The function linkageclasses will calculate these for a given network, returning a vector of the integer indices of reaction complexes participating in each set of linkage-classes. Note, indices of reaction complexes can be determined from the ordering returned by reactioncomplexes.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"# we must first calculate the reaction complexes -- they are cached in rn\nreactioncomplexes(rn)\n\n# now we can calculate the linkage classes\nlcs = linkageclasses(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"It can often be convenient to obtain the disconnected sub-networks as distinct ReactionSystems, which are returned by the subnetworks function:","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"subnets = subnetworks(rn)\n\n# check the reactions in each subnetwork\nreactions.(subnets)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The graphs of the reaction complexes in the two sub-networks are then","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"  complexgraph(subnets[1])","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: subnetwork_1)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"and,","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":" complexgraph(subnets[2])","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: subnetwork_2)","category":"page"},{"location":"tutorials/reaction_network_representation/#Deficiency-of-the-network","page":"Network Analysis in Catalyst","title":"Deficiency of the network","text":"","category":"section"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"A famous theorem in Chemical Reaction Network Theory, the Deficiency Zero Theorem [1], allows us to use knowledge of the net stoichiometry matrix and the linkage classes of a mass action RRE ODE system to draw conclusions about the system's possible steady-states. In this section we'll see how Catalyst can calculate a network's deficiency.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The rank, r, of a reaction network is defined as the dimension of the subspace spanned by the net stoichiometry vectors of the reaction-network [1], i.e. the span of the columns of the net stoichiometry matrix N. It corresponds to the number of independent species in a chemical reaction network. That is, if we calculate the linear conservation laws of a network, and use them to eliminate the dependent species of the network, we will have r independent species remaining. For our current example the conservation laws are given by","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"# first we calculate the conservation laws -- they are cached in rn\nconservationlaws(rn)\n\n# then we display them as equations for the dependent variables\nconservedequations(rn)\nshow(stdout, MIME\"text/plain\"(), ans) # hide","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Here the parameters _ConLaw[i] represent the constants of the three conservation laws, and we see that there are three dependent species that could be eliminated. As","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"numspecies(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"we find that there are five independent species. Let's check this is correct:","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"using LinearAlgebra\nrank(netstoichmat(rn)) == 5","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"So we know that the rank of our reaction network is five.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The deficiency, delta, of a reaction network is defined as","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"delta = textrm(number of complexes) - textrm(number of linkage classes) - textrm(rank)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"For our network this is 7 - 2 - 5 = 0, which we can calculate in Catalyst as","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"# first we calculate the reaction complexes of rn and cache them in rn\nreactioncomplexes(rn)\n\n# then we can calculate the deficiency\nδ = deficiency(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Quoting Feinberg [1]","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Deficiency zero networks are ones for which the reaction vectors [i.e. net stoichiometry vectors] are as independent as the partition of complexes into linkage classes will allow.","category":"page"},{"location":"tutorials/reaction_network_representation/#Reversibility-of-the-network","page":"Network Analysis in Catalyst","title":"Reversibility of the network","text":"","category":"section"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"A reaction network is reversible if the \"arrows\" of the reactions are symmetric so that every reaction is accompanied by its reverse reaction. Catalyst's API provides the isreversible function to determine whether a reaction network is reversible. As an example, consider","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n  (k1,k2),A <--> B\n  (k3,k4),A + C <--> D\n  (k5,k6),D <--> B+E\n  (k7,k8),B+E <--> A+C\nend k1 k2 k3 k4 k5 k6 k7 k8\n\n# calculate the set of reaction complexes\nreactioncomplexes(rn)\n\n# test if the system is reversible\nisreversible(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Consider another example,","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n  (k1,k2),A <--> B\n  k3, A + C --> D\n  k4, D --> B+E\n  k5, B+E --> A+C\nend k1 k2 k3 k4 k5\nreactioncomplexes(rn)\nisreversible(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"complexgraph(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: reversibility)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"It is evident from the preceding graph that the network is not reversible. However, it satisfies a weaker property in that there is a path from each reaction complex back to itself within its associated subgraph. This is known as weak reversiblity. One can test a network for weak reversibility by using the isweaklyreversible function:","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"# need subnetworks from the reaction network first\nsubnets = subnetworks(rn)\nisweaklyreversible(rn, subnets)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Every reversible network is also weakly reversible, but not every weakly reversible network is reversible.","category":"page"},{"location":"tutorials/reaction_network_representation/#Deficiency-Zero-Theorem","page":"Network Analysis in Catalyst","title":"Deficiency Zero Theorem","text":"","category":"section"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Knowing the deficiency and weak reversibility of a mass action chemical reaction network ODE model allows us to make inferences about the corresponding steady-state behavior. Before illustrating how this works for one example, we need one last definition.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Recall that in the matrix-vector representation for the RRE ODEs, the entries, N_m k, of the stoichiometry matrix, N, give the net change in species m due to reaction k. If we let mathbfN_k denote the kth column of this matrix, this vector corresponds to the change in the species state vector, mathbfx(t), due to reaction k, i.e. when reaction k occurs mathbfx(t) to mathbfx(t) + mathbfN_k. Moreover, by integrating the ODE","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"fracdmathbfxdt = N mathbfv(mathbfx(t)) = sum_k=1^K v_k(mathbfx(t))  mathbfN_k","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"we find","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"mathbfx(t) = mathbfx(0) + sum_k=1^K left(int_0^t v_k(mathbfx)(s)  dsright) mathbfN_k","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"which demonstrates that mathbfx(t) - mathbfx(0) is always given by a linear combination of the stochiometry vectors, i.e.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"DeclareMathOperatorspanspan\nmathbfx(t) - mathbfx(0) in spanmathbfN_k ","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"In particular, this says that mathbfx(t) lives in the translation of the spanmathbfN_k  by mathbfx(0) which we write as (mathbfx(0) + spanmathbfN_k). In fact, since the solution should stay non-negative, if we let barmathbbR_+^M denote the subset of vectors in mathbbR^M with non-negative components, the possible physical values for the solution, mathbfx(t), must be in the set","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(mathbfx(0) + spanmathbfN_k) cap barmathbbR_+^M","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"This set is called the stoichiometric compatibility class of mathbfx(t). The key property of stoichiometric compatibility classes is that they are invariant under the RRE ODE's dynamics, i.e. a solution will always remain within the subspace given by the stoichiometric compatibility class. Finally, we note that the positive stoichiometric compatibility class generated by mathbfx(0) is just (mathbfx(0) + spanmathbfN_k) cap mathbbR_+^M, where mathbbR_+^M denotes the vectors in mathbbR^M with strictly positive components.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"With these definitions we can now see how knowing the deficiency and weak reversibility of the network can tell us about its steady-state behavior. Consider the previous example, which we know is weakly reversible. Its deficiency is","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"deficiency(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We also verify that the system is purely mass action (though it is apparent from the network's definition):","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"all(rx -> ismassaction(rx, rn), reactions(rn))","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can therefore apply the Deficiency Zero Theorem to draw conclusions about the system's steady-state behavior. The Deficiency Zero Theorem (roughly) says that a mass action network with deficiency zero satisfies","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"If the network is weakly reversible, then independent of the reaction rate constants the RRE ODEs have exactly one equilibrium solution within each positive stoichiometric compatibility class. That equilibrium is locally asymptotically stable.\nIf the network is not weakly reversible, then the RRE ODEs cannot admit a positive equilibrium solution.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"See [1] for a more precise statement, proof, and additional examples.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can therefore conclude that for any initial condition that is positive, and hence in some positive stoichiometric compatibility class, rn will have exactly one equilibrium solution which will be positive and locally asymptotically stable.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"As a final example, consider the following network from [1]","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n  (k1,k2),A <--> 2B\n  (k3,k4), A + C <--> D\n  k5, B+E --> C + D\nend k1 k2 k3 k4 k5\nreactioncomplexes(rn)\nsubnets = subnetworks(rn)\nisma = all(rx -> ismassaction(rx,rn), reactions(rn))\ndef = deficiency(rn)\niswr = isweaklyreversible(rn, subnets)\nisma,def,iswr","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"which we see is mass action and has deficiency zero, but is not weakly reversible. As such, we can conclude that for any choice of rate constants the RRE ODEs cannot have a positive equilibrium solution.","category":"page"},{"location":"tutorials/reaction_network_representation/#Caching-of-Network-Properties-in-ReactionSystems","page":"Network Analysis in Catalyst","title":"Caching of Network Properties in ReactionSystems","text":"","category":"section"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"When calling many of the network API functions, Catalyst calculates and caches in rn a variety of information. For example the first call to","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rcs,B = reactioncomplexes(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"calculates, caches, and returns the reaction complexes, rcs, and the incidence matrix, B, of rn. Subsequent calls simply return rcs and B from the cache.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Similarly, the first call to","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"N = netstoichmat(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"calculates, caches and returns the net stoichiometry matrix. Subsequent calls then simply return the cached value of N. Caching such information means users do not need to manually know which subsets of network properties are needed for a given calculation (like the deficiency). Generally only","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rcs,B = reactioncomplexes(rn)    # must be called once to cache rcs and B\nany_other_network_property(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"should work to calculate a desired network property, with the API doc strings indicating when reactioncomplexes(rn) must be called at least once before a given function is used.","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Because of the caching of network properties, subsequent calls to most API functions will be fast, simply returning the previously calculated and cached values. In some cases it may be desirable to reset the cache and recalculate these properties, for example after modifying a network (see addspecies!, addparam!, or addreaction!). This can be done by calling","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Catalyst.reset_networkproperties!(rn)","category":"page"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Network property functions will then recalculate their associated properties and cache the new values the next time they are called.","category":"page"},{"location":"tutorials/reaction_network_representation/#References","page":"Network Analysis in Catalyst","title":"References","text":"","category":"section"},{"location":"tutorials/reaction_network_representation/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"[1]: Feinberg, M. Foundations of Chemical Reaction Network Theory, Applied Mathematical Sciences 202, Springer (2019).","category":"page"},{"location":"tutorials/reaction_systems/#Programmatic-Construction-of-Symbolic-Reaction-Systems","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"","category":"section"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"While the DSL provides a simple interface for creating ReactionSystems, it can often be convenient to build or augment a ReactionSystem programmatically. In this tutorial we show how to build the repressilator model of the Using Catalyst tutorial directly using symbolic variables, and then summarize the basic API functionality for accessing information stored within ReactionSystems.","category":"page"},{"location":"tutorials/reaction_systems/#Directly-Building-the-Repressilator-with-ReactionSystems","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Directly Building the Repressilator with ReactionSystems","text":"","category":"section"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"We first load Catalyst","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"using Catalyst","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"and then define symbolic variables for each parameter and species in the system (the latter corresponding to a variable or state in ModelingToolkit terminology)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"@parameters α K n δ γ β μ\n@variables t m₁(t) m₂(t) m₃(t) P₁(t) P₂(t) P₃(t)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"@parameters α, K, n, δ, γ, β, μ;\n@variables t, m₁(t), m₂(t), m₃(t), P₁(t), P₂(t), P₃(t);","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Note, each species is declared as a variable that is a function of time!","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Next we specify the chemical reactions that comprise the system using Catalyst Reactions","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rxs = [Reaction(hillr(P₃,α,K,n), nothing, [m₁]),\n       Reaction(hillr(P₁,α,K,n), nothing, [m₂]),\n       Reaction(hillr(P₂,α,K,n), nothing, [m₃]),\n       Reaction(δ, [m₁], nothing),\n       Reaction(γ, nothing, [m₁]),\n       Reaction(δ, [m₂], nothing),\n       Reaction(γ, nothing, [m₂]),\n       Reaction(δ, [m₃], nothing),\n       Reaction(γ, nothing, [m₃]),\n       Reaction(β, [m₁], [m₁,P₁]),\n       Reaction(β, [m₂], [m₂,P₂]),\n       Reaction(β, [m₃], [m₃,P₃]),\n       Reaction(μ, [P₁], nothing),\n       Reaction(μ, [P₂], nothing),\n       Reaction(μ, [P₃], nothing)]","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rxs = [Reaction(hillr(P₃,α,K,n), nothing, [m₁]),\n       Reaction(hillr(P₁,α,K,n), nothing, [m₂]),\n       Reaction(hillr(P₂,α,K,n), nothing, [m₃]),\n       Reaction(δ, [m₁], nothing),\n       Reaction(γ, nothing, [m₁]),\n       Reaction(δ, [m₂], nothing),\n       Reaction(γ, nothing, [m₂]),\n       Reaction(δ, [m₃], nothing),\n       Reaction(γ, nothing, [m₃]),\n       Reaction(β, [m₁], [m₁,P₁]),\n       Reaction(β, [m₂], [m₂,P₂]),\n       Reaction(β, [m₃], [m₃,P₃]),\n       Reaction(μ, [P₁], nothing),\n       Reaction(μ, [P₂], nothing),\n       Reaction(μ, [P₃], nothing)]","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Here we use nothing where the DSL used varnothing. Finally, we are ready to construct our ReactionSystem as","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"@named repressilator = ReactionSystem(rxs, t)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"@named repressilator = ReactionSystem(rxs, t)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Notice, the model is named repressilator. A name must always be specified when directly constructing a ReactionSystem (the DSL will auto-generate one if left out). Using @named when constructing a ReactionSystem causes the name of the system to be the same as the name of the variable storing the system. Alternatively, one can use the name=:repressilator keyword argument to the ReactionSystem constructor.","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"We can check that this is the same model as the one we defined via the DSL as follows (this requires that we use the same names for rates, species and the system)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"repressilator2 = @reaction_network repressilator begin\n    hillr(P₃,α,K,n), ∅ --> m₁\n    hillr(P₁,α,K,n), ∅ --> m₂\n    hillr(P₂,α,K,n), ∅ --> m₃\n    (δ,γ), m₁ <--> ∅\n    (δ,γ), m₂ <--> ∅\n    (δ,γ), m₃ <--> ∅\n    β, m₁ --> m₁ + P₁\n    β, m₂ --> m₂ + P₂\n    β, m₃ --> m₃ + P₃\n    μ, P₁ --> ∅\n    μ, P₂ --> ∅\n    μ, P₃ --> ∅\nend α K n δ γ β μ\nrepressilator == repressilator2","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"For more options in building ReactionSystems, see the ReactionSystem API docs.","category":"page"},{"location":"tutorials/reaction_systems/#More-General-Reactions","page":"Programmatic Construction of Symbolic Reaction Systems","title":"More General Reactions","text":"","category":"section"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"In the example above all the specified Reactions were first or zero order. The three-argument form of Reaction implicitly assumes all species have a stoichiometric coefficient of one, i.e. for substrates [S₁,...,Sₘ] and products [P₁,...,Pₙ] it has the possible forms","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"# rate, S₁ + ... + Sₘ --> P₁ + ... + Pₙ\nReaction(rate, [S₁,...,Sₘ], [P₁,...,Pₙ])\n\n# rate, S₁ + ... + Sₘ --> ∅\nReaction(rate, [S₁,...,Sₘ], nothing)\n\n# rate, ∅ --> P₁ + ... + Pₙ\nReaction(rate, nothing, [P₁,...,Pₙ])","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"To allow for other stoichiometric coefficients we also provide a five argument form","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"# rate, α₁*S₁ + ... + αₘ*Sₘ --> β₁*P₁ + ... + βₙ*Pₙ\nReaction(rate, [S₁,...,Sₘ], [P₁,...,Pₙ], [α₁,...,αₘ], [β₁,...,βₙ])\n\n# rate, α₁*S₁ + ... + αₘ*Sₘ --> ∅\nReaction(rate, [S₁,...,Sₘ], nothing, [α₁,...,αₘ], nothing)\n\n# rate, ∅ --> β₁*P₁ + ... + βₙ*Pₙ\nReaction(rate, nothing, [P₁,...,Pₙ], nothing, [β₁,...,βₙ])","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Finally, we note that the rate constant, rate above, does not need to be a constant or fixed function, but can be a general symbolic expression:","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"@parameters α, β\n@variables t, A(t), B(t)\nrx = Reaction(α+β*t*A, [A], [B])","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"See the FAQs for info on using general user-specified functions for the rate constant.","category":"page"},{"location":"tutorials/reaction_systems/#@reaction-macro-for-constructing-Reactions","page":"Programmatic Construction of Symbolic Reaction Systems","title":"@reaction macro for constructing Reactions","text":"","category":"section"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"In some cases one wants to build reactions incrementally, as in the repressilator example, but it would be nice to still have a short hand as in the @reaction_network DSL. In this case one can construct individual reactions using the @reaction macro.","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"For example, the repressilator reactions could also have been constructed like","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"@variables t P₁(t) P₂(t) P₃(t)\nrxs = [(@reaction hillr($P₃,α,K,n), ∅ --> m₁),\n       (@reaction hillr($P₁,α,K,n), ∅ --> m₂),\n       (@reaction hillr($P₂,α,K,n), ∅ --> m₃),\n       (@reaction δ, m₁ --> ∅),\n       (@reaction γ, ∅ --> m₁),\n       (@reaction δ, m₂ --> ∅),\n       (@reaction γ, ∅ --> m₂),\n       (@reaction δ, m₃ --> ∅),\n       (@reaction γ, ∅ --> m₃),\n       (@reaction β, m₁ --> m₁ + P₁),\n       (@reaction β, m₂ --> m₂ + P₂),\n       (@reaction β, m₃ --> m₃ + P₃),\n       (@reaction μ, P₁ --> ∅),\n       (@reaction μ, P₂ --> ∅),\n       (@reaction μ, P₃ --> ∅)]\n@named repressilator = ReactionSystem(rxs, t)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Note, there are a few differences when using the @reaction macro to specify one reaction versus using the full @reaction_network macro to create a ReactionSystem. First, only one reaction (i.e. a single forward arrow type) can be used, i.e. reversible arrows like <--> will not work (since they define more than one reaction). Second, the @reaction macro must try to infer which symbols are species versus parameters, and uses the heuristic that anything appearing in the rate expression is a parameter. Coefficients in the reaction part are also inferred as parameters, while rightmost symbols (i.e. substrates and products) are inferred as species. As such, the following are equivalent","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx = @reaction hillr(P,α,K,n), A --> B","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"is equivalent to","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"@parameters P α K n\n@variables t A(t) B(t)\nrx = Reaction(hillr(P,α,K,n), [A], [B])","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Here (P,α,K,n) are parameters and (A,B) are species.","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"This behavior is the reason that in the repressilator example above we pre-declared (P₁(t),P₂(t),P₃(t)) as variables, and then used them via interpolating their values into the rate law expressions using $ in the macro. This ensured they were properly treated as species and not parameters. See the @reaction macro docstring for more information.","category":"page"},{"location":"tutorials/reaction_systems/#Basic-Querying-of-ReactionSystems","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Basic Querying of ReactionSystems","text":"","category":"section"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"The Catalyst.jl API provides a large variety of functionality for querying properties of a reaction network. Here we go over a few of the most useful basic functions. Given the repressillator defined above we have that","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"species(repressilator)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"parameters(repressilator)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"reactions(repressilator)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"We can test if a Reaction is mass action, i.e. the rate does not depend on t or other species, as","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"# Catalyst.hillr(P₃(t), α, K, n), ∅ --> m₁\nrx1 = reactions(repressilator)[1]\nismassaction(rx1,repressilator)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"while","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"# δ, m₁ --> ∅\nrx2 = reactions(repressilator)[4]\nismassaction(rx2,repressilator)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Similarly, we can determine which species a reaction's rate law will depend on like","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rn = @reaction_network begin\n       k*W, 2X + 3Y --> 5Z + W\n     end k\ndependents(reactions(rn)[1], rn)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Basic stoichiometry matrices can be obtained from a ReactionSystem as","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"substoichmat(repressilator)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"prodstoichmat(repressilator)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"netstoichmat(repressilator)","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Here the (ij) entry gives the corresponding stoichiometric coefficient of species i for reaction j.","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Finally, we can directly access fields of individual reactions like","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.rate","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.substrates","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.products","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.substoich","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.prodstoich","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.netstoich","category":"page"},{"location":"tutorials/reaction_systems/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"See the Catalyst.jl API for much more detail on the various querying and analysis functions provided by Catalyst.","category":"page"},{"location":"tutorials/parameter_estimation/#Parameter-Estimation","page":"Parameter Estimation","title":"Parameter Estimation","text":"","category":"section"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"The parameters of a model, generated by Catalyst, can be estimated using various packages available in the Julia ecosystem. Refer here for more extensive information. Below follows a quick tutorial of how DiffEqFlux can be used to fit a parameter set to data.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"First, we fetch the required packages.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"using OrdinaryDiffEq\nusing DiffEqFlux, Flux\nusing Catalyst","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Next, we declare our model. For our example, we will use the Brusselator, a simple oscillator.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"brusselator = @reaction_network begin\n    A, ∅ → X\n    1, 2X + Y → 3X\n    B, X → Y\n    1, X → ∅\nend A B\np_real = [1., 2.]","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"We simulate our model, and from the simulation generate sampled data points (with added noise), to which we will attempt to fit a parameter et.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"u0 = [1.0, 1.0]\ntspan = (0.0, 30.0)\n\nsample_times = range(tspan[1],stop=tspan[2],length=100)\nprob = ODEProblem(brusselator, u0, tspan, p_real)\nsol_real = solve(prob, Rosenbrock23(), tstops=sample_times)\n\nsample_vals = [sol_real.u[findfirst(sol_real.t .>= ts)][var] * (1+(0.1rand()-0.05)) for var in 1:2, ts in sample_times];","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"We can plot the real solution, as well as the noisy samples.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"using Plots\nplot(sol_real,size=(1200,400),label=\"\",framestyle=:box,lw=3,color=[:darkblue :darkred])\nplot!(sample_times,sample_vals',seriestype=:scatter,color=[:blue :red],label=\"\")","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"(Image: parameter_estimation_plot1)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Next, we create an optimisation function. For a given initial estimate of the parameter values, p, this function will fit parameter values to our data samples. However, it will only do so on the interval [0,tend].","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"function optimise_p(p_init,tend)\n    function loss(p)\n        sol = solve(remake(prob,tspan=(0.,tend),p=p), Rosenbrock23(), tstops=sample_times)\n        vals = hcat(map(ts -> sol.u[findfirst(sol.t .>= ts)], sample_times[1:findlast(sample_times .<= tend)])...)    \n        loss = sum(abs2, vals .- sample_vals[:,1:size(vals)[2]])   \n        return loss, sol\n    end\n    return DiffEqFlux.sciml_train(loss,p_init,ADAM(0.1),maxiters = 100)\nend","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Next, we will fit a parameter set to the data on the interval [0,10].","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"p_estimate = optimise_p([5.,5.],10.).minimizer","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"We can compare this to the real solution, as well as the sample data","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"sol_estimate = solve(remake(prob,tspan=(0.,10.),p=p_estimate), Rosenbrock23())\nplot(sol_real,size=(1200,400),color=[:blue :red],framestyle=:box,lw=3,label=[\"X real\" \"Y real\"],linealpha=0.2)\nplot!(sample_times,sample_vals',seriestype=:scatter,color=[:blue :red],label=[\"Samples of X\" \"Samples of Y\"],alpha=0.4)\nplot!(sol_estimate,color=[:darkblue :darkred], linestyle=:dash,lw=3,label=[\"X estimated\" \"Y estimated\"],xlimit=tspan)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"(Image: parameter_estimation_plot2)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Next, we use this parameter estimation as the input to the next iteration of our fitting process, this time on the interval [0,20].","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"p_estimate = optimise_p(p_estimate,20.).minimizer\n\nsol_estimate = solve(remake(prob,tspan=(0.,20.),p=p_estimate), Rosenbrock23())\nplot(sol_real,size=(1200,400),color=[:blue :red],framestyle=:box,lw=3,label=[\"X real\" \"Y real\"],linealpha=0.2)\nplot!(sample_times,sample_vals',seriestype=:scatter,color=[:blue :red],label=[\"Samples of X\" \"Samples of Y\"],alpha=0.4)\nplot!(sol_estimate,color=[:darkblue :darkred], linestyle=:dash,lw=3,label=[\"X estimated\" \"Y estimated\"],xlimit=tspan)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"(Image: parameter_estimation_plot3)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"Finally, we use this estimate as the input to fit a parameter set on the full interval of sampled data.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"p_estimate = optimise_p(p_estimate,30.).minimizer\n\nsol_estimate = solve(remake(prob,tspan=(0.,30.),p=p_estimate), Rosenbrock23())\nplot(sol_real,size=(1200,400),color=[:blue :red],framestyle=:box,lw=3,label=[\"X real\" \"Y real\"],linealpha=0.2)\nplot!(sample_times,sample_vals',seriestype=:scatter,color=[:blue :red],label=[\"Samples of X\" \"Samples of Y\"],alpha=0.4)\nplot!(sol_estimate,color=[:darkblue :darkred], linestyle=:dash,lw=3,label=[\"X estimated\" \"Y estimated\"],xlimit=tspan)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"(Image: parameter_estimation_plot4)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"The final parameter set becomes [0.9996559014056948, 2.005632696191224] (the real one was [1.0, 2.0]).","category":"page"},{"location":"tutorials/parameter_estimation/#Why-we-fit-the-parameters-in-iterations.","page":"Parameter Estimation","title":"Why we fit the parameters in iterations.","text":"","category":"section"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"The reason we chose to fit the model on a smaller interval to begin with, and then extend the interval, is to avoid getting stuck in a local minimum. Here specifically, we chose our initial interval to be smaller than a full cycle of the oscillation. If we had chosen to fit a parameter set on the full interval immediately we would have received an inferior solution.","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"p_estimate = optimise_p([5.,5.],30.).minimizer\n\nsol_estimate = solve(remake(prob,tspan=(0.,30.),p=p_estimate), Rosenbrock23())\nplot(sol_real,size=(1200,400),color=[:blue :red],framestyle=:box,lw=3,label=[\"X real\" \"Y real\"],linealpha=0.2)\nplot!(sample_times,sample_vals',seriestype=:scatter,color=[:blue :red],label=[\"Samples of X\" \"Samples of Y\"],alpha=0.4)\nplot!(sol_estimate,color=[:darkblue :darkred], linestyle=:dash,lw=3,label=[\"X estimated\" \"Y estimated\"],xlimit=tspan)","category":"page"},{"location":"tutorials/parameter_estimation/","page":"Parameter Estimation","title":"Parameter Estimation","text":"(Image: parameter_estimation_plot5)","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/#Finding-Steady-States-through-Homotopy-Continuation","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"","category":"section"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"The steady states of a dynamical system dx over dt = f(x) can be found by solving 0 = f(x). This is typically a hard problem, and generally, there is no method that guarantees to find all steady states for a system that has multiple ones. However, most CRNs generate polynomial systems (the main exception is when Hill functions with non-integer exponents are used). The roots of these can reliably be found through a homotopy continuation algorithm. This is implemented in Julia through the HomotopyContinuation.jl package. In this tutorial, we will demonstrate how homotopy continuation can be used to find the steady states of a CNR implemented in  Catalyst.","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/#Basic-Example","page":"Finding Steady States through Homotopy Continuation","title":"Basic Example","text":"","category":"section"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"For this tutorial, we will use a model from the Wilhem (2009) paper (which demonstrates bistability in a small CRN). We declare the model and the parameter set for which we want to find the steady states:","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"using Catalyst\r\nwilhelm_2009_model = @reaction_network begin\r\n    k1, Y --> 2X\r\n    k2, 2X --> X + Y\r\n    k3, X + Y --> Y\r\n    k4, X --> 0\r\nend k1 k2 k3 k4\r\np = [:k1 => 8.0, :k2 => 2.0, :k3 => 1.0, :k4 => 1.5]","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Next, we will need to extract the actual equations from our model. In addition, we will substitute in our parameter values.","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"ns = convert(NonlinearSystem,wilhelm_2009_model)\r\nsubs = Dict(Pair.(ModelingToolkit.parameters(ns),last.(p)))\r\nnew_eqs = map(eq -> substitute(eq.rhs,subs), equations(ns))","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Finally, we use the as_polynomial function to read our symbolic expression as a polynomial, within it, we can apply homotopy continuation's solve command to find the roots. In addition, we use the real_solutions to filter away imaginary roots (as CRNs' states typically are non-imaginary):","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"using HomotopyContinuation\r\nsols = real_solutions(as_polynomial((f, x...) -> HomotopyContinuation.solve(collect(x)), new_eqs...))","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"While it is not the case for this CRN, we note that some solutions with negative species concentrations may still appear. Typically, these will need to be filtered away as well.","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/#Rational-Polynomial-Systems","page":"Finding Steady States through Homotopy Continuation","title":"Rational Polynomial Systems","text":"","category":"section"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"It is not uncommon for CRNs to generate systems corresponding to rational multivariate polynomials (e.g. through Hill functions). The roots of these can also be found using homotopy continuation. An expanded tutorial for this will be published once some awaited improvements to the as_polynomial function are completed. ","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/#Systems-with-Conservation-Laws","page":"Finding Steady States through Homotopy Continuation","title":"Systems with Conservation Laws","text":"","category":"section"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Finally, some systems are underdetermined, and have an infinite number of possible steady states. These are typically systems containing a conservation law, e.g.","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"using Catalyst\r\ntwo_state_model = @reaction_network begin\r\n    (k1,k2), X1 <--> X2\r\nend k1 k2","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"However, the conservation laws can be computed using the conservationlaws function. By supplying these, as well as fixed concentrations (in this case the total amount of X, that is X1+X2), steady states can be found. First, we set the default values of the system's initial conditions and steady states. This will allow the system to automatically find the conserved amounts.","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"setdefaults!(two_state_model, [:X1 => 1.0, :X2 => 1.0, :k1 => 2.0, :k2 => 1.0])","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Next, we create a NonlinearSystem, while also removing the redundant equation.","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"ns = convert(NonlinearSystem,two_state_model; remove_conserved=true)","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Again, we will create the dictionary for parameter values that we will sub in. However, we will do it slightly differently so that the conserved quantitites are accoutned for.","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"const MT = ModelingToolkit\r\nsubs = Dict(MT.parameters(ns) .=> MT.varmap_to_vars([], MT.parameters(ns); defaults=MT.defaults(ns)))","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"We now extract the equation produced by the conservation law, and then sub in the parameter values creating a final set of equations (like previously). Unlike previously, we have to do eq.rhs-eq.lhs, as cons_eq may contain important information on both the lhs and rhs.","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"cons_eq = conservedequations(two_state_model)\r\nnew_eqs = map(eq -> substitute(eq.rhs-eq.lhs,subs), [equations(ns)...;cons_eq...])","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Finally, we compute the solution:","category":"page"},{"location":"tutorials/homotopy_continuation_tutorial/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"using HomotopyContinuation\r\nsols = real_solutions(as_polynomial((f, x...) -> HomotopyContinuation.solve(collect(x)), new_eqs...))","category":"page"},{"location":"tutorials/symbolic_stoich/#Parametric-Stoichiometry","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"","category":"section"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"Catalyst supports stoichiometric coefficients that involve parameters, species, or even general expressions. In this tutorial we show several examples of how to use parametric stoichiometry, and discuss several caveats to be aware of.","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"Note, this tutorial requires ModelingToolkit v8.5.4 or greater to work properly.","category":"page"},{"location":"tutorials/symbolic_stoich/#Using-Symbolic-Stoichiometry","page":"Parametric Stoichiometry","title":"Using Symbolic Stoichiometry","text":"","category":"section"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"Let's first consider a simple reversible reaction where the number of reactants is a parameter, and the number of products is the product of two parameters. ","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"using Catalyst, Latexify, DifferentialEquations, ModelingToolkit, Plots\nrevsys = @reaction_network revsys begin\n    k₊, m*A --> (m*n)*B\n    k₋, B --> A\nend k₊ k₋ m n\nreactions(revsys)","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"Note, as always the @reaction_network macro sets all symbols not declared to be parameters to be species, so that in this example we have two species, A and B, and four parameters. In addition, the stoichiometry is applied to the right most symbol in a given term, i.e. in the first equation the substrate A has stoichiometry m and the product B has stoichiometry m*n. For example, in","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"rn = @reaction_network begin\n    k, A*C --> 2B\n    end k\nreactions(rn)","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"we see three species, (A,B,C), however, A is treated as the stoichiometric coefficient of C, i.e.","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"rx = reactions(rn)[1]\nrx.substrates[1],rx.substoich[1]","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"We could have equivalently specified our systems directly via the Catalyst API. For example, for revsys we would could use","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"@parameters k₊,k₋,m,n\n@variables t, A(t), B(t)\nrxs = [Reaction(k₊,[A],[B],[m],[m*n]),\n       Reaction(k₋,[B],[A])] \nrevsys2 = ReactionSystem(rxs,t; name=:revsys)\nrevsys2 == revsys","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"which can be simplified using the @reaction macro to","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"rxs2 = [(@reaction k₊, m*A --> (m*n)*B),\n        (@reaction k₋, B --> A)]\nrevsys3 = ReactionSystem(rxs2,t; name=:revsys)\nrevsys3 == revsys","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"Note, the @reaction macro assumes all symbols are parameters except the right most symbols in the reaction line (i.e. A and B). For example, in  @reaction k, F*A + 2(H*G+B) --> D, the substrates are (A,G,B) with stoichiometries (F,2*H,2).","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"Let's now convert revsys to ODEs and look at the resulting equations:","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"osys = convert(ODESystem, revsys)\nequations(osys)\nshow(stdout, MIME\"text/plain\"(), equations(osys)) # hide","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"Notice, as described in the Reaction rate laws used in simulations section, the default rate laws involve factorials in the stoichiometric coefficients. For this reason we must specify m and n as integers, and hence use a tuple for the parameter mapping","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"p  = (k₊ => 1.0, k₋ => 1.0, m => 2, n => 2)\nu₀ = [A => 1.0, B => 1.0]\noprob = ODEProblem(osys, u₀, (0.0,1.0), p)","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"We can now solve and plot the system","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"sol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"If we had used a vector to store parameters, m and n would be converted to floating point giving an error when solving the system.","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"An alternative approach to avoid the issues of using mixed floating point and integer variables is to disable the rescaling of rate laws as described in Reaction rate laws used in simulations section. This requires passing the combinatoric_ratelaws=false keyword to convert or to ODEProblem (if directly building the problem from a ReactionSystem instead of first converting to an ODESystem). For the previous example this gives the following (different) system of ODEs","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"osys = convert(ODESystem, revsys; combinatoric_ratelaws=false)\nequations(osys)\nshow(stdout, MIME\"text/plain\"(), equations(osys)) # hide","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"Since we no longer have factorial functions appearing, our example will now run even with floating point values for m and n:","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"p  = (k₊ => 1.0, k₋ => 1.0, m => 2.0, n => 2.0)\noprob = ODEProblem(osys, u₀, (0.0,1.0), p)\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"tutorials/symbolic_stoich/#Gene-expression-with-randomly-produced-amounts-of-protein","page":"Parametric Stoichiometry","title":"Gene expression with randomly produced amounts of protein","text":"","category":"section"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"As a second example, let's build the negative feedback model from MomentClosure.jl that involves a bursty reaction that produces a random amount of protein. ","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"In our model G₋ will denote the repressed state, and G₊ the active state where the gene can transcribe. P will denote the protein product of the gene. We will assume that proteins are produced in bursts that produce m proteins, where m is a (shifted) geometric random variable with mean b. To define m we must register the Distributions.Geometric distribution from Distributions.jl with Symbolics.jl, after which we can use it in symbolic expressions:","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"using Distributions: Geometric\n@register_symbolic Geometric(b)\n@parameters b\nm = rand(Geometric(1/b)) + 1\nnothing # hide","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"Note, as we require the shifted geometric distribution, we add one to Distributions.jl's Geometric random variable (which includes zero). ","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"We can now define our model","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"burstyrn = @reaction_network burstyrn begin\n    k₊, G₋ --> G₊\n    k₋*P^2, G₊ --> G₋\n    kₚ, G₊ --> G₊ + $m*P\n    γₚ, P --> ∅\nend k₊ k₋ kₚ γₚ\nreactions(burstyrn)\nshow(stdout, MIME\"text/plain\"(), reactions(burstyrn)) # hide","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"The parameter b does not need to be explicitly declared in the @reaction_network macro as it is detected when the expression rand(Geometric(1/b)) + 1 is substituted for m.","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"We next convert our network to a jump process representation","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"jsys = convert(JumpSystem, burstyrn; combinatoric_ratelaws=false)\nequations(jsys)\nshow(stdout, MIME\"text/plain\"(), equations(jsys)) # hide","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"Notice, the equations of jsys have three MassActionJumps for the first three reactions, and one ConstantRateJump for the last reaction. If we examine the ConstantRateJump more closely we can see the generated rate and affect! functions for the bursty reaction that makes protein","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"equations(jsys)[4].rate\nshow(stdout, MIME\"text/plain\"(), equations(jsys)[4].rate) # hide","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"equations(jsys)[4].affect!\nshow(stdout, MIME\"text/plain\"(), equations(jsys)[4].affect!) # hide","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"Finally, we can now simulate our jumpsystem","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"pmean = 200\nbval = 70\nγₚval = 1\nk₋val = 0.001\nk₊val = 0.05\nkₚval = pmean * γₚval * (k₋val * pmean^2 + k₊val) / (k₊val * bval)\np = symmap_to_varmap(jsys, (:k₊ => k₊val, :k₋ => k₋val, :kₚ => kₚval, :γₚ => γₚval, :b => bval))\nu₀ = symmap_to_varmap(jsys, [:G₊ => 1, :G₋ => 0, :P => 1])\ntspan = (0., 6.0)   # time interval to solve over\ndprob = DiscreteProblem(jsys, u₀, tspan, p)\njprob = JumpProblem(jsys, dprob, Direct())\nsol = solve(jprob, SSAStepper())\nplot(sol.t, sol[jsys.P], legend=false, xlabel=\"time\", ylabel=\"P(t)\")","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"To double check our results are consistent with MomentClosure.jl, let's calculate and plot the average amount of protein (which is also plotted in the MomentClosure.jl tutorial).","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"function getmean(jprob, Nsims, tv)\n    Pmean = zeros(length(tv))\n    @variables t, P(t)\n    for n in 1:Nsims\n        sol = solve(jprob, SSAStepper())        \n        Pmean .+= sol(tv, idxs=P)\n    end\n    Pmean ./= Nsims\nend\ntv = range(tspan[1],tspan[2],step=.1)\npsim_mean = getmean(jprob, 20000, tv)\nplot(tv, psim_mean, ylabel=\"average of P(t)\", xlabel=\"time\", xlim=(0.0,6.0), legend=false)","category":"page"},{"location":"tutorials/symbolic_stoich/","page":"Parametric Stoichiometry","title":"Parametric Stoichiometry","text":"Comparing, we see similar averages for P(t).","category":"page"},{"location":"faqs/#FAQs","page":"FAQs","title":"FAQs","text":"","category":"section"},{"location":"faqs/#How-to-index-solution-objects-using-symbolic-variables-and-observables?","page":"FAQs","title":"How to index solution objects using symbolic variables and observables?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"One can directly use symbolic variables to index into SciML solution objects. Moreover, observables can also be evaluated in this way. For example, consider the system","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst, DifferentialEquations, Plots\nrn = @reaction_network ABtoC begin\n  (k₊,k₋), A + B <--> C\nend k₊ k₋\n\n# initial condition and parameter values\nsetdefaults!(rn, [:A => 1.0, :B => 2.0, :C => 0.0, :k₊ => 1.0, :k₋ => 1.0])","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Let's convert it to a system of ODEs, using the conservation laws of the system to eliminate two of the species:","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"osys = convert(ODESystem, rn; remove_conserved=true)\nshow(osys) # hide","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Notice the resulting ODE system has just one ODE","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"equations(osys)\nshow(equations(osys)) # hide","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"while algebraic observables have been added for the two removed species (in terms of the conservation law constants, _ConLaw[1] and _ConLaw[2])","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"observed(osys)\nshow(observed(osys))  # hide","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Let's solve the system and see how to index the solution using our symbolic variables","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"oprob = ODEProblem(osys, [], (0.0, 10.0), [])\nsol = solve(oprob, Tsit5())","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Suppose we want to plot just species C, without having to know its integer index in the state vector. We can do this using the symbolic variable C, which we can get at in several ways","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"sol[osys.C]","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"or","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"@unpack C = osys\nsol[C]","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"To evaluate C at specific times and plot it we can just do","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"t = range(0.0, 10.0, length=101)\nplot(t, sol(t, idxs = C), label = \"C(t)\", xlabel = \"t\")","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"If we want to get multiple variables we can just do","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"@unpack A, B = osys\nsol(t, idxs = [A, B])","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Plotting multiple variables using the SciML plot recipe can be achieved like","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"plot(sol; idxs = [A, B])","category":"page"},{"location":"faqs/#How-to-disable-rescaling-of-reaction-rates-in-rate-laws?","page":"FAQs","title":"How to disable rescaling of reaction rates in rate laws?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"As explained in the Reaction rate laws used in simulations section, for a reaction such as k, 2X --> 0, the generated rate law will rescale the rate constant, giving k*X^2/2 instead of k*X^2 for ODEs and k*X*(X-1)/2 instead of k*X*(X-1) for jumps. This can be disabled when directly converting a ReactionSystem. If rn is a generated ReactionSystem, we can do","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"osys = convert(ODESystem, rn; combinatoric_ratelaws=false)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Disabling these rescalings should work for all conversions of ReactionSystems to other ModelingToolkit.AbstractSystems.","category":"page"},{"location":"faqs/#How-to-use-non-integer-stoichiometric-coefficients?","page":"FAQs","title":"How to use non-integer stoichiometric coefficients?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"rn = @reaction_network begin\n  k, 2.5*A --> 3*B\nend k","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"or directly via","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"@parameters k b\n@variables t A(t) B(t) C(t) D(t)\nrx1 = Reaction(k,[B,C],[B,D], [2.5,1],[3.5, 2.5])\nrx2 = Reaction(2*k, [B], [D], [1], [2.5])\nrx3 = Reaction(2*k, [B], [D], [2.5], [2])\n@named mixedsys = ReactionSystem([rx1,rx2,rx3],t,[A,B,C,D],[k,b])\nosys = convert(ODESystem, mixedsys; combinatoric_ratelaws=false)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Note, when using convert(ODESystem, mixedsys; combinatoric_ratelaws=false) the combinatoric_ratelaws=false parameter must be passed. This is also true when calling ODEProblem(mixedsys,...; combinatoric_ratelaws=false). As described above, this disables Catalyst's standard rescaling of reaction rates when generating reaction rate laws, see also the Reaction rate laws used in simulations section. Leaving this keyword out for systems with floating point stoichiometry will give an error message.","category":"page"},{"location":"faqs/#How-to-set-default-values-for-initial-conditions-and-parameters?","page":"FAQs","title":"How to set default values for initial conditions and parameters?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"When directly constructing a ReactionSystem these can be passed to the constructor, and allow solving the system without needing initial condition or parameter vectors in the generated problem. For example","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst, Plots, OrdinaryDiffEq\n@parameters β ν\n@variables t S(t) I(t) R(t)\nrx1 = Reaction(β, [S,I], [I], [1,1], [2])\nrx2 = Reaction(ν, [I], [R])\ndefs = [β => 1e-4, ν => .01, S => 999.0, I => 1.0, R => 0.0]\n@named sir = ReactionSystem([rx1,rx2],t; defaults=defs)\noprob = ODEProblem(sir, [], (0.0,250.0))\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"alternatively we could also have said","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"@parameters β=1e-4 ν=.01\n@variables t S(t)=999.0 I(t)=1.0 R(t)=0.0\nrx1 = Reaction(β, [S,I], [I], [1,1], [2])\nrx2 = Reaction(ν, [I], [R])\n@named sir = ReactionSystem([rx1,rx2],t)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"The @reaction_network macro does not currently provide a way to specify default values, however, they can be added after creating the system via the setdefaults! command, like","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"sir = @reaction_network sir begin\n    β, S + I --> 2I\n    ν, I --> R\nend β ν\nsetdefaults!(sir, [:β => 1e-4, :ν => .01, :S => 999.0, :I => 1.0, :R => 0.0])","category":"page"},{"location":"faqs/#How-to-specify-initial-conditions-and-parameters-values-for-ODEProblem-and-other-problem-types?","page":"FAQs","title":"How to specify initial conditions and parameters values for ODEProblem and other problem types?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"To explicitly pass initial conditions and parameters we can use mappings from Julia Symbols corresponding to each variable/parameter to values, or from ModelingToolkit symbolic variables to each variable/parameter. Using Symbols we have","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"rn = @reaction_network begin\n    α, S + I --> 2I\n    β, I --> R\nend α β\nu0 = [:S => 999.0, :I => 1.0, :R => 0.0]\np  = (:α => 1e-4, :β => .01)\nop  = ODEProblem(rn, u0, (0.0,250.0), p)\nsol = solve(op, Tsit5())","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"while using ModelingToolkit symbolic variables we have","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"@parameters α β\n@variables t S(t) I(t) R(t)\nu0 = [S => 999.0, I => 1.0, R => 0.0]\np  = (α => 1e-4, β => .01)\nop  = ODEProblem(rn, u0, (0.0,250.0), p)\nsol = solve(op, Tsit5())","category":"page"},{"location":"faqs/#How-to-modify-generated-ODEs?","page":"FAQs","title":"How to modify generated ODEs?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Conversion to other ModelingToolkit.AbstractSystems allows the possibility to modify the system with further terms that are difficult to encode as a chemical reaction. For example, suppose we wish to add a forcing term, 10sin(10t), to the ODE for dX/dt above. We can do so as:","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"dXdteq = equations(osys)[1]\nt      = get_iv(osys)\ndXdteq = Equation(dXdteq.lhs, dXdteq.rhs + 10*sin(10*t))\n@named osys2  = ODESystem([dXdteq], t, states(osys), parameters(osys))\noprob  = ODEProblem(osys2, u0map, tspan, pmap)\nosol   = solve(oprob, Tsit5())","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"We can add e^-X to dXdt as a forcing term by","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"dXdteq = equations(osys)[1]\n@variables X(t)\ndXdteq = Equation(dXdteq.lhs, dXdteq.rhs + exp(-X))\n@named osys2  = ODESystem([dXdteq], t, states(osys), parameters(osys))\noprob  = ODEProblem(osys2, u0map, tspan, pmap)\nosol   = solve(oprob, Tsit5())","category":"page"},{"location":"faqs/#How-to-override-mass-action-kinetics-rate-laws?","page":"FAQs","title":"How to override mass action kinetics rate laws?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"While generally one wants the reaction rate law to use the law of mass action, so the reaction","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"rn = @reaction_network begin\n  k, X --> ∅\nend k","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"occurs at the (ODE) rate dXdt = -kX, it is possible to override this by using any of the following non-filled arrows when declaring the reaction: ⇐, ⟽, ⇒, ⟾, ⇔, ⟺. This means that the reaction","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"rn = @reaction_network begin\n  k, X ⇒ ∅\nend k","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"will occur at rate dXdt = -k (which might become a problem since X will be degraded at a constant rate even when very small or equal to 0).","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Note, stoichiometric coefficients are still included, i.e. the reaction","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"rn = @reaction_network begin\n  k, 2*X ⇒ ∅\nend k","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"has rate dXdt = -2 k.","category":"page"},{"location":"faqs/#user_functions","page":"FAQs","title":"How to specify user defined functions as reaction rates?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"The reaction network DSL can \"see\" user defined functions that work with ModelingToolkit. e.g., this is should work","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"myHill(x) = 2.0*x^3/(x^3+1.5^3)\nrn = @reaction_network begin\n  myHill(X), ∅ → X\nend","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"In some cases, it may be necessary or desirable to register functions with Symbolics.jl before their use in Catalyst, see the discussion here.","category":"page"},{"location":"#Catalyst.jl-for-Reaction-Network-Modeling","page":"Home","title":"Catalyst.jl for Reaction Network Modeling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst.jl is a symbolic modeling package for analysis and high performance simulation of chemical reaction networks. Catalyst defines symbolic ReactionSystems, which can be created programmatically or easily specified using Catalyst's domain specific language (DSL). Leveraging ModelingToolkit and Symbolics.jl, Catalyst enables large-scale simulations through auto-vectorization and parallelism. Symbolic ReactionSystems can be used to generate ModelingToolkit-based models, allowing the easy simulation and parameter estimation of mass action ODE models, Chemical Langevin SDE models, stochastic chemical kinetics jump process models, and more. Generated models can be used with solvers throughout the broader SciML ecosystem, including higher level SciML packages (e.g. for sensitivity analysis, parameter estimation, machine learning applications, etc).","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DSL provides a simple and readable format for manually specifying chemical reactions.\nCatalyst ReactionSystems provide a symbolic representation of reaction networks, built on ModelingToolkit.jl and Symbolics.jl.\nNon-integer (e.g. Float64) stoichiometric coefficients are supported for generating ODE models, and symbolic expressions for stoichiometric coefficients are supported for all system types.\nThe Catalyst.jl API provides functionality for extending networks, building networks programmatically, network analysis, and for composing multiple networks together.\nReactionSystems generated by the DSL can be converted to a variety of ModelingToolkit.AbstractSystems, including symbolic ODE, SDE and jump process representations.\nConservation laws can be detected and applied to reduce system sizes, and generate non-singular Jacobians, during conversion to ODEs, SDEs, and steady-state equations.\nBy leveraging ModelingToolkit, users have a variety of options for generating optimized system representations to use in solvers. These include construction of dense or sparse Jacobians, multithreading or parallelization of generated derivative functions, automatic classification of reactions into optimized jump types for Gillespie type simulations, automatic construction of dependency graphs for jump systems, and more.\nGenerated systems can be solved using any DifferentialEquations.jl ODE/SDE/jump solver, and can be used within EnsembleProblems for carrying out parallelized parameter sweeps and statistical sampling. Plot recipes are available for visualizing the solutions.\nJulia Exprs can be obtained for all rate laws and functions determining the deterministic and stochastic terms within resulting ODE, SDE or jump models.\nLatexify can be used to generate LaTeX expressions corresponding to generated mathematical models or the underlying set of reactions.\nGraphviz can be used to generate and visualize reaction network graphs. (Reusing the Graphviz interface created in Catlab.jl.)","category":"page"},{"location":"#Packages-Supporting-Catalyst","page":"Home","title":"Packages Supporting Catalyst","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst ReactionSystems can be imported from SBML files via SBMLToolkit.jl, and from BioNetGen .net files and various stoichiometric matrix network representations using ReactionNetworkImporters.jl.\nMomentClosure.jl allows generation of symbolic ModelingToolkit ODESystems, representing moment closure approximations to moments of the Chemical Master Equation, from reaction networks defined in Catalyst.\nFiniteStateProjection.jl allows the construction and numerical solution of Chemical Master Equation models from reaction networks defined in Catalyst.\nDelaySSAToolkit.jl can augment Catalyst reaction network models with delays, and can simulate the resulting stochastic chemical kinetics with delays models.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst can be installed through the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add Catalyst\nusing Catalyst","category":"page"},{"location":"#Illustrative-Example","page":"Home","title":"Illustrative Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a simple example of generating, visualizing and solving an SIR ODE model. We first define the SIR reaction model using Catalyst","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Catalyst\nrn = @reaction_network begin\n    α, S + I --> 2I\n    β, I --> R\nend α β","category":"page"},{"location":"","page":"Home","title":"Home","text":"Assuming Graphviz and is installed and command line accessible, the network can be visualized using the Graph command","category":"page"},{"location":"","page":"Home","title":"Home","text":"Graph(rn)","category":"page"},{"location":"","page":"Home","title":"Home","text":"which in Jupyter notebooks will give the figure","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: SIR Network Graph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To generate and solve a mass action ODE version of the model we use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using OrdinaryDiffEq\np     = [:α => .1/1000, :β => .01]\ntspan = (0.0,250.0)\nu0    = [:S => 999.0, :I => 1.0, :R => 0.0]\nop    = ODEProblem(rn, u0, tspan, p)\nsol   = solve(op, Tsit5())       # use Tsit5 ODE solver","category":"page"},{"location":"","page":"Home","title":"Home","text":"which we can plot as","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nplot(sol, lw=2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: SIR Solution)","category":"page"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst developers are active on the Julia Discourse, and the Julia Slack channels #sciml-bridged and #sciml-sysbio. For bugs or feature requests open an issue.","category":"page"},{"location":"#Supporting-and-Citing-Catalyst.jl","page":"Home","title":"Supporting and Citing Catalyst.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The software in this ecosystem was developed as part of academic research. If you would like to help support it,  please star the repository as such metrics may help us secure funding in the future. If you use Catalyst as part  of your research, teaching, or other activities, we would be grateful if you could cite our work:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article {2022Catalyst,\n\tauthor = {Loman, T. and Ma, Y. and Ilin, V. and Gowda, S. and Korsbo, N. and Yewale, N. and Rackauckas, C. V. and Isaacson, S. A.},\n\ttitle = {Catalyst: Fast Biochemical Modeling with Julia},\n\telocation-id = {2022.07.30.502135},\n\tyear = {2022},\n\tdoi = {10.1101/2022.07.30.502135},\n\tpublisher = {Cold Spring Harbor Laboratory},\n\tURL = {https://www.biorxiv.org/content/early/2022/08/02/2022.07.30.502135},\n\teprint = {https://www.biorxiv.org/content/early/2022/08/02/2022.07.30.502135.full.pdf},\n\tjournal = {bioRxiv}\n}","category":"page"},{"location":"tutorials/models/#Model-Simulation","page":"Model Simulation","title":"Model Simulation","text":"","category":"section"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"Once created, a reaction network can be used as input to various problem types, which can be solved by DifferentialEquations.jl, and more broadly used within SciML packages.","category":"page"},{"location":"tutorials/models/#Deterministic-simulations-using-ODEs","page":"Model Simulation","title":"Deterministic simulations using ODEs","text":"","category":"section"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"A reaction network can be used as input to an ODEProblem instead of a function, using","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"odeprob = ODEProblem(rn, args...; kwargs...)","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"E.g., a model can be created and solved using:","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"using DiffEqBase, OrdinaryDiffEq\nrn = @reaction_network begin\n  p, ∅ → X\n  d, X → ∅\nend p d\np = [1.0,2.0]\nu0 = [0.1]\ntspan = (0.,1.)\nprob = ODEProblem(rn,u0,tspan,p)\nsol = solve(prob, Tsit5())","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"Here, the order of unknowns in u0 and p matches the order that species and parameters first appear within the DSL. They can also be determined by examining the ordering within the species(rn) and parameters vectors, or accessed more explicitly through the speciesmap(rn) and paramsmap(rn) dictionaries, which map the ModelingToolkit Terms and/or Syms corresponding to each species or parameter to their integer id. Note, if no parameters are given in the @reaction_network, then p does not need to be provided.","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"We can then plot the solution using the solution plotting recipe:","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"using Plots\nplot(sol, lw=2)","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"(Image: models1)","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"To solve for a steady-state starting from the guess u0, one can use","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"using SteadyStateDiffEq\nprob = SteadyStateProblem(rn,u0,p)\nsol = solve(prob, SSRootfind())","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"or","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"prob = SteadyStateProblem(rn,u0,p)\nsol = solve(prob, DynamicSS(Tsit5()))","category":"page"},{"location":"tutorials/models/#Stochastic-simulations-using-SDEs","page":"Model Simulation","title":"Stochastic simulations using SDEs","text":"","category":"section"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"In a similar way an SDE can be created using","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"using StochasticDiffEq\nsdeprob = SDEProblem(rn, args...; kwargs...)","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"In this case the chemical Langevin equations (as derived in Gillespie, J. Chem. Phys. 2000) will be used to generate stochastic differential equations.","category":"page"},{"location":"tutorials/models/#Stochastic-simulations-using-discrete-stochastic-simulation-algorithms","page":"Model Simulation","title":"Stochastic simulations using discrete stochastic simulation algorithms","text":"","category":"section"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"Instead of solving SDEs, one can create a stochastic jump process model using integer copy numbers and a discrete stochastic simulation algorithm (i.e., Gillespie Method or Kinetic Monte Carlo). This can be done using:","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"using JumpProcesses\nrn = @reaction_network begin\n  p, ∅ → X\n  d, X → ∅\nend p d\np = [1.0,2.0]\nu0 = [10]\ntspan = (0.,1.)\ndiscrete_prob = DiscreteProblem(rn, u0, tspan, p)\njump_prob = JumpProblem(rn, discrete_prob, Direct())\nsol = solve(jump_prob, SSAStepper())","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"Here, we used Gillespie's Direct method as the underlying stochastic simulation algorithm. We get:","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"plot(sol, lw=2)","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"(Image: models2)","category":"page"},{"location":"tutorials/models/#[Reaction](@ref)-fields","page":"Model Simulation","title":"Reaction fields","text":"","category":"section"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"Each Reaction within reactions(rn) has a number of subfields. For rx a Reaction we have:","category":"page"},{"location":"tutorials/models/","page":"Model Simulation","title":"Model Simulation","text":"rx.substrates, a vector of ModelingToolkit expressions storing each substrate variable.\nrx.products, a vector of ModelingToolkit expressions storing each product variable.\nrx.substoich, a vector storing the corresponding stoichiometry of each substrate species in rx.substrates.\nrx.prodstoich, a vector storing the corresponding stoichiometry of each product species in rx.products.\nrx.rate, a Number, ModelingToolkit.Sym, or ModelingToolkit expression representing the reaction rate. E.g., for a reaction like k*X, Y --> X+Y, we'd have rate = k*X.\nrx.netstoich, a vector of pairs mapping the ModelingToolkit expression for each species that changes numbers by the reaction to how much it changes. E.g., for k, X + 2Y --> X + W, we'd have rx.netstoich = [Y(t) => -2, W(t) => 1].\nrx.only_use_rate, a boolean that is true if the reaction was made with non-filled arrows and should ignore mass action kinetics. false by default.","category":"page"}]
}
