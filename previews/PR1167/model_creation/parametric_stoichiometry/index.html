<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic Stochiometries · Catalyst.jl</title><meta name="title" content="Symbolic Stochiometries · Catalyst.jl"/><meta property="og:title" content="Symbolic Stochiometries · Catalyst.jl"/><meta property="twitter:title" content="Symbolic Stochiometries · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/model_creation/parametric_stoichiometry/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/model_creation/parametric_stoichiometry/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/model_creation/parametric_stoichiometry/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Introduction to Catalyst</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Model creation and properties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../conservation_laws/">Working with conservation laws</a></li><li class="is-active"><a class="tocitem" href>Symbolic Stochiometries</a><ul class="internal"><li><a class="tocitem" href="#Using-symbolic-stoichiometry"><span>Using symbolic stoichiometry</span></a></li><li><a class="tocitem" href="#Gene-expression-with-randomly-produced-amounts-of-protein"><span>Gene expression with randomly produced amounts of protein</span></a></li></ul></li><li><a class="tocitem" href="../model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../reactionsystem_content_accessing/">Accessing model properties</a></li><li><a class="tocitem" href="../network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Model simulation and visualization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for performant ODE simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for performant SDE simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/examples/periodic_events_simulation/">Modelling a periodic event during ODE and jump simulations</a></li><li><a class="tocitem" href="../../model_simulation/examples/interactive_brusselator_simulation/">Interactive Simulation and Plotting</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Steady state analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Inverse problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/petab_ode_param_fitting/">Parameter Fitting for ODEs using PEtab.jl</a></li><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Spatial modelling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial jump simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../devdocs/dev_guide/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model creation and properties</a></li><li class="is-active"><a href>Symbolic Stochiometries</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic Stochiometries</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/model_creation/parametric_stoichiometry.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="parametric_stoichiometry"><a class="docs-heading-anchor" href="#parametric_stoichiometry">Symbolic Stochiometries</a><a id="parametric_stoichiometry-1"></a><a class="docs-heading-anchor-permalink" href="#parametric_stoichiometry" title="Permalink"></a></h1><p>Catalyst supports stoichiometric coefficients that involve parameters, species, or even general expressions. In this tutorial we show several examples of how to use symbolic stoichiometries, and discuss several caveats to be aware of.</p><h2 id="Using-symbolic-stoichiometry"><a class="docs-heading-anchor" href="#Using-symbolic-stoichiometry">Using symbolic stoichiometry</a><a id="Using-symbolic-stoichiometry-1"></a><a class="docs-heading-anchor-permalink" href="#Using-symbolic-stoichiometry" title="Permalink"></a></h2><p>Let&#39;s first consider a simple reversible reaction where the number of reactants is a parameter, and the number of products is the product of two parameters.</p><pre><code class="language-julia hljs">using Catalyst, Latexify, OrdinaryDiffEqTsit5, ModelingToolkit, Plots
revsys = @reaction_network revsys begin
    @parameters m::Int64 n::Int64
    k₊, m*A --&gt; (m*n)*B
    k₋, B --&gt; A
end
reactions(revsys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Reaction}:
 k₊, m*A --&gt; (m*n)*B
 k₋, B --&gt; A</code></pre><p>Notice, as described in the <a href="../../introduction_to_catalyst/introduction_to_catalyst/#introduction_to_catalyst_ratelaws">Reaction rate laws used in simulations</a> section, the default rate laws involve factorials in the stoichiometric coefficients. For this reason we explicitly specify <code>m</code> and <code>n</code> as integers (as otherwise ModelingToolkit will implicitly assume they are floating point).</p><p>As always the <code>@reaction_network</code> macro defaults to setting all symbols neither used as a reaction substrate nor a product to be parameters. Hence, in this example we have two species (<code>A</code> and <code>B</code>) and four parameters (<code>k₊</code>, <code>k₋</code>, <code>m</code>, and <code>n</code>). In addition, the stoichiometry is applied to the rightmost symbol in a given term, i.e. in the first equation the substrate <code>A</code> has stoichiometry <code>m</code> and the product <code>B</code> has stoichiometry <code>m*n</code>. For example, in</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    k, A*C --&gt; 2B
    end
reactions(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Reaction}:
 k, A*C --&gt; 2*B</code></pre><p>we see two species, <code>(B,C)</code>, with <code>A</code> treated as a parameter representing the stoichiometric coefficient of <code>C</code>, i.e.</p><pre><code class="language-julia hljs">rx = reactions(rn)[1]
rx.substrates[1],rx.substoich[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(C(t), A)</code></pre><p>We could have equivalently specified our systems directly via the Catalyst API. For example, for <code>revsys</code> we would could use</p><pre><code class="language-julia hljs">t = default_t()
@parameters k₊ k₋ m::Int n::Int
@species A(t), B(t)
rxs = [Reaction(k₊, [A], [B], [m], [m*n]),
       Reaction(k₋, [B], [A])]
revsys2 = ReactionSystem(rxs,t; name=:revsys)
revsys2 == revsys</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>or</p><pre><code class="language-julia hljs">rxs2 = [(@reaction k₊, $m*A --&gt; ($m*$n)*B),
        (@reaction k₋, B --&gt; A)]
revsys3 = ReactionSystem(rxs2,t; name=:revsys)
revsys3 == revsys</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Here we interpolate in the pre-declared <code>m</code> and <code>n</code> symbolic variables using <code>$m</code> and <code>$n</code> to ensure the parameter is known to be integer-valued. The <code>@reaction</code> macro again assumes all symbols are parameters except the substrates or reactants (i.e. <code>A</code> and <code>B</code>). For example, in <code>@reaction k, F*A + 2(H*G+B) --&gt; D</code>, the substrates are <code>(A,G,B)</code> with stoichiometries <code>(F,2*H,2)</code>.</p><p>Let&#39;s now convert <code>revsys</code> to ODEs and look at the resulting equations:</p><pre><code class="language-julia hljs">osys = convert(ODESystem, revsys)
osys = complete(osys)
equations(osys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Equation}:
 Differential(t)(A(t)) ~ (-k₊*m*(A(t)^m)) / factorial(m) + k₋*B(t)
 Differential(t)(B(t)) ~ (k₊*m*n*(A(t)^m)) / factorial(m) - k₋*B(t)</code></pre><p>Specifying the parameter and initial condition values,</p><pre><code class="language-julia hljs">p  = (revsys.k₊ =&gt; 1.0, revsys.k₋ =&gt; 1.0, revsys.m =&gt; 2, revsys.n =&gt; 2)
u₀ = [revsys.A =&gt; 1.0, revsys.B =&gt; 1.0]
oprob = ODEProblem(osys, u₀, (0.0, 1.0), p)</code></pre><p>we can now solve and plot the system</p><pre><code class="language-julia hljs">sol = solve(oprob, Tsit5())
plot(sol)</code></pre><img src="6e03ec44.svg" alt="Example block output"/><p>An alternative approach to avoid the issues of using mixed floating point and integer variables is to disable the rescaling of rate laws as described in <a href="../../introduction_to_catalyst/introduction_to_catalyst/#introduction_to_catalyst_ratelaws">Reaction rate laws used in simulations</a> section. This requires passing the <code>combinatoric_ratelaws=false</code> keyword to <code>convert</code> or to <code>ODEProblem</code> (if directly building the problem from a <code>ReactionSystem</code> instead of first converting to an <code>ODESystem</code>). For the previous example this gives the following (different) system of ODEs where we now let <code>m</code> and <code>n</code> be floating point valued parameters (the default):</p><pre><code class="language-julia hljs">revsys = @reaction_network revsys begin
    k₊, m*A --&gt; (m*n)*B
    k₋, B --&gt; A
end
osys = convert(ODESystem, revsys; combinatoric_ratelaws = false)
osys = complete(osys)
equations(osys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Equation}:
 Differential(t)(A(t)) ~ k₋*B(t) - k₊*m*(A(t)^m)
 Differential(t)(B(t)) ~ -k₋*B(t) + k₊*m*n*(A(t)^m)</code></pre><p>Since we no longer have factorial functions appearing, our example will now run with <code>m</code> and <code>n</code> treated as floating point parameters:</p><pre><code class="language-julia hljs">p  = (revsys.k₊ =&gt; 1.0, revsys.k₋ =&gt; 1.0, revsys.m =&gt; 2.0, revsys.n =&gt; 2.0)
oprob = ODEProblem(osys, u₀, (0.0, 1.0), p)
sol = solve(oprob, Tsit5())
plot(sol)</code></pre><img src="c1d568d9.svg" alt="Example block output"/><h2 id="Gene-expression-with-randomly-produced-amounts-of-protein"><a class="docs-heading-anchor" href="#Gene-expression-with-randomly-produced-amounts-of-protein">Gene expression with randomly produced amounts of protein</a><a id="Gene-expression-with-randomly-produced-amounts-of-protein-1"></a><a class="docs-heading-anchor-permalink" href="#Gene-expression-with-randomly-produced-amounts-of-protein" title="Permalink"></a></h2><p>As a second example, let&#39;s build the negative feedback model from <a href="https://augustinas1.github.io/MomentClosure.jl/dev/tutorials/geometric_reactions+conditional_closures/">MomentClosure.jl</a> that involves a bursty reaction that produces a random amount of protein.</p><p>In our model <code>G₋</code> will denote the repressed state, and <code>G₊</code> the active state where the gene can transcribe. <code>P</code> will denote the protein product of the gene. We will assume that proteins are produced in bursts that produce <code>m</code> proteins, where <code>m</code> is a (shifted) geometric random variable with mean <code>b</code>. To define <code>m</code> we must register the <code>Distributions.Geometric</code> distribution from Distributions.jl with Symbolics.jl, after which we can use it in symbolic expressions:</p><pre><code class="language-julia hljs">using Distributions: Geometric
@register_symbolic Geometric(b)
@parameters b
m = rand(Geometric(1/b)) + 1</code></pre><p>Note, as we require the shifted geometric distribution, we add one to Distributions.jl&#39;s <code>Geometric</code> random variable (which includes zero).</p><p>We can now define our model</p><pre><code class="language-julia hljs">burstyrn = @reaction_network burstyrn begin
    k₊, G₋ --&gt; G₊
    k₋*P^2, G₊ --&gt; G₋
    kₚ, G₊ --&gt; G₊ + $m*P
    γₚ, P --&gt; ∅
end
reactions(burstyrn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Reaction}:
 k₊, G₋ --&gt; G₊
 k₋*(P(t)^2), G₊ --&gt; G₋
 kₚ, G₊ --&gt; G₊ + (1 + rand(Distributions.Geometric(1 / b)))*P
 γₚ, P --&gt; ∅</code></pre><p>The parameter <code>b</code> does not need to be explicitly declared in the <code>@reaction_network</code> macro as it is detected when the expression <code>rand(Geometric(1/b)) + 1</code> is substituted for <code>m</code>.</p><p>We next convert our network to a jump process representation</p><pre><code class="language-julia hljs">using JumpProcesses
jsys = convert(JumpSystem, burstyrn; combinatoric_ratelaws = false)
jsys = complete(jsys)
equations(jsys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(JumpProcesses.MassActionJump[JumpProcesses.MassActionJump{Num, Vector{Pair{Any, Int64}}, Vector{Pair{Any, Int64}}, Nothing}(k₊, Pair{Any, Int64}[G₋(t) =&gt; 1], Pair{Any, Int64}[G₊(t) =&gt; 1, G₋(t) =&gt; -1], nothing), JumpProcesses.MassActionJump{Num, Vector{Pair{Any, Int64}}, Vector{Pair{Any, Int64}}, Nothing}(γₚ, Pair{Any, Int64}[P(t) =&gt; 1], Pair{Any, Int64}[P(t) =&gt; -1], nothing)], JumpProcesses.ConstantRateJump[JumpProcesses.ConstantRateJump{SymbolicUtils.BasicSymbolic{Real}, Vector{Equation}}(k₋*G₊(t)*(P(t)^2), Equation[G₊(t) ~ -1 + G₊(t), G₋(t) ~ 1 + G₋(t)]), JumpProcesses.ConstantRateJump{SymbolicUtils.BasicSymbolic{Real}, Vector{Equation}}(kₚ*G₊(t), Equation[P(t) ~ 1 + rand(Distributions.Geometric(1 / b)) + P(t)])], JumpProcesses.VariableRateJump[], Equation[])</code></pre><p>Notice, the <code>equations</code> of <code>jsys</code> have three <code>MassActionJump</code>s for the first three reactions, and one <code>ConstantRateJump</code> for the last reaction. If we examine the <code>ConstantRateJump</code> more closely we can see the generated <code>rate</code> and <code>affect!</code> functions for the bursty reaction that makes protein</p><pre><code class="language-julia hljs">equations(jsys)[4].rate</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">kₚ*G₊(t)</code></pre><pre><code class="language-julia hljs">equations(jsys)[4].affect!</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Equation}:
 P(t) ~ 1 + rand(Distributions.Geometric(1 / b)) + P(t)</code></pre><p>Finally, we can now simulate our <code>JumpSystem</code></p><pre><code class="language-julia hljs">pmean = 200
bval = 70
γₚval = 1
k₋val = 0.001
k₊val = 0.05
kₚval = pmean * γₚval * (k₋val * pmean^2 + k₊val) / (k₊val * bval)
p = symmap_to_varmap(jsys, (:k₊ =&gt; k₊val, :k₋ =&gt; k₋val, :kₚ =&gt; kₚval,
                            :γₚ =&gt; γₚval, :b =&gt; bval))
u₀ = symmap_to_varmap(jsys, [:G₊ =&gt; 1, :G₋ =&gt; 0, :P =&gt; 1])
tspan = (0., 6.0)   # time interval to solve over
dprob = DiscreteProblem(jsys, u₀, tspan, p)
jprob = JumpProblem(jsys, dprob, Direct())
sol = solve(jprob)
plot(sol.t, sol[jsys.P], legend = false, xlabel = &quot;time&quot;, ylabel = &quot;P(t)&quot;)</code></pre><img src="5f234b44.svg" alt="Example block output"/><p>To double check our results are consistent with MomentClosure.jl, let&#39;s calculate and plot the average amount of protein (which is also plotted in the MomentClosure.jl <a href="https://augustinas1.github.io/MomentClosure.jl/dev/tutorials/geometric_reactions+conditional_closures/">tutorial</a>).</p><pre><code class="language-julia hljs">t = default_t()
function getmean(jprob, Nsims, tv)
    Pmean = zeros(length(tv))
    @variables P(t)
    for n in 1:Nsims
        sol = solve(jprob)
        Pmean .+= sol(tv, idxs=P)
    end
    Pmean ./= Nsims
end
tv = range(tspan[1],tspan[2],step=.1)
psim_mean = getmean(jprob, 20000, tv)
plot(tv, psim_mean; ylabel = &quot;average of P(t)&quot;, xlabel = &quot;time&quot;,
                    xlim = (0.0,6.0), legend = false)</code></pre><img src="a34abf5f.svg" alt="Example block output"/><p>Comparing, we see similar averages for <code>P(t)</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../conservation_laws/">« Working with conservation laws</a><a class="docs-footer-nextpage" href="../model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 9 January 2025 00:59">Thursday 9 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
