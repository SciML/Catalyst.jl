var documenterSearchIndex = {"docs":
[{"location":"steady_state_functionality/dynamical_systems/#dynamical_systems","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"","category":"section"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"The DynamicalSystems.jl package implements a wide range of methods for analysing dynamical systems[1][2]. This includes both continuous-time systems (i.e. ODEs) and discrete-times ones (difference equations, however, these are not relevant to chemical reaction network modelling). Here we give two examples of how DynamicalSystems.jl can be used, with the package's documentation describing many more features. Finally, it should also be noted that DynamicalSystems.jl contain several tools for analysing data measured from dynamical systems.","category":"page"},{"location":"steady_state_functionality/dynamical_systems/#dynamical_systems_basins_of_attraction","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Finding basins of attraction","text":"","category":"section"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"Given enough time, an ODE will eventually reach a so-called attractor. For chemical reaction networks (CRNs), this will typically be either a steady state or a limit cycle. Since ODEs are deterministic, which attractor a simulation will reach is uniquely determined by the initial condition (assuming parameter values are fixed). Conversely, each attractor is associated with a set of initial conditions such that model simulations originating in these will tend to that attractor. These sets are called basins of attraction. Here, phase space (the space of all possible states of the system) can be divided into a number of basins of attraction equal to the number of attractors. ","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"DynamicalSystems.jl provides a simple interface for finding an ODE's basins of attraction across any given subspace of phase space. In this example we will use the bistable Wilhelm model (which steady states we have previous computed using homotopy continuation). As a first step, we create an ODEProblem corresponding to the model which basins of attraction we wish to compute. For this application, u0 and tspan is unused, and their values are of little importance (the only exception is than tspan, for implementation reason, must provide a not too small interval, we recommend minimum (0.0, 1.0)). ","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"using Catalyst\nwilhelm_model = @reaction_network begin\n    k1, Y --> 2X\n    k2, 2X --> X + Y\n    k3, X + Y --> Y\n    k4, X --> 0\nend\n\nu0 = [:X => 0.0, :Y => .0]\ntspan = (0.0, 10.0)\nps = [:k1 => 8.0, :k2 => 2.0, :k3 => 1.0, :k4 => 1.5]\noprob = ODEProblem(wilhelm_model, u0, tspan, ps)\nnothing # hide","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"Next, for any application of DynamicalSystems.jl, our ODEProblem must be converted into a so-called CoupledODEs structure. This is done by combining the ODE with the solver (and potential solver options) with which we wish to simulate it (just like when it is simulated using solve). Here, we will simply designate the Tsit5 numeric solver (but provide no other options).","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"using DynamicalSystems, OrdinaryDiffEqTsit5\nds = CoupledODEs(oprob, (alg = Tsit5(),))","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"We can now compute the basins of attraction. This is done by first creating a grid that designates which subspace of phase-space we wish to investigate (here, the corresponding basin of attraction is found for every point on the grid). Next, we create a AttractorsViaRecurrences struct, that maps initial conditions to attractors, and then use that as input to the basins_of_attraction function.","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"# We provide one grid of values for each species. These are then bundled into a tuple.\nx_grid = 0.0:0.03:6.0\ny_grid = 0.0:0.03:9.0\ngrid = (x_grid, y_grid)\navr = AttractorsViaRecurrences(ds, grid)\nbasins, attractors = basins_of_attraction(avr, grid; show_progress = false)\nattractors","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"Here, attractors is a dictionary that maps attractor labels (integers) to attractors. In this case we have two fixed points, one at (0000) and one at (4560). Next, basins is a matrix of equal size to grid, where each value is an integer describing to which attractor's basin that state belongs.","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"DynamicalSystems.jl also provides a simple interface for plotting the resulting basins. This uses Makie.jl, an alternative plotting package to Plots.jl (which is typically the preferred plotting package within the context of Catalyst). Generally, Makie is good at creating animations or interactive graphics (however, it is also a popular competitor to Plots.jl for general-purpose plotting). ","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"using CairoMakie\nheatmap_basins_attractors(grid, basins, attractors)","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"Here, in addition to the basins of attraction, the system's three steady states are marked (the one at the intersection of the two basins is unstable).","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"warning: Warning\nBoth Makie and Plots.jl exports a function called plot. Hence, if both these packages are imported into the same session, calls to plot must be prepended with the package one wishes to use (e.g. Plots.plot(sol)).","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"More information on how to compute basins of attractions for ODEs using DynamicalSystems.jl can be found here.","category":"page"},{"location":"steady_state_functionality/dynamical_systems/#dynamical_systems_lyapunov_exponents","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Computing Lyapunov exponents","text":"","category":"section"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"Lyapunov exponents are scalar values that can be computed for any attractor of an ODE. For an ODE with n variables, for each state, a total of n Lyapunov exponents can be computed (and these are collectively called the Lyapunov spectrum). Positive Lyapunov exponents indicate that trajectories initially infinitesimally close diverge from each other. Conversely, negative Lyapunov exponents suggests that trajectories converge to each others. ","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"While Lyapunov exponents can be used for other purposes, they are primarily used to characterise chaotic behaviours (where small changes in initial conditions has large effect on the resulting trajectories). Generally, an ODE exhibit chaotic behaviour if its attractor(s) have at least one positive Lyapunov exponent. Practically, Lyapunov exponents can be computed using DynamicalSystems.jl's lyapunovspectrum function. Here we will use it to investigate two models, one which exhibits chaos and one which do not.","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"First, let us consider the Willamowski–Rössler model, which is known to exhibit chaotic behaviour.","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"using Catalyst\nwr_model = @reaction_network begin\n    k1, 2X --> 3X\n    k2, X --> 2X\n    k3, Z + 2X --> 2Z\n    k4, Y + X --> 2Y\n    k5, Y --> ∅\n    k6, 2Z --> ∅\n    k7, Z --> ∅\nend","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"We can simulate the model, noting that its behaviour seems chaotic.","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"using OrdinaryDiffEqRosenbrock, Plots\n\nu0 = [:X => 1.5, :Y => 1.5, :Z => 1.5]\ntspan = (0.0, 100.0)\np = [:k1 => 2.1, :k2 => 0.7, :k3 => 2.9, :k4 => 1.1, :k5 => 1.0, :k6 => 0.5, :k7 => 2.7]\n\noprob = ODEProblem(wr_model, u0, tspan, p)\nsol = solve(oprob, Rodas5P())\nplot(sol; idxs=(:X, :Y, :Z))","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"Next, like when we computed basins of attraction, we create a CoupledODEs corresponding to the model and state for which we wish to compute our Lyapunov spectrum. Lke previously, tspan must provide some small interval (at least (0.0, 1.0) is recommended), but else have no impact on the computed Lyapunov spectrum.","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"using DynamicalSystems\nds = CoupledODEs(oprob, (alg = Rodas5P(autodiff = false),))\nnothing # hide","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"Here, the autodiff = false argument is required when Lyapunov spectrums are computed. We can now provide our CoupledODEs (ds) to lyapunovspectrum to compute the lyapunov spectrum. This function requires a second argument (here set to 100). Generally setting this to a higher value will increase accuracy, but also increase runtime (since lyapunovspectrum is fast for most systems, setting this to a large value is recommended).","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"lyapunovspectrum(ds, 100)","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"Here, the largest exponent is positive, suggesting that the model is chaotic (or, more accurately, it has at least one chaotic attractor, to which is approached from the initial condition (151515)).","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"Next, we consider the [Brusselator] model. First we simulate the model for two similar initial conditions, confirming that they converge to the same limit cycle:","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"using OrdinaryDiffEqTsit5\nbrusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend\n\nu0_1 = [:X => 1.0, :Y => 1.0]\nu0_2 = [:X => 1.2, :Y => 1.0]\ntspan = (0., 25.)\nps = [:A => 1.0, :B => 4.0]\n\noprob1 = ODEProblem(brusselator, u0_1, tspan, ps)\noprob2 = ODEProblem(brusselator, u0_2, tspan, ps)\nosol1  = solve(oprob1, Tsit5())\nosol2  = solve(oprob2, Tsit5())\nplot(osol1; idxs = (:X, :Y))\nplot!(osol2; idxs = (:X, :Y))","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"Next, we compute the Lyapunov spectrum at one of the initial conditions:","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"ds = CoupledODEs(oprob1, (alg = Rodas5P(autodiff = false),))\nlyapunovspectrum(ds, 100)","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"Here, all Lyapunov exponents are negative, confirming that the brusselator is non-chaotic.","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"More details on how to compute Lyapunov exponents using DynamicalSystems.jl can be found here. A full overview of tools for analysing chaotic behaviours (using the \"ChaosTools.jl subpackage) can be found here.","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"","category":"page"},{"location":"steady_state_functionality/dynamical_systems/#dynamical_systems_citations","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Citations","text":"","category":"section"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"If you use this functionality in your research, in addition to Catalyst, please cite the following paper to support the author of the DynamicalSystems.jl package:","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"@article{DynamicalSystems.jl-2018,\n  doi = {10.21105/joss.00598},\n  url = {https://doi.org/10.21105/joss.00598},\n  year  = {2018},\n  month = {mar},\n  volume = {3},\n  number = {23},\n  pages = {598},\n  author = {George Datseris},\n  title = {DynamicalSystems.jl: A Julia software library for chaos and nonlinear dynamics},\n  journal = {Journal of Open Source Software}\n}","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"","category":"page"},{"location":"steady_state_functionality/dynamical_systems/#Learning-more","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Learning more","text":"","category":"section"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"If you want to learn more about analysing dynamical systems, including chaotic behaviour, see the textbook Nonlinear Dynamics. It utilizes DynamicalSystems.jl and provides a concise, hands-on approach to learning nonlinear dynamics and analysing dynamical systems [3].","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"","category":"page"},{"location":"steady_state_functionality/dynamical_systems/#References","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"References","text":"","category":"section"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"[1]: S. H. Strogatz, Nonlinear Dynamics and Chaos, Westview Press (1994).","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"[2]: A. M. Lyapunov, The general problem of the stability of motion, International Journal of Control (1992).","category":"page"},{"location":"steady_state_functionality/dynamical_systems/","page":"Analysing model steady state properties with DynamicalSystems.jl","title":"Analysing model steady state properties with DynamicalSystems.jl","text":"[3]: G. Datseris, U. Parlitz, Nonlinear dynamics: A concise introduction interlaced with code, Springer (2022).","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/#homotopy_continuation","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"","category":"section"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"The steady states of a dynamical system dx over dt = f(x) can be found by solving 0 = f(x). This is typically a hard problem, and generally, there is no method guaranteed to find all steady states for a system that has multiple ones. However, many chemical reaction networks generate polynomial systems (for example those which are purely mass action or have only have Hill functions with integer Hill exponents). The roots of these can reliably be found through a homotopy continuation algorithm[1][2]. This is implemented in Julia through the HomotopyContinuation.jl package[3].","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Catalyst contains a special homotopy continuation extension that is loaded whenever HomotopyContinuation.jl is. This exports a single function, hc_steady_states, that can be used to find the steady states of any ReactionSystem structure.","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"For this tutorial, we will use the Wilhelm model (which demonstrates bistability in a small chemical reaction network). We declare the model and the parameter set for which we want to find the steady states:","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"using Catalyst\nimport HomotopyContinuation\n\nwilhelm_2009_model = @reaction_network begin\n    k1, Y --> 2X\n    k2, 2X --> X + Y\n    k3, X + Y --> Y\n    k4, X --> 0\nend\nps = [:k1 => 8.0, :k2 => 2.0, :k3 => 1.0, :k4 => 1.5]\nnothing # hide","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Here, we only run import HomotopyContinuation as we do not require any of its functions, and just need it to be present in the current scope for the extension to be activated.","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Now we can find the steady states using:","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"hc_steady_states(wilhelm_2009_model, ps)","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"The order of the species in the output vectors are the same as in species(wilhelm_2009_model).","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"It should be noted that the steady state multivariate polynomials produced by reaction systems may have both imaginary and negative roots, which are filtered away by hc_steady_states. If you want the negative roots, you can use the hc_steady_states(wilhelm_2009_model, ps; filter_negative=false) argument.","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/#homotopy_continuation_conservation_laws","page":"Finding Steady States through Homotopy Continuation","title":"Systems with conservation laws","text":"","category":"section"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Some systems are under-determined, and have an infinite number of possible steady states. These are typically systems containing a conservation law, e.g.","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"using Catalyst # hide\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"Catalyst allows the conservation laws of such systems to be computed using the conservationlaws function. By using these to reduce the dimensionality of the system, as well as specifying the initial amount of each species, homotopy continuation can again be used to find steady states. Here we do this by designating such an initial condition (which is used to compute the system's conserved quantities, in this case X1 + X2):","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"import HomotopyContinuation # hide\nps = [:k1 => 2.0, :k2 => 1.0]\nu0 = [:X1 => 1.0, :X2 => 1.0]\nhc_steady_states(two_state_model, ps; u0)","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/#Final-notes","page":"Finding Steady States through Homotopy Continuation","title":"Final notes","text":"","category":"section"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"hc_steady_states support any systems where all rates are systems of rational polynomials (such as Hill functions with integer Hill coefficients).\nWhen providing initial conditions to compute conservation laws, values are only required for those species that are part of conserved quantities. If this set of species is unknown, it is recommended to provide initial conditions for all species. \nAdditional arguments provided to hc_steady_states are automatically passed to HomotopyContinuation's solve command. Use e.g. show_progress = false to disable the progress bar.","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/#homotopy_continuation_citation","page":"Finding Steady States through Homotopy Continuation","title":"Citation","text":"","category":"section"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"If you use this functionality in your research, please cite the following paper to support the authors of the HomotopyContinuation package:","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"@inproceedings{HomotopyContinuation.jl,\n  title={{H}omotopy{C}ontinuation.jl: {A} {P}ackage for {H}omotopy {C}ontinuation in {J}ulia},\n  author={Breiding, Paul and Timme, Sascha},\n  booktitle={International Congress on Mathematical Software},\n  pages={458--465},\n  year={2018},\n  organization={Springer}\n}","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/#References","page":"Finding Steady States through Homotopy Continuation","title":"References","text":"","category":"section"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"[1]: Andrew J Sommese, Charles W Wampler The Numerical Solution of Systems of Polynomials Arising in Engineering and Science, World Scientific (2005).","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"[2]: Daniel J. Bates, Paul Breiding, Tianran Chen, Jonathan D. Hauenstein, Anton Leykin, Frank Sottile, Numerical Nonlinear Algebra, arXiv (2023).","category":"page"},{"location":"steady_state_functionality/homotopy_continuation/","page":"Finding Steady States through Homotopy Continuation","title":"Finding Steady States through Homotopy Continuation","text":"[3]: Paul Breiding, Sascha Timme, HomotopyContinuation.jl: A Package for Homotopy Continuation in Julia, International Congress on Mathematical Software (2018).","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/#model_accessing","page":"Accessing model properties","title":"Accessing model properties","text":"","category":"section"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Catalyst is based around the creation, analysis, and simulation of chemical reaction network models. Catalyst stores these models in ReactionSystem structures. This page describes some basic functions for accessing the content of these structures. This includes retrieving lists of species, parameters, or reactions that a model consists of. An extensive list of relevant functions for working with ReactionSystem models can be found in Catalyst's API.","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"warning: Warning\nGenerally, a field of a Julia structure can be accessed through struct.fieldname. E.g. a simulation's time vector can be retrieved using simulation.t. While Catalyst ReactionSystems are structures, one should never access their fields using this approach, but rather using the accessor functions described below and in the API (direct accessing of fields can yield unexpected behaviours). E.g. to retrieve the species of a ReactionsSystem rs, use Catalyst.get_species(rs), not rs.species. The reason is that, as shown below, Catalyst (and more generally any [ModelingToolkit]https://github.com/SciML/ModelingToolkit.jl system types) reserves this type of accessing for accessing symbolic variables stored in the system. I.e. rs.X refers to the X symbolic variable, not a field in rs named \"X\".","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/#model_accessing_symbolic_variables","page":"Accessing model properties","title":"Direct accessing of symbolic model parameter and species","text":"","category":"section"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Previously we have described how the parameters and species that Catalyst models contain are represented using so-called symbolic variables (and how these enable the forming of symbolic expressions). We have described how, during programmatic modelling, the user has direct access to these and how this can be taken advantage of. We have also described how, during DSL-based modelling, the need for symbolic representation can be circumvented by using @unpack or by creating an observable. However, sometimes, it is easier to directly access a symbolic variable through the model itself, something which we will describe here.","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Let us consider the following two-state model","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"using Catalyst\nrs = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"If we wish to access one of the symbolic variables stored in it (here X1, X2, k1, and k2), we simply write ","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"rs.X1","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"to access e.g. X1. This symbolic variable can be used just like those declared using @parameters and @species:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"using OrdinaryDiffEqDefault\nu0 = [rs.X1 => 1.0, rs.X2 => 2.0]\nps = [rs.k1 => 2.0, rs.k2 => 4.0]\noprob = ODEProblem(rs, u0, (0.0, 10.0), ps)\nsol = solve(oprob)\nnothing # hide","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"We can also use them to form symbolic expressions:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Xtot = rs.X1 + rs.X2","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"which can be used when we e.g. plot our simulation:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"using Plots\nplot(sol; idxs = [rs.X1, rs.X2, Xtot])","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Next we create our two-state model programmatically:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"t = default_t()\n@species X1(t) X2(t)\n@parameters k1 k2\nrxs = [\n    Reaction(k1, [X1], [X2]),\n    Reaction(k2, [X2], [X1])\n]\n@named rs_prog = ReactionSystem(rxs, t)\nrs_prog = complete(rs_prog)\nnothing # hide","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Here, we can confirm that the symbolic variables we access through the model are identical to those we used to create it:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"isequal(rs.k1, k1)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"warning: Warning\nWhen accessing model symbolic variables through the model (using e.g. rs.X1), it is important to first ensure that the model has been marked complete.","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/#model_accessing_basics","page":"Accessing model properties","title":"Accessing basic model properties","text":"","category":"section"},{"location":"model_creation/reactionsystem_content_accessing/#model_accessing_basics_parameters_n_species","page":"Accessing model properties","title":"Accessing model parameter and species","text":"","category":"section"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Previously we showed how to access individual parameters or species of a ReactionSystem model. Next, the parameters and species functions allow us to retrieve all parameters and species as vectors:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"using Catalyst # hide\nsir = @reaction_network begin\n    α, S + I --> 2I\n    β, I --> R\nend\nparameters(sir)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"species(sir)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"These vectors contain the exact same symbolic variables that we would access through the system:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"issetequal([sir.S, sir.I, sir.R], species(sir))","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"If we wish to count the number of parameters or species in a system, we can do this directly through the numparams and numspecies functions:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"numparams(sir)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"numspecies(sir)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/#model_accessing_basics_reactions","page":"Accessing model properties","title":"Accessing model reactions","text":"","category":"section"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"A vector containing all a model's reactions can be retrieved using the reactions function:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"reactions(sir)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"We can count the number of reactions in a model using the numreactions function:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"numreactions(sir)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Finally, a vector with all the reactions' rates can be retrieved using reactionrates:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"reactionrates(sir)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/#model_accessing_basics_reactions-2","page":"Accessing model properties","title":"Accessing content of models coupled to equations","text":"","category":"section"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Previously, we have shown how to couple equations to a chemical reaction network model, creating models containing non-species unknowns (variables). Here we create a birth-death model where some nutrient supply (modelled through the variable N) is depleted in the presence of X:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"using Catalyst # hide\ncoupled_crn = @reaction_network begin\n    @equations D(N) ~ -N * X\n    (p/(1+N),d), 0 <--> X\nend","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Here, the unknowns function returns all unknowns (i.e. species and variables):","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"unknowns(coupled_crn)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Meanwhile, species returns the species only, while nonspecies returns the variables only:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"species(coupled_crn)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"nonspecies(coupled_crn)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Similarly, the equations function returns a vector with all reactions and equations of the model (ordered so that reactions occur first and equations thereafter):","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"equations(coupled_crn)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Meanwhile, reactions returns the reactions only, while nonreactions returns any algebraic or differential equations:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"reactions(coupled_crn)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"nonreactions(coupled_crn)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/#model_accessing_basics_others","page":"Accessing model properties","title":"Accessing other model properties","text":"","category":"section"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"There exist several other functions for accessing model properties. ","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"The observed, continuous_events, discrete_events functions can be used to access a model's observables, continuous events, and discrete events, respectively.","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"The ModelingToolkit.get_iv function can be used to retrieve a model's independent variable:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"ModelingToolkit.get_iv(sir)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/#model_accessing_hierarchical","page":"Accessing model properties","title":"Accessing properties of hierarchical models","text":"","category":"section"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Previously, we have described how compositional modelling can be used to create hierarchical models. There are some special considerations when accessing the content of hierarchical models, which we will describe here.","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"First, we will create a simple hierarchical model. It describes a protein (X) which is created in its inactive form (Xᵢ) in the nucleus, from which it is transported to the cytoplasm, where it is activated.","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"using Catalyst # hide\n# Declare submodels.\nnucleus_sys = @network_component nucleus begin\n    (p,d), 0 <--> Xᵢ\nend\ncytoplasm_sys = @network_component cytoplasm begin\n    kₐ, Xᵢ --> Xₐ\n    d, (Xᵢ, Xₐ) --> 0\nend\n\n# Assembly hierarchical model.\ntransport = @reaction kₜ, $(nucleus_sys.Xᵢ) --> $(cytoplasm_sys.Xᵢ)\n@named rs = ReactionSystem([transport], default_t(); systems = [nucleus_sys, cytoplasm_sys])\nrs = complete(rs)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"This model consists of a top-level system, which contains the transportation reaction only, and two subsystems. We can retrieve all the subsystems of the top-level system through Catalyst.get_systems:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Catalyst.get_systems(rs)\nnothing # hide","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"note: Note\nIf either of the subsystems had had further subsystems, these would not be retrieved by Catalyst.get_systems (which only returns the direct subsystems of the input system).","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/#model_accessing_hierarchical_symbolic_variables","page":"Accessing model properties","title":"Accessing parameter and species of hierarchical models","text":"","category":"section"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Our hierarchical model consists of a top-level system (rs) with two subsystems (nucleus_sys and cytoplasm_sys). Note that we have given our subsystems names (nucleus and cytoplasm, respectively). Above, we retrieved the subsystems by calling Catalyst.get_systems on our top-level system. We can also retrieve a subsystem directly by calling:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"rs.nucleus","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"rs.cytoplasm","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"note: Note\nWhen accessing subsystems, we use the subsystems' names, not the name of their variables (i.e. we call rs.nucleus, not rs.nucleus_sys).","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Next, if we wish to access a species declared as a part of one of the subsystems, we do so through it. E.g. here we access Xₐ (which is part of the cytoplasm subsystem):","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"rs.cytoplasm.Xₐ","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Note that species contained in a subsystem have the subsystem's name prepended to their name when we access it.","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Both subsystems contain a species Xᵢ. However, while they have the same name, these are different species when accessed through their respective models:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"isequal(rs.nucleus.Xᵢ, rs.cytoplasm.Xᵢ)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"The same holds for the model parameters, i.e. while each subsystem contains a parameter d, these are considered different parameters:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"isequal(rs.nucleus.d, rs.cytoplasm.d)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"The parameter kₜ is actually contained within the top-level model, and is accessed directly through it:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"rs.kₜ","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Practically, when we simulate our hierarchical model, we use all of this to designate initial conditions and parameters. I.e. below we designate values for the two Xᵢ species and d parameters separately:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"using OrdinaryDiffEqDefault, Plots\nu0 = [rs.nucleus.Xᵢ => 0.0, rs.cytoplasm.Xᵢ => 0.0, rs.cytoplasm.Xₐ => 0.0]\nps = [rs.nucleus.p => 1.0, rs.nucleus.d => 0.2, rs.cytoplasm.kₐ => 5.0, rs.cytoplasm.d => 0.2, rs.kₜ => 0.1]\noprob = ODEProblem(rs, u0, (0.0, 10.0), ps)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"note: Note\nWhen we access a symbolic variable through a subsystem (e.g. rs.nucleus.Xᵢ) that subsystem's name is prepended to the symbolic variable's name (we call this namespacing). This is also the case if we access it through the original model, i.e. nucleus_sys.Xᵢ. Namespacing is only performed when we access variables of incomplete systems. I.e. isequal(nucleus_sys.d, cytoplasm_sys.d) returns false (as the systems are incomplete and namespacing is performed). However, isequal(complete(nucleus_sys).d, complete(cytoplasm_sys).d) returns true  (as the systems are complete and namespacing is not performed). This is the reason that the system top-level system's name is never prepended when we do e.g. rs.kₜ (because here, rs is complete).","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/#model_accessing_hierarchical_symbolic_variables-2","page":"Accessing model properties","title":"Accessing the content of hierarchical models","text":"","category":"section"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"In the last section, we noted that our hierarchical model contained several instances of the Xᵢ species. The species function, which retrieves all of a model's species shows that our model has three species (two types of Xᵢ, and one type of Xₐ)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"species(rs)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Similarly, parameters retrieves five different parameters. Here, we note that kₜ (which has no model name prepended) belongs to the top-level system (and not a subsystem):","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"parameters(rs)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"If we wish to retrieve the species (or parameters) that are specifically contained in the top-level system (and not only indirectly through its subsystems), we can use the Catalyst.get_species (or Catalyst.get_ps) functions:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Catalyst.get_species(rs)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Catalyst.get_ps(rs)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Here, our top-level model contains a single parameter (kₜ), and two the two versions of the Xᵢ species. These are all the symbolic variables that occur in the transportation reaction (@kₜ, $(nucleus_sys.Xᵢ) --> $(cytoplasm_sys.Xᵢ)), which is the only reaction of the top-level system. We can apply these functions to the systems as well. However, when we do so, the systems' names are not prepended:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Catalyst.get_ps(rs.nucleus)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Generally, functions starting with get_ retrieve only the components stored in the input system (and do not consider its subsystems), while the corresponding function without get_ also retrieves the components stored in subsystems. I.e. compare the Catalyst.get_rxs and reactions functions:","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"reactions(rs)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Catalyst.get_rxs(rs)","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"Other examples of similar pairs of functions are get_unknowns and unknowns, and get_observed and observed.","category":"page"},{"location":"model_creation/reactionsystem_content_accessing/","page":"Accessing model properties","title":"Accessing model properties","text":"note: Note\nDue to the large number of available accessor functions, most get_ functions are not directly exported by Catalyst. Hence, these must be used as Catalyst.get_rxs, rather than get_rxs directly. Again, a full list of accessor functions and instructions on how to use them can be found in Catalyst's API.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Global sensitivity analysis (GSA) is used to study the sensitivity of a function's outputs with respect to its input[1]. Within the context of chemical reaction network modelling it is primarily used for two purposes:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"When fitting a model's parameters to data, it can be applied to the cost function of the optimisation problem. Here, GSA helps determine which parameters do, and do not, affect the model's fit to the data. This can be used to identify parameters that are less relevant to the observed data.\nWhen measuring some system behaviour or property, it can help determine which parameters influence that property. E.g. for a model of a biofuel-producing circuit in a synthetic organism, GSA could determine which system parameters have the largest impact on the total rate of biofuel production.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"GSA can be carried out using the GlobalSensitivity.jl package. This tutorial contains a brief introduction of how to use it for GSA on Catalyst models, with GlobalSensitivity providing a more complete documentation.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_global_vs_local_sensitivity","page":"Global Sensitivity Analysis","title":"Global vs local sensitivity","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"A related concept to global sensitivity is local sensitivity. This, rather than measuring a function's sensitivity (with regards to its inputs) across its entire (or large part of its) domain, measures it at a specific point. This is equivalent to computing the function's gradients at a specific point in phase space, which is an important routine for most gradient-based optimisation methods (typically carried out through automatic differentiation). For most Catalyst-related functionalities, local sensitivities are computed using the SciMLSensitivity.jl package. While certain GSA methods can utilise local sensitivities, this is not necessarily the case.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"While local sensitivities are primarily used as a subroutine of other methodologies (such as optimisation schemes), it also has direct uses. E.g., in the context of fitting parameters to data, local sensitivity analysis can be used to, at the parameter set of the optimal fit, determine the cost function's sensitivity to the system parameters.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_basic_example","page":"Global Sensitivity Analysis","title":"Basic example","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"We will consider a simple SEIR model of an infectious disease. This is an expansion of the classic SIR model with an additional exposed state, E, denoting individuals who are latently infected but currently unable to transmit their infection to others.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"using Catalyst\nseir_model = @reaction_network begin\n    10^β, S + I --> E + I\n    10^a, E --> I\n    10^γ, I --> R\nend","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"We will study the peak number of infected cases's (max(I(t))) sensitivity to the system's three parameters. We create a function which simulates the system from a given initial condition and measures this property:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"using OrdinaryDiffEqDefault\n\nu0 = [:S => 999.0, :I => 1.0, :E => 0.0, :R => 0.0]\np_dummy = [:β => 0.0, :a => 0.0, :γ => 0.0]\noprob_base = ODEProblem(seir_model, u0, (0.0, 10000.0), p_dummy)\n\nfunction peak_cases(p)\n    ps = [:β => p[1], :a => p[2], :γ => p[3]]\n    oprob = remake(oprob_base; p = ps)\n    sol = solve(oprob; maxiters = 100000, verbose = false)\n    SciMLBase.successful_retcode(sol) || return Inf\n    return maximum(sol[:I])\nend\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Now, GSA can be applied to our peak_cases function using GlobalSensitivity's gsa function. It takes 3 mandatory inputs:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"The function for which we wish to carry out GSA.\nA method with which we wish to carry out GSA.\nA domain on which we carry out GSA. This is defined by a vector, which contains one two-valued Tuple for each parameter. These Tuples contain a lower and an upper bound for their respective parameter's value.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"E.g., here we carry out GSA using Morris's method:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"using GlobalSensitivity\nglobal_sens = gsa(peak_cases, Morris(), [(-3.0,-1.0), (-2.0,0.0), (-2.0,0.0)])\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"on the domain 10^β  (-30-10), 10^a  (-2000), 10^γ  (-2000) (which corresponds to β  (000101), a  (00110), γ  (00110)). The output of gsa varies depending on which GSA approach is used. GlobalSensitivity implements a range of methods for GSA. Below, we will describe the most common ones, as well as how to apply them and interpret their outputs.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"note: Note\nWe should make a couple of notes about the example above:Here, we write our parameters on the forms 10^β, 10^a, and 10^γ, which transforms them into log-space. As previously described, this is advantageous in the context of inverse problems such as this one.\nFor GSA, where a function is evaluated a large number of times, it is ideal to write it as performant as possible. Hence, we initially create a base ODEProblem, and then apply the remake function to it in each evaluation of peak_cases to generate a problem which is solved for that specific parameter set.\nAgain, as previously described in other inverse problem tutorials, when exploring a function over large parameter spaces, we will likely simulate our model for unsuitable parameter sets. To reduce time spent on these, and to avoid excessive warning messages, we provide the maxiters = 100000 and verbose = false arguments to solve.\nAs we have encountered in a few other cases, the gsa function is not able to take parameter inputs of the map form usually used for Catalyst. Hence, as a first step in peak_cases we convert the parameter vector to this form. Next, we remember that the order of the parameters when we e.g. evaluate the GSA output, or set the parameter bounds, corresponds to the order used in ps = [:β => p[1], :a => p[2], :γ => p[3]].","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_sobol","page":"Global Sensitivity Analysis","title":"Sobol's method-based global sensitivity analysis","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"The most common method for GSA is Sobol's method. This can be carried out using:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens = gsa(peak_cases, Sobol(), [(-3.0,-1.0), (-2.0,0.0), (-2.0,0.0)]; samples = 500)\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Note: when Sobol() is used as the method, the samples argument must also be used.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Sobol's method computes so-called Sobol indices, each measuring some combination of input's effect on the output. Here, when Sobol() is used, the first order, second order, and total order Sobol indices are computed. These can be accessed through the following fields:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens.S1: A vector where the i'th element is the output's sensitivity to variations in the i'th input.\nglobal_sens.S2: A matrix where element i-j contains the output's sensitivity to simultaneous variations in the i'th and j'th inputs.\nglobal_sens.ST: A vector where the i'th element is the output's sensitivity to any simultaneous variation of any combination of inputs that contain the i'th input. While only the first and second-order (and the total) Sobol indices are computed, the total order index compounds the information contained in Sobol indices across all orders.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"We can plot the first-order Sobol indices to analyse their content:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"using Plots\nbar([\"β\", \"a\", \"γ\"], global_sens.S1; group = [\"β\", \"a\", \"γ\"], fillrange = 1e-3)","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Here, we see that β has a relatively low effect on the peak in infected cases, as compared to a and γ. Plotting the total order indices suggests the same:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"bar([\"β\", \"a\", \"γ\"], global_sens.ST; group = [\"β\", \"a\", \"γ\"], fillrange = 1e-3)","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"GlobalSensitivity implements several versions of Sobol's method, and also provides several options. These are described here. Specifically, it is often recommended to, due to its quick computation time, use the related extended Fourier amplitude sensitivity test (EFAST) version. We can run this using:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens = gsa(peak_cases, eFAST(), [(-3.0,-1.0), (-2.0,0.0), (-2.0,0.0)]; samples = 500)\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"It should be noted that when EFAST is used, only the first and total-order Sobol indices are computed (and not the second-order ones).","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_morris","page":"Global Sensitivity Analysis","title":"Morris's method-based global sensitivity analysis","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"An alternative to using Sobol's method is to use Morris's method. The syntax is similar to previously (however, the samples argument is no longer required):","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens = gsa(peak_cases, Morris(), [(-3.0,-1.0), (-2.0,0.0), (-2.0,0.0)])\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Morris's method computes, for parameter samples across parameter space, their elementary effect on the output. Next, the output's sensitivity with respect to each parameter is assessed through various statistics on these elementary effects. In practice, the following two fields are considered:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens.means_star (called μ*): Measures each parameter's influence on the output. A large μ* indicates a parameter to which the output is sensitive. \nglobal_sens.variances: Measures the variance of each parameter's influence on the output. A large variance suggests that a parameter's influence on the output is highly dependent on other parameter values.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"We can check these values for our example:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"mean_star_plot = bar([\"β\" \"a\" \"γ\"], global_sens.means_star; labels=[\"β\" \"a\" \"γ\"], title=\"μ*\")\nvariances_plot = bar([\"β\" \"a\" \"γ\"], global_sens.variances; labels=[\"β\" \"a\" \"γ\"], title=\"σ²\")\nplot(mean_star_plot, variances_plot)","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"As previously, we note that the peak number of infected cases is more sensitive to a and γ than to β.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"note: Note\nThe syntax for plotting the output using Sobol's and Morris's methods is slightly different. The reason is that global_sens.means_star and global_sens.variances (for Morris's method) are 1x3 Matrices, while for Sobol's method, global_sens.S1 and global_sens.ST are length-3 vectors.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Generally, Morris's method is computationally less intensive, and has easier to interpret output, as compared to Sobol's method. However, if computational resources are available, Sobol's method is more comprehensive.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_other_methods","page":"Global Sensitivity Analysis","title":"Other global sensitivity analysis methods","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"GlobalSensitivity also implements additional methods for GSA, more details on these can be found in the package's documentation.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_nonscalars","page":"Global Sensitivity Analysis","title":"Global sensitivity analysis for non-scalar outputs","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Previously, we have demonstrated GSA on functions with scalar outputs. However, it is also possible to apply it to functions with vector outputs. Let us consider our previous function, but where it provides both the peak number of exposed and infected individuals:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"function peak_cases_2(p)\n    ps = [:β => p[1], :a => p[2], :γ => p[3]]\n    oprob = remake(oprob_base; p = ps)\n    sol = solve(oprob; maxiters = 100000, verbose = false)\n    SciMLBase.successful_retcode(sol) || return Inf\n    return [maximum(sol[:E]), maximum(sol[:I])]\nend\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"We can apply gsa to this function as previously:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens = gsa(peak_cases_2, Morris(), [(-3.0,-1.0), (-2.0,0.0), (-2.0,0.0)])\nnothing # hide","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"however, each output field is now a multi-row matrix, containing one row for each of the outputs. E.g., we have","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"global_sens.means_star","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"Here, the function's sensitivity is evaluated with respect to each output independently. Hence, GSA on peak_cases_2 is equivalent to first carrying out GSA on a function returning the peak number of exposed individuals, and then on one returning the peak number of infected individuals.","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#global_sensitivity_analysis_citations","page":"Global Sensitivity Analysis","title":"Citations","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"If you use this functionality in your research, in addition to Catalyst, please cite the following paper to support the authors of the GlobalSensitivity.jl package:","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"@article{dixit2022globalsensitivity,\n  title={GlobalSensitivity. jl: Performant and Parallel Global Sensitivity Analysis with Julia},\n  author={Dixit, Vaibhav Kumar and Rackauckas, Christopher},\n  journal={Journal of Open Source Software},\n  volume={7},\n  number={76},\n  pages={4561},\n  year={2022}\n}","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"","category":"page"},{"location":"inverse_problems/global_sensitivity_analysis/#References","page":"Global Sensitivity Analysis","title":"References","text":"","category":"section"},{"location":"inverse_problems/global_sensitivity_analysis/","page":"Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"[1]: Saltelli, A et al. Global Sensitivity Analysis. The Primer, Wiley (2008).","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#introduction_to_catalyst","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"In this tutorial we provide an introduction to using Catalyst to specify chemical reaction networks, and then to solve ODE, jump, and SDE models generated from them [1]. At the end we show what mathematical rate laws and transition rate functions (i.e. intensities or propensities) are generated by Catalyst for ODE, SDE and jump process models. The Mathematical Models Catalyst can Generate documentation illustrates the abstract mathematical models Catalyst reaction models can be converted to, but please note it assumes one has already read this tutorial as a prerequisite.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"We begin by installing Catalyst and any needed packages into a new environment. This step can be skipped if you have already installed them in your current, active environment:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"using Pkg\n\n# name of the environment\nPkg.activate(\"catalyst_introduction\")\n\n# packages we will use in this tutorial\nPkg.add(\"Catalyst\")\nPkg.add(\"OrdinaryDiffEqTsit5\")\nPkg.add(\"Plots\")\nPkg.add(\"Latexify\")\nPkg.add(\"JumpProcesses\")\nPkg.add(\"StochasticDiffEq\")","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"We next load the basic packages we'll need for our first example:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"using Catalyst, OrdinaryDiffEqTsit5, Plots, Latexify","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Let's start by using the Catalyst @reaction_network macro to specify a simple chemical reaction network: the well-known repressilator. We first construct the reaction network. The basic types of arrows and predefined rate laws one can use are discussed in detail within the tutorial, The Reaction DSL. Here, we use a mix of first order, zero order, and repressive Hill function rate laws. Note, varnothing corresponds to the empty state, and is used for zeroth order production and first order degradation reactions:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"rn = @reaction_network Repressilator begin\n    hillr(P₃,α,K,n), ∅ --> m₁\n    hillr(P₁,α,K,n), ∅ --> m₂\n    hillr(P₂,α,K,n), ∅ --> m₃\n    (δ,γ), m₁ <--> ∅\n    (δ,γ), m₂ <--> ∅\n    (δ,γ), m₃ <--> ∅\n    β, m₁ --> m₁ + P₁\n    β, m₂ --> m₂ + P₂\n    β, m₃ --> m₃ + P₃\n    μ, P₁ --> ∅\n    μ, P₂ --> ∅\n    μ, P₃ --> ∅\nend\nshow(stdout, MIME\"text/plain\"(), rn) # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"showing that we've created a new network model named Repressilator with the listed chemical species and unknowns. @reaction_network returns a ReactionSystem, which we saved in the rn variable. It can be converted to a variety of other mathematical models represented as ModelingToolkit.AbstractSystems, or analyzed in various ways using the Catalyst.jl API. For example, to see the chemical species, parameters, and reactions we can use","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"species(rn)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"parameters(rn)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"and","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"reactions(rn)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"We can also use Latexify to see the corresponding reactions in Latex, which shows what the hillr terms mathematically correspond to","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"latexify(rn)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"rn #hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Assuming Graphviz is installed and command line accessible, within a Jupyter notebook we can also graph the reaction network by","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"g = Graph(rn)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"giving","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"(Image: Repressilator solution)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"The network graph shows a variety of information, representing each species as a blue node, and each reaction as an orange dot. Black arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry. Similarly, black arrows from reactions to species indicate products, and are labelled with their output stoichiometry. In contrast, red arrows from a species to reactions indicate the species is used within the reactions' rate expressions. For the repressilator, the reactions","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"hillr(P₃,α,K,n), ∅ --> m₁\nhillr(P₁,α,K,n), ∅ --> m₂\nhillr(P₂,α,K,n), ∅ --> m₃","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"have rates that depend on the proteins, and hence lead to red arrows from each Pᵢ.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Note, from the REPL or scripts one can always use savegraph to save the graph (assuming Graphviz is installed).","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#Mass-action-ODE-models","page":"Introduction to Catalyst","title":"Mass action ODE models","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Let's now use our ReactionSystem to generate and solve a corresponding mass action ODE model. We first convert the system to a ModelingToolkit.ODESystem by","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"rn = complete(rn)\nodesys = convert(ODESystem, rn)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"(Here Latexify is used automatically to display odesys in Latex within Markdown documents or notebook environments like Pluto.jl.)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Before we can solve the ODEs, we need to specify the values of the parameters in the model, the initial condition, and the time interval to solve the model on. To do this we need to build mappings from the symbolic parameters and the species to the corresponding numerical values for parameters and initial conditions. We can build such mappings in several ways. One is to use Julia Symbols to specify the values like","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"pmap  = (:α => .5, :K => 40, :n => 2, :δ => log(2)/120,\n         :γ => 5e-3, :β => log(2)/6, :μ => log(2)/60)\nu₀map = [:m₁ => 0., :m₂ => 0., :m₃ => 0., :P₁ => 20., :P₂ => 0., :P₃ => 0.]\nnothing   # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Alternatively, we can use ModelingToolkit-based symbolic species variables to specify these mappings like","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"psymmap  = (rn.α => .5, rn.K => 40, rn.n => 2, rn.δ => log(2)/120,\n    rn.γ => 5e-3, rn.β => 20*log(2)/120, rn.μ => log(2)/60)\nu₀symmap = [rn.m₁ => 0., rn.m₂ => 0., rn.m₃ => 0., rn.P₁ => 20.,\n    rn.P₂ => 0., rn.P₃ => 0.]\nnothing   # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Knowing these mappings we can set up the ODEProblem we want to solve:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"# time interval to solve on\ntspan = (0., 10000.)\n\n# create the ODEProblem we want to solve\noprob = ODEProblem(rn, u₀map, tspan, pmap)\nnothing   # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"By passing rn directly to the ODEProblem, Catalyst has to (internally) call convert(ODESystem, rn) again to generate the symbolic ODEs. We could instead pass odesys directly like","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"odesys = complete(odesys)\noprob2 = ODEProblem(odesys, u₀symmap, tspan, psymmap)\nnothing   # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"oprob and oprob2 are functionally equivalent, each representing the same underlying problem.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"note: Note\nWhen passing odesys to ODEProblem we needed to use the symbolic variable-based parameter mappings, u₀symmap and psymmap, while when directly passing rn we could use either those or the Symbol-based mappings, u₀map and pmap. Symbol-based mappings can always be converted to symbolic mappings using symmap_to_varmap.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"note: Note\nAbove we have used rn = complete(rn) and odesys = complete(odesys) to mark these systems as complete, indicating to Catalyst and ModelingToolkit that these models are finalized. This must be done before any system is given as input to a convert call or some problem type. ReactionSystem models created through the @reaction_network DSL (which is introduced elsewhere, and primarily used throughout these documentation) are always marked as complete when generated. Hence complete does not need to be called on them. Symbolically generated ReactionSystems, ReactionSystems generated via the @network_component macro, and any ModelingToolkit system generated by convert always needs to be manually marked as complete as we do for odesys above. An expanded description on completeness can be found here.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"At this point we are all set to solve the ODEs. We can now use any ODE solver from within the OrdinaryDiffEq.jl package. We'll use the recommended default explicit solver, Tsit5(), and then plot the solutions:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"sol = solve(oprob, Tsit5(), saveat=10.0)\nplot(sol)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"We see the well-known oscillatory behavior of the repressilator! For more on the choices of ODE solvers, see the OrdinaryDiffEq.jl documentation.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#Stochastic-simulation-algorithms-(SSAs)-for-stochastic-chemical-kinetics","page":"Introduction to Catalyst","title":"Stochastic simulation algorithms (SSAs) for stochastic chemical kinetics","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Let's now look at a stochastic chemical kinetics model of the repressilator, modeling it with jump processes. Here, we will construct a JumpProcesses JumpProblem that uses Gillespie's Direct method, and then solve it to generate one realization of the jump process:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"# imports the JumpProcesses packages\nusing JumpProcesses\n\n# redefine the initial condition to be integer valued\nu₀map = [:m₁ => 0, :m₂ => 0, :m₃ => 0, :P₁ => 20, :P₂ => 0, :P₃ => 0]\n\n# next we process the inputs for the jump problem\njinputs = JumpInputs(rn, u₀map, tspan, pmap)\n\n# now, we create a JumpProblem, and let a solver be chosen for us automatically\n# in this case Gillespie's Direct Method will be selected\njprob = JumpProblem(jinputs)\n\n# now, let's solve and plot the jump process:\nsol = solve(jprob)\nplot(sol)\nCatalyst.PNG(plot(sol; fmt = :png, dpi = 200)) # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"We see that oscillations remain, but become much noisier. Note, in constructing the JumpProblem we could have specified any of the SSAs that are part of JumpProcesses instead of letting JumpProcesses auto-select a solver, see the list of SSAs (i.e., constant rate jump aggregators) in the documentation. For example, to choose the SortingDirect method we would instead say","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"jprob = JumpProblem(jinputs, SortingDirect())\nsol = solve(jprob)\nplot(sol)\nCatalyst.PNG(plot(sol; fmt = :png, dpi = 200)) # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Common questions that arise in using the JumpProcesses SSAs (i.e. Gillespie methods) are collated in the JumpProcesses FAQ.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#Chemical-Langevin-equation-(CLE)-stochastic-differential-equation-(SDE)-models","page":"Introduction to Catalyst","title":"Chemical Langevin equation (CLE) stochastic differential equation (SDE) models","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"At an intermediate physical scale between macroscopic ODE models and microscopic stochastic chemical kinetics models lies the CLE, given by a system of SDEs that add to each ODE above a noise term. As the repressilator has species that get very close to zero in size, it is not a good candidate to model with the CLE (where solutions can then go negative and become unphysical). Let's create a simpler reaction network for a birth-death process that will stay non-negative:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"bdp = @reaction_network begin\n  c₁, X --> 2X\n  c₂, X --> 0\n  c₃, 0 --> X\nend\np = (:c₁ => 1.0, :c₂ => 2.0, :c₃ => 50.)\nu₀ = [:X => 5.]\ntspan = (0.,4.)\nnothing   # hide","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"The corresponding Chemical Langevin Equation SDE is then","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"dX(t) = left( c_1 Xleft( t right) - c_2 Xleft( t right) + c_3 right) dt + sqrtc_1 X(t) dW_1(t) - sqrtc_2 X(t) dW_2(t) + sqrtc_3 dW_3(t)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"where each W_i(t) denotes an independent Brownian Motion. We can solve the CLE model by creating an SDEProblem and solving it similarly to what we did for ODEs above:","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"# imports the StochasticDiffEq package for SDE simulations\nusing StochasticDiffEq\n\n# SDEProblem for CLE\nsprob = SDEProblem(bdp, u₀, tspan, p)\n\n# solve and plot, tstops is used to specify enough points\n# that the plot looks well-resolved\nsol = solve(sprob, LambaEM(), tstops = range(0., step = 4e-3, length = 1001))\nplot(sol)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"We again have complete freedom to select any of the StochasticDiffEq.jl SDE solvers, see the documentation.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#Specifying-a-complete-model-via-the-DSL","page":"Introduction to Catalyst","title":"Specifying a complete model via the DSL","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"In the previous examples we specified initial conditions and parameter values via mappings that were constructed after building our ReactionSystem. Catalyst also supports specifying default values for these during ReactionSystem construction. For example, for the last SDE example we could have also built and simulated the complete model using the DSL like","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"bdp2 = @reaction_network begin\n    @parameters c₁ = 1.0 c₂ = 2.0 c₃ = 50.0\n    @species X(t) = 5.0\n    c₁, X --> 2X\n    c₂, X --> 0\n    c₃, 0 --> X\nend\ntspan = (0., 4.)\nsprob2 = SDEProblem(bdp2, [], tspan)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Let's now simulate both models, starting from the same random number generator seed, and check we get the same solutions","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"using Random\nRandom.seed!(1)\nsol = solve(sprob, LambaEM(), tstops = range(0., step = 4e-3, length = 1001))\np1 = plot(sol)\nRandom.seed!(1)\nsol2 = solve(sprob2, LambaEM(), tstops = range(0., step = 4e-3, length = 1001))\np2 = plot(sol2)\nplot(p1, p2, layout = (2,1))","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"For details on what information can be specified via the DSL see the The Reaction DSL tutorial.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#introduction_to_catalyst_ratelaws","page":"Introduction to Catalyst","title":"Reaction rate laws used in simulations","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"In generating mathematical models from a ReactionSystem, reaction rates are treated as microscopic rates. That is, for a general mass action reaction of the form n_1 S_1 + n_2 S_2 + dots n_M S_M to dots with stoichiometric substrate coefficients n_i_i=1^M and rate constant k, the corresponding ODE and SDE rate laws are taken to be","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"k prod_i=1^M frac(S_i)^n_in_i","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"while the jump process transition rate (i.e., the propensity or intensity function) is","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"k prod_i=1^M fracS_i (S_i-1) dots (S_i-n_i+1)n_i","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"For example, the rate law of the reaction 2X + 3Y to Z with rate constant k would be","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"k fracX^22 fracY^33 ","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"giving the ODE model","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"beginalign*\nfracdXdt =  -2 k fracX^22 fracY^33 \nfracdYdt =  -3 k fracX^22 fracY^33 \nfracdZdt = k fracX^22 fracY^33\nendalign*","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"This implicit rescaling of rate constants can be disabled through explicit conversion of a ReactionSystem to another system via Base.convert using the combinatoric_ratelaws=false keyword argument, i.e.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"rn = @reaction_network ...\nconvert(ODESystem, rn; combinatoric_ratelaws=false)","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"For the previous example using this keyword argument would give the rate law","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"k X^2 Y^3","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"and the ODE model","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"beginalign*\nfracdXdt =  -2 k X^2 Y^3 \nfracdYdt =  -3 k X^2 Y^3 \nfracdZdt = k X^2 Y^3\nendalign*","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"A more detailed summary of the precise mathematical equations Catalyst can generate is available in the Mathematical Models Catalyst can Generate documentation.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#Notes","page":"Introduction to Catalyst","title":"Notes","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"For each of the preceding models we converted the ReactionSystem to, i.e., ODEs, jumps, or SDEs, we had two paths for conversion:\na. Convert to the corresponding ModelingToolkit system and then use it in     creating the corresponding problem.\nb. Directly create the desired problem type from the ReactionSystem.\nThe latter is more convenient, however, the former will be more efficient if one needs to repeatedly create the associated Problem.\nModelingToolkit offers many options for optimizing the generated ODEs and SDEs, including options to build functions for evaluating Jacobians and/or multithreaded versions of derivative evaluation functions. See the options for ODEProblems and SDEProblems.","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"","category":"page"},{"location":"introduction_to_catalyst/introduction_to_catalyst/#References","page":"Introduction to Catalyst","title":"References","text":"","category":"section"},{"location":"introduction_to_catalyst/introduction_to_catalyst/","page":"Introduction to Catalyst","title":"Introduction to Catalyst","text":"Torkel E. Loman, Yingbo Ma, Vasily Ilin, Shashi Gowda, Niklas Korsbo, Nikhil Yewale, Chris Rackauckas, Samuel A. Isaacson, Catalyst: Fast and flexible modeling of reaction networks, PLOS Computational Biology (2023).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Fitting parameters to data involves solving an optimisation problem (that is, finding the parameter set that optimally fits your model to your data, typically by minimising an objective function)[1]. The SciML ecosystem's primary package for solving optimisation problems is Optimization.jl. It provides access to a variety of solvers via a single common interface by wrapping a large number of optimisation libraries that have been implemented in Julia.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"This tutorial demonstrates how to ","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Create a custom objective function which minimiser corresponds to the parameter set optimally fitting the data.\nUse Optimization.jl to minimize this objective function and find the parameter set providing the optimal fit.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"For simple parameter fitting problems (such as the one outlined below), PEtab.jl often provides a more straightforward parameter fitting interface. However, Optimization.jl provides additional flexibility in defining your objective function. Indeed, it can also be used in other contexts, such as finding parameter sets that maximise the magnitude of some system behaviour. More details on how to use Optimization.jl can be found in its documentation.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_basics","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Basic example","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Let us consider a Michaelis-Menten enzyme kinetics model, where an enzyme (E) converts a substrate (S) into a product (P):","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"using Catalyst\nrn = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"From some known initial condition, and a true parameter set (which we later want to recover from the data) we generate synthetic data (on which we will demonstrate the fitting process).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"# Define initial conditions and parameters.\nu0 = [:S => 1.0, :E => 1.0, :SE => 0.0, :P => 0.0]\nps_true = [:kB => 1.0, :kD => 0.1, :kP => 0.5]\n\n# Generate synthetic data.\nusing OrdinaryDiffEqDefault\noprob_true = ODEProblem(rn, u0, (0.0, 10.0), ps_true)\ntrue_sol = solve(oprob_true)\ndata_sol = solve(oprob_true; saveat = 1.0)\ndata_ts = data_sol.t[2:end]\ndata_vals = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\n\n# Plots the true solutions and the (synthetic) data measurements.\nusing Plots\nplot(true_sol; idxs = :P, label = \"True solution\", lw = 8)\nplot!(data_ts, data_vals; label = \"Measurements\", seriestype=:scatter, ms = 6, color = :blue)\nplt = plot(true_sol; idxs = :P, label = \"True solution\", lw = 8) # hide\nplot!(plt, data_ts, data_vals; label = \"Measurements\", seriestype=:scatter, ms = 6, color = :blue) # hide\nCatalyst.PNG(plot(plt; fmt = :png, dpi = 200)) # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Next, we will formulate an objective function which, for a single parameter set, simulates our model and computes the sum-of-square distance between the data and the simulation (non-sum-of-square approaches can be used, but this is the most straightforward one).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"ps_init = [:kB => 1.0, :kD => 1.0, :kP => 1.0]\noprob_base = ODEProblem(rn, u0, (0.0, 10.0), ps_init)\nfunction objective_function(p, _)\n    p = Pair.([:kB, :kD, :kP], p)\n    oprob = remake(oprob_base; p)\n    sol = solve(oprob; saveat = data_ts, save_idxs = :P, verbose = false, maxiters = 10000)\n    SciMLBase.successful_retcode(sol) || return Inf\n    return sum((sol .- data_vals) .^2)\nend","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"When our optimisation algorithm searches parameter space it will likely consider many highly non-plausible parameter sets. To better handle this we:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Add maxiters = 10000 to our solve command. As most well-behaved ODEs can be solved in relatively few timesteps, this speeds up the optimisation procedure by preventing us from spending too much time trying to simulate (for the model) unsuitable parameter sets.\nAdd verbose = false to our solve command. This prevents (potentially a very large number of) warnings from being printed to our output as unsuitable parameter sets are simulated.\nAdd the line SciMLBase.successful_retcode(sol) || return Inf, which returns an infinite value for parameter sets which does not lead to successful simulations.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"To improve optimisation performance, rather than creating a new ODEProblem in each iteration, we pre-declare one which we apply remake to. We also use the saveat = data_ts, save_idxs = :P arguments to only save the values of the measured species at the measured time points.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"We can now create an OptimizationProblem using our objective_function and some initial guess of parameter values from which the optimiser will start:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"using Optimization\np_guess = [1.0, 1.0, 1.0]\noptprob = OptimizationProblem(objective_function, p_guess)\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"note: Note\nOptimizationProblems cannot currently accept parameter values in the form of a map (e.g. [:kB => 1.0, :kD => 1.0, :kP => 1.0]). These must be provided as individual values (using the same order as the parameters occur in in the parameters(rs) vector). This should hopefully be remedied in future Optimization releases.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"note: Note\nEspecially if you check Optimization.jl's documentation, you will note that objective functions have the f(u,p) form. This is because OptimizationProblems (like e.g. ODEProblems) can take both variables (which are varied during the optimisation procedure), but also parameters that are fixed. In our case, the optimisation variables correspond to our model parameters. Hence, our model parameter values (p) are the first argument (u). This is also why we find the optimisation solution (our optimised parameter set) in opt_sol's u field. Our optimisation problem does not actually have any parameters, hence, the second argument of objective_function is unused (that is why we call it _, a name commonly indicating unused function arguments).There are several modifications to our problem where it would actually have parameters. E.g. we might want to run the optimisation where one parameter has a known fixed value. If we then would like to rerun this for alternative fixed values, this value could be encoded as an OptimizationProblem parameter.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Finally, we can solve optprob to find the parameter set that best fits our data. Optimization.jl only provides a few optimisation methods natively. However, for each supported optimisation package, it provides a corresponding wrapper package to import that optimisation package for use with Optimization.jl. E.g., if we wish to use NLopt.jl's Nelder-Mead method, we must install and import the OptimizationNLopt package. A summary of all, by Optimization.jl supported, optimisation packages can be found here. Here, we import the NLopt.jl package and uses it to minimise our objective function (thus finding a parameter set that fits the data):","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"using OptimizationNLopt\noptsol = solve(optprob, NLopt.LN_NELDERMEAD())\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"We can now simulate our model for the found parameter set (stored in optsol.u), checking that it fits our data.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"oprob_fitted = remake(oprob_base; p = Pair.([:kB, :kD, :kP], optsol.u))\nfitted_sol = solve(oprob_fitted)\nplot!(fitted_sol; idxs = :P, label = \"Fitted solution\", linestyle = :dash, lw = 6, color = :lightblue)\nplot!(plt, fitted_sol; idxs = :P, label = \"Fitted solution\", linestyle = :dash, lw = 6, color = :lightblue) # hide\nCatalyst.PNG(plot(plt; fmt = :png, dpi = 200)) # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"note: Note\nHere, a good exercise is to check the resulting parameter set and note that, while it creates a good fit to the data, it does not actually correspond to the original parameter set. Identifiability is a concept that studies how to deal with this problem.<!–NTS: re-add ref when identifiablity works again–>","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Say that we instead would like to use a genetic algorithm approach, as implemented by the Evolutionary.jl package. In this case we can run:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"using OptimizationEvolutionary\nsol = solve(optprob, Evolutionary.GA())\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"to solve optprob for this combination of solve and implementation.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_AD","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Utilising automatic differentiation","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Optimisation methods can be divided into differentiation-free and differentiation-based optimisation methods. E.g. consider finding the minimum of the function f(x) = x^2, given some initial guess of x. Here, we can simply compute the differential and descend along it until we find x=0 (admittedly, for this simple problem the minimum can be computed directly). This principle forms the basis of optimisation methods such as gradient descent, which utilises information of a function's differential to minimise it. When attempting to find a global minimum, to avoid getting stuck in local minimums, these methods are often augmented by additional routines. While the differentiation of most algebraic functions is trivial, it turns out that even complicated functions (such as the one we used above) can be differentiated computationally through the use of automatic differentiation (AD).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Through packages such as ForwardDiff.jl, ReverseDiff.jl, and Zygote.jl, Julia supports AD for most code. Specifically for code including simulation of differential equations, differentiation is supported by SciMLSensitivity.jl. Generally, AD can be used without specific knowledge from the user, however, it requires an additional step in the construction of our OptimizationProblem. Here, we create a specialised OptimizationFunction from our objective function. To it, we will also provide our choice of AD method. There are several alternatives, and in our case we will use AutoForwardDiff() (a good choice for small optimisation problems). We can then create a new OptimizationProblem using our updated objective function:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"opt_func = OptimizationFunction(objective_function, AutoForwardDiff())\nopt_prob = OptimizationProblem(opt_func, p_guess)\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Finally, we can find the optimum using some differentiation-based optimisation methods. Here we will use Optim.jl's Broyden–Fletcher–Goldfarb–Shanno algorithm implementation:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"using OptimizationOptimJL\nopt_sol = solve(opt_prob, OptimizationOptimJL.BFGS())","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_multiple_species","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Optimisation problems with data for multiple species","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Imagine that, in our previous example, we had measurements of the concentration of both S and P:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"data_vals_S = (0.8 .+ 0.4*rand(10)) .* data_sol[:S][2:end]\ndata_vals_P = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\n\nplot(true_sol; idxs = [:S, :P], label = [\"True S\" \"True P\"], lw = 8)\nplot!(data_ts, data_vals_S; label = \"Measured S\", seriestype=:scatter, ms = 6, color = :blue)\nplot!(data_ts, data_vals_P; label = \"Measured P\", seriestype=:scatter, ms = 6, color = :red)\nplt2 = plot(true_sol; idxs = [:S, :P], label = [\"True S\" \"True P\"], lw = 8)  # hide\nplot!(plt2, data_ts, data_vals_S; label = \"Measured S\", seriestype = :scatter, ms = 6, color = :blue)  # hide\nplot!(plt2, data_ts, data_vals_P; label = \"Measured P\", seriestype = :scatter, ms = 6, color = :red)  # hide\nCatalyst.PNG(plot(plt2; fmt = :png, dpi = 200)) # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"In this case we simply modify our objective function to take this into account:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"function objective_function_S_P(p, _)\n    p = Pair.([:kB, :kD, :kP], p)\n    oprob = remake(oprob_base; p)\n    sol = solve(oprob; saveat = data_ts, save_idxs = [:S, :P], verbose = false, maxiters = 10000)\n    SciMLBase.successful_retcode(sol) || return Inf\n    return sum((sol[:S] .- data_vals_S) .^2 + (sol[:P] .- data_vals_P) .^2)\nend","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Here we do not normalise the contribution from each species to the objective function. However, if species are present at different concentration levels this might be necessary (or you might essentially only take the highest concentration species(s) into account).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"We can now fit our model to data and plot the results:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"optprob_S_P = OptimizationProblem(objective_function_S_P, p_guess)\noptsol_S_P = solve(optprob_S_P, NLopt.LN_NELDERMEAD())\noprob_fitted_S_P = remake(oprob_base; p = optsol_S_P.u)\nfitted_sol_S_P = solve(oprob_fitted_S_P)\nplot!(fitted_sol_S_P; idxs=[:S, :P], label=\"Fitted solution\", linestyle = :dash, lw = 6, color = [:lightblue :pink])\nplot!(plt2, fitted_sol_S_P; idxs=[:S, :P], label=\"Fitted solution\", linestyle = :dash, lw = 6, color = [:lightblue :pink]) # hide\nCatalyst.PNG(plot(plt2; fmt = :png, dpi = 200)) # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_constraints","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Setting parameter constraints and boundaries","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Sometimes, it is desirable to set boundaries on parameter values. Indeed, this can speed up the optimisation process (by preventing searching through unfeasible parts of parameter space), and can also be a requirement for some optimisation methods. This can be done by passing the lb (lower bounds) and up (upper bounds) arguments to OptimizationProblem. These are vectors (of the same length as the number of parameters), with each argument corresponding to the boundary value of the parameter with the same index. If we wish to constrain each parameter to the interval (01 100) this can be done through:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"optprob = OptimizationProblem(objective_function, [1.0, 1.0, 1.0]; lb = [1e-1, 1e-1, 1e-1], ub = [1e1, 1e1, 1e1])\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"In addition to boundaries, Optimization.jl also supports setting linear and non-linear constraints on its output solution (only available for some optimisers).","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_known_parameters","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter fitting with known parameters","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"If we from previous knowledge know that kD = 01, and only want to fit the values of kB and kP, this can be achieved by making corresponding changes to our objective function.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"function objective_function_known_kD(p, _)\n    p = Pair.([:kB, :kD, :kP], [p[1], 0.1, p[2]])\n    oprob = remake(oprob_base; p)\n    sol = solve(oprob; saveat = data_ts, save_idxs = :P, verbose = false, maxiters = 10000)\n    SciMLBase.successful_retcode(sol) || return Inf\n    return sum((sol .- data_vals) .^2)\nend","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"We can now create and solve the corresponding OptimizationProblem, but with only two parameters in the initial guess.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"optprob_known_kD = OptimizationProblem(objective_function_known_kD, [1.0, 1.0])\noptsol_known_kD = solve(optprob_known_kD, NLopt.LN_NELDERMEAD())\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_solver_options","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Optimisation solver options","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Optimization.jl supports various optimisation solver options that can be supplied to the solve command. For example, to set a maximum number of seconds (after which the optimisation process is terminated), you can use the maxtime argument:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"optsol_fixed_kD = solve(optprob, NLopt.LN_NELDERMEAD(); maxtime = 100)\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"It should be noted that not all solver options are available to all optimisation solvers.","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_log_scale","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Fitting parameters on the logarithmic scale","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"Often it can be advantageous to fit parameters on a logarithmic scale (rather than on a linear scale). The most straightforward way to do this is to simply replace each parameter in the model definition by its logarithmic version:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"using Catalyst\nrn = @reaction_network begin\n    10^kB, S + E --> SE\n    10^kD, SE --> S + E\n    10^kP, SE --> P + E\nend","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"And then going forward, by keeping in mind that parameter values are logarithmic. Here, setting","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"p_true = [:kB => 0.0, :kD => -1.0, :kP => 10^(0.5)]\nnothing # hide","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"corresponds to the same true parameter values as used previously ([:kB => 1.0, :kD => 0.1, :kP => 0.5]). Alternatively, we can provide the log-transform in the objective function:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"function objective_function_logtransformed(p, _)\n    p = Pair.([:kB, :kD, :kP], 10.0 .^ p)\n    oprob = remake(oprob_base; p)\n    sol = solve(oprob; saveat = data_ts, save_idxs = :P, verbose = false, maxiters = 10000)\n    SciMLBase.successful_retcode(sol) || return Inf\n    return sum((sol .- data_vals) .^2)\nend","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#optimization_parameter_fitting_citation","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Citation","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"If you use this functionality in your research, please cite the following paper to support the authors of the Optimization.jl package:","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"@software{vaibhav_kumar_dixit_2023_7738525,\n\tauthor = {Vaibhav Kumar Dixit and Christopher Rackauckas},\n\tmonth = mar,\n\tpublisher = {Zenodo},\n\ttitle = {Optimization.jl: A Unified Optimization Package},\n\tversion = {v3.12.1},\n\tdoi = {10.5281/zenodo.7738525},\n  \turl = {https://doi.org/10.5281/zenodo.7738525},\n\tyear = 2023\n}","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"","category":"page"},{"location":"inverse_problems/optimization_ode_param_fitting/#References","page":"Parameter Fitting for ODEs using Optimization.jl","title":"References","text":"","category":"section"},{"location":"inverse_problems/optimization_ode_param_fitting/","page":"Parameter Fitting for ODEs using Optimization.jl","title":"Parameter Fitting for ODEs using Optimization.jl","text":"[1]: Alejandro F. Villaverde, Dilan Pathirana, Fabian Fröhlich, Jan Hasenauer, Julio R. Banga, A protocol for dynamic model calibration, Briefings in Bioinformatics (2023).","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/#steady_state_stability","page":"Steady state stability computation","title":"Steady state stability computation","text":"","category":"section"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"After system steady states have been found using HomotopyContinuation.jl, NonlinearSolve.jl, or other means, their stability can be computed using Catalyst's steady_state_stability function. Systems with conservation laws will automatically have these removed, permitting stability computation on systems with singular Jacobian.","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"warning: Warning\nCatalyst currently computes steady state stabilities using the naive approach of checking whether a system's largest eigenvalue real part is negative. Furthermore, Catalyst uses a tolerance tol = 10*sqrt(eps()) to determine whether a computed eigenvalue is far away enough from 0 to be reliably considered non-zero. This threshold can be changed through the tol keyword argument.","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/#steady_state_stability_basics","page":"Steady state stability computation","title":"Basic examples","text":"","category":"section"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"Let us consider the following basic example:","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"using Catalyst\nrn = @reaction_network begin \n    (p,d), 0 <--> X\nend","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"It has a single (stable) steady state at X = pd. We can confirm stability using the steady_state_stability function, to which we provide the steady state, the reaction system, and the parameter values:","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"ps = [:p => 2.0, :d => 0.5]\nsteady_state = [:X => 4.0]\nsteady_state_stability(steady_state, rn, ps)","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"Next, let us consider the following self-activation loop:","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"sa_loop = @reaction_network begin \n    (hill(X,v,K,n),d), 0 <--> X\nend","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"For certain parameter choices, this system exhibits multi-stability. Here, we can find the steady states using homotopy continuation:","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"import HomotopyContinuation\nps = [:v => 2.0, :K => 0.5, :n => 3, :d => 1.0]\nsteady_states = hc_steady_states(sa_loop, ps)","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"Next, we can apply steady_state_stability to each steady state yielding a vector of their stabilities:","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"[steady_state_stability(sstate, sa_loop, ps) for sstate in steady_states]","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"Finally, as described above, Catalyst uses an optional argument, tol, to determine how strict to make the stability check.  I.e. below we set the tolerance to 1e-6 (a larger value, that is stricter, than the default of 10*sqrt(eps()))","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"[steady_state_stability(sstate, sa_loop, ps; tol = 1e-6) for sstate in steady_states]\nnothing# hide","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/#steady_state_stability_jacobian","page":"Steady state stability computation","title":"Pre-computing the Jacobian to increase performance when computing stability for many steady states","text":"","category":"section"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"Catalyst uses the system Jacobian to compute steady state stability, and the Jacobian is computed once for each call to steady_state_stability. If you repeatedly compute stability for steady states of the same system, pre-computing the Jacobian and supplying it to the steady_state_stability function can improve performance. ","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"In this example we use the self-activation loop from previously, pre-computes its Jacobian, and uses it to multiple steady_state_stability calls:","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"ss_jac = steady_state_jac(sa_loop)\n\nps_1 = [:v => 2.0, :K => 0.5, :n => 3, :d => 1.0]\nsteady_states_1 = hc_steady_states(sa_loop, ps)\nstabs_1 = [steady_state_stability(st, sa_loop, ps_1; ss_jac) for st in steady_states_1]\n\nps_2 = [:v => 4.0, :K => 1.5, :n => 2, :d => 1.0]\nsteady_states_2 = hc_steady_states(sa_loop, ps)\nstabs_2 = [steady_state_stability(st, sa_loop, ps_2; ss_jac) for st in steady_states_2]\nnothing # hide","category":"page"},{"location":"steady_state_functionality/steady_state_stability_computation/","page":"Steady state stability computation","title":"Steady state stability computation","text":"warning: Warning\nFor systems with conservation laws, steady_state_jac must be supplied a u0 vector (indicating species concentrations for conservation law computation). This is required to eliminate the conserved quantities, preventing a singular Jacobian. These are supplied using the u0 optional argument.","category":"page"},{"location":"model_creation/model_file_loading_and_export/#model_file_import_export","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"","category":"section"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"Catalyst stores chemical reaction network (CRN) models in ReactionSystem structures. This tutorial describes how to load such ReactionSystems from, and save them to, files. This can be used to save models between Julia sessions, or transfer them from one session to another. Furthermore, to facilitate the computation modelling of CRNs, several standardised file formats have been created to represent CRN models (e.g. SBML). This enables CRN models to be shared between different software and programming languages. While Catalyst itself does not have the functionality for loading such files, we will here (briefly) introduce a few packages that can load different file types to Catalyst ReactionSystems.","category":"page"},{"location":"model_creation/model_file_loading_and_export/#model_file_import_export_crn_serialization","page":"Loading Chemical Reaction Network Models from Files","title":"Saving Catalyst models to, and loading them from, Julia files","text":"","category":"section"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"Catalyst provides a save_reactionsystem function, enabling the user to save a ReactionSystem to a file. Here we demonstrate this by first creating a simple cross-coupling model:","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"using Catalyst\ncc_system = @reaction_network begin\n    k₁, S₁ + C --> S₁C\n    k₂, S₁C + S₂ --> CP\n    k₃, CP --> C + P\nend","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"and next saving it to a file","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"save_reactionsystem(\"cross_coupling.jl\", cc_system)","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"Here, save_reactionsystem's first argument is the path to the file where we wish to save it. The second argument is the ReactionSystem we wish to save. To load the file, we use Julia's include function:","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"cc_loaded = include(\"cross_coupling.jl\")\nrm(\"cross_coupling.jl\") # hide\ncc_loaded # hide","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"note: Note\nThe destination file can be in a folder. E.g. save_reactionsystem(\"my\\_folder/reaction_network.jl\", rn) saves the model to the file \"reaction_network.jl\" in the folder \"my_folder\".","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"Here, include is used to execute the Julia code from any file. This means that save_reactionsystem actually saves the model as executable code which re-generates the exact model which was saved (this is the reason why we use the \".jl\" extension for the saved file). Indeed, we can confirm this if we check what is printed in the file:","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"let\n\n# Independent variable:\n@parameters t\n\n# Parameters:\nps = @parameters kB kD kP\n\n# Species:\nsps = @species S(t) E(t) SE(t) P(t)\n\n# Reactions:\nrxs = [\n    Reaction(kB, [S, E], [SE], [1, 1], [1]),\n    Reaction(kD, [SE], [S, E], [1], [1, 1]),\n    Reaction(kP, [SE], [P, E], [1], [1, 1])\n]\n\n# Declares ReactionSystem model:\nrs = ReactionSystem(rxs, t, sps, ps; name = Symbol(\"##ReactionSystem#12592\"))\ncomplete(rs)\n\nend","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"note: Note\nThe code that save_reactionsystem prints uses programmatic modelling to generate the written model.","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"In addition to transferring models between Julia sessions, the save_reactionsystem function can also be used or print a model to a text file where you can easily inspect its components.","category":"page"},{"location":"model_creation/model_file_loading_and_export/#model_file_import_export_julia_serialisation","page":"Loading Chemical Reaction Network Models from Files","title":"Loading and Saving arbitrary Julia variables using Serialization.jl","text":"","category":"section"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"Julia provides a general and lightweight interface for loading and saving Julia structures to and from files that it can be good to be aware of. It is called Serialization.jl and provides two functions, serialize and deserialize. The first allows us to write a Julia structure to a file. E.g. if we wish to save a parameter set associated with our model, we can use","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"using Serialization\nps = [:k₁ => 1.0, :k₂ => 0.1, :k₃ => 2.0]\nserialize(\"saved_parameters.jls\", ps)","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"Here, we use the extension \".jls\" (standing for JuLia Serialization), however, any extension code can be used. To load a structure, we can then use","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"loaded_sol = deserialize(\"saved_parameters.jls\")\nrm(\"saved_parameters.jls\") # hide\nloaded_sol # hide","category":"page"},{"location":"model_creation/model_file_loading_and_export/#model_file_import_export_sbml_rni_net","page":"Loading Chemical Reaction Network Models from Files","title":"Loading .net files using ReactionNetworkImporters.jl","text":"","category":"section"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"A general-purpose format for storing CRN models is so-called .net files. These can be generated by e.g. BioNetGen. The ReactionNetworkImporters.jl package enables the loading of such files to Catalyst ReactionSystem. Here we load a Repressilator model stored in the \"repressilator.net\" file:","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"using ReactionNetworkImporters\nprn = loadrxnetwork(BNGNetwork(), \"repressilator.net\")","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"Here, .net files not only contain information regarding the reaction network itself, but also the numeric values (initial conditions and parameter values) required for simulating it. Hence, loadrxnetwork generates a ParsedReactionNetwork structure, containing all this information. You can access the model as prn.rn, the initial conditions as prn.u0, and the parameter values as prn.p. Furthermore, these initial conditions and parameter values are also made default values of the model.","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"A parsed reaction network's content can then be provided to various problem types for simulation. E.g. here we perform an ODE simulation of our repressilator model:","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"using Catalyst, OrdinaryDiffEqDefault, Plots\ntspan = (0.0, 10000.0)\noprob = ODEProblem(prn.rn, Float64[], tspan, Float64[])\nsol = solve(oprob)\nplot(sol; idxs = [:mTetR, :mLacI, :mCI])","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"(Image: Repressilator Simulation)","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"Note that, as all initial conditions and parameters have default values, we can provide empty vectors for these into our ODEProblem.","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"note: Note\nIt should be noted that .net files support a wide range of potential model features, not all of which are currently supported by ReactionNetworkImporters. Hence, there might be some .net files which loadrxnetwork will not be able to load.","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"A more detailed description of ReactionNetworkImporter's features can be found in its documentation.","category":"page"},{"location":"model_creation/model_file_loading_and_export/#model_file_import_export_sbml","page":"Loading Chemical Reaction Network Models from Files","title":"Loading SBML files using SBMLImporter.jl and SBMLToolkit.jl","text":"","category":"section"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"The Systems Biology Markup Language (SBML) is the most widespread format for representing CRN models. Currently, there exist two different Julia packages, SBMLImporter.jl and SBMLToolkit.jl, that are able to load SBML files to Catalyst ReactionSystem structures. SBML is able to represent a very wide range of model features, with both packages supporting most features. However, there exist SBML files (typically containing obscure model features such as events with time delays) that currently cannot be loaded into Catalyst models.","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"SBMLImporter's load_SBML function can be used to load SBML files. Here, we load a Brusselator model stored in the \"brusselator.xml\" file:","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"using SBMLImporter\nprn, cbs = load_SBML(\"brusselator.xml\", massaction = true)","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"Here, while ReactionNetworkImporters generates a ParsedReactionSystem only, SBMLImporter generates a ParsedReactionSystem (here stored in prn) and a so-called CallbackSet (here stored in cbs). While prn can be used to create various problems, when we simulate them, we must also supply cbs. E.g. to simulate our brusselator we use:","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"using Catalyst, OrdinaryDiffEqDefault, Plots\ntspan = (0.0, 50.0)\noprob = ODEProblem(prn.rn, prn.u0, tspan, prn.p)\nsol = solve(oprob; callback = cbs)\nplot(sol)","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"(Image: Brusselator Simulation)","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"Note that, while ReactionNetworkImporters adds initial condition and species values as default to the imported model, SBMLImporter does not do this. These must hence be provided to the ODEProblem directly.","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"A more detailed description of SBMLImporter's features can be found in its documentation.","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"note: Note\nThe massaction = true option informs the importer that the target model follows mass-action principles. When given, this enables SBMLImporter to make appropriate modifications to the model (which are important for e.g. jump simulation performance).","category":"page"},{"location":"model_creation/model_file_loading_and_export/#model_file_import_export_package_alts","page":"Loading Chemical Reaction Network Models from Files","title":"SBMLImporter and SBMLToolkit","text":"","category":"section"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"Above, we described how to use SBMLImporter to import SBML files. Alternatively, SBMLToolkit can be used instead. It has a slightly different syntax, which is described in its documentation, and does not support as wide a range of SBML features as SBMLImporter. A short comparison of the two packages can be found here. Generally, while they both perform well, we note that for jump simulations SBMLImporter is preferable (its way for internally representing reaction event enables more performant jump simulations).","category":"page"},{"location":"model_creation/model_file_loading_and_export/#model_file_import_export_matrix_representations","page":"Loading Chemical Reaction Network Models from Files","title":"Loading models from matrix representation using ReactionNetworkImporters.jl","text":"","category":"section"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"While CRN models can be represented through various file formats, they can also be represented in various matrix forms. E.g. a CRN with m species and n reactions (and with constant rates) can be represented with either","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"An mxn substrate matrix (with each species's substrate stoichiometry in each reaction) and an nxm product matrix (with each species's product stoichiometry in each reaction).","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"Or","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"An mxn complex stoichiometric matrix (...) and a 2mxn incidence matrix (...).","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"The advantage of these forms is that they offer a compact and very general way to represent a large class of CRNs. ReactionNetworkImporters have the functionality for converting matrices of these forms directly into Catalyst ReactionSystem models. Instructions on how to do this are available in ReactionNetworkImporter's documentation.","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"","category":"page"},{"location":"model_creation/model_file_loading_and_export/#petab_citations","page":"Loading Chemical Reaction Network Models from Files","title":"Citations","text":"","category":"section"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"If you use any of this functionality in your research, in addition to Catalyst, please cite the paper(s) corresponding to whichever package(s) you used:","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"@software{2022ReactionNetworkImporters,\n  author       = {Isaacson, Samuel},\n  title        = {{ReactionNetworkImporters.jl}},\n  howpublished = {\\url{https://github.com/SciML/ReactionNetworkImporters.jl}},\n  year         = {2022}\n}","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"@software{2024SBMLImporter,\n  author       = {Persson, Sebastian},\n  title        = {{SBMLImporter.jl}},\n  howpublished = {\\url{https://github.com/sebapersson/SBMLImporter.jl}},\n  year         = {2024}\n}","category":"page"},{"location":"model_creation/model_file_loading_and_export/","page":"Loading Chemical Reaction Network Models from Files","title":"Loading Chemical Reaction Network Models from Files","text":"@article{LangJainRackauckas+2024,\n    url = {https://doi.org/10.1515/jib-2024-0003},\n    title = {SBMLToolkit.jl: a Julia package for importing SBML into the SciML ecosystem},\n    title = {},\n    author = {Paul F. Lang and Anand Jain and Christopher Rackauckas},\n    pages = {20240003},\n    journal = {Journal of Integrative Bioinformatics},\n    doi = {doi:10.1515/jib-2024-0003},\n    year = {2024},\n    lastchecked = {2024-06-02}\n}","category":"page"},{"location":"model_simulation/simulation_plotting/#simulation_plotting","page":"Simulation plotting","title":"Simulation plotting","text":"","category":"section"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"Catalyst uses the Plots.jl package for performing all plots. This section provides a brief summary of some useful plotting options, while Plots.jl's documentation provides a more throughout description of how to tune your plots.","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"note: Note\nMakie.jl is a popular alternative to the Plots.jl package. While it is not used within Catalyst's documentation, it is worth considering (especially for users interested in interactivity, or increased control over their plots).","category":"page"},{"location":"model_simulation/simulation_plotting/#simulation_plotting_options","page":"Simulation plotting","title":"Common plotting options","text":"","category":"section"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"Let us consider the oscillating Brusselator model. We have previously shown how model simulation solutions can be plotted using the plot function. Here we plot an ODE simulation from the Brusselator:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"using Catalyst, OrdinaryDiffEqDefault, Plots\n\nbrusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend\nu0 = [:X => 1.0, :Y => 0.0]\ntspan = (0.0, 50.0)\nps = [:A => 1.0, :B => 4.0]\n\noprob = ODEProblem(brusselator, u0, tspan, ps)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"Various plotting options can be provided as optional arguments to the plot command. Common options include:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"lw: Determine plot line widths.\nla: Determine plot line's transparency (at la = 0.0 lines are fully transparent, i.e. not visible).\nlinestyle: Determines plot line style.\ncolor: Determines the line colours.\nlegend: Determines the position of the legend/labels.\nlabel: Determines label texts.\nxguide, yguide: Determines x and y axis labels.\ntitle: Determines plot title.\nlegendfontsize, guidefontsize, titlefontsize: Determines the font size of the labels, x and y guides, and title, respectively.","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"Here, we re-plot our simulations, utilising some of these options (legend = :none is used to disable the legends).","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plot(sol; lw = 4, linestyle = :dash, color = :green, xguide = \"Time\", yguide = \"Concentration\", guidefontsize = 14)","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"Note that, by default, Catalyst uses xguide = \"t\". Here, however, we modify this to xguide = \"Time\". We also note that the color = :green change both lines' colours to green. To set different colours for each line, we provide these as a vector without , in-between elements (in Julia interpreted as a matrix with its first dimension equal to 1):","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plot(sol; lw = 4, color = [:green :purple])","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"A full list of available colours can be found here. A full list of possible plotting options can be found here (look at the list of various plot attributes, e.g. \"Series Attributes\"). if there is some option(s) you intend to use multiple times, you can call the default function using these, in which case they will be used for all subsequent plots. E.g. here:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"default(framestyle = :box, grid = false)","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"we designate a box-style frame, and remove the faint background grid, for all subsequent plots in this tutorial.","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"A useful option unique to Catalyst (and other DifferentialEquations.jl-based) plots is idxs. Its input is a vector, listing all the species (or quantities) that should be plotted. I.e.","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plot(sol; idxs = [:X])","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"can be used to plot X only. When only a single argument is given, the vector form is unnecessary (e.g. idxs = :X could have been used instead). If symbolic species representation is used, this can be used to designate any algebraic expression(s) that should be plotted. E.g. here we plot the total concentration of X + Y throughout the simulation:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plot(sol; idxs = brusselator.X + brusselator.Y)","category":"page"},{"location":"model_simulation/simulation_plotting/#simulation_plotting_options_subplots","page":"Simulation plotting","title":"Multi-plot plots","text":"","category":"section"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"It is possible to save plots in variables. These can then be used as input to the plot command. Here, the plot command can be used to create plots containing multiple plots (by providing multiple inputs). E.g. here we plot the concentration of X and Y in separate subplots:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plt_X = plot(sol; idxs = [:X])\nplt_Y = plot(sol; idxs = [:Y])\nplot(plt_X, plt_Y)","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"When working with subplots, the layout and size options are typically useful. Here we use layout to put the first plot above the second one, and size to reshape the plot size:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plot(plt_X, plt_Y; layout = (2,1), size = (700,500))","category":"page"},{"location":"model_simulation/simulation_plotting/#simulation_plotting_options_saving","page":"Simulation plotting","title":"Saving plots","text":"","category":"section"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"Once a plot has been saved to a variable, the savefig function can be used to save it to a file. Here we save our Brusselator plot simulation (the first argument) to a file called \"saved_plot.png\" (the second argument):","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plt = plot(sol)\nsavefig(plt, \"saved_plot.png\")\nrm(\"saved_plot.png\") # hide","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"The plot file type is automatically determined from the extension (if none is given, a .png file is created).","category":"page"},{"location":"model_simulation/simulation_plotting/#simulation_plotting_options_phasespace","page":"Simulation plotting","title":"Phase-space plots","text":"","category":"section"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"By default, simulations are plotted as species concentrations over time. However, phase space plots are also possible. This is done by designating the axis arguments using the idxs option, but providing them as a tuple. E.g. here we plot our simulation in X-Y space:","category":"page"},{"location":"model_simulation/simulation_plotting/","page":"Simulation plotting","title":"Simulation plotting","text":"plot(sol; idxs = (:X, :Y))","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/#smoluchowski_coagulation_equation","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"","category":"section"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"This tutorial shows how to programmatically construct a ReactionSystem corresponding to the chemistry underlying the Smoluchowski coagulation model using ModelingToolkit/Catalyst. A jump process version of the model is then constructed from the ReactionSystem, and compared to the model's analytical solution obtained by the method of Scott (see also 3).","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"The Smoluchowski coagulation equation describes a system of reactions in which monomers may collide to form dimers, monomers and dimers may collide to form trimers, and so on. This models a variety of chemical/physical processes, including polymerization and flocculation.","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"We begin by importing some necessary packages.","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"using ModelingToolkit, Catalyst, LinearAlgebra\nusing JumpProcesses\nusing Plots, SpecialFunctions","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"Suppose the maximum cluster size is N. We assume an initial concentration of monomers, Nₒ, and let uₒ denote the initial number of monomers in the system. We have nr total reactions, and label by V the bulk volume of the system (which plays an important role in the calculation of rate laws since we have bimolecular reactions). Our basic parameters are then","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# maximum cluster size\nN = 10\n\n# volume of a monomers in cm³\nVₒ = (4π / 3) * (10e-06 * 100)^3\n\n# initial conc. = (No. of init. monomers) / bulk volume\nNₒ = 1e-06 / Vₒ\n\n# No. of monomers initially\nuₒ = 10000\n\n# Bulk volume of system in cm³\nV = uₒ / Nₒ\nn = floor(Int, N / 2)\n\n# No. of forward reactions\nnr = ((N % 2) == 0) ? (n*(n + 1) - n) : (n*(n + 1))\nnothing #hide","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"The Smoluchowski coagulation equation Wikipedia page illustrates the set of possible reactions that can occur. We can easily enumerate the pairs of multimer reactants that can combine when allowing a maximal cluster size of N monomers. We initialize the volumes of the reactant multimers as volᵢ and volⱼ","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# possible pairs of reactant multimers\npair = []\nfor i = 2:N\n    halfi = floor(Int, i/2)\n    push!(pair, [(1:halfi)  (i .- (1:halfi))])\nend\npair = vcat(pair...)\nvᵢ = @view pair[:, 1]  # Reactant 1 indices\nvⱼ = @view pair[:, 2]  # Reactant 2 indices\nvolᵢ = Vₒ * vᵢ         # cm⁻³\nvolⱼ = Vₒ * vⱼ         # cm⁻³\nsum_vᵢvⱼ = @. vᵢ + vⱼ  # Product index\nnothing #hide","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"We next specify the rates (i.e. kernel) at which reactants collide to form products. For simplicity, we allow a user-selected additive kernel or constant kernel. The constants(B and C) are adopted from Scott's paper 2","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# set i to  1 for additive kernel, 2  for constant\ni = 1\nif i == 1\n    B = 1.53e03    # s⁻¹\n\n    # dividing by volume as it is a bimolecular reaction chain\n    kv = @. B * (volᵢ + volⱼ) / V\nelseif i==2\n    C = 1.84e-04    # cm³ s⁻¹\n    kv = fill(C / V, nr)\nend\nnothing #hide","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"We'll set the parameters and the initial condition that only monomers are present at t=0 in u₀map.","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# k is a vector of the parameters, with values given by the vector kv\n@parameters k[1:nr] = kv\n\n# create the vector of species X_1,...,X_N\nt = default_t()\n@species (X(t))[1:N]\n\n# time-span\nif i == 1\n    tspan = (0.0, 2000.0)\nelseif i == 2\n    tspan = (0.0, 350.0)\nend\n\n # initial condition of monomers\nu₀    = zeros(Int64, N)\nu₀[1] = uₒ\nu₀map = Pair.(collect(X), u₀)   # map species to its initial value\nnothing #hide","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"Here we generate the reactions programmatically. We systematically create Catalyst Reactions for each possible reaction shown in the figure on Wikipedia. When vᵢ[n] == vⱼ[n], we set the stoichiometric coefficient of the reactant multimer to two.","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# vector to store the Reactions in\nrx = []\nfor n = 1:nr\n    # for clusters of the same size, double the rate\n    if (vᵢ[n] == vⱼ[n])\n        push!(rx, Reaction(k[n], [X[vᵢ[n]]], [X[sum_vᵢvⱼ[n]]], [2], [1]))\n    else\n        push!(rx, Reaction(k[n], [X[vᵢ[n]], X[vⱼ[n]]], [X[sum_vᵢvⱼ[n]]],\n                           [1, 1], [1]))\n    end\nend\n@named rs = ReactionSystem(rx, t, collect(X), [k])\nrs = complete(rs)","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"We now convert the ReactionSystem into a ModelingToolkit.JumpSystem, and solve it using Gillespie's direct method. For details on other possible solvers (SSAs), see the DifferentialEquations.jl documentation","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# solving the system\njinputs = JumpInputs(rs, u₀map, tspan)\njprob = JumpProblem(jinputs, Direct(); save_positions = (false, false))\njsol = solve(jprob; saveat = tspan[2] / 30)\nnothing #hide","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"Lets check the results for the first three polymers/cluster sizes. We compare to the analytical solution for this system:","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"# Results for first three polymers...i.e. monomers, dimers and trimers\nv_res = [1; 2; 3]\n\n# comparison with analytical solution\n# we only plot the stochastic solution at a small number of points\n# to ease distinguishing it from the exact solution\nt   = jsol.t\nsol = zeros(length(v_res), length(t))\nif i == 1\n    ϕ = @. 1 - exp(-B*Nₒ*Vₒ*t)\n    for j in v_res\n        sol[j,:] = @. Nₒ*(1 - ϕ)*(((j*ϕ)^(j-1))/gamma(j+1))*exp(-j*ϕ)\n    end\nelseif i == 2\n    ϕ = @. (C*Nₒ*t)\n    for j in v_res\n        sol[j,:] = @. 4Nₒ*((ϕ^(j-1))/((ϕ + 2)^(j+1)))\n    end\nend\n\n# plotting normalised concentration vs analytical solution\ndefault(lw = 2, xlabel = \"Time (sec)\")\nscatter(ϕ, jsol(t)[1,:] / uₒ, label = \"X1 (monomers)\", markercolor = :blue)\nplot!(ϕ, sol[1,:]/Nₒ, line = (:dot,4,:blue), label=\"Analytical sol--X1\")\n\nscatter!(ϕ, jsol(t)[2,:] / uₒ, label = \"X2 (dimers)\", markercolor = :orange)\nplot!(ϕ, sol[2,:] / Nₒ, line = (:dot, 4, :orange), label = \"Analytical sol--X2\")\n\nscatter!(ϕ, jsol(t)[3,:] / uₒ, label = \"X3 (trimers)\", markercolor = :purple)\nplot!(ϕ, sol[3,:] / Nₒ, line = (:dot, 4, :purple), label = \"Analytical sol--X3\",\n      ylabel = \"Normalized Concentration\")","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"","category":"page"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/#References","page":"Smoluchowski Coagulation Equation","title":"References","text":"","category":"section"},{"location":"model_creation/examples/smoluchowski_coagulation_equation/","page":"Smoluchowski Coagulation Equation","title":"Smoluchowski Coagulation Equation","text":"https://en.wikipedia.org/wiki/Smoluchowski_coagulation_equation\nScott, W. T. (1968). Analytic Studies of Cloud Droplet Coalescence I, Journal of Atmospheric Sciences, 25(1), 54-65. Retrieved Feb 18, 2021, from https://journals.ametsoc.org/view/journals/atsc/25/1/1520-0469_1968_025_0054_asocdc_2_0_co_2.xml\nIan J. Laurenzi, John D. Bartels, Scott L. Diamond, A General Algorithm for Exact Simulation of Multicomponent Aggregation Processes, Journal of Computational Physics, Volume 177, Issue 2, 2002, Pages 418-449, ISSN 0021-9991, https://doi.org/10.1006/jcph.2002.7017.","category":"page"},{"location":"devdocs/dev_guide/#Catalyst-Developer-Documentation","page":"Developer Documentation","title":"Catalyst Developer Documentation","text":"","category":"section"},{"location":"devdocs/dev_guide/#Release-Process","page":"Developer Documentation","title":"Release Process","text":"","category":"section"},{"location":"devdocs/dev_guide/","page":"Developer Documentation","title":"Developer Documentation","text":"Beginning with v15, Catalyst is using a new release process to try to ensure continuing stability of releases. Before making a release one should","category":"page"},{"location":"devdocs/dev_guide/","page":"Developer Documentation","title":"Developer Documentation","text":"Create a new release branch, i.e. \"release-15.0.0\"\nOn this branch, cap major dependencies to their latest version that works and for which tests pass.\nCaps need to be included in both Project.toml and docs/Project.toml.\nDo not cap the master branch as this can prevent upstream libraries from properly testing against Catalyst, and hide breaking changes that impact Catalyst.\nCheck docs build with the capped dependencies. Visually verify via checking the artifact in the doc build that the docs actually look ok (since sometimes issues can arise that do not lead to actual errors in the doc CI).\nRelease via the registration issue with the command:\n@JuliaRegistrator register branch=release-15.0.0\nmodifying as appropriate for the version you are releasing.","category":"page"},{"location":"devdocs/dev_guide/","page":"Developer Documentation","title":"Developer Documentation","text":"If there is subsequently a need to increment the version of a dependency, this should be done via a new release that follows the above process, and modifies the patch, minor, or major Catalyst version (as appropriate for the potential impact of the dependency change on Catalyst users). If the dependency being updated is a non-breaking release, and would have automatically been installed by the package resolver had it not been capped, a patch release should be preferred. If the new release branch is branched from master, it needs to ensure Project.toml caps are all ≥ to those listed in the previous Catalyst release branch.","category":"page"},{"location":"model_simulation/sde_simulation_performance/#sde_simulation_performance","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"","category":"section"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"While there exist relatively straightforward approaches to manage performance for ODE and jump simulations, this is generally not the case for SDE simulations. Below, we briefly describe some options. However, as one starts to investigate these, one quickly reaches what is (or could be) active areas of research.","category":"page"},{"location":"model_simulation/sde_simulation_performance/#sde_simulation_performance_solvers","page":"Advice for performant SDE simulations","title":"SDE solver selection","text":"","category":"section"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"We have previously described how ODE solver selection can impact simulation performance. Again, it can be worthwhile to investigate solver selection's impact on performance for SDE simulations. Throughout this documentation, we generally use the STrapezoid solver as the default choice. However, if the DifferentialEquations package is loaded","category":"page"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"using DifferentialEquations","category":"page"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"automatic SDE solver selection enabled (just like is the case for ODEs by default). Generally, the automatic SDE solver choice enabled by DifferentialEquations is better than just using STrapezoid. Next, if performance is critical, it can be worthwhile to check the list of available SDE solvers to find one with advantageous performance for a given problem. When doing so, it is important to pick a solver compatible with non-diagonal noise and with Ito problems. ","category":"page"},{"location":"model_simulation/sde_simulation_performance/#sde_simulation_performance_jacobian","page":"Advice for performant SDE simulations","title":"Options for Jacobian computation","text":"","category":"section"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"In the section on ODE simulation performance, we describe various options for computing the system Jacobian, and how these could be used to improve performance for implicit solvers. These can be used in tandem with implicit SDE solvers (such as STrapezoid). However, due to additional considerations during SDE simulations, it is much less certain whether these will actually have any impact on performance. So while these options might be worth reading about and trialling, there is no guarantee that they will be beneficial.","category":"page"},{"location":"model_simulation/sde_simulation_performance/#sde_simulation_performance_parallelisation","page":"Advice for performant SDE simulations","title":"Parallelisation on CPUs and GPUs","text":"","category":"section"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"We have previously described how simulation parallelisation can be used to improve performance when multiple ODE simulations are carried out. The same approaches can be used for SDE simulations. Indeed, it is often more relevant for SDEs, as these are often re-simulated using identical simulation conditions (to investigate their typical behaviour across many samples). CPU parallelisation of SDE simulations uses the same approach as ODEs. GPU parallelisation requires some additional considerations, which are described below.","category":"page"},{"location":"model_simulation/sde_simulation_performance/#sde_simulation_performance_parallelisation_GPU","page":"Advice for performant SDE simulations","title":"GPU parallelisation of SDE simulations","text":"","category":"section"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"GPU parallelisation of SDE simulations uses a similar approach as that for ODE simulations. The main differences are that SDE parallelisation requires a GPU SDE solver (like GPUEM) and fixed time stepping.","category":"page"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"We will assume that we are using the CUDA GPU hardware, so we will first load the CUDA.jl backend package, as well as DiffEqGPU:","category":"page"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"using CUDA, DiffEqGPU","category":"page"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"Which backend package you should use depends on your available hardware, with the alternatives being listed here.","category":"page"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"Next, we create the SDEProblem which we wish to simulate. Like for ODEs, we ensure that all vectors are static vectors and that all values are Float32s. Here we prepare the parallel simulations of a simple birth-death process.","category":"page"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"using Catalyst, StochasticDiffEq, StaticArrays\nbd_model = @reaction_network begin\n    (p,d), 0 <--> X\nend\n@unpack X, p, d = bd_model\n\nu0 = @SVector [X => 20.0f0]\ntspan = (0.0f0, 10.0f0)\nps = @SVector [p => 10.0f0, d => 1.0f0]\nsprob = SDEProblem(bd_model, u0, tspan, ps)\nnothing # hide","category":"page"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"The SDEProblem is then used to create an EnsembleProblem.","category":"page"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"eprob = EnsembleProblem(sprob)\nnothing # hide","category":"page"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"Finally, we can solve our EnsembleProblem while:","category":"page"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"Using a valid GPU SDE solver (either GPUEM or GPUSIEA).\nDesignating the GPU ensemble method, EnsembleGPUKernel (with the correct GPU backend as input).\nDesignating the number of trajectories we wish to simulate.\nDesignating a fixed time step size.","category":"page"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"esol = solve(eprob, GPUEM(), EnsembleGPUKernel(CUDA.CUDABackend()); trajectories = 10000, dt = 0.01)","category":"page"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"Above we parallelise GPU simulations with identical initial conditions and parameter values. However, varying these is also possible.","category":"page"},{"location":"model_simulation/sde_simulation_performance/#sde_simulation_performance_parallelisation_mlmc","page":"Advice for performant SDE simulations","title":"Multilevel Monte Carlo","text":"","category":"section"},{"location":"model_simulation/sde_simulation_performance/","page":"Advice for performant SDE simulations","title":"Advice for performant SDE simulations","text":"An approach for speeding up parallel stochastic simulations is so-called multilevel Monte Carlo approaches (MLMC). These are used when a stochastic process is simulated repeatedly using identical simulation conditions. Here, instead of performing all simulations using identical tolerance, the ensemble is simulated using a range of tolerances (primarily lower ones, which yields faster simulations). Currently, StochasticDiffEq.jl do not have a native implementation for performing MLMC simulations (this will hopefully be added in the future). However, if high performance of parallel SDE simulations is required, these approaches may be worth investigating.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_parameter_fitting","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"The PEtab.jl package implements the PEtab format for fitting the parameters of deterministic CRN models to data [1]. PEtab.jl both implements methods for creating cost functions (determining how well parameter sets fit to data), and for minimizing these cost functions. The PEtab approach covers most cases of fitting deterministic (ODE) models to data and is a good default choice when fitting reaction rate equation ODE models. This page describes how to combine PEtab.jl and Catalyst for parameter fitting, with the PEtab.jl package providing a more extensive documentation (this tutorial is partially an adaptation of this documentation). ","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"While PEtab's interface generally is very flexible, there might be specific use-cases where it cannot create an appropriate cost-function. Here, it is recommended to instead look at using Optimization.jl.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Introductory-example","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Introductory example","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Let us consider a simple catalysis network, where an enzyme (E) turns a substrate (S) into a product (P):","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Catalyst, PEtab\n\nrn = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"From some known initial condition, and a true parameter set (which we later want to recover from the data) we generate synthetic data (on which we will demonstrate the fitting process).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"# Define initial conditions and parameters.\nu0 = [:S => 1.0, :E => 1.0, :SE => 0.0, :P => 0.0]\np_true = [:kB => 1.0, :kD => 0.1, :kP => 0.5]\n\n# Generate synthetic data.\nusing OrdinaryDiffEqDefault\noprob_true = ODEProblem(rn, u0, (0.0, 10.0), p_true)\ntrue_sol = solve(oprob_true)\ndata_sol = solve(oprob_true; saveat = 1.0)\ndata_ts = data_sol.t[2:end]\ndata_vals = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\n\n# Plots the true solutions and the (synthetic data) measurements.\nusing Plots\ndefault(bottom_margin = 4Plots.Measures.mm, left_margin = 4Plots.Measures.mm) # hide\nplot(true_sol; idxs = :P, label = \"True solution\", lw = 4)\nplot!(data_ts, data_vals; label = \"Measurements\", seriestype = :scatter, ms = 6, color = :blue)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Generally, PEtab takes five different inputs to define an optimisation problem (the minimiser of which generates a fitted parameter set):","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Model: The model which we want to fit to the data (a ReactionSystem).\nObservables: The possible observables that can be measured (a Dict{String,PEtabObservable}).\nEstimation parameters: The parameters which we want to fit to the data (a Vector{PEtabParameter}).\nExperimental (or simulation) conditions: The simulations (each corresponding to a potential experiment) carried out during each step of the optimisation process (a Dict{String,Dict{Symbol,Float64}}).\nMeasurements: The measurements to which the model is fitted (a DataFrame).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Observables","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Observables","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"The observables define the quantities that we may measure in our experiments. Typically, each corresponds to a single species, however, more complicated observables are possible. For each observable, we also need a noise formula, defining the uncertainty in its measurements. By default, PEtab assumes normally distributed noise, with a mean equal to the true value and a standard deviation which we have to define. It is also possible to use more advanced noise formulas.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In our example, we only have a single possible observable, the P species. We will assume that the noise is normally distributed with a standard deviation 0.5 (in our case this is not true, however, typically the noise distribution is unknown and a guess must be made). We combine this information in a PEtabObservable struct (to access the P species we must use @unpack). Finally, we store all our observables in a dictionary, giving each an id tag (which is later used in the measurements input).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"@unpack P = rn\nobs_P = PEtabObservable(P, 0.5)\nobservables = Dict(\"obs_P\" => obs_P)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Parameters","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameters","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Each parameter of the system can either be","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Known (described here).\nDepend on experimental/simulation conditions (described here).\nBe an unknown that we wish to fit to data.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In our case, we wish to fit all three system parameters (kB, kD, and kP). For each, we create a single PEtabParameter, and then gather these into a single vector.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"par_kB = PEtabParameter(:kB)\npar_kD = PEtabParameter(:kD)\npar_kP = PEtabParameter(:kP)\nparams = [par_kB, par_kD, par_kP]\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"For each parameter, it is also possible to set a lower and/or upper bound (by default, (00011000) is used), set whether to use logarithmic or linear scale, or add a prior distribution of its value.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Simulation-conditions","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Simulation conditions","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Sometimes, several different experiments are performed on a system (each potentially generating several measurements). An experiment could e.g. be the time development of a system from a specific initial condition. Since each experimental condition (during the optimisation procedure, for a guess of the unknown parameters) generates a distinct simulation, these are also called simulation conditions. In our example, all data comes from a single experiment, and the simulation condition input is not required. How to define and use different experimental conditions is described here.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Measurements","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Measurements","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Finally, we need to define the system measurements to which the parameters will be fitted. Each measurement combines:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"The observable which is observed (here we use the id tag defined in the observables dictionary).\nThe time point of the measurement.\nThe measured value.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"For cases where several simulation conditions are given, we also need to provide:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"The simulation condition which generates the measurement (here is an example where this is used).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Note also, when pre-equilibration is used to initiate the system in a steady state, a fifth field is also required.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Each individual measurement is provided as a row of a DataFrame. The values are provided in the obs_id, time, measurement, and simulation_id columns. In our case we only need to fill in the first three:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using DataFrames\nmeasurements = DataFrame(obs_id = \"obs_P\", time = data_ts, measurement = data_vals)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Since, in our example, all measurements are of the same observable, we can set obs_id=\"obs_P\". However, it is also possible to include measurements from several different observables.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Creating-a-PEtabModel","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Creating a PEtabModel","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Finally, we combine all inputs in a single PEtabModel. To it, we also pass the initial conditions of our simulations (using the speciemap argument). It is also possible to have initial conditions with uncertainty, that vary between different simulations, or that we attempt to fit to the data.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"petab_model = PEtabModel(rn, observables, measurements, params; speciemap = u0)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Fitting-parameters","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Fitting parameters","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"We are now able to fit our model to the data. First, we create a PEtabODEProblem. Here, we use petab_model as the only input, but it is also possible to set various numeric solver and automatic differentiation options (such as method or tolerance).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"petab_problem = PEtabODEProblem(petab_model)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Since no additional input is given, default options are selected by PEtab.jl (and generally, its choices are good).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"To fit a parameter set we use the calibrate function. In addition to our PEtabODEProblem, we must also provide an initial guess (which can be generated with the generate_startguesses function) and an optimisation algorithm (which needs to be imported specifically). PEtab.jl supports various optimisation methods and options.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Optim\np0 = get_startguesses(petab_problem, 1)\np0 = [0.0, 0.0, 0.0] # hide\nres = calibrate(petab_problem, p0, IPNewton()) # hide\nres = calibrate(petab_problem, p0, IPNewton())","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"We can now simulate our model for the fitted parameter set, and compare the result to the measurements and true solution.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"oprob_fitted = remake(oprob_true; p = get_ps(res, petab_problem))\nfitted_sol = solve(oprob_fitted)\nplot!(fitted_sol; idxs = :P, label = \"Fitted solution\", linestyle = :dash, lw = 4, color = :lightblue)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here we use the get_ps function to retrieve a full parameter set using the optimal parameters. Alternatively, the ODEProblem or fitted simulation can be retrieved directly using the get_odeproblem or get_odesol functions, respectively (and the initial condition using the get_u0 function). The calibration result can also be found in res.xmin, however, note that PEtab automatically (unless a linear scale is selected) converts parameters to logarithmic scale, so typically 10 .^res.xmin are the values of interest. If you investigate the result from this example you might note, that even if PEtab.jl has found the global optimum (which fits the data well), this does not actually correspond to the true parameter set. This phenomenon is related to the concept of identifiability, which is very important for parameter fitting.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Final-notes","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Final notes","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"PEtab.jl also supports multistart optimisation, automatic pre-equilibration before simulations, and events. Various plot recipes exist for investigating the optimisation process. Please read the PEtab.jl documentation for a more complete description of the package's features. Below follows additional details of various options and features (generally, PEtab is able to find good default values for most options that are not specified).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_observables","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Additional features: Observables","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_observables_observables","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Defining non-trivial observables","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"It is possible for observables to be any algebraic expression of species concentrations and parameters. E.g. in this example the total amount of X in the system is an observable:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Catalyst, PEtab # hide\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\n@unpack X1, X2 = two_state_model\nobs_X = PEtabObservable(X1 + X2, 0.5)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"A common application for this is to define an offset and a scale for each observable.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_observables_noise_formula","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Advanced observables noise formulas","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In our basic example we assumed that the normally distributed noise had a standard deviation of 0.5. However, this value may be a parameter (or indeed any algebraic expression). E.g, we could set","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"@parameters σ\nobs_P = PEtabObservable(P, σ)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"and then let the parameter σ vary between different simulation conditions. Alternatively we could let the noise scale linearly with the species' concentration:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"obs_P = PEtabObservable(P, 0.05P)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"It would also be possible to make σ a parameter that is fitted as a part of the parameter fitting process.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"PEtab.jl assumes that noise is normally distributed (with a standard deviation equal to the second argument provided to PEtabObservable). The only other (currently implemented) noise distribution is log-normally distributed noise, which is designated through the transformation=:log argument:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"obs_P = PEtabObservable(P, σ; transformation = :log)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_parameters","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Additional features: Parameters","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_parameters_known","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Known parameters","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In our previous example, all parameters were unknowns that we wished to fit to the data. If any parameters have known values, it is possible to provide these to PEtabModel through the parameter_map argument. E.g if we had known that kB = 10, then we would only define kD and kP as parameters we wish to fit:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"par_kD = PEtabParameter(:kD)\npar_kP = PEtabParameter(:kP)\nparams = [par_kD, par_kP]\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"We then provide parameter_map=[:kB => 1.0] when we assembly our model:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"petab_model_known_param = PEtabModel(rn, observables, measurements, params; speciemap = u0, parametermap = [:kB => 1.0])\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_parameters_bounds","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter bounds","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"By default, when fitted, potential parameter values are assumed to be in the interval (1e-3 1e3). When declaring a PEtabParameter it is possible to change these values through the lb and ub arguments. E.g. we could use","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"par_kB = PEtabParameter(:kB; lb = 1e-2, ub = 1e2)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"to achieve the more conservative bound (1e-2 1e2) for the parameter kB.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_parameters_scales","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter scales","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Internally, parameters that are fitted are converted to a logarithmic scale (generally, this is considered advantageous[2]). To prevent this conversion, the scale=:lin argument can be used. Here we change the scale of kB to linear:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"par_kB = PEtabParameter(:kB; scale = :lin)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_parameters_priors","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter priors","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"If we have prior knowledge about the distribution of a parameter, it is possible to incorporate this into the model. The prior can be any continuous, univariate, distribution from the Distributions.jl package. E.g we can use:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Distributions\npar_kB = PEtabParameter(:kB; prior = Normal(1.0,0.2))","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"to set a normally distributed prior (with mean 1.0 and standard deviation 0.2) on the value of kB. By default, the prior is assumed to be on the linear scale of the parameter (before any potential log transform). To specify that the prior is on the logarithmic scale, the prior_on_linear_scale=false argument can be provided:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"par_kB = PEtabParameter(:kB; prior = Normal(1.0,0.2), prior_on_linear_scale = false)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In this example, setting prior_on_linear_scale=false makes sense as a (linear) normal distribution is non-zero for negative values (an alternative is to use a log-normal distribution, e.g. prior=LogNormal(3.0, 3.0)).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_conditions","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Simulation conditions","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Sometimes, we have data from different experimental conditions. Here, when a potential parameter set is evaluated during the fitting process, each experimental condition corresponds to one simulation condition (which produces one simulation). To account for this, PEtab permits the user to define different simulation conditions, with each condition being defined by specific values for some initial conditions and/or parameters.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"If, for our previous catalysis example, we had measured the system for two different initial values of S (S(0)=10 and S(0)=tfrac12), these would correspond to two different simulation conditions. For each condition we define a Dict mapping the species to their initial condition (here, S is the only species in each Dict):","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"c1 = Dict(:S => 1.0)\nc2 = Dict(:S => 0.5)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Similarly as for observables, we then gather the conditions in another Dict, giving each an id tag:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"simulation_conditions = Dict(\"c1\" => c1, \"c2\" => c2)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Again (like for observables), each measurement in the measurements DataFrame needs to be associated with a simulation condition id tag (describing which condition those measurements were taken from). Parameters, just like initial conditions, may vary between different conditions. If an initial condition (or parameter) occurs in one condition, it must occur in all of them.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here follows a complete version of our basic example, but with measurements both for S(0)=10 and S(0)=tfrac12.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Catalyst, PEtab\n\nrn = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend\n\nu0 = [:E => 1.0, :SE => 0.0, :P => 0.0]\np_true = [:kB => 1.0, :kD => 0.1, :kP => 0.5]\n\n# Simulate data.\nusing OrdinaryDiffEqDefault\nt1, d1 = let\n    oprob_true = ODEProblem(rn, [:S => 1.0; u0], (0.0, 10.0), p_true)\n    data_sol = solve(oprob_true; saveat = 1.0)\n    data_sol.t[2:end], (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\nend\nt2, d2 = let\n    oprob_true = ODEProblem(rn, [:S=>0.5; u0], (0.0, 10.0), p_true)\n    data_sol = solve(oprob_true; saveat = 1.0)\n    data_sol.t[2:end], (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\nend\n\n@unpack P = rn\nobs_P = PEtabObservable(P, 0.5)\nobservables = Dict(\"obs_P\" => obs_P)\n\npar_kB = PEtabParameter(:kB)\npar_kD = PEtabParameter(:kD)\npar_kP = PEtabParameter(:kP)\nparams = [par_kB, par_kD, par_kP]\n\nc1 = Dict(:S => 1.0)\nc2 = Dict(:S => 0.5)\nsimulation_conditions = Dict(\"c1\" => c1, \"c2\" => c2)\n\nusing DataFrames\nm1 = DataFrame(simulation_id = \"c1\", obs_id = \"obs_P\", time = t1, measurement = d1)\nm2 = DataFrame(simulation_id = \"c2\", obs_id = \"obs_P\", time = t2, measurement = d2)\nmeasurements = vcat(m1,m2)\n\npetab_model = PEtabModel(rn, observables, measurements, params; speciemap = u0, \n                         simulation_conditions = simulation_conditions)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Note that the u0 we pass into PEtabModel through the speciemap argument no longer contains the value of S (as it is provided by the conditions).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_measurements","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Additional features: Measurements","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_measurements_several_observables","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Measurements of several observables","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In our previous example, all our measurements were from a single observable, obs_P. If we also had collected measurements of both S and P:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"data_ts = data_sol.t[2:end]\ndata_vals_S = (0.8 .+ 0.4*rand(10)) .* data_sol[:S][2:end]\ndata_vals_P = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"and then corresponding observables:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"@unpack S, P = rn\nobs_S = PEtabObservable(S, 0.5)\nobs_P = PEtabObservable(P, 0.5)\nobservables = Dict(\"obs_S\" => obs_P, \"obs_P\" => obs_P)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"we are able to include all these measurements in the same measurements DataFrame:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"m1 = DataFrame(obs_id = \"obs_P\", time = data_ts, measurement = data_vals_S)\nm2 = DataFrame(obs_id = \"obs_S\", time = data_ts, measurement = data_vals_P)\nmeasurements = vcat(m1,m2)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"which then can be used as input to PEtabModel.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Varying-parameters-between-different-simulation-conditions","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Varying parameters between different simulation conditions","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Sometimes, the parameters that are used vary between the different conditions. Consider our catalysis example, if we had performed the experiment twice, using two different enzymes with different catalytic properties, this could have generated such conditions. The two enzymes could e.g. yield different rates (kP_1 and kP_2) for the SE --> P + E reaction, but otherwise be identical. Here, the parameters kP_1 and kP_2 are unique to their respective conditions. PEtab.jl provides support for cases such as this, and its documentation provided instructions of how to handle them.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_initial_conditions","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Additional features: Initial conditions","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_initial_conditions_fitted","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Fitting initial conditions","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Sometimes, initial conditions are uncertain quantities which we wish to fit to the data. This is possible by defining an initial condition as a parameter:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Catalyst, PEtab # hide\nrn = @reaction_network begin\n    @parameters E0\n    @species E(t)=E0\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here, the initial value of E is equal to the parameter E0. We modify our u0 vector by removing E (which is no longer known):","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"u0 = [:S => 1.0, :SE => 0.0, :P => 0.0]\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Next, we add E0 to the parameters we wish to fit:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"par_kB = PEtabParameter(:kB)\npar_kD = PEtabParameter(:kD)\npar_kP = PEtabParameter(:kP)\npar_E0 = PEtabParameter(:E0)\nparams = [par_kB, par_kD, par_kP, par_E0]\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"and we can use our updated rn, u0, and params as input to our PEtabModel.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_initial_conditions_uncertainty","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Uncertain initial conditions","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Often, while an initial condition has been reported for an experiment, its exact value is uncertain. This can be modelled by making the initial condition a parameter that is fitted to the data and attaching a prior to it corresponding to our certainty about its value.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Let us consider our initial example, but where we want to add uncertainty to the initial conditions of S and E. We will add priors on these, assuming normal distributions with mean 1.0 and standard deviation 0.1. For the synthetic measured data we will use the true values S(0) = E(0) = 10.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Catalyst, Distributions, PEtab \n\nrn = @reaction_network begin\n    @parameters S0 E0\n    @species S(t)=S0 E(t)=E0\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend\n\nu0 = [:SE => 0.0, :P => 0.0]\np_true = [:kB => 1.0, :kD => 0.1, :kP => 0.5, :S0=>1.0, :E0 => 1.0]\n\nusing OrdinaryDiffEqDefault\noprob_true = ODEProblem(rn, u0, (0.0, 10.0), p_true)\ntrue_sol = solve(oprob_true)\ndata_sol = solve(oprob_true; saveat = 1.0)\ndata_ts = data_sol.t[2:end]\ndata_vals = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]\n\n@unpack P = rn\nobs_P = PEtabObservable(P, 0.5)\nobservables = Dict(\"obs_P\" => obs_P)\n\npar_kB = PEtabParameter(:kB)\npar_kD = PEtabParameter(:kD)\npar_kP = PEtabParameter(:kP)\npar_S0 = PEtabParameter(:S0; prior = Normal(1.0, 0.1))\npar_E0 = PEtabParameter(:E0; prior = Normal(1.0, 0.1))\nparams = [par_kB, par_kD, par_kP, par_S0, par_E0]\n\nusing DataFrames\nmeasurements = DataFrame(obs_id = \"obs_P\", time = data_ts, measurement = data_vals)\n\npetab_model = PEtabModel(rn, observables, measurements, params; speciemap = u0)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here, when we fit our data we will also gain values for S0 and E0, however, unless we are explicitly interested in these, they can be ignored.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_simulation_options","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Additional features: Simulation options","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"While in our basic example, we do not provide any additional information to our PEtabODEProblem, this is an opportunity to specify how the model should be simulated, and what automatic differentiation techniques to use for the optimisation procedure (if none are provided, appropriate defaults are selected).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here is an example, adapted from the more detailed PEtab.jl documentation","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using OrdinaryDiffEqRosenbrock\nPEtabODEProblem(petab_model, \n                odesolver = ODESolver(Rodas5P(), abstol = 1e-8, reltol = 1e-8),\n                gradient_method = :ForwardDiff, \n                hessian_method = :ForwardDiff)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"where we simulate our ODE model using the Rodas5P method (with absolute and relative tolerance both equal 1e-8) and use forward automatic differentiation for both gradient and hessian computation. More details on available ODE solver options can be found in the PEtab.jl documentation.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_optimisation","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Additional features: Optimisation","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_optimisation_optimisers","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Optimisation methods and options","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"For our examples, we have used the Optim.IPNewton optimisation method. PEtab.jl supports several additional optimisation methods. Furthermore, calibrate's options argument permits the customisation of the options for any used optimiser. E.g. to designate the maximum number of iterations of the Optim.IPNewton method we would use:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"res = calibrate(petab_problem, p0, IPNewton(); options = Optim.Options(iterations = 10000))\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Please read the PEtab.jl documentation to learn how to customize the various optimisers' properties.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_optimisation_path_recording","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Optimisation path recording","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"To record all the parameter sets evaluated (and their objective values) during the optimisation procedure, provide the save_trace=true argument to calibrate (or calibrate_multistart):","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"res = calibrate(petab_problem, p0, IPNewton(); save_trace = true)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"This is required for the various optimisation evaluation plots provided by PEtab.jl. If desired, this information can be accessed in the calibration output's .xtrace and .ftrace fields.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#Objective-function-extraction","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Objective function extraction","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"While PEtab.jl provides various tools for analysing the objective function generated by PEtabODEProblem, it is also possible to extract this function for customised analysis. Given a PEtabODEProblem","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"petab_problem = PEtabODEProblem(petab_model)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"petab_problem = PEtabODEProblem(petab_model)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"We can find the:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Objective function (negative log-likelihood) as the petab_problem.nllh. It takes a single argument (p) and returns the objective value.\nGradient as the petab_problem.grad! field. It takes two arguments (g and p) with the updated gradient values being written to g.\nHessian as the petab_problem.hess! field. It takes two arguments (H and p) with the updated hessian values being written to H.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_multistart_optimisation","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Multi-start optimisation","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"To avoid the optimisation process returning a local minimum, it is often advised to run it multiple times, using different initial guesses. PEtab.jl supports this through the calibrate_multistart function. This is identical to the calibrate function, but takes one additional arguments:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"nmultistarts: The number of runs to perform.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"And two additional optional argument:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"dirsave: A location to which the output is automatically saved. If dirsave=nothing, no output is saved. It is recommended to save intermediate results for parameter estimation runs that take a long time, to not lose intermediate results if something goes wrong.\nsampling_method: Selects the sampling method with which to select the initial guesses (QuasiMonteCarlo.LatinHypercubeSample() used by default).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Because calibrate_multistart handles initial guess sampling, unlike for calibrate, no initial guess has to be provided.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here, we fit parameters through 10 independent optimisation runs, using QuasiMonteCarlo's SobolSample method, and save the result to the OptimisationRuns folder:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"using Optim\nusing QuasiMonteCarlo\nmkdir(\"OptimisationRuns\") # hide\nres_ms = calibrate_multistart(petab_problem, IPNewton(), 10; dirsave = \"OptimisationRuns\",\n    sampling_method = QuasiMonteCarlo.SobolSample())\nres_ms = calibrate_multistart(petab_problem, IPNewton(), 10; dirsave = \"OptimisationRuns\", sampling_method = QuasiMonteCarlo.SobolSample()) # hide\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"The best result across all runs can still be retrieved using get_ps(res_ms, petab_problem), with the results of the individual runs being stored in the res_ms.runs field.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"To load the result in a later session, we can call:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"res_ms = PEtabMultistartResult(\"OptimisationRuns\")\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"where \"OptimisationRuns\" is the name of the save directory (specified in calibrate_multistart). If the OptimisationRuns folder contains the output from several runs, we can designate which to load using the which_run argument. Here we load the second run to be saved in that folder:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"res_ms = PEtabMultistartResult(\"OptimisationRuns\"; which_run = 2)\nrm(\"OptimisationRuns\", recursive = true) # hide\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"By default, which_run loads the first run saved to that directory.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_events","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Events","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"So far, we have assumed that all experiments, after initiation, run without interference. Experiments where conditions change, or where species are added/removed during the time course, can be represented through events. In PEtab, an event is represented through the PEtabEvent structure. It takes three arguments:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"The condition for triggering the event. This can either indicate a point in time, or a boolean condition.\nA rule for updating the event's target\nThe event's target (either a species or parameter).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here we create an event which adds 0.5 units of S to the system at time 5.0:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"@unpack S = rn\nevent1 = PEtabEvent(5.0, S + 0.5, S)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here, the first argument is evaluated to a scalar value, in which case it is interpreted as a time point at which the event happens. If we instead want the event to happen whenever the concentration of S falls below 0.5 we set the first argument to a boolean condition indicating this:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"event2 = PEtabEvent(S < 0.5, S + 0.5, S)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Here, the event only triggers whenever the condition changes from false to true, and not while it remains true (or when changing from true to false). E.g. this event only triggers when S concentration passes from more than 50 to less that 50.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"Whenever we have several events or not, we bundle them together in a single vector which is later passed to the PEtabODEProblem using the events argument:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"params = [par_kB, par_kD, par_kP] # hide\nevents = [event1, event2]\npetab_model = PEtabModel(rn, observables, measurements, params; speciemap = u0, events = events)\nnothing # hide","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"More details on how to use events, including how to create events with multiple targets, can be found in PEtab.jl's documentation.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"note: Note\nPEtab currently ignores events created as a part of a Catalyst ReactionSystem model, and does not support SciML-style events. Instead, events have to use the preceding interface.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_plotting","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Plot recipes","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"There exist various types of graphs that can be used to evaluate the parameter fitting process. These can be plotted using the plot command, where the input is either the result of a calibrate or a calibrate_multistart run. To be able to use this functionality, you have to ensure that PEtab.jl records the optimisation process by providing the save_trace=true argument to the calibration functions.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"To, for a single start calibration run, plot, for each iteration of the optimization process, the best objective value achieved so far, run:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"res = calibrate(petab_problem, p0, IPNewton(); save_trace = true) # hide\nplot(res)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"For a multi-start calibration run, the default output is instead a so-called waterfall plot:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"res_ms = PEtabMultistartResult(\"../assets/boehm___for_petab_tutorial\") # hide\nplot(res_ms)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"(for this, and the next plot, we use a multi-start optimisation result from a different model, which yields less trivial optimisation runs than our catalysis one)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"In the waterfall plot, each dot shows the final objective value for a single run in the multi-start process. The runs are ordered by their objective values, and colours designate runs in the same local minimum. A common use of waterfall plots is to check whether a sufficient number of runs (typically 5) has converged to the same best local minimum (in which case it is assumed to be the global minimum).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"To instead use the best objective value plot for a multi-start run (with one curve for each run), the plot_type argument is used:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"plot(res_ms; plot_type = :best_objective)","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"There exist several types of plots for both types of calibration results. More details of the types of available plots, and how to customise them, can be found here.","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#petab_citations","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Citations","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"If you use this functionality in your research, in addition to Catalyst, please cite the following papers to support the authors of the PEtab.jl package (currently there is no article associated with this package) and the PEtab standard:","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"@misc{2023Petabljl,\n  author       = {Ognissanti, Damiano AND Arutjunjan, Rafael AND Persson, Sebastian AND Hasselgren, Viktor},\n  title        = {{2023Petabljl.jl}},\n  howpublished = {\\url{https://github.com/sebapersson/PEtab.jl/}},\n  year         = {2023}\n}","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"@article{SchmiesterSch2021,\n  author    = {Schmiester, Leonard AND Schälte, Yannik AND Bergmann, Frank T. AND Camba, Tacio AND Dudkin, Erika AND Egert, Janine AND Fröhlich, Fabian AND Fuhrmann, Lara AND Hauber, Adrian L. AND Kemmer, Svenja AND Lakrisenko, Polina AND Loos, Carolin AND Merkt, Simon AND Müller, Wolfgang AND Pathirana, Dilan AND Raimúndez, Elba AND Refisch, Lukas AND Rosenblatt, Marcus AND Stapor, Paul L. AND Städter, Philipp AND Wang, Dantong AND Wieland, Franz-Georg AND Banga, Julio R. AND Timmer, Jens AND Villaverde, Alejandro F. AND Sahle, Sven AND Kreutz, Clemens AND Hasenauer, Jan AND Weindl, Daniel},\n  journal   = {PLOS Computational Biology},\n  title     = {PEtab—Interoperable specification of parameter estimation problems in systems biology},\n  year      = {2021},\n  month     = {01},\n  number    = {1},\n  pages     = {1-10},\n  volume    = {17},\n  doi       = {10.1371/journal.pcbi.1008646},\n  publisher = {Public Library of Science},\n  url       = {https://doi.org/10.1371/journal.pcbi.1008646},\n}","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/#References","page":"Parameter Fitting for ODEs using PEtab.jl","title":"References","text":"","category":"section"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"[1]: Schmiester, L et al. PEtab—Interoperable specification of parameter estimation problems in systems biology, PLOS Computational Biology (2021).","category":"page"},{"location":"inverse_problems/petab_ode_param_fitting/","page":"Parameter Fitting for ODEs using PEtab.jl","title":"Parameter Fitting for ODEs using PEtab.jl","text":"[2]: Hass, H et al. PBenchmark problems for dynamic modeling of intracellular processes, Bioinformatics (2019).","category":"page"},{"location":"model_creation/network_analysis/#network_analysis","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"","category":"section"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"In this tutorial we introduce several of the Catalyst API functions for network analysis. A complete summary of the exported functions is given in the API section Network-Analysis-and-Representations.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Note, currently API functions for network analysis and conservation law analysis do not work with constant species (currently only generated by SBMLToolkit).","category":"page"},{"location":"model_creation/network_analysis/#network_analysis_repressilator_representation","page":"Network Analysis in Catalyst","title":"Network representation of the Repressilator ReactionSystem","text":"","category":"section"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We first load Catalyst and construct our model of the repressilator","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"using Catalyst\nrepressilator = @reaction_network Repressilator begin\n       hillr(P₃,α,K,n), ∅ --> m₁\n       hillr(P₁,α,K,n), ∅ --> m₂\n       hillr(P₂,α,K,n), ∅ --> m₃\n       (δ,γ), m₁ <--> ∅\n       (δ,γ), m₂ <--> ∅\n       (δ,γ), m₃ <--> ∅\n       β, m₁ --> m₁ + P₁\n       β, m₂ --> m₂ + P₂\n       β, m₃ --> m₃ + P₃\n       μ, P₁ --> ∅\n       μ, P₂ --> ∅\n       μ, P₃ --> ∅\nend","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"In the Introduction to Catalyst tutorial we showed how the above network could be visualized as a species-reaction graph. There, species are represented by the nodes of the graph and edges show the reactions in which a given species is a substrate or product.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"g = Graph(repressilator)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: Repressilator solution)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We also showed in the Introduction to Catalyst tutorial that the reaction rate equation ODE model for the repressilator is","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"beginaligned\nfracdm_1(t)dt = fracalpha K^nK^n + left( P_3left( t right) right)^n - delta m_1left( t right) + gamma \nfracdm_2(t)dt = fracalpha K^nK^n + left( P_1left( t right) right)^n - delta m_2left( t right) + gamma \nfracdm_3(t)dt = fracalpha K^nK^n + left( P_2left( t right) right)^n - delta m_3left( t right) + gamma \nfracdP_1(t)dt = beta m_1left( t right) - mu P_1left( t right) \nfracdP_2(t)dt = beta m_2left( t right) - mu P_2left( t right) \nfracdP_3(t)dt = beta m_3left( t right) - mu P_3left( t right)\nendaligned","category":"page"},{"location":"model_creation/network_analysis/#network_analysis_matrix_vector_representation","page":"Network Analysis in Catalyst","title":"Matrix-vector reaction rate equation representation","text":"","category":"section"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"In general, reaction rate equation (RRE) ODE models for chemical reaction networks can be represented as a first-order system of ODEs in a compact matrix-vector notation. Suppose we have a reaction network with K reactions and M species, labelled by the state vector","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"mathbfx(t) = beginpmatrix x_1(t)  vdots  x_M(t)) endpmatrix","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"For the repressilator, mathbfx(t) is just","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"x = species(repressilator)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The RRE ODEs satisfied by mathbfx(t) are then","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"fracdmathbfxdt = N mathbfv(mathbfx(t)t)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"where N is a constant M by K matrix with N_m k the net stoichiometric coefficient of species m in reaction k. mathbfv(mathbfx(t)t) is the rate law vector, with v_k(mathbfx(t)t) the rate law for the kth reaction. For example, for the first reaction of the repressilator above, the rate law is","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"v_1(mathbfx(t)t) = fracalpha K^nK^n + left( P_3(t) right)^n","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can calculate each of these in Catalyst via","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"N = netstoichmat(repressilator)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"and by using the oderatelaw function","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rxs = reactions(repressilator)\nν = oderatelaw.(rxs)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Note, as oderatelaw takes just one reaction as input we use broadcasting to apply it to each element of rxs.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Let's check that this really gives the same ODEs as Catalyst. Here is what Catalyst generates by converting to an ODESystem","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"osys = convert(ODESystem, repressilator)\n\n# for display purposes we just pull out the right side of the equations\nodes = [eq.rhs for eq in equations(osys)]","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"whereas our matrix-vector representation gives","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"odes2 = N * ν","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Let's check these are equal symbolically","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"isequal(odes, odes2)","category":"page"},{"location":"model_creation/network_analysis/#network_analysis_reaction_complexes","page":"Network Analysis in Catalyst","title":"Reaction complex representation","text":"","category":"section"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We now introduce a further decomposition of the RRE ODEs, which has been used to facilitate analysis of a variety of reaction network properties. Consider a simple reaction system like","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n k*A, 2*A + 3*B --> A + 2*C + D\n b, C + D --> 2*A + 3*B\nend","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can think of the first reaction as converting the reaction complex, 2A+3B to the complex A+2C+D with rate kA. Suppose we order our species the same way as Catalyst does, i.e.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"beginpmatrix\nx_1(t)\nx_2(t)\nx_3(t)\nx_4(t)\nendpmatrix =\nbeginpmatrix\nA(t)\nB(t)\nC(t)\nD(t)\nendpmatrix","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"which should be the same as","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"species(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can describe a given reaction complex by the stoichiometric coefficients of each species within the complex. For the reactions in rn these vectors would be","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"beginalign*\n2A+3B = beginpmatrix\n2\n3\n0\n0\nendpmatrix \nA+2C+D = beginpmatrix\n1\n0\n2\n1\nendpmatrix\n \nC+D = beginpmatrix\n0\n0\n1\n1\nendpmatrix\nendalign*","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Catalyst can calculate these representations as the columns of the complex stoichiometry matrix,","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Z = complexstoichmat(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"If we have C complexes, Z is a M by C matrix with Z_m c giving the stoichiometric coefficient of species m within complex c.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can use this representation to provide another representation of the RRE ODEs. The net stoichiometry matrix can be factored as N = Z B, where B is called the incidence matrix of the reaction network,","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"B = incidencemat(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Here B is a C by K matrix with B_c k = 1 if complex c appears as a product of reaction k, and B_c k = -1 if complex c is a substrate of reaction k.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Using our decomposition of N, the RRE ODEs become","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"fracdxdt = Z B mathbfv(mathbfx(t)t)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Let's verify that N = Z B,","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"N = netstoichmat(rn)\nN == Z*B","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Reaction complexes give an alternative way to visualize a reaction network graph. Catalyst's complexgraph command will calculate the complexes of a network and then show how they are related. For example,","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"complexgraph(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"gives","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: Simple example complex graph)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"while for the repressilator we find","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"complexgraph(repressilator)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: Repressilator complex)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Here ∅ represents the empty complex, black arrows show reactions converting substrate complexes into product complexes where the rate is just a number or parameter, and red arrows indicate the conversion of substrate complexes into product complexes where the rate is an expression involving chemical species.","category":"page"},{"location":"model_creation/network_analysis/#network_analysis_structural_aspects","page":"Network Analysis in Catalyst","title":"Aspects of reaction network structure","text":"","category":"section"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The reaction complex representation can be exploited via Chemical Reaction Network Theory to provide insight into possible steady state and time-dependent properties of RRE ODE models and stochastic chemical kinetics models. We'll now illustrate some of the types of network properties that Catalyst can determine, using the reaction complex representation in these calculations.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Consider the following reaction network.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n    (k1,k2), A + B <--> C\n    k3, C --> D+E\n    (k4,k5), D+E <--> F\n    (k6,k7), 2A <--> B+G\n    k8, B+G --> H\n    k9, H --> 2A\nend","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"with graph","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"complexgraph(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: network_1)","category":"page"},{"location":"model_creation/network_analysis/#network_analysis_structural_aspects_linkage","page":"Network Analysis in Catalyst","title":"Linkage classes and sub-networks of the reaction network","text":"","category":"section"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The preceding reaction complex graph shows that rn is composed of two disconnected sub-graphs, one containing the complexes A+B, C, D+E, and F, the other containing the complexes 2A, B + G, and H. These sets, A+B C D+E F and 2A B + GH are called the \"linkage classes\" of the reaction network. The function linkageclasses will calculate these for a given network, returning a vector of the integer indices of reaction complexes participating in each set of linkage-classes. Note, indices of reaction complexes can be determined from the ordering returned by reactioncomplexes.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"# we must first calculate the reaction complexes -- they are cached in rn\nreactioncomplexes(rn)\n\n# now we can calculate the linkage classes\nlcs = linkageclasses(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"It can often be convenient to obtain the disconnected sub-networks as distinct ReactionSystems, which are returned by the subnetworks function:","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"subnets = subnetworks(rn)\n\n# check the reactions in each subnetwork\nreactions.(subnets)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The graphs of the reaction complexes in the two sub-networks are then","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"  complexgraph(subnets[1])","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: subnetwork_1)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"and,","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":" complexgraph(subnets[2])","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: subnetwork_2)","category":"page"},{"location":"model_creation/network_analysis/#network_analysis_structural_aspects_deficiency","page":"Network Analysis in Catalyst","title":"Deficiency of the network","text":"","category":"section"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"A famous theorem in Chemical Reaction Network Theory, the Deficiency Zero Theorem [1], allows us to use knowledge of the net stoichiometry matrix and the linkage classes of a mass action RRE ODE system to draw conclusions about the system's possible steady states. In this section we'll see how Catalyst can calculate a network's deficiency.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The rank, r, of a reaction network is defined as the dimension of the subspace spanned by the net stoichiometry vectors of the reaction-network [1], i.e. the span of the columns of the net stoichiometry matrix N. It corresponds to the number of independent species in a chemical reaction network. That is, if we calculate the linear conservation laws of a network, and use them to eliminate the dependent species of the network, we will have r independent species remaining. For our current example the conservation laws are given by","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"# first we calculate the conservation laws -- they are cached in rn\nconservationlaws(rn)\n\n# then we display them as equations for the dependent variables\nconservedequations(rn)\nshow(stdout, MIME\"text/plain\"(), ans) # hide","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Here the parameters Γ[i] represent the constants of the three conservation laws, and we see that there are three dependent species that could be eliminated. As","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"numspecies(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"we find that there are five independent species. Let's check this is correct:","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"using LinearAlgebra\nrank(netstoichmat(rn)) == 5","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"So we know that the rank of our reaction network is five. An extended section discussing how to utilise conservation law elimination during chemical reaction network modelling can be found here.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"The deficiency, delta, of a reaction network is defined as","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"delta = textrm(number of complexes) - textrm(number of linkage classes) - textrm(rank)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"For our network this is 7 - 2 - 5 = 0, which we can calculate in Catalyst as","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"# first we calculate the reaction complexes of rn and cache them in rn\nreactioncomplexes(rn)\n\n# then we can calculate the deficiency\nδ = deficiency(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Quoting Feinberg [1]","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Deficiency zero networks are ones for which the reaction vectors [i.e. net stoichiometry vectors] are as independent as the partition of complexes into linkage classes will allow.","category":"page"},{"location":"model_creation/network_analysis/#network_analysis_structural_aspects_reversibility","page":"Network Analysis in Catalyst","title":"Reversibility of the network","text":"","category":"section"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"A reaction network is reversible if the \"arrows\" of the reactions are symmetric so that every reaction is accompanied by its reverse reaction. Catalyst's API provides the isreversible function to determine whether a reaction network is reversible. As an example, consider","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n  (k1,k2),A <--> B\n  (k3,k4),A + C <--> D\n  (k5,k6),D <--> B+E\n  (k7,k8),B+E <--> A+C\nend\n\n# calculate the set of reaction complexes\nreactioncomplexes(rn)\n\n# test if the system is reversible\nisreversible(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Consider another example,","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n  (k1,k2),A <--> B\n  k3, A + C --> D\n  k4, D --> B+E\n  k5, B+E --> A+C\nend\nreactioncomplexes(rn)\nisreversible(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"complexgraph(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(Image: reversibility)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"It is evident from the preceding graph that the network is not reversible. However, it satisfies a weaker property in that there is a path from each reaction complex back to itself within its associated subgraph. This is known as weak reversibility. One can test a network for weak reversibility by using the isweaklyreversible function:","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"# need subnetworks from the reaction network first\nsubnets = subnetworks(rn)\nisweaklyreversible(rn, subnets)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Every reversible network is also weakly reversible, but not every weakly reversible network is reversible.","category":"page"},{"location":"model_creation/network_analysis/#network_analysis_structural_aspects_deficiency_zero_theorem","page":"Network Analysis in Catalyst","title":"Deficiency Zero Theorem","text":"","category":"section"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Knowing the deficiency and weak reversibility of a mass action chemical reaction network ODE model allows us to make inferences about the corresponding steady state behavior. Before illustrating how this works for one example, we need one last definition.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Recall that in the matrix-vector representation for the RRE ODEs, the entries, N_m k, of the stoichiometry matrix, N, give the net change in species m due to reaction k. If we let mathbfN_k denote the kth column of this matrix, this vector corresponds to the change in the species state vector, mathbfx(t), due to reaction k, i.e. when reaction k occurs mathbfx(t) to mathbfx(t) + mathbfN_k. Moreover, by integrating the ODE","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"fracdmathbfxdt = N mathbfv(mathbfx(t)) = sum_k=1^K v_k(mathbfx(t))  mathbfN_k","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"we find","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"mathbfx(t) = mathbfx(0) + sum_k=1^K left(int_0^t v_k(mathbfx)(s)  dsright) mathbfN_k","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"which demonstrates that mathbfx(t) - mathbfx(0) is always given by a linear combination of the stoichiometry vectors, i.e.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"mathbfx(t) - mathbfx(0) in operatornamespanmathbfN_k ","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"In particular, this says that mathbfx(t) lives in the translation of the operatornamespanmathbfN_k  by mathbfx(0) which we write as (mathbfx(0) + operatornamespanmathbfN_k). In fact, since the solution should stay non-negative, if we let barmathbbR_+^M denote the subset of vectors in mathbbR^M with non-negative components, the possible physical values for the solution, mathbfx(t), must be in the set","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"(mathbfx(0) + operatornamespanmathbfN_k) cap barmathbbR_+^M","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"This set is called the stoichiometric compatibility class of mathbfx(t). The key property of stoichiometric compatibility classes is that they are invariant under the RRE ODE's dynamics, i.e. a solution will always remain within the subspace given by the stoichiometric compatibility class. Finally, we note that the positive stoichiometric compatibility class generated by mathbfx(0) is just (mathbfx(0) + operatornamespanmathbfN_k) cap mathbbR_+^M, where mathbbR_+^M denotes the vectors in mathbbR^M with strictly positive components.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"With these definitions we can now see how knowing the deficiency and weak reversibility of the network can tell us about its steady state behavior. Consider the previous example, which we know is weakly reversible. Its deficiency is","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"deficiency(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We also verify that the system is purely mass action (though it is apparent from the network's definition):","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"all(rx -> ismassaction(rx, rn), reactions(rn))","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can therefore apply the Deficiency Zero Theorem to draw conclusions about the system's steady state behavior. The Deficiency Zero Theorem (roughly) says that a mass action network with deficiency zero satisfies","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"If the network is weakly reversible, then independent of the reaction rate constants the RRE ODEs have exactly one equilibrium solution within each positive stoichiometric compatibility class. That equilibrium is locally asymptotically stable.\nIf the network is not weakly reversible, then the RRE ODEs cannot admit a positive equilibrium solution.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"See [1] for a more precise statement, proof, and additional examples.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"We can therefore conclude that for any initial condition that is positive, and hence in some positive stoichiometric compatibility class, rn will have exactly one equilibrium solution which will be positive and locally asymptotically stable.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"As a final example, consider the following network from [1]","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rn = @reaction_network begin\n  (k1,k2),A <--> 2B\n  (k3,k4), A + C <--> D\n  k5, B+E --> C + D\nend\nreactioncomplexes(rn)\nsubnets = subnetworks(rn)\nisma = all(rx -> ismassaction(rx,rn), reactions(rn))\ndef = deficiency(rn)\niswr = isweaklyreversible(rn, subnets)\nisma,def,iswr","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"which we see is mass action and has deficiency zero, but is not weakly reversible. As such, we can conclude that for any choice of rate constants the RRE ODEs cannot have a positive equilibrium solution.","category":"page"},{"location":"model_creation/network_analysis/#network_analysis_caching_properties","page":"Network Analysis in Catalyst","title":"Caching of Network Properties in ReactionSystems","text":"","category":"section"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"When calling many of the network API functions, Catalyst calculates and caches in rn a variety of information. For example the first call to","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rcs,B = reactioncomplexes(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"calculates, caches, and returns the reaction complexes, rcs, and the incidence matrix, B, of rn. Subsequent calls simply return rcs and B from the cache.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Similarly, the first call to","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"N = netstoichmat(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"calculates, caches and returns the net stoichiometry matrix. Subsequent calls then simply return the cached value of N. Caching such information means users do not need to manually know which subsets of network properties are needed for a given calculation (like the deficiency). Generally only","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"rcs,B = reactioncomplexes(rn)    # must be called once to cache rcs and B\nany_other_network_property(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"should work to calculate a desired network property, with the API doc strings indicating when reactioncomplexes(rn) must be called at least once before a given function is used.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Because of the caching of network properties, subsequent calls to most API functions will be fast, simply returning the previously calculated and cached values. In some cases it may be desirable to reset the cache and recalculate these properties. This can be done by calling","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Catalyst.reset_networkproperties!(rn)","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"Network property functions will then recalculate their associated properties and cache the new values the next time they are called.","category":"page"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"","category":"page"},{"location":"model_creation/network_analysis/#References","page":"Network Analysis in Catalyst","title":"References","text":"","category":"section"},{"location":"model_creation/network_analysis/","page":"Network Analysis in Catalyst","title":"Network Analysis in Catalyst","text":"[1]: Feinberg, M. Foundations of Chemical Reaction Network Theory, Applied Mathematical Sciences 202, Springer (2019).","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/#steady_state_solving","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"","category":"section"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Catalyst ReactionSystem models can be converted to ODEs (through the reaction rate equation). We have previously described how these ODEs' steady states can be found through homotopy continuation. Generally, homotopy continuation (due to its ability to find all of a system's steady states) is the preferred approach. However, Catalyst supports two additional approaches for finding steady states:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Through solving the nonlinear system produced by setting all ODE differentials to 0[1].\nThrough forward ODE simulation from an initial condition until a steady state has been reached.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"While these approaches only find a single steady state, they offer two advantages as compared to homotopy continuation:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"They are typically much faster.\nThey can find steady states for models that do not produce multivariate, rational, polynomial systems (which is a requirement for homotopy continuation to work). Examples include models with non-integer hill coefficients.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"In practice, model steady states are found through nonlinear system solving by creating a NonlinearProblem, and through forward ODE simulation by creating a SteadyStateProblem. These are then solved through solvers implemented in the NonlinearSolve.jl, package (with the latter approach also requiring the SteadyStateDiffEq.jl package). This tutorial describes how to find steady states through these two approaches. More extensive descriptions of available solvers and options can be found in NonlinearSolve's documentation.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/#steady_state_solving_nonlinear","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Steady state finding through nonlinear solving","text":"","category":"section"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Let us consider a simple dimerisation system, where a protein (P) can exist in a monomer and a dimer form. The protein is produced at a constant rate from its mRNA, which is also produced at a constant rate.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"using Catalyst\ndimer_production = @reaction_network begin\n    pₘ, 0 --> mRNA\n    pₚ, mRNA --> mRNA + P\n    (k₁, k₂), 2P <--> P₂\n    d, (mRNA, P, P₂) --> 0\nend","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"This system corresponds to the following ODE:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"beginaligned\nfracdmRNAdt = pₘ - d cdot mRNA \nfracdPdt = pₚ cdot mRNA - k₁ cdot P + 2k₂ cdot P₂ - d cdot P \nfracdP₂dt = k₁ cdot P + 2k₂ cdot P₂ \nendaligned","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"To find its steady states we need to solve:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"beginaligned\n0 = pₘ - d cdot mRNA \n0 = pₚ cdot mRNA - k₁ cdot P + 2k₂ cdot P₂ - d cdot P \n0 = k₁ cdot P + 2k₂ cdot P₂ \nendaligned","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"To solve this problem, we must first designate our parameter values, and also make an initial guess of the solution. Generally, for problems with a single solution (like this one), most arbitrary guesses will work fine (the exception typically being systems with conservation laws). Using these, we can create the NonlinearProblem that we wish to solve.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"p = [:pₘ => 0.5, :pₚ => 2.0, :k₁ => 5.0, :k₂ => 1.0, :d => 1.0]\nu_guess = [:mRNA => 1.0, :P => 1.0, :P₂ => 1.0]\nnlprob = NonlinearProblem(dimer_production, u_guess, p)\nnothing # hide","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Finally, we can solve it using the solve command, returning the steady state solution:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"using NonlinearSolve\nsol = solve(nlprob)","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Typically, a good default method is automatically selected for any problem. However, NonlinearSolve does provide a wide range of potential solvers. If we wish to designate one, it can be supplied as a second argument to solve. Here, we use the Newton Trust Region method, and then check that the solution is equal to the previous one.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"sol_ntr = solve(nlprob, TrustRegion())\nsol ≈ sol_ntr","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/#steady_state_solving_nonlinear_conservation_laws","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Systems with conservation laws","text":"","category":"section"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"As described in the section on homotopy continuation, when finding the steady states of systems with conservation laws, additional considerations have to be taken. E.g. consider the following two-state system:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"using Catalyst, NonlinearSolve # hide\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"It has an infinite number of steady states. To make steady state finding possible, information of the system's conserved quantities (here C = X1 + X2) must be provided. Since these can be computed from system initial conditions (u0, i.e. those provided when performing ODE simulations), designating an u0 is often the best way. There are two ways to do this. First, one can perform forward ODE simulation-based steady state finding, using the initial condition as the initial u guess. Alternatively, any conserved quantities can be eliminated when the NonlinearProblem is created. This feature is supported by Catalyst's conservation law finding and elimination feature.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"To eliminate conservation laws we simply provide the remove_conserved = true argument to NonlinearProblem:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"p = [:k1 => 2.0, :k2 => 3.0]\nu_guess = [:X1 => 3.0, :X2 => 1.0]\nnl_prob = NonlinearProblem(two_state_model, u_guess, p; remove_conserved = true)\nnothing # hide","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"here it is important that the quantities used in u_guess correspond to the conserved quantities we wish to use. E.g. here the conserved quantity X1 + X2 = 30 + 10 = 4 holds for the initial condition, and will hence also hold in the computed steady state as well. We can now find the steady states using solve like before: <!– ```@example steadystatesolvingclaws sol = solve(nlprob)","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"We note that the output only provides a single value. The reason is that the actual system solved only contains a single equation (the other being eliminated with the conserved quantity). To find the values of $X1$ and $X2$ we can [directly query the solution object for these species' values, using the species themselves as inputs](@ref simulation_structure_interfacing_solutions):\n<!--```@example steady_state_solving_claws\nsol[[:X1, :X2]]","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"–>","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/#steady_state_solving_simulation","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding steady states through ODE simulations","text":"","category":"section"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"The NonlinearProblems generated by Catalyst corresponds to ODEs. A common method of solving these is to simulate the ODE from an initial condition until a steady state is reached. Here we do so for the dimerisation system considered in the previous section. First, we declare our model, initial condition, and parameter values.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"using Catalyst # hide\ndimer_production = @reaction_network begin\n    pₘ, 0 --> mRNA\n    pₚ, mRNA --> mRNA + P\n    (k₁, k₂), 2P <--> P₂\n    d, (mRNA, P, P₂) --> 0\nend\np = [:pₘ => 0.5, :pₚ => 2.0, :k₁ => 5.0, :k₂ => 1.0, :d => 1.0]\nu0 = [:mRNA => 0.1, :P => 0.0, :P₂ => 0.0]\nnothing # hide","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Next, we provide these as an input to a SteadyStateProblem","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"ssprob = SteadyStateProblem(dimer_production, u0, p)\nnothing # hide","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Finally, we can find the steady states using the solver command. Since SteadyStateProblems are solved through forward ODE simulation, we must load the sublibrary of the OrdinaryDiffEq.jl package that corresponds to the selected ODE solver. Any available ODE solver can be used, however, it has to be encapsulated by the DynamicSS() function. E.g. here we use the Rodas5P solver which is loaded from the OrdinaryDiffEqRosenbrock sublibrary:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"(which requires loading the SteadyStateDiffEq package).","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"using SteadyStateDiffEq, OrdinaryDiffEqRosenbrock\nsolve(ssprob, DynamicSS(Rodas5P()))","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Note that, unlike for nonlinear system solving, u0 is not just an initial guess of the solution, but the initial conditions from which the steady state simulation is carried out. This means that, for a system with multiple steady states, we can determine the steady states associated with specific initial conditions (which is not possible when the nonlinear solving approach is used). This also permits us to easily handle the presence of conservation laws. The forward ODE simulation approach (unlike homotopy continuation and nonlinear solving) cannot find unstable steady states.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"Generally, SteadyStateProblems can be solved using the same options that are available for ODE simulations. E.g. here we designate a specific dt step size:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"solve(ssprob, DynamicSS(Rodas5P()); dt = 0.01)\nnothing # hide","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"It is possible to use solve SteadyStateProblems using a nonlinear solver, and NonlinearProblems using forward ODE simulation solvers:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"using NonlinearSolve\nsolve(ssprob, TrustRegion())\nnothing # hide","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"nlprob = NonlinearProblem(dimer_production, u0, p)\nsolve(nlprob, DynamicSS(Rodas5P()))\nnothing # hide","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"However, especially when the forward ODE simulation approach is used, it is recommended to use the problem type which corresponds to the intended solver.","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/#nonlinear_solve_citation","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Citations","text":"","category":"section"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"If you use this functionality in your research, in addition to Catalyst, please cite the following paper to support the authors of the NonlinearSolve.jl package:","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"@article{pal2024nonlinearsolve,\n  title={NonlinearSolve. jl: High-Performance and Robust Solvers for Systems of Nonlinear Equations in Julia},\n  author={Pal, Avik and Holtorf, Flemming and Larsson, Axel and Loman, Torkel and Schaefer, Frank and Qu, Qingyu and Edelman, Alan and Rackauckas, Chris and others},\n  journal={arXiv preprint arXiv:2403.16341},\n  year={2024}\n}","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"","category":"page"},{"location":"steady_state_functionality/nonlinear_solve/#References","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"References","text":"","category":"section"},{"location":"steady_state_functionality/nonlinear_solve/","page":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","title":"Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl","text":"[1]: J. Nocedal, S. J. Wright, Numerical Optimization, Springer (2006).","category":"page"},{"location":"api/#api","page":"API","title":"Catalyst.jl API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Catalyst","category":"page"},{"location":"api/#Reaction-network-generation-and-representation","page":"API","title":"Reaction network generation and representation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Catalyst provides the @reaction_network macro for generating a complete network, stored as a ReactionSystem, which in turn is composed of Reactions. ReactionSystems can be converted to other ModelingToolkit.AbstractSystems, including a ModelingToolkit.ODESystem, ModelingToolkit.SDESystem, or ModelingToolkit.JumpSystem.","category":"page"},{"location":"api/","page":"API","title":"API","text":"When using the @reaction_network macro, Catalyst will automatically attempt to detect what is a species and what is a parameter. Everything that appear as a substrate or product in some reaction will be treated as a species, while all remaining symbols will be considered parameters (corresponding to those symbols that only appear within rate expressions and/or as stoichiometric coefficients). I.e. in","category":"page"},{"location":"api/","page":"API","title":"API","text":"rn = @reaction_network begin\n    k*X, Y --> W\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"Y and W will all be classified as chemical species, while k and X will be classified as parameters.","category":"page"},{"location":"api/","page":"API","title":"API","text":"The ReactionSystem generated by the @reaction_network macro is a ModelingToolkit.AbstractSystem that symbolically represents a system of chemical reactions. In some cases it can be convenient to bypass the macro and directly generate a collection of symbolic Reactions and a corresponding ReactionSystem encapsulating them. Below we illustrate with a simple SIR example how a system can be directly constructed, and demonstrate how to then generate from the ReactionSystem and solve corresponding chemical reaction ODE models, chemical Langevin equation SDE models, and stochastic chemical kinetics jump process models.","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Catalyst, OrdinaryDiffEqTsit5, StochasticDiffEq, JumpProcesses, Plots\nt = default_t()\n@parameters β γ\n@species S(t) I(t) R(t)\n\nrxs = [Reaction(β, [S,I], [I], [1,1], [2])\n       Reaction(γ, [I], [R])]\n@named rs = ReactionSystem(rxs, t)\nrs = complete(rs)\n\nu₀map    = [S => 999.0, I => 1.0, R => 0.0]\nparammap = [β => 1/10000, γ => 0.01]\ntspan    = (0.0, 250.0)\n\n# solve as ODEs\nodesys = convert(ODESystem, rs)\nodesys = complete(odesys)\noprob = ODEProblem(odesys, u₀map, tspan, parammap)\nsol = solve(oprob, Tsit5())\np1 = plot(sol, title = \"ODE\")\n\n# solve as SDEs\nsdesys = convert(SDESystem, rs)\nsdesys = complete(sdesys)\nsprob = SDEProblem(sdesys, u₀map, tspan, parammap)\nsol = solve(sprob, EM(), dt=.01, saveat = 2.0)\np2 = plot(sol, title = \"SDE\")\n\n# solve as jump process\njumpsys = convert(JumpSystem, rs)\njumpsys = complete(jumpsys)\nu₀map    = [S => 999, I => 1, R => 0]\ndprob = DiscreteProblem(jumpsys, u₀map, tspan, parammap)\njprob = JumpProblem(jumpsys, dprob, Direct())\nsol = solve(jprob)\nsol = solve(jprob; seed = 1234) # hide\np3 = plot(sol, title = \"jump\")\nplot(p1, p2, p3; layout = (3,1))\nCatalyst.PNG(plot(p1, p2, p3; layout = (3,1), fmt = :png, dpi = 200)) # hide","category":"page"},{"location":"api/","page":"API","title":"API","text":"@reaction_network\n@network_component\nmake_empty_network\n@reaction\nReaction\nReactionSystem","category":"page"},{"location":"api/#Catalyst.@reaction_network","page":"API","title":"Catalyst.@reaction_network","text":"@reaction_network\n\nGenerates a ReactionSystem that encodes a chemical reaction network.\n\nSee The Reaction DSL documentation for details on parameters to the macro.\n\nExamples:\n\n# a basic SIR model, with name SIR\nsir_model = @reaction_network SIR begin\n    c1, s + i --> 2i\n    c2, i --> r\nend\n\n# a basic SIR model, with random generated name\nsir_model = @reaction_network begin\n    c1, s + i --> 2i\n    c2, i --> r\nend\n\n# an empty network with name empty\nemptyrn = @reaction_network empty\n\n# an empty network with random generated name\nemptyrn = @reaction_network\n\nReactionSystems generated through @reaction_network are complete.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Catalyst.@network_component","page":"API","title":"Catalyst.@network_component","text":"@network_component\n\nEquivalent to @reaction_network except the generated ReactionSystem is not marked as complete.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Catalyst.make_empty_network","page":"API","title":"Catalyst.make_empty_network","text":"make_empty_network(; iv=DEFAULT_IV, name=gensym(:ReactionSystem))\n\nConstruct an empty ReactionSystem. iv is the independent variable, usually time, and name is the name to give the ReactionSystem.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.@reaction","page":"API","title":"Catalyst.@reaction","text":"@reaction\n\nGenerates a single Reaction object.\n\nExamples:\n\nrx = @reaction k*v, A + B --> C + D\n\n# is equivalent to\nt = default_t()\n@parameters k v\n@species A(t) B(t) C(t) D(t)\nrx == Reaction(k*v, [A,B], [C,D])\n\nHere k and v will be parameters and A, B, C and D will be variables. Interpolation of existing parameters/variables also works\n\nt = default_t()\n@parameters k b\n@species A(t)\nex = k*A^2 + t\nrx = @reaction b*$ex*$A, $A --> C\n\nNotes:\n\nAny symbols arising in the rate expression that aren't interpolated are treated as\n\nparameters. In the reaction part (α*A + B --> C + D), coefficients are treated as parameters, e.g. α, and rightmost symbols as species, e.g. A,B,C,D.\n\nWorks with any single arrow types supported by @reaction_network.\nInterpolation of Julia variables into the macro works similar to the @reaction_network\n\nmacro. See The Reaction DSL tutorial for more details.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Catalyst.Reaction","page":"API","title":"Catalyst.Reaction","text":"struct Reaction{S, T}\n\nOne chemical reaction.\n\nFields\n\nrate: The rate function (excluding mass action terms).\nsubstrates: Reaction substrates.\nproducts: Reaction products.\nsubstoich: The stoichiometric coefficients of the reactants.\nprodstoich: The stoichiometric coefficients of the products.\nnetstoich: The net stoichiometric coefficients of all species changed by the reaction.\nonly_use_rate: false (default) if rate should be multiplied by mass action terms to give the rate law. true if rate represents the full reaction rate law.\n\nmetadata: Contain additional data, such whenever the reaction have a specific noise-scaling expression for the chemical Langevin equation.\n\nExamples\n\nusing Catalyst\nt = default_t()\n@parameters k[1:20]\n@species A(t) B(t) C(t) D(t)\nrxs = [Reaction(k[1], nothing, [A]),            # 0 -> A\n       Reaction(k[2], [B], nothing),            # B -> 0\n       Reaction(k[3],[A],[C]),                  # A -> C\n       Reaction(k[4], [C], [A,B]),              # C -> A + B\n       Reaction(k[5], [C], [A], [1], [2]),      # C -> A + A\n       Reaction(k[6], [A,B], [C]),              # A + B -> C\n       Reaction(k[7], [B], [A], [2], [1]),      # 2B -> A\n       Reaction(k[8], [A,B], [A,C]),            # A + B -> A + C\n       Reaction(k[9], [A,B], [C,D]),            # A + B -> C + D\n       Reaction(k[10], [A], [C,D], [2], [1,1]), # 2A -> C + D\n       Reaction(k[11], [A], [A,B], [2], [1,1]), # 2A -> A + B\n       Reaction(k[12], [A,B,C], [C,D], [1,3,4], [2, 3]),          # A+3B+4C -> 2C + 3D\n       Reaction(k[13], [A,B], nothing, [3,1], nothing),           # 3A+B -> 0\n       Reaction(k[14], nothing, [A], nothing, [2]),               # 0 -> 2A\n       Reaction(k[15]*A/(2+A), [A], nothing; only_use_rate=true), # A -> 0 with custom rate\n       Reaction(k[16], [A], [B]; only_use_rate=true),             # A -> B with custom rate.\n       Reaction(k[17]*A*exp(B), [C], [D], [2], [1]),              # 2C -> D with non constant rate.\n       Reaction(k[18]*B, nothing, [B], nothing, [2]),             # 0 -> 2B with non constant rate.\n       Reaction(k[19]*t, [A], [B]),                                # A -> B with non constant rate.\n       Reaction(k[20]*t*A, [B,C], [D],[2,1],[2])                  # 2A +B -> 2C with non constant rate.\n  ]\n\nNotes:\n\nnothing can be used to indicate a reaction that has no reactants or no products. In this case the corresponding stoichiometry vector should also be set to nothing.\nThe three-argument form assumes all reactant and product stoichiometric coefficients are one.\n\n\n\n\n\n","category":"type"},{"location":"api/#Catalyst.ReactionSystem","page":"API","title":"Catalyst.ReactionSystem","text":"struct ReactionSystem{V<:Catalyst.NetworkProperties} <: AbstractTimeDependentSystem\n\nA system of chemical reactions.\n\nFields\n\neqs: The equations (reactions and algebraic/differential) defining the system.\nrxs: The Reactions defining the system.\niv: Independent variable (usually time).\nsivs: Spatial independent variables\nunknowns: All dependent (unknown) variables, species and non-species. Must not contain the independent variable.\nspecies: Dependent unknown variables representing species\nps: Parameter variables. Must not contain the independent variable.\nvar_to_name: Maps Symbol to corresponding variable.\nobserved: Equations for observed variables.\nname: The name of the system\nsystems: Internal sub-systems\ndefaults: The default values to use when initial conditions and/or parameters are not supplied in ODEProblem.\n\nconnection_type: Type of the system\nnetworkproperties: NetworkProperties object that can be filled in by API functions. INTERNAL – not considered part of the public API.\ncombinatoric_ratelaws: Sets whether to use combinatoric scalings in rate laws. true by default.\ncontinuous_events: continuous_events: A Vector{SymbolicContinuousCallback} that model events. The integrator will use root finding to guarantee that it steps at each zero crossing.\n\ndiscrete_events: discrete_events: A Vector{SymbolicDiscreteCallback} that models events. Symbolic analog to SciMLBase.DiscreteCallback that executes an affect when a given condition is true at the end of an integration step.\n\nmetadata: Metadata for the system, to be used by downstream packages.\n\ncomplete: complete: if a model sys is complete, then sys.x no longer performs namespacing.\n\nparent: The hierarchical parent system before simplification that MTK now seems to require for hierarchical namespacing to work in indexing.\n\nExample\n\nContinuing from the example in the Reaction definition:\n\n# simple constructor that infers species and parameters\n@named rs = ReactionSystem(rxs, t)\n\n# allows specification of species and parameters\n@named rs = ReactionSystem(rxs, t, [A,B,C,D], k)\n\nKeyword Arguments:\n\nobserved::Vector{Equation}, equations specifying observed variables.\nsystems::Vector{AbstractSystems}, vector of sub-systems. Can be ReactionSystems, ODESystems, or NonlinearSystems.\nname::Symbol, the name of the system (must be provided, or @named must be used).\ndefaults::Dict, a dictionary mapping parameters to their default values and species to their default initial values.\nchecks = true, boolean for whether to check units.\nnetworkproperties = NetworkProperties(), cache for network properties calculated via API functions.\ncombinatoric_ratelaws = true, sets the default value of combinatoric_ratelaws used in calls to convert or calling various problem types with the ReactionSystem.\nbalanced_bc_check = true, sets whether to check that BC species appearing in reactions are balanced (i.e appear as both a substrate and a product with the same stoichiometry).\n\nNotes:\n\nReactionSystems currently do rudimentary unit checking, requiring that all species have the same units, and all reactions have rate laws with units of (species units) / (time units). Unit checking can be disabled by passing the keyword argument checks=false.\n\n\n\n\n\n","category":"type"},{"location":"api/#api_dsl_options","page":"API","title":"Options for the @reaction_network DSL","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"We have previously described how options permits the user to supply non-reaction information to ReactionSystem created through the DSL. Here follows a list of all options currently available.","category":"page"},{"location":"api/","page":"API","title":"API","text":"[parameters]:(@ref dsladvancedoptionsdeclaringspeciesandparameters) Allows the designation of a set of symbols as system parameter.\nspecies: Allows the designation of a set of symbols as system species.\nvariables: Allows the designation of a set of symbols as system non-species variables.\nivs: Allows the designation of a set of symbols as system independent variables.\ncompounds: Allows the designation of compound species.\nobservables: Allows the designation of compound observables.\ndefault_noise_scaling: Enables the setting of a default noise scaling expression.\ndifferentials: Allows the designation of differentials.\nequations: Allows the creation of algebraic and/or differential equations.\ncontinuous_events: Allows the creation of continuous events.\ndiscrete_events: Allows the creation of discrete events.\ncombinatoric_ratelaws: Takes a single option (true or false), which sets whether to use combinatorial rate laws.","category":"page"},{"location":"api/#api_accessor_functions","page":"API","title":"ModelingToolkit and Catalyst accessor functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A ReactionSystem is an instance of a ModelingToolkit.AbstractTimeDependentSystem, and has a number of fields that can be accessed using the Catalyst API and the ModelingToolkit.jl Abstract System Interface. Below we overview these components.","category":"page"},{"location":"api/","page":"API","title":"API","text":"There are three basic sets of convenience accessors that will return information either from a top-level system, the top-level system and all sub-systems that are also ReactionSystems (i.e. the full reaction-network), or the top-level system, all subs-systems, and all constraint systems (i.e. the full model). To retrieve info from just a base ReactionSystem rn, ignoring sub-systems of rn, one can use the ModelingToolkit accessors (these provide direct access to the corresponding internal fields of the ReactionSystem)","category":"page"},{"location":"api/","page":"API","title":"API","text":"ModelingToolkit.get_unknowns(rn) is a vector that collects all the species defined within rn, ordered by species and then non-species variables.\nCatalyst.get_species(rn) is a vector of all the species variables in the system. The entries in get_species(rn) correspond to the first length(get_species(rn)) components in get_unknowns(rn).\nModelingToolkit.get_ps(rn) is a vector that collects all the parameters defined within reactions in rn.\nModelingToolkit.get_eqs(rn) is a vector that collects all the Reactions and Symbolics.Equation defined within rn, ordering all Reactions before Equations.\nCatalyst.get_rxs(rn) is a vector of all the Reactions in rn, and corresponds to the first length(get_rxs(rn)) entries in get_eqs(rn).\nModelingToolkit.get_iv(rn) is the independent variable used in the system (usually t to represent time).\nModelingToolkit.get_systems(rn) is a vector of all sub-systems of rn.\nModelingToolkit.get_defaults(rn) is a dictionary of all the default values for parameters and species in rn.","category":"page"},{"location":"api/","page":"API","title":"API","text":"The preceding accessors do not allocate, directly accessing internal fields of the ReactionSystem.","category":"page"},{"location":"api/","page":"API","title":"API","text":"To retrieve information from the full reaction network represented by a system rn, which corresponds to information within both rn and all sub-systems, one can call:","category":"page"},{"location":"api/","page":"API","title":"API","text":"ModelingToolkit.unknowns(rn) returns all species and variables across the system, all sub-systems, and all constraint systems. Species are ordered before non-species variables in unknowns(rn), with the first numspecies(rn) entries in unknowns(rn) being the same as species(rn).\nspecies(rn) is a vector collecting all the chemical species within the system and any sub-systems that are also ReactionSystems.\nModelingToolkit.parameters(rn) returns all parameters across the system, all sub-systems, and all constraint systems.\nModelingToolkit.equations(rn) returns all Reactions and all Symbolics.Equations defined across the system, all sub-systems, and all constraint systems. Reactions are ordered ahead of Equations with the first numreactions(rn) entries in equations(rn) being the same as reactions(rn).\nreactions(rn) is a vector of all the Reactions within the system and any sub-systems that are also ReactionSystems.","category":"page"},{"location":"api/","page":"API","title":"API","text":"These accessors will generally allocate new arrays to store their output unless there are no subsystems. In the latter case the usually return the same vector as the corresponding get_* function.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Below we list the remainder of the Catalyst API accessor functions mentioned above.","category":"page"},{"location":"api/#Basic-system-properties","page":"API","title":"Basic system properties","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"See Programmatic Construction of Symbolic Reaction Systems for examples and ModelingToolkit and Catalyst Accessor Functions for more details on the basic accessor functions.","category":"page"},{"location":"api/","page":"API","title":"API","text":"species\nCatalyst.get_species\nnonspecies\nreactions\nCatalyst.get_rxs\nnonreactions\nnumspecies\nnumparams\nnumreactions\nspeciesmap\nparamsmap\nisautonomous","category":"page"},{"location":"api/#Catalyst.species","page":"API","title":"Catalyst.species","text":"species(network)\n\nGiven a ReactionSystem, return a vector of all species defined in the system and any subsystems that are of type ReactionSystem. To get the species and non-species variables in the system and all subsystems, including non-ReactionSystem subsystems, uses unknowns(network).\n\nNotes:\n\nIf ModelingToolkit.get_systems(network) is non-empty will allocate.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.get_species","page":"API","title":"Catalyst.get_species","text":"get_species(sys::ReactionSystem)\n\nReturn the current dependent variables that represent species in sys (toplevel system only).\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.nonspecies","page":"API","title":"Catalyst.nonspecies","text":"nonspecies(network)\n\nReturn the non-species variables within the network, i.e. those unknowns for which isspecies == false.\n\nNotes:\n\nAllocates a new array to store the non-species variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.reactions","page":"API","title":"Catalyst.reactions","text":"reactions(network)\n\nGiven a ReactionSystem, return a vector of all Reactions in the system.\n\nNotes:\n\nIf ModelingToolkit.get_systems(network) is not empty, will allocate.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.get_rxs","page":"API","title":"Catalyst.get_rxs","text":"get_rxs(sys::ReactionSystem)\n\nReturn the system's Reaction vector (toplevel system only).\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.nonreactions","page":"API","title":"Catalyst.nonreactions","text":"nonreactions(network)\n\nReturn the non-reaction equations within the network (i.e. algebraic and differential equations).\n\nNotes:\n\nAllocates a new array to store the non-species variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.numspecies","page":"API","title":"Catalyst.numspecies","text":"numspecies(network)\n\nReturn the total number of species within the given ReactionSystem and subsystems that are ReactionSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.numparams","page":"API","title":"Catalyst.numparams","text":"numparams(network)\n\nReturn the total number of parameters within the given system and all subsystems.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.numreactions","page":"API","title":"Catalyst.numreactions","text":"numreactions(network)\n\nReturn the total number of reactions within the given ReactionSystem and subsystems that are ReactionSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.speciesmap","page":"API","title":"Catalyst.speciesmap","text":"speciesmap(network)\n\nGiven a ReactionSystem, return a Dictionary mapping species that participate in Reactions to their index within species(network).\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.paramsmap","page":"API","title":"Catalyst.paramsmap","text":"paramsmap(network)\n\nGiven a ReactionSystem, return a Dictionary mapping from all parameters that appear within the system to their index within parameters(network).\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.isautonomous","page":"API","title":"Catalyst.isautonomous","text":"isautonomous(rs::ReactionSystem)\n\nChecks if a system is autonomous (i.e. no rate or equation depend on the independent variable(s)). Example:\n\nrs1 = @reaction_system\n    (p,d), 0 <--> X\nend\nisautonomous(rs1) # Returns `true`.\n\nrs2 = @reaction_system\n    (p/t,d), 0 <--> X\nend\nisautonomous(rs2) # Returns `false`.\n\n\n\n\n\n","category":"function"},{"location":"api/#Coupled-reaction/equation-system-properties","page":"API","title":"Coupled reaction/equation system properties","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following system property accessor functions are primarily relevant to reaction system coupled to differential and/or algebraic equations.","category":"page"},{"location":"api/","page":"API","title":"API","text":"ModelingToolkit.has_alg_equations\nModelingToolkit.alg_equations\nModelingToolkit.has_diff_equations\nModelingToolkit.diff_equations","category":"page"},{"location":"api/#ModelingToolkit.has_alg_equations","page":"API","title":"ModelingToolkit.has_alg_equations","text":"has_alg_equations(sys::AbstractSystem)\n\nFor a system, returns true if it contain at least one algebraic equation (i.e. that does not contain any differentials).\n\nExample:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@parameters p d\n@variables X(t)\neq1 = D(X) ~ p - d*X\neq2 = 0 ~ p - d*X\n@named osys1 = ODESystem([eq1], t)\n@named osys2 = ODESystem([eq2], t)\n\nhas_alg_equations(osys1) # returns `false`.\nhas_alg_equations(osys2) # returns `true`.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.alg_equations","page":"API","title":"ModelingToolkit.alg_equations","text":"alg_equations(sys::AbstractSystem)\n\nFor a system, returns a vector of all its algebraic equations (i.e. that does not contain any differentials).\n\nExample: ```julia using ModelingToolkit using ModelingToolkit: tnounits as t, Dnounits as D @parameters p d @variables X(t) eq1 = D(X) ~ p - dX eq2 = 0 ~ p - dX @named osys = ODESystem([eq1, eq2], t)\n\nalg_equations(osys) # returns [0 ~ p - d*X(t)].\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.has_diff_equations","page":"API","title":"ModelingToolkit.has_diff_equations","text":"has_diff_equations(sys::AbstractSystem)\n\nFor a system, returns true if it contain at least one differential equation (i.e. that contain a differential).\n\nExample:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@parameters p d\n@variables X(t)\neq1 = D(X) ~ p - d*X\neq2 = 0 ~ p - d*X\n@named osys1 = ODESystem([eq1], t)\n@named osys2 = ODESystem([eq2], t)\n\nhas_diff_equations(osys1) # returns `true`.\nhas_diff_equations(osys2) # returns `false`.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.diff_equations","page":"API","title":"ModelingToolkit.diff_equations","text":"diff_equations(sys::AbstractSystem)\n\nFor a system, returns a vector of all its differential equations (i.e. that does contain a differential).\n\nExample: ```julia using ModelingToolkit using ModelingToolkit: tnounits as t, Dnounits as D @parameters p d @variables X(t) eq1 = D(X) ~ p - dX eq2 = 0 ~ p - dX @named osys = ODESystem([eq1, eq2], t)\n\ndiff_equations(osys) # returns [Differential(t)(X(t)) ~ p - d*X(t)].\n\n\n\n\n\n","category":"function"},{"location":"api/#Basic-species-properties","page":"API","title":"Basic species properties","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following functions permits the querying of species properties.","category":"page"},{"location":"api/","page":"API","title":"API","text":"isspecies\nCatalyst.isconstant\nCatalyst.isbc\nCatalyst.isvalidreactant","category":"page"},{"location":"api/#Catalyst.isspecies","page":"API","title":"Catalyst.isspecies","text":"isspecies(s)\n\nTests if the given symbolic variable corresponds to a chemical species.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.isconstant","page":"API","title":"Catalyst.isconstant","text":"Catalyst.isconstant(s)\n\nTests if the given symbolic variable corresponds to a constant species.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.isbc","page":"API","title":"Catalyst.isbc","text":"Catalyst.isbc(s)\n\nTests if the given symbolic variable corresponds to a boundary condition species.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.isvalidreactant","page":"API","title":"Catalyst.isvalidreactant","text":"isvalidreactant(s)\n\nTest if a species is valid as a reactant (i.e. a species variable or a constant parameter).\n\n\n\n\n\n","category":"function"},{"location":"api/#Basic-reaction-properties","page":"API","title":"Basic reaction properties","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ismassaction\ndependents\ndependants\nsubstoichmat\nprodstoichmat\nnetstoichmat\nreactionrates","category":"page"},{"location":"api/#Catalyst.ismassaction","page":"API","title":"Catalyst.ismassaction","text":"ismassaction(rx, rs; rxvars = get_variables(rx.rate),\n                              haveivdep = nothing,\n                              unknownset = Set(unknowns(rs)),\n                              ivset = nothing)\n\nTrue if a given reaction is of mass action form, i.e. rx.rate does not depend on any chemical species that correspond to unknowns of the system, and does not depend explicitly on the independent variable (usually time).\n\nArguments\n\nrx, the Reaction.\nrs, a ReactionSystem containing the reaction.\nOptional: rxvars, Variables which are not in rxvars are ignored as possible dependencies.\nOptional: haveivdep, true if the Reaction rate field explicitly depends on any independent variable (i.e. t or for spatial systems x,y,etc). If not set, will be automatically calculated.\nOptional: unknownset, set of unknowns which if the rxvars are within mean rx is non-mass action.\nOptional: ivset, a Set of the independent variables of the system. If not provided and the system is spatial, i.e. isspatial(rs) == true, it will be created with all the spatial variables and the time variable. If the rate expression contains any element of ivset, then ismassaction(rx,rs) == false. Pass a custom set to control this behavior.\n\nNotes:\n\nNon-integer stoichiometry is treated as non-mass action. This includes symbolic variables/terms or floating point numbers for stoichiometric coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.dependents","page":"API","title":"Catalyst.dependents","text":"dependents(rx, network)\n\nGiven a Reaction and a ReactionSystem, return a vector of the non-constant species and variables the reaction rate law depends on. e.g., for\n\nk*W, 2X + 3Y --> 5Z + W\n\nthe returned vector would be [W(t),X(t),Y(t)].\n\nNotes:\n\nAllocates\nDoes not check for dependents within any subsystems.\nConstant species are not considered dependents since they are internally treated as parameters.\nIf the rate expression depends on a non-species unknown variable that will be included in the dependents, i.e. in\nt = default_t()\n@parameters k\n@variables V(t)\n@species A(t) B(t) C(t)\nrx = Reaction(k*V, [A, B], [C])\n@named rs = ReactionSystem([rx], t)\nissetequal(dependents(rx, rs), [A,B,V]) == true\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.dependants","page":"API","title":"Catalyst.dependants","text":"dependents(rx, network)\n\nSee documentation for dependents.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.substoichmat","page":"API","title":"Catalyst.substoichmat","text":"substoichmat(rn; sparse=false)\n\nReturns the substrate stoichiometry matrix, S, with S_i j the stoichiometric coefficient of the ith substrate within the jth reaction.\n\nNote:\n\nSet sparse=true for a sparse matrix representation\nNote that constant species are not considered substrates, but just components that modify the associated rate law.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.prodstoichmat","page":"API","title":"Catalyst.prodstoichmat","text":"prodstoichmat(rn; sparse=false)\n\nReturns the product stoichiometry matrix, P, with P_i j the stoichiometric coefficient of the ith product within the jth reaction.\n\nNote:\n\nSet sparse=true for a sparse matrix representation\nNote that constant species are not treated as products, but just components that modify the associated rate law.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.netstoichmat","page":"API","title":"Catalyst.netstoichmat","text":"netstoichmat(rn, sparse=false)\n\nReturns the net stoichiometry matrix, N, with N_i j the net stoichiometric coefficient of the ith species within the jth reaction.\n\nNotes:\n\nSet sparse=true for a sparse matrix representation\nCaches the matrix internally within rn so subsequent calls are fast.\nNote that constant species are not treated as reactants, but just components that modify the associated rate law. As such they do not contribute to the net stoichiometry matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.reactionrates","page":"API","title":"Catalyst.reactionrates","text":"reactionrates(network)\n\nGiven a ReactionSystem, returns a vector of the symbolic reaction rates for each reaction.\n\n\n\n\n\n","category":"function"},{"location":"api/#api_rx_metadata","page":"API","title":"Reaction metadata","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following functions permits the retrieval of reaction metadata.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Catalyst.hasnoisescaling\nCatalyst.getnoisescaling\nCatalyst.hasdescription\nCatalyst.getdescription\nCatalyst.hasmisc\nCatalyst.getmisc","category":"page"},{"location":"api/#Catalyst.hasnoisescaling","page":"API","title":"Catalyst.hasnoisescaling","text":"hasnoisescaling(reaction::Reaction)\n\nReturns true if the input reaction has the noise_scaing metadata field assigned, else false.\n\nArguments:\n\nreaction: The reaction we wish to check for the noise_scaing metadata field.\n\nExample:\n\nreaction = @reaction k, 0 --> X, [noise_scaling=0.0]\nhasnoisescaling(reaction)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.getnoisescaling","page":"API","title":"Catalyst.getnoisescaling","text":"getnoisescaling(reaction::Reaction)\n\nReturns noise_scaing metadata field for the input reaction.\n\nArguments:\n\nreaction: The reaction we wish to retrieve the noise_scaing metadata field.\n\nExample:\n\nreaction = @reaction k, 0 --> X, [noise_scaling=0.0]\ngetnoisescaling(reaction)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.hasdescription","page":"API","title":"Catalyst.hasdescription","text":"hasdescription(reaction::Reaction)\n\nReturns true if the input reaction has the description metadata field assigned, else false.\n\nArguments:\n\nreaction: The reaction we wish to check for the description metadata field.\n\nExample:\n\nreaction = @reaction k, 0 --> X, [description=\"A reaction\"]\nhasdescription(reaction)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.getdescription","page":"API","title":"Catalyst.getdescription","text":"getdescription(reaction::Reaction)\n\nReturns description metadata field for the input reaction.\n\nArguments:\n\nreaction: The reaction we wish to retrieve the description metadata field.\n\nExample:\n\nreaction = @reaction k, 0 --> X, [description=\"A reaction\"]\ngetdescription(reaction)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.hasmisc","page":"API","title":"Catalyst.hasmisc","text":"hasmisc(reaction::Reaction)\n\nReturns true if the input reaction has the misc metadata field assigned, else false.\n\nArguments:\n\nreaction: The reaction we wish to check for the misc metadata field.\n\nExample:\n\nreaction = @reaction k, 0 --> X, [misc=\"A reaction\"]\nhasmisc(reaction)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.getmisc","page":"API","title":"Catalyst.getmisc","text":"getmisc(reaction::Reaction)\n\nReturns misc metadata field for the input reaction.\n\nArguments:\n\nreaction: The reaction we wish to retrieve the misc metadata field.\n\nExample:\n\nreaction = @reaction k, 0 --> X, [misc=\"A reaction\"]\ngetmisc(reaction)\n\nNotes:\n\nThe misc field can contain any valid Julia structure. This mean that Catalyst cannot check it\n\nfor symbolic variables that are added here. This means that symbolic variables (e.g. parameters of species) that are stored here are not accessible to Catalyst. This can cause troubles when e.g. creating a ReactionSystem programmatically (in which case any symbolic variables stored in the misc metadata field should also be explicitly provided to the ReactionSystem constructor).\n\n\n\n\n\n","category":"function"},{"location":"api/#api_network_extension_and_modification","page":"API","title":"Functions to extend or modify a network","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ReactionSystems can be programmatically extended using ModelingToolkit.extend and ModelingToolkit.compose.","category":"page"},{"location":"api/","page":"API","title":"API","text":"setdefaults!\nModelingToolkit.extend\nModelingToolkit.compose\nCatalyst.flatten","category":"page"},{"location":"api/#Catalyst.setdefaults!","page":"API","title":"Catalyst.setdefaults!","text":"setdefaults!(rn, newdefs)\n\nSets the default (initial) values of parameters and species in the ReactionSystem, rn.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nsetdefaults!(sir, [:S => 999.0, :I => 1.0, :R => 1.0, :β => 1e-4, :ν => .01])\n\n# or\nt = default_t()\n@parameter β ν\n@species S(t) I(t) R(t)\nsetdefaults!(sir, [S => 999.0, I => 1.0, R => 0.0, β => 1e-4, ν => .01])\n\ngives initial/default values to each of S, I and β\n\nNotes:\n\nCan not be used to set default values for species, variables or parameters of subsystems or constraint systems. Either set defaults for those systems directly, or flatten to collate them into one system before setting defaults.\nDefaults can be specified in any iterable container of symbols to value pairs or symbolics to value pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.extend","page":"API","title":"ModelingToolkit.extend","text":"extend(\n    sys::ModelingToolkit.AbstractSystem,\n    basesys::ModelingToolkit.AbstractSystem;\n    name,\n    description,\n    gui_metadata\n) -> ReactionSystem{Catalyst.NetworkProperties{Int64, V}} where V<:SymbolicUtils.BasicSymbolic{Real}\n\n\nExtend basesys with sys. By default, the resulting system inherits sys's name and description.\n\nSee also compose.\n\n\n\n\n\nModelingToolkit.extend(sys::AbstractSystem, rs::ReactionSystem; name::Symbol=nameof(sys))\n\nExtends the indicated ReactionSystem with another AbstractSystem.\n\nNotes:\n\nThe AbstractSystem being added in must be an ODESystem, NonlinearSystem, or ReactionSystem currently.\nReturns a new ReactionSystem and does not modify rs.\nBy default, the new ReactionSystem will have the same name as sys.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.compose","page":"API","title":"ModelingToolkit.compose","text":"compose(sys, systems; name)\n\n\nCompose multiple systems together. The resulting system would inherit the first system's name.\n\nSee also extend.\n\n\n\n\n\nModelingToolkit.compose(sys::ReactionSystem, systems::AbstractArray; name = nameof(sys))\n\nCompose the indicated ReactionSystem with one or more AbstractSystems.\n\nNotes:\n\nThe AbstractSystem being added in must be an ODESystem, NonlinearSystem, or ReactionSystem currently.\nReturns a new ReactionSystem and does not modify rs.\nBy default, the new ReactionSystem will have the same name as sys.\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelingToolkit.flatten","page":"API","title":"ModelingToolkit.flatten","text":"Catalyst.flatten(rs::ReactionSystem)\n\nMerges all subsystems of the given ReactionSystem up into rs.\n\nNotes:\n\nReturns a new ReactionSystem that represents the flattened system.\nAll Reactions within subsystems are namespaced and merged into the list of Reactions of rs. The merged list is then available as reactions(rs).\nAll algebraic and differential equations are merged in the equations of rs.\nCurrently only ReactionSystems, NonlinearSystems and ODESystems are supported as sub-systems when flattening.\nrs.networkproperties is reset upon flattening.\nThe default value of combinatoric_ratelaws will be the logical or of all ReactionSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/#Network-analysis-and-representations","page":"API","title":"Network analysis and representations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Note, currently API functions for network analysis and conservation law analysis do not work with constant species (currently only generated by SBMLToolkit).","category":"page"},{"location":"api/","page":"API","title":"API","text":"conservationlaws\nconservedquantities\nconservedequations\nconservationlaw_constants\nReactionComplexElement\nReactionComplex\nreactioncomplexmap\nreactioncomplexes\nincidencemat\ncomplexstoichmat\ncomplexoutgoingmat\nincidencematgraph\nlinkageclasses\ndeficiency\nsubnetworks\nlinkagedeficiencies\nisreversible\nisweaklyreversible\nreset_networkproperties!","category":"page"},{"location":"api/#Catalyst.conservationlaws","page":"API","title":"Catalyst.conservationlaws","text":"conservationlaws(netstoichmat::AbstractMatrix)::Matrix\n\nGiven the net stoichiometry matrix of a reaction system, computes a matrix of conservation laws, each represented as a row in the output.\n\n\n\n\n\nconservationlaws(rs::ReactionSystem)\n\nReturn the conservation law matrix of the given ReactionSystem, calculating it if it is not already stored within the system, or returning an alias to it.\n\nNotes:\n\nThe first time being called it is calculated and cached in rn, subsequent calls should be fast.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.conservedquantities","page":"API","title":"Catalyst.conservedquantities","text":"conservedquantities(state, cons_laws)\n\nCompute conserved quantities for a system with the given conservation laws.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.conservedequations","page":"API","title":"Catalyst.conservedequations","text":"conservedequations(rn::ReactionSystem)\n\nCalculate symbolic equations from conservation laws, writing dependent variables as functions of independent variables and the conservation law constants.\n\nNotes:\n\nCaches the resulting equations in rn, so will be fast on subsequent calls.\n\nExamples:\n\nrn = @reaction_network begin\n    k, A + B --> C\n    k2, C --> A + B\n    end\nconservedequations(rn)\n\ngives\n\n2-element Vector{Equation}:\n B(t) ~ A(t) + Γ[1]\n C(t) ~ Γ[2] - A(t)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.conservationlaw_constants","page":"API","title":"Catalyst.conservationlaw_constants","text":"conservationlaw_constants(rn::ReactionSystem)\n\nCalculate symbolic equations from conservation laws, writing the conservation law constants in terms of the dependent and independent variables.\n\nNotes:\n\nCaches the resulting equations in rn, so will be fast on subsequent calls.\n\nExamples:\n\nrn = @reaction_network begin\n    k, A + B --> C\n    k2, C --> A + B\n    end\nconservationlaw_constants(rn)\n\ngives\n\n2-element Vector{Equation}:\n Γ[1] ~ B(t) - A(t)\n Γ[2] ~ A(t) + C(t)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.ReactionComplexElement","page":"API","title":"Catalyst.ReactionComplexElement","text":"struct ReactionComplexElement{T}\n\nOne reaction complex element\n\nFields\n\nspeciesid: The integer id of the species representing this element.\nspeciesstoich: The stoichiometric coefficient of this species.\n\n\n\n\n\n","category":"type"},{"location":"api/#Catalyst.ReactionComplex","page":"API","title":"Catalyst.ReactionComplex","text":"struct ReactionComplex{V<:Integer} <: AbstractArray{Catalyst.ReactionComplexElement{V<:Integer}, 1}\n\nOne reaction complex.\n\nFields\n\nspeciesids: The integer ids of all species participating in this complex.\nspeciesstoichs: The stoichiometric coefficients of all species participating in this complex.\n\n\n\n\n\n","category":"type"},{"location":"api/#Catalyst.reactioncomplexmap","page":"API","title":"Catalyst.reactioncomplexmap","text":"reactioncomplexmap(rn::ReactionSystem)\n\nFind each ReactionComplex within the specified system, constructing a mapping from the complex to vectors that indicate which reactions it appears in as substrates and products.\n\nNotes:\n\nEach ReactionComplex is mapped to a vector of pairs, with each pair having the form reactionidx => ± 1, where -1 indicates the complex appears as a substrate and +1 as a product in the reaction with integer label reactionidx.\nConstant species are ignored as part of a complex. i.e. if species A is constant then the reaction A + B --> C + D is considered to consist of the complexes B and C + D. Likewise A --> B would be treated as the same as 0 --> B.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.reactioncomplexes","page":"API","title":"Catalyst.reactioncomplexes","text":"reactioncomplexes(network::ReactionSystem; sparse=false)\n\nCalculate the reaction complexes and complex incidence matrix for the given ReactionSystem.\n\nNotes:\n\nreturns a pair of a vector of ReactionComplexs and the complex incidence matrix.\nAn empty ReactionComplex denotes the null (∅) state (from reactions like ∅ -> A or A -> ∅).\nConstant species are ignored in generating a reaction complex. i.e. if A is constant then A –> B consists of the complexes ∅ and B.\nThe complex incidence matrix, B, is number of complexes by number of reactions with\n\nB_i j = begincases\n-1 textif the ith complex is the substrate of the jth reaction\n1 textif the ith complex is the product of the jth reaction\n0 textotherwise\nendcases\n\nSet sparse=true for a sparse matrix representation of the incidence matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.incidencemat","page":"API","title":"Catalyst.incidencemat","text":"incidencemat(rn::ReactionSystem; sparse=false)\n\nCalculate the incidence matrix of rn, see reactioncomplexes.\n\nNotes:\n\nIs cached in rn so that future calls, assuming the same sparsity, will also be fast.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.complexstoichmat","page":"API","title":"Catalyst.complexstoichmat","text":"complexstoichmat(network::ReactionSystem; sparse=false)\n\nGiven a ReactionSystem and vector of reaction complexes, return a matrix with positive entries of size number of species by number of complexes, where the non-zero positive entries in the kth column denote stoichiometric coefficients of the species participating in the kth reaction complex.\n\nNotes:\n\nSet sparse=true for a sparse matrix representation\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.complexoutgoingmat","page":"API","title":"Catalyst.complexoutgoingmat","text":"complexoutgoingmat(network::ReactionSystem; sparse=false)\n\nGiven a ReactionSystem and complex incidence matrix, B, return a matrix of size num of complexes by num of reactions that identifies substrate complexes.\n\nNotes:\n\nThe complex outgoing matrix, Delta, is defined by\n\nDelta_i j = begincases\n    = 0    textif  B_i j = 1 \n    = B_i j textotherwise\nendcases\n\nSet sparse=true for a sparse matrix representation\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.incidencematgraph","page":"API","title":"Catalyst.incidencematgraph","text":"incidencematgraph(rn::ReactionSystem)\n\nConstruct a directed simple graph where nodes correspond to reaction complexes and directed edges to reactions converting between two complexes.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nincidencematgraph(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.linkageclasses","page":"API","title":"Catalyst.linkageclasses","text":"linkageclasses(rn::ReactionSystem)\n\nGiven the incidence graph of a reaction network, return a vector of the connected components of the graph (i.e. sub-groups of reaction complexes that are connected in the incidence graph).\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nlinkageclasses(sir)\n\ngives\n\n2-element Vector{Vector{Int64}}:\n [1, 2]\n [3, 4]\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.deficiency","page":"API","title":"Catalyst.deficiency","text":"deficiency(rn::ReactionSystem)\n\nCalculate the deficiency of a reaction network.\n\nHere the deficiency, delta, of a network with n reaction complexes, ell linkage classes and a rank s stoichiometric matrix is\n\ndelta = n - ell - s\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nδ = deficiency(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.subnetworks","page":"API","title":"Catalyst.subnetworks","text":"subnetworks(rn::ReactionSystem)\n\nFind subnetworks corresponding to each linkage class of the reaction network.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nsubnetworks(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.linkagedeficiencies","page":"API","title":"Catalyst.linkagedeficiencies","text":"linkagedeficiencies(network::ReactionSystem)\n\nCalculates the deficiency of each sub-reaction network within network.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nlinkage_deficiencies = linkagedeficiencies(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.isreversible","page":"API","title":"Catalyst.isreversible","text":"isreversible(rn::ReactionSystem)\n\nGiven a reaction network, returns if the network is reversible or not.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nisreversible(sir)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.isweaklyreversible","page":"API","title":"Catalyst.isweaklyreversible","text":"isweaklyreversible(rn::ReactionSystem, subnetworks)\n\nDetermine if the reaction network with the given subnetworks is weakly reversible or not.\n\nFor example,\n\nsir = @reaction_network SIR begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nsubnets = subnetworks(rn)\nisweaklyreversible(rn, subnets)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.reset_networkproperties!","page":"API","title":"Catalyst.reset_networkproperties!","text":"reset_networkproperties!(rn::ReactionSystem)\n\nClears the cache of various properties (like the netstoichiometry matrix). Use if such properties need to be recalculated for some reason.\n\n\n\n\n\n","category":"function"},{"location":"api/#Network-comparison","page":"API","title":"Network comparison","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"==(rn1::Reaction, rn2::Reaction)\nisequivalent\n==(rn1::ReactionSystem, rn2::ReactionSystem)","category":"page"},{"location":"api/#Base.:==-Tuple{Reaction, Reaction}","page":"API","title":"Base.:==","text":"==(rx1::Reaction, rx2::Reaction)\n\nTests whether two Reactions are identical.\n\nNotes:\n\nIgnores the order in which stoichiometry components are listed.\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\n\n\n\n\n\n","category":"method"},{"location":"api/#Catalyst.isequivalent","page":"API","title":"Catalyst.isequivalent","text":"isequivalent(rn1::ReactionSystem, rn2::ReactionSystem; ignorenames = true)\n\nTests whether the underlying species, parameters and reactions are the same in the two ReactionSystems. Ignores the names of the systems in testing equality.\n\nNotes:\n\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\nDoes not include defaults in determining equality.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.:==-Tuple{ReactionSystem, ReactionSystem}","page":"API","title":"Base.:==","text":"==(rn1::ReactionSystem, rn2::ReactionSystem)\n\nTests whether the underlying species, parameters and reactions are the same in the two ReactionSystems. Requires the systems to have the same names too.\n\nNotes:\n\nDoes not currently simplify rates, so a rate of A^2+2*A+1 would be   considered different than (A+1)^2.\nDoes not include defaults in determining equality.\n\n\n\n\n\n","category":"method"},{"location":"api/#Network-visualization","page":"API","title":"Network visualization","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Latexify can be used to convert networks to LaTeX equations by","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Latexify\nlatexify(rn)","category":"page"},{"location":"api/","page":"API","title":"API","text":"An optional argument, form allows using latexify to display a reaction network's ODE (as generated by the reaction rate equation) or SDE (as generated by the chemical Langevin equation) form:","category":"page"},{"location":"api/","page":"API","title":"API","text":"latexify(rn; form=:ode)","category":"page"},{"location":"api/","page":"API","title":"API","text":"latexify(rn; form=:sde)","category":"page"},{"location":"api/","page":"API","title":"API","text":"(As of writing this, an upstream bug causes the SDE form to be erroneously displayed as the ODE form)","category":"page"},{"location":"api/","page":"API","title":"API","text":"Finally, another optional argument (expand_functions=true) automatically expands functions defined by Catalyst (such as mm). To disable this, set expand_functions=false.","category":"page"},{"location":"api/","page":"API","title":"API","text":"If Graphviz is installed and commandline accessible, it can be used to create and save network diagrams using Graph and savegraph.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Graph\ncomplexgraph\nsavegraph","category":"page"},{"location":"api/#Catalyst.Graph","page":"API","title":"Catalyst.Graph","text":"Graph(rn::ReactionSystem)\n\nConverts a ReactionSystem into a Graphviz graph. Reactions correspond to small green circles, and species to blue circles.\n\nNotes:\n\nBlack arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry.\nBlack arrows from reactions to species indicate products, and are labelled with their output stoichiometry.\nRed arrows from species to reactions indicate that species is used within the rate expression. For example, in the reaction k*A, B --> C, there would be a red arrow from A to the reaction node. In k*A, A+B --> C, there would be red and black arrows from A to the reaction node.\nRequires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"type"},{"location":"api/#Catalyst.complexgraph","page":"API","title":"Catalyst.complexgraph","text":"complexgraph(rn::ReactionSystem; complexdata=reactioncomplexes(rn))\n\nCreates a Graphviz graph of the ReactionComplexs in rn. Reactions correspond to arrows and reaction complexes to blue circles.\n\nNotes:\n\nBlack arrows from complexes to complexes indicate reactions whose rate is a parameter or a Number. i.e. k, A --> B.\nRed dashed arrows from complexes to complexes indicate reactions whose rate depends on species. i.e. k*C, A --> B for C a species.\nRequires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.savegraph","page":"API","title":"Catalyst.savegraph","text":"savegraph(g::Graph, fname, fmt=\"png\")\n\nGiven a Graph generated by Graph, save the graph to the file with name fname and extension fmt.\n\nNotes:\n\nfmt=\"png\" is the default output format.\nRequires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.\n\n\n\n\n\n","category":"function"},{"location":"api/#api_rate_laws","page":"API","title":"Rate laws","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"As the underlying ReactionSystem is comprised of ModelingToolkit expressions, one can directly access the generated rate laws, and using ModelingToolkit tooling generate functions or Julia Exprs from them.","category":"page"},{"location":"api/","page":"API","title":"API","text":"oderatelaw\njumpratelaw\nmm\nmmr\nhill\nhillr\nhillar","category":"page"},{"location":"api/#Catalyst.oderatelaw","page":"API","title":"Catalyst.oderatelaw","text":"oderatelaw(rx; combinatoric_ratelaw=true)\n\nGiven a Reaction, return the symbolic reaction rate law used in generated ODEs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X(t)^2*Y(t)*Z(t). For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe expression that is returned will be k * (X(t)^2/2) * (Y(t)^3/6).\n\nNotes:\n\nAllocates\ncombinatoric_ratelaw=true uses factorial scaling factors in calculating the   rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. If   combinatoric_ratelaw=false then the ratelaw is k*S^2, i.e. the scaling   factor is ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.jumpratelaw","page":"API","title":"Catalyst.jumpratelaw","text":"jumpratelaw(rx; combinatoric_ratelaw=true)\n\nGiven a Reaction, return the symbolic reaction rate law used in generated stochastic chemical kinetics model SSAs for the reaction. Note, for a reaction defined by\n\nk*X*Y, X+Z --> 2X + Y\n\nthe expression that is returned will be k*X^2*Y*Z. For a reaction of the form\n\nk, 2X+3Y --> Z\n\nthe expression that is returned will be k * binomial(X,2) * binomial(Y,3).\n\nNotes:\n\nAllocates\ncombinatoric_ratelaw=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaw=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.mm","page":"API","title":"Catalyst.mm","text":"mm(X,v,K) = v*X / (X + K)\n\nA Michaelis-Menten rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.mmr","page":"API","title":"Catalyst.mmr","text":"mmr(X,v,K) = v*K / (X + K)\n\nA repressive Michaelis-Menten rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.hill","page":"API","title":"Catalyst.hill","text":"hill(X,v,K,n) = v*(X^n) / (X^n + K^n)\n\nA Hill rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.hillr","page":"API","title":"Catalyst.hillr","text":"hillr(X,v,K,n) = v*(K^n) / (X^n + K^n)\n\nA repressive Hill rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.hillar","page":"API","title":"Catalyst.hillar","text":"hillar(X,Y,v,K,n) = v*(X^n) / (X^n + Y^n + K^n)\n\nAn activation/repressing Hill rate function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Transformations","page":"API","title":"Transformations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Base.convert\nJumpInputs\nModelingToolkit.structural_simplify\nset_default_noise_scaling","category":"page"},{"location":"api/#Base.convert","page":"API","title":"Base.convert","text":"Base.convert(::Type{<:ODESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ModelingToolkit.ODESystem.\n\nKeyword args and default values:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. Set combinatoric_ratelaws=false for a ratelaw of k*S^2, i.e. the scaling factor is ignored. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nremove_conserved=false, if set to true will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.\nremove_conserved_warn = true: If true, if also remove_conserved = true, there will be a warning regarding limitations of modifying problems generated from the created system.\n\n\n\n\n\nBase.convert(::Type{<:NonlinearSystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ModelingToolkit.NonlinearSystem.\n\nKeyword args and default values:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. Set combinatoric_ratelaws=false for a ratelaw of k*S^2, i.e. the scaling factor is ignored. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nremove_conserved=false, if set to true will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.\nremove_conserved_warn = true: If true, if also remove_conserved = true, there will be a warning regarding limitations of modifying problems generated from the created system.\n\n\n\n\n\nBase.convert(::Type{<:SDESystem},rs::ReactionSystem)\n\nConvert a ReactionSystem to an ModelingToolkit.SDESystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses factorial scaling factors in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S^2/2!. Set combinatoric_ratelaws=false for a ratelaw of k*S^2, i.e. the scaling factor is ignored. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nremove_conserved=false, if set to true will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.\nremove_conserved_warn = true: If true, if also remove_conserved = true, there will be a warning regarding limitations of modifying problems generated from the created system.\n\n\n\n\n\nBase.convert(::Type{<:JumpSystem},rs::ReactionSystem; combinatoric_ratelaws=true)\n\nConvert a ReactionSystem to an ModelingToolkit.JumpSystem.\n\nNotes:\n\ncombinatoric_ratelaws=true uses binomials in calculating the rate law, i.e. for 2S -> 0 at rate k the ratelaw would be k*S*(S-1)/2. If combinatoric_ratelaws=false then the ratelaw is k*S*(S-1), i.e. the rate law is not normalized by the scaling factor. Defaults to the value given when the ReactionSystem was constructed (which itself defaults to true).\nDoes not currently support ReactionSystems that include coupled algebraic or differential equations.\nDoes not currently support continuous events as these are not supported by ModelingToolkit.JumpSystems.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.JumpInputs","page":"API","title":"Catalyst.JumpInputs","text":"struct JumpInputs{S<:JumpSystem, T<:SciMLBase.AbstractODEProblem}\n\nInputs for a JumpProblem from a given ReactionSystem.\n\nFields\n\nsys: The JumpSystem to define the problem over\nprob: The problem the JumpProblem should be defined over, for example DiscreteProblem\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelingToolkit.structural_simplify","page":"API","title":"ModelingToolkit.structural_simplify","text":"structural_simplify(sys; ...)\nstructural_simplify(\n    sys,\n    io;\n    additional_passes,\n    simplify,\n    split,\n    allow_symbolic,\n    allow_parameter,\n    conservative,\n    fully_determined,\n    kwargs...\n)\n\n\nStructurally simplify algebraic equations in a system and compute the topological sort of the observed equations in sys.\n\nOptional Arguments:\n\noptional argument io may take a tuple (inputs, outputs). This will convert all inputs to parameters and allow them to be unconnected, i.e., simplification will allow models where n_unknowns = n_equations - n_inputs.\n\nOptional Keyword Arguments:\n\nWhen simplify=true, the simplify function will be applied during the tearing process.\nallow_symbolic=false, allow_parameter=true, and conservative=false limit the coefficient types during tearing. In particular, conservative=true limits tearing to only solve for trivial linear systems where the coefficient has the absolute value of 1.\nfully_determined=true controls whether or not an error will be thrown if the number of equations don't match the number of inputs, outputs, and equations.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.set_default_noise_scaling","page":"API","title":"Catalyst.set_default_noise_scaling","text":"setdefaultnoisescaling(rs::ReactionSystem, noisescaling)\n\nCreates an updated ReactionSystem. This is the old ReactionSystem, but each Reaction that does not have a noise_scaling metadata have its noisescaling metadata updated. The input ReactionSystem is not mutated. Any subsystems of rs have their `noisescaling` metadata updated as well.\n\nArguments:\n\nrs::ReactionSystem: The ReactionSystem which you wish to remake.\nnoise_scaling: The updated noise scaling terms\n\n\n\n\n\n","category":"function"},{"location":"api/#Chemistry-related-functionalities","page":"API","title":"Chemistry-related functionalities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Various functionalities primarily relevant to modelling of chemical systems (but potentially also in biology).","category":"page"},{"location":"api/","page":"API","title":"API","text":"@compound\n@compounds\niscompound\ncomponents\ncoefficients\ncomponent_coefficients","category":"page"},{"location":"api/#Catalyst.@compound","page":"API","title":"Catalyst.@compound","text":"@compound\n\nMacro that creates a compound species, which is composed of smaller component species.\n\nExample:\n\nt = default_t()\n@species C(t) O(t)\n@compound CO2(t) ~ C + 2O\n\nNotes:\n\nThe component species must be defined before using the @compound macro.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Catalyst.@compounds","page":"API","title":"Catalyst.@compounds","text":"@compounds\n\nMacro that creates several compound species, which each is composed of smaller component species. Uses the same syntax as @compound, but with one compound species one each line.\n\nExample:\n\nt = default_t()\n@species C(t) H(t) O(t)\n@compounds\n    CH4(t) = C + 4H\n    O2(t) = 2O\n    CO2(t) = C + 2O\n    H2O(t) = 2H + O\nend\n\nNotes:\n\nThe component species must be defined before using the @compound macro.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Catalyst.iscompound","page":"API","title":"Catalyst.iscompound","text":"iscompound(s)\n\nReturns true if the input is a compound species (else false).\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.components","page":"API","title":"Catalyst.components","text":"components(s)\n\nReturns a vector with a list of all the components of a compound species (created using e.g. the @compound macro).\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.coefficients","page":"API","title":"Catalyst.coefficients","text":"coefficients(s)\n\nReturns a vector with a list of all the stoichiometric coefficients of the components of a compound species (created using e.g. the @compound macro).\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.component_coefficients","page":"API","title":"Catalyst.component_coefficients","text":"component_coefficients(s)\n\nReturns a Vector{Pari{Symbol,Int64}}, listing a compounds species (created using e.g. the @compound macro) all the coefficients and their stoichiometric coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#Unit-validation","page":"API","title":"Unit validation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"validate(rx::Reaction; info::String = \"\")\nvalidate(rs::ReactionSystem, info::String=\"\")","category":"page"},{"location":"api/#ModelingToolkit.validate-Tuple{Reaction}","page":"API","title":"ModelingToolkit.validate","text":"validate(rx::Reaction; info::String = \"\")\n\nCheck that all substrates and products within the given Reaction have the same units, and that the units of the reaction's rate expression are internally consistent (i.e. if the rate involves sums, each term in the sum has the same units).\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelingToolkit.validate","page":"API","title":"ModelingToolkit.validate","text":"validate(rs::ReactionSystem, info::String=\"\")\n\nCheck that all species in the ReactionSystem have the same units, and that the rate laws of all reactions reduce to units of (species units) / (time units).\n\nNotes:\n\nDoes not check subsystems, constraint equations, or non-species variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utility-functions","page":"API","title":"Utility functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"symmap_to_varmap","category":"page"},{"location":"api/#Catalyst.symmap_to_varmap","page":"API","title":"Catalyst.symmap_to_varmap","text":"symmap_to_varmap(sys, symmap)\n\nGiven a system and map of Symbols to values, generates a map from corresponding symbolic variables/parameters to the values that can be used to pass initial conditions and parameter mappings.\n\nFor example,\n\nsir = @reaction_network sir begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nsubsys = @reaction_network subsys begin\n    k, A --> B\nend\n@named sys = compose(sir, [subsys])\n\ngives\n\nModel sys with 3 equations\nUnknowns (5):\n  S(t)\n  I(t)\n  R(t)\n  subsys₊A(t)\n  subsys₊B(t)\nParameters (3):\n  β\n  ν\n  subsys₊k\n\nto specify initial condition and parameter mappings from symbols we can use\n\nsymmap = [:S => 1.0, :I => 1.0, :R => 1.0, :subsys₊A => 1.0, :subsys₊B => 1.0]\nu0map  = symmap_to_varmap(sys, symmap)\npmap   = symmap_to_varmap(sys, [:β => 1.0, :ν => 1.0, :subsys₊k => 1.0])\n\nu0map and pmap can then be used as input to various problem types.\n\nNotes:\n\nAny Symbol, sym, within symmap must be a valid field of sys. i.e. sys.sym must be defined.\n\n\n\n\n\n","category":"function"},{"location":"api/#api_lattice_simulations","page":"API","title":"Spatial modelling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The first step of spatial modelling is to create a so-called LatticeReactionSystem:","category":"page"},{"location":"api/","page":"API","title":"API","text":"LatticeReactionSystem","category":"page"},{"location":"api/#Catalyst.LatticeReactionSystem","page":"API","title":"Catalyst.LatticeReactionSystem","text":"struct LatticeReactionSystem{Q, R, S, T} <: AbstractTimeDependentSystem\n\nA representation of a spatial system of chemical reactions on a discrete (lattice) space.\n\nFields\n\nreactionsystem: The (non-spatial) reaction system within each vertex.\nspatial_reactions: The spatial reactions defined between individual vertices.\nlattice: The lattice on which the (discrete) spatial system is defined.\nnum_verts: The number of vertices (compartments).\nnum_edges: The number of edges.\nnum_species: The number of species.\nspatial_species: List of species that may move spatially.\nparameters: All parameters related to the lattice reaction system (both those whose values are tied to vertices and edges).\n\nvertex_parameters: Parameters which values are tied to vertices, e.g. that possibly could have unique values at each vertex of the system.\n\nedge_parameters: Parameters whose values are tied to edges (adjacencies), e.g. that possibly could have unique values at each edge of the system.\n\nedge_iterator: An iterator over all the lattice's edges. Currently, the format is always a Vector{Pair{Int64,Int64}}. However, in the future, different types could potentially be used for different types of lattice (E.g. for a Cartesian grid, we do not technically need to enumerate each edge)\n\nArguments:\n\nrs: The non-spatial ReactionSystem model that is expanded to a spatial model.\nsrs: A vector of spatial reactions. These provide the rules for how species may move spatially.\nlattice: Either a Cartesian grid, a masked grid, or a graph. This describes the discrete space\n\nto which the non-spatial model is expanded.\n\nKeyword Arguments:\n\ndiagonal_connections = false: Only relevant for Cartesian and masked lattices. If true,\n\ndiagonally adjacent compartments are considered adjacent, and spatial reactions in between these are possible.\n\nExample:\n\n# Fetch packages.\nusing Catalyst, OrdinaryDiffEqDefault\nimport CairoMakie\n\n# Creates the `LatticeReactionSystem` model.\nrs = @reaction_network begin\n    (p,d), 0 <--> X\nend\ndiffusion_rx = @transport_reaction D X\nlattice = CartesianGrid((5,5))\nlrs = LatticeReactionSystem(rs, [diffusion_rx], lattice)\n\n# Simulates the model (using ODE and jumps).\nu0 = [:X => rand(5,5)]\ntspan = (0.0, 1.0)\nps = [:p => 1.0, :d => 0.5, :D => 0.1]\noprob = ODEProblem(lrs, u0, tspan, ps)\nosol = solve(oprob)\n\n# Saves an animation of the solution to the file \"lattice_animation.mp4\".\nlattice_animation(osol, :X, lrs, \"lattice_animation.mp4\")\n\nNotes:\n\nSpatial modelling in Catalyst is still a work in progress, any feedback (or contributions) to this\n\nis highly welcome.\n\nLatticeReactionSystems are primarily intended to model systems in discrete space. Modelling\n\ncontinuous space systems with them is possible, but requires the user to determine the discretisation (the lattice). Better support for continuous space models is a work in progress.\n\nCatalyst contains extensive documentation on spatial modelling, which can be found here.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"The following functions can be used to querying the properties of LatticeReactionSystems:","category":"page"},{"location":"api/","page":"API","title":"API","text":"reactionsystem\nCatalyst.spatial_reactions\nCatalyst.lattice\nCatalyst.num_verts\nCatalyst.num_edges\nCatalyst.num_species\nCatalyst.spatial_species\nCatalyst.vertex_parameters\nCatalyst.edge_parameters\nCatalyst.edge_iterator\nCatalyst.is_transport_system\nhas_cartesian_lattice\nhas_masked_lattice\nhas_grid_lattice\nhas_graph_lattice\ngrid_size\ngrid_dims","category":"page"},{"location":"api/#Catalyst.reactionsystem","page":"API","title":"Catalyst.reactionsystem","text":"reactionsystem(lrs::LatticeReactionSystem)\n\nReturns the non-spatial ReactionSystem stored in a LatticeReactionSystem.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.spatial_reactions","page":"API","title":"Catalyst.spatial_reactions","text":"spatial_reactions(lrs::LatticeReactionSystem)\n\nReturns a vector with all the spatial reactions stored in a LatticeReactionSystem.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.lattice","page":"API","title":"Catalyst.lattice","text":"lattice(lrs::LatticeReactionSystem)\n\nReturns the lattice stored in a LatticeReactionSystem.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.num_verts","page":"API","title":"Catalyst.num_verts","text":"num_verts(lrs::LatticeReactionSystem)\n\nReturns the number of vertices (i.e. compartments) in the lattice stored in a LatticeReactionSystem.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.num_edges","page":"API","title":"Catalyst.num_edges","text":"num_edges(lrs::LatticeReactionSystem)\n\nReturns the number of edges (i.e. connections between vertices) in the lattice stored in a LatticeReactionSystem.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.num_species","page":"API","title":"Catalyst.num_species","text":"num_species(lrs::LatticeReactionSystem)\n\nReturns the number of species that a LatticeReactionSystem contains.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.spatial_species","page":"API","title":"Catalyst.spatial_species","text":"spatial_species(lrs::LatticeReactionSystem)\n\nReturns the number of species that can move spatially that a LatticeReactionSystem contains.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.vertex_parameters","page":"API","title":"Catalyst.vertex_parameters","text":"vertex_parameters(lrs::LatticeReactionSystem)\n\nReturns all the parameters of a LatticeReactionSystem whose values are tied to vertices.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.edge_parameters","page":"API","title":"Catalyst.edge_parameters","text":"edge_parameters(lrs::LatticeReactionSystem)\n\nReturns all the parameters of a LatticeReactionSystem whose values are tied to edges.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.edge_iterator","page":"API","title":"Catalyst.edge_iterator","text":"edge_iterator(lrs::LatticeReactionSystem)\n\nReturns an iterator over all of the edges in the lattice stored in a LatticeReactionSystem. Each edge is a Pair{Int64, Int64}, taking the source vertex to the destination vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.is_transport_system","page":"API","title":"Catalyst.is_transport_system","text":"is_transport_system(lrs::LatticeReactionSystem)\n\nReturns true if all spatial reactions in lrs are TransportReactions.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.has_cartesian_lattice","page":"API","title":"Catalyst.has_cartesian_lattice","text":"has_cartesian_lattice(lrs::LatticeReactionSystem)\n\nReturns true if lrs was created using a cartesian grid lattice (e.g. created via CartesianGrid(5,5)). Otherwise, returns false.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.has_masked_lattice","page":"API","title":"Catalyst.has_masked_lattice","text":"has_masked_lattice(lrs::LatticeReactionSystem)\n\nReturns true if lrs was created using a masked grid lattice (e.g. created via [true true; true false]). Otherwise, returns false.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.has_grid_lattice","page":"API","title":"Catalyst.has_grid_lattice","text":"has_grid_lattice(lrs::LatticeReactionSystem)\n\nReturns true if lrs was created using a cartesian or masked grid lattice. Otherwise, returns false.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.has_graph_lattice","page":"API","title":"Catalyst.has_graph_lattice","text":"has_graph_lattice(lrs::LatticeReactionSystem)\n\nReturns true if lrs was created using a graph grid lattice (e.g. created via path_graph(5)). Otherwise, returns false.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.grid_size","page":"API","title":"Catalyst.grid_size","text":"grid_size(lrs::LatticeReactionSystem)\n\nReturns the size of lrs's lattice (only if it is a cartesian or masked grid lattice). E.g. for a lattice CartesianGrid(4,6), (4,6) is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.grid_dims","page":"API","title":"Catalyst.grid_dims","text":"grid_dims(lrs::LatticeReactionSystem)\n\nReturns the number of dimensions of lrs's lattice (only if it is a cartesian or masked grid lattice). The output is either 1, 2, or 3.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"In addition, most accessor functions for normal ReactionSystems (such as species and parameters) works when applied to LatticeReactionSystems as well.","category":"page"},{"location":"api/","page":"API","title":"API","text":"The following two helper functions can be used to create non-uniform parameter values.","category":"page"},{"location":"api/","page":"API","title":"API","text":"make_edge_p_values\nmake_directed_edge_values","category":"page"},{"location":"api/#Catalyst.make_edge_p_values","page":"API","title":"Catalyst.make_edge_p_values","text":"make_edge_p_values(lrs::LatticeReactionSystem, make_edge_p_value::Function)\n\nGenerates edge parameter values for a lattice reaction system. Only work for (Cartesian or masked) grid lattices (without diagonal adjacencies).\n\nInput:\n\nlrs: The lattice reaction system for which values should be generated.\nmake_edge_p_value: a function describing a rule for generating the edge parameter values.\n\nOutput:     - ep_vals: A sparse matrix of size (numverts,numverts) (where numverts is the number of     vertices in lrs). Here, eps[i,j] is filled only if there is an edge going from vertex i to     vertex j. The value of eps[i,j] is determined by `makeedgepvalue`.\n\nHere, make_edge_p_value should take two arguments, src_vert and dst_vert, which correspond to the grid indices of an edge's source and destination vertices, respectively. It outputs a single value, which is the value assigned to that edge.\n\nExample:     In the following example, we assign the value 0.1 to all edges, except for the one leading from     vertex (1,1) to vertex (1,2), to which we assign the value 1.0.\n\nusing Catalyst\nrn = @reaction_network begin\n    (p,d), 0 <--> X\nend\ntr = @transport_reaction D X\nlattice = CartesianGrid((5,5))\nlrs = LatticeReactionSystem(rn, [tr], lattice)\n\nfunction make_edge_p_value(src_vert, dst_vert)\n    if src_vert == (1,1) && dst_vert == (1,2)\n        return 1.0\n    else\n        return 0.1\n    end\nend\n\nD_vals = make_edge_p_values(lrs, make_edge_p_value)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.make_directed_edge_values","page":"API","title":"Catalyst.make_directed_edge_values","text":"make_directed_edge_values(lrs::LatticeReactionSystem, x_vals::Tuple{T,T}, y_vals::Tuple{T,T} = (undef,undef),\n                 z_vals::Tuple{T,T} = (undef,undef)) where {T}\n\nGenerates edge parameter values for a lattice reaction system. Only work for (Cartesian or masked) grid lattices (without diagonal adjacencies). Each dimension (x, and possibly y and z), and direction has assigned its own constant edge parameter value.\n\nInput:     - lrs: The lattice reaction system for which values should be generated.     - x_vals::Tuple{T,T}: The values in the increasing (from a lower x index to a higher x index)     and decreasing (from a higher x index to a lower x index) direction along the x dimension.     - y_vals::Tuple{T,T}: The values in the increasing and decreasing direction along the y dimension.     Should only be used for 2 and 3-dimensional grids.     - z_vals::Tuple{T,T}: The values in the increasing and decreasing direction along the z dimension.     Should only be used for 3-dimensional grids.\n\nOutput:     - ep_vals: A sparse matrix of size (numverts,numverts) (where numverts is the number of     vertices in lrs). Here, eps[i,j] is filled only if there is an edge going from vertex i to     vertex j. The value of eps[i,j] is determined by the `xvals,yvals, andzvals` Tuples,     and vertices i and j's relative position in the grid.\n\nIt should be noted that two adjacent vertices will always be different in exactly a single dimension (x, y, or z). The corresponding tuple determines which value is assigned.\n\nExample:     In the following example, we wish to have diffusion in the x dimension, but a constant flow from     low y values to high y values (so not transportation from high to low y). We achieve it in the     following manner:\n\nusing Catalyst\nrn = @reaction_network begin\n    (p,d), 0 <--> X\nend\ntr = @transport_reaction D X\nlattice = CartesianGrid((5,5))\nlrs = LatticeReactionSystem(rn, [tr], lattice)\n\nD_vals = make_directed_edge_values(lrs, (0.1, 0.1), (0.1, 0.0))\n\nHere, since we have a 2d grid, we only provide the first two Tuples to make_directed_edge_values.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The following functions can be used to access, or change, species or parameter values stored in problems, integrators, and solutions that are based on LatticeReactionSystems.","category":"page"},{"location":"api/","page":"API","title":"API","text":"lat_getu\nlat_setu!\nlat_getp\nlat_setp!\nrebuild_lat_internals!","category":"page"},{"location":"api/#Catalyst.lat_getu","page":"API","title":"Catalyst.lat_getu","text":"lat_getu(sim_struct, sp, lrs::LatticeReactionSystem)\n\nFor a problem or integrators, retrieves its u values. For non-lattice models, this is can be done through direct interfacing (e.g. prob[X]). However, for LatticeReactionSystem-based problems and integrators, this function must be used instead. The output format depends on the lattice (a dense array for cartesian grid lattices, a sparse array for masked grid lattices, and a vector for graph lattices). This format is similar to which is used to designate species initial conditions.\n\nArguments:\n\nsim_struct: The simulation structure which u value we wish to retrieve. Can be either a ODEProblem, JumpProblem, or an integrator derived from either of these.\nsp: The species which value we wish to update. Can be provided either in its symbolic form (e.g. X) or as a symbol (e.g. :X).\nlrs: The LatticeReactionSystem which was used to generate the structure we wish to modify.\n\nNotes:\n\nEven if the species is spatially uniform, a full array with its values across all vertices will be retrieved.\n\nExample:\n\n# Prepare `LatticeReactionSystem`s.\nusing Catalyst\nrs = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\ntr = @transport_reaction D X1\nlrs = LatticeReactionSystem(rs, [tr], CartesianGrid((2,3)))\n\n# Prepares a corresponding ODEProblem.\nu0 = [:X1 => [1.0 2.0 3.0; 4.0 5.0 6.0], :X2 => 2.0]\ntspan = (0.0, 50.0)\nps = [:k1 => 2.0, :k2 => 1.0, :D => 0.01]\noprob = ODEProblem(lrs, u0, tspan, ps)\n\n# Updates the `ODEProblem`.\nlat_getu(oprob, :X1, lrs) # Retrieves the value of `X1`.\n\n\n\n\n\nlat_getu(sol, sp, lrs::LatticeReactionSystem; t = nothing)\n\nA function for retrieving the solution of a LatticeReactionSystem-based simulation on various desired forms. Generally, for LatticeReactionSystems, the values in sol is ordered in a way which is not directly interpretable by the user. Furthermore, the normal Catalyst interface for solutions (e.g. sol[:X]) does not work for these solutions. Hence this function is used instead.\n\nThe output is a vector, which in each position contains sp's value (either at a time step of time, depending on the input t). Its shape depends on the lattice (using a similar form as heterogeneous initial conditions). I.e. for a NxM cartesian grid, the values are NxM matrices. For a masked grid, the values are sparse matrices. For a graph lattice, the values are vectors (where the value in the n'th position corresponds to sp's value in the n'th vertex).\n\nArguments:\n\nsol: The solution from which we wish to retrieve some values.\nsp: The species which value we wish to update. Can be provided either in its symbolic form (e.g. X) or as a symbol (e.g. :X).\nlrs: The LatticeReactionSystem which was simulated to generate the solution.\nt = nothing: If nothing, we simply return the solution across all saved time steps (default). If t instead is a vector (or range of values), returns the solution interpolated at these time points.\n\nNotes:\n\nThe lat_getu is not optimised for performance. However, it should still be quite performant, but there might be some limitations if called a very large number of times.\nLong-term it is likely that this function gets replaced with a sleeker interface.\n\nExample:\n\nusing Catalyst, OrdinaryDiffEqDefault\n\n# Prepare `LatticeReactionSystem`s.\nrs = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\ntr = @transport_reaction D X1\nlrs = LatticeReactionSystem(rs, [tr], CartesianGrid((2,2)))\n\n# Create problems.\nu0 = [:X1 => 1, :X2 => 2]\ntspan = (0.0, 10.0)\nps = [:k1 => 1, :k2 => 2.0, :D => 0.1]\n\noprob = ODEProblem(lrs1, u0, tspan, ps)\nosol = solve(oprob)\nlat_getu(osol, :X1, lrs) # Returns the value of X1 at each time step.\nlat_getu(osol, :X1, lrs; t = 0.0:10.0) # Returns the value of X1 at times 0.0, 1.0, ..., 10.0\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.lat_setu!","page":"API","title":"Catalyst.lat_setu!","text":"lat_setu!(sim_struct, sp, lrs::LatticeReactionSystem, u)\n\nFor a problem or integrators, update its u vector with the input u. For non-lattice models, this is can be done through direct interfacing (e.g. prob[X] = 1.0). However, for LatticeReactionSystem-based problems and integrators, this function must be used instead.\n\nArguments:\n\nsim_struct: The simulation structure which u value we wish to update. Can be either a ODEProblem, JumpProblem, or an integrator derived from either of these.\nsp: The species which value we wish to update. Can be provided either in its symbolic form (e.g. X) or as a symbol (e.g. :X).\nlrs: The LatticeReactionSystem which was used to generate the structure we wish to modify.\nu: The species's new values. Must be given in a form which is also a valid initial input to the ODEProblem/JumpProblem.\n\nExample:\n\n# Prepare `LatticeReactionSystem`s.\nusing Catalyst\nrs = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\ntr = @transport_reaction D X1\nlrs = LatticeReactionSystem(rs, [tr], CartesianGrid((2,3)))\n\n# Prepares a corresponding ODEProblem.\nu0 = [:X1 => [1.0 2.0 3.0; 4.0 5.0 6.0], :X2 => 2.0]\ntspan = (0.0, 50.0)\nps = [:k1 => 2.0, :k2 => 1.0, :D => 0.01]\noprob = ODEProblem(lrs, u0, tspan, ps)\n\n# Updates the `ODEProblem`.\nlat_setu!(oprob, :X1, lrs, 0.0) # Sets `X1` to uniformly 0 across the lattice.\nlat_setu!(oprob, :X2, lrs, [1.0 0.0 0.0; 0.0 0.0 0.0]) # Sets `X2` to `1.0` in one vertex, and 0 elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.lat_getp","page":"API","title":"Catalyst.lat_getp","text":"lat_getp(sim_struct, p, lrs::LatticeReactionSystem)\n\nFor a problem or integrators, retrieves its p values. For non-lattice models, this is can be done through direct interfacing (e.g. prob[p]). However, for LatticeReactionSystem-based problems and integrators, this function must be used instead. The output format depends on the lattice (a dense array for cartesian grid lattices, a sparse array for masked grid lattices, and a vector for graph lattices). This format is similar to what is used to designate parameter initial values.\n\nArguments:\n\nsim_struct: The simulation structure which p value we wish to retrieve. Can be either a ODEProblem,\n\nJumpProblem, or an integrator derived from either of these.\n\np: The species which value we wish to update. Can be provided either in its symbolic form (e.g. k) or as a symbol (e.g. :k).\nlrs: The LatticeReactionSystem which was used to generate the structure we wish to modify.\n\nNotes:\n\nEven if the parameter is spatially uniform, a full array with its values across all vertices will be retrieved.\n\nExample:\n\n# Prepare `LatticeReactionSystem`s.\nusing Catalyst\nrs = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\ntr = @transport_reaction D X1\nlrs = LatticeReactionSystem(rs, [tr], CartesianGrid((2,3)))\n\n# Prepares a corresponding ODEProblem.\nu0 = [:X1 => 1.0, :X2 => 2.0]\ntspan = (0.0, 50.0)\nps = [:k1 => [1.0 2.0 3.0; 4.0 5.0 6.0], :k2 => 1.0, :D => 0.01]\noprob = ODEProblem(lrs, u0, tspan, ps)\n\n# Updates the `ODEProblem`.\nlat_getp(oprob, :k1, lrs) # Retrieves the value of `k1`.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.lat_setp!","page":"API","title":"Catalyst.lat_setp!","text":"lat_setp!(sim_struct, p, lrs::LatticeReactionSystem, p_val)\n\nFor a problem or integrators, update its p vector with the input p_val. For non-lattice models, this is can be done through direct interfacing (e.g. prob[p] = 1.0). However, for LatticeReactionSystem-based problems and integrators, this function must be used instead.\n\nArguments:\n\nsim_struct: The simulation structure which u value we wish to update. Can be either a ODEProblem, JumpProblem, or an integrator derived from either of these.\np: The species which value we wish to update. Can be provided either in its symbolic form (e.g. k) or as a symbol (e.g. :k).\nlrs: The LatticeReactionSystem which was used to generate the structure we wish to modify.\np_val: The parameter's new values. Must be given in a form which is also a valid initial input to the ODEProblem/JumpProblem.\n\nExample:\n\n# Prepare `LatticeReactionSystem`s.\nusing Catalyst\nrs = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\ntr = @transport_reaction D X1\nlrs = LatticeReactionSystem(rs, [tr], CartesianGrid((2,3)))\n\n# Prepares a corresponding ODEProblem.\nu0 = [:X1 => 1.0, :X2 => 2.0]\ntspan = (0.0, 50.0)\nps = [:k1 => [1.0 2.0 3.0; 4.0 5.0 6.0], :k2 => 1.0, :D => 0.01]\noprob = ODEProblem(lrs, u0, tspan, ps)\n\n# Updates the `ODEProblem`.\nlat_setp!(oprob, :k1, lrs, 0.0) # Sets `k1` to uniformly 0 across the lattice.\nlat_setp!(oprob, :k2, lrs, [1.0 0.0 0.0; 0.0 0.0 0.0]) # Sets `k2` to `1.0` in one vertex, and 0 elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.rebuild_lat_internals!","page":"API","title":"Catalyst.rebuild_lat_internals!","text":"rebuild_lat_internals!(sciml_struct)\n\nRebuilds the internal functions for simulating a LatticeReactionSystem. Whenever a problem or integrator has had its parameter values updated, this function should be called for the update to be taken into account. For ODE simulations, rebuild_lat_internals! needs only to be called when\n\nAn edge parameter has been updated.\nWhen a parameter with spatially homogeneous values has been given spatially heterogeneous values (or vice versa).\n\nArguments:\n\nsciml_struct: The problem (e.g. an ODEProblem) or an integrator which we wish to rebuild.\n\nNotes:\n\nCurrently does not work for DiscreteProblems, JumpProblems, or their integrators.\nThe function is not built with performance in mind, so avoid calling it multiple times in performance-critical applications.\n\nExample:\n\n# Creates an initial `ODEProblem`\nrs = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\ntr = @transport_reaction D X1\ngrid = CartesianGrid((2,2))\nlrs = LatticeReactionSystem(rs, [tr], grid)\n\nu0 = [:X1 => 2, :X2 => [5 6; 7 8]]\ntspan = (0.0, 10.0)\nps = [:k1 => 1.5, :k2 => [1.0 1.5; 2.0 3.5], :D => 0.1]\n\noprob = ODEProblem(lrs, u0, tspan, ps)\n\n# Updates parameter values.\noprob.ps[:ks] = [2.0 2.5; 3.0 4.5]\noprob.ps[:D] = 0.05\n\n# Rebuilds `ODEProblem` to make changes have an effect.\nrebuild_lat_internals!(oprob)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Finally, we provide the following helper functions to plot and animate spatial lattice simulations.","category":"page"},{"location":"api/","page":"API","title":"API","text":"lattice_plot\nlattice_animation\nlattice_kymograph","category":"page"},{"location":"api/#Catalyst.lattice_plot","page":"API","title":"Catalyst.lattice_plot","text":"lattice_plot(sol, sp, lrs::LatticeReactionSystem, filename::String; t = sol.tspan[2], kwargs...)\n\nCreates a plot of a LatticeReactionSystem simulation. The plot is created at the time point specified by t (defaults to the simulation's final time point).\n\nArguments (all lattices):\n\nsol: The simulation we wish to plot.\nsp: The species whose values we wish to plot. Can be provided either in its symbolic form or as a symbol.\nlrs: The LatticeReactionSystem which was simulated.\nt = sol.t[end]: The time point at which we wish to plot the solution\n\nIn addition, depending on the type of lattice used, the following optional arguments might be relevant.\n\nArguments (1d lattices):\n\nmarkersize = 20: The size of the markers marking each compartment's value.\n\nArguments (Graph & 2d lattices):\n\ncolormap = :BuGn_7: The colour map with which we display the species amounts in the animation.\nplot_min = nothing: The minimum value for the colour scale (values less than this will be set at this value when the colour scale is computed). If nothing, use the simulation's minimum value (across the entire simulation, not just at the plotted time value).\nplot_max = nothing: The maximum value for the colour scale (values more than this will be set at this value when the colour scale is computed). If nothing, use the simulation's minimum value (across the entire simulation, not just at the plotted time value).\n\nArguments (Graph lattices):\n\nnode_size = 50: The size of the compartments in the plot.\nlayout = Spring(): The layout for the graph nodes in the plot. Can be provided as a vector, where the i'th element is a 2-valued tuple (determining the i'th compartment's y and x positions, respectively).\n\nNotes: \n\nFor masked lattices, there are no value displayed for grid points which do not correspond to a compartments.\nThe current plotting interface is a work in progress, and modifications are expected. if you have any feedback, please contact the package authors.\nAdditional arguments can be passed to lattice_plot, which then will be passed to Makie's lines plotting command.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.lattice_animation","page":"API","title":"Catalyst.lattice_animation","text":"lattice_animation(sol, sp, lrs::LatticeReactionSystem, filename::String; kwargs...)\n\nCreates an animation of a LatticeReactionSystem simulation. The animation is saved to a file,  whose name is provided in the filename argument.\n\nArguments (all lattices):\n\nsol: The simulation we wish to animate.\nsp: The species which values we wish to animate. Can be provided either in its symbolic form or as a symbol.\nlrs: The LatticeReactionSystem which was simulated.\nfilename: The name of the file to which we wish to save the animation.\nnframes = 200: The number of frames in the animation (these are evenly samples across the simulation).\nframerate = 20: The frame rate of the animation.\nttitle = true: Whether to add a title showing the simulation's time throughout the animation.\n\nIn addition, depending on the type of lattice used, the following optional arguments might be relevant.\n\nArguments (1d lattices):\n\nmarkersize = 20: The size of the markers marking each compartment's value.\nplot_min = nothing: The y-scale's minimum. If nothing, use the simulation's minimum value.\nplot_max = nothing: The y-scale's maximum. If nothing, use the simulation's maximum value.\n\nArguments (Graph & 2d lattices):\n\ncolormap = :BuGn_7: The colour map with which we display the species amounts in the animation.\nplot_min = nothing: The minimum value for the colour scale (values less than this will be set at this value when the colour scale is computed). If nothing, use the simulation's minimum value.\nplot_max = nothing: The maximum value for the colour scale (values more than this will be set at this value when the colour scale is computed). If nothing, use the simulation's minimum value.\n\nArguments (Graph lattices):\n\nnode_size = 50: The size of the compartments in the plot.\nlayout = Spring(): The layout for the graph nodes in the plot. Can be provided as a vector, where the i'th element is a 2-valued tuple (determining the i'th compartment's y and x positions, respectively).\n\nNotes: \n\nFor masked lattices, there are no value displayed for grid points which do not correspond to a compartments.\nThe current animation interface if a work in progress, and modifications are expected. if you have any feedback, please contact the package authors.\nAdditional arguments can be passed to lattice_animation, which then will be passed to Makie's heatmap plotting command.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catalyst.lattice_kymograph","page":"API","title":"Catalyst.lattice_kymograph","text":"lattice_kymograph(sol, sp, lrs::LatticeReactionSystem, kwargs...)\n\nCreates a kymograph of a LatticeReactionSystem simulation based on a Cartesian or masked lattice.  The plot shows the compartments on the y-axis, and the time development of the system's state along the x-axis. Species amounts are shown as a heatmap.\n\nArguments (all lattices):\n\nsol: The simulation we wish to plot.\nsp: The species whose values we wish to plot. Can be provided either in its symbolic form or as a symbol.\nlrs: The LatticeReactionSystem which was simulated.\ncolormap = :BuGn_7: The colour map with which we display the species amounts in the kymograph.\nnframes = 200: The number of time samples which the time series is sampled with.\nplot_min = nothing: The minimum value for the colour scale (values less than this will be set at this value when the colour scale is computed). If nothing, use the simulation's minimum value.\nplot_max = nothing: The maximum value for the colour scale (values more than this will be set at this value when the colour scale is computed). If nothing, use the simulation's minimum value.\n\nNotes: \n\nFor masked lattices, there are no value displayed for grid points which do not correspond to a compartments.\nThe current plotting interface is a work in progress, and modifications are expected. if you have any feedback, please contact the package authors.\nAdditional arguments can be passed to lattice_plot, which then will be passed to Makie's heatmap plotting command.\n\n\n\n\n\n","category":"function"},{"location":"model_simulation/simulation_introduction/#simulation_intro","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Catalyst's core functionality is the creation of chemical reaction network (CRN) models that can be simulated using ODE, SDE, and jump simulations. How such simulations are carried out has already been described in Catalyst's introduction. This page provides a deeper introduction, giving some additional background and introducing various simulation-related options.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Here we will focus on the basics, with other sections of the simulation documentation describing various specialised features, or giving advice on performance. Anyone who plans on using Catalyst's simulation functionality extensively is recommended to also read the documentation on solution plotting, and on how to interact with simulation problems, integrators, and solutions. Anyone with an application for which performance is critical should consider reading the corresponding page on performance advice for ODEs or SDEs.","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_theory","page":"Model Simulation Introduction","title":"Background to CRN simulations","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"This section provides some brief theory on CRN simulations. For details on how to carry out these simulations in actual code, please skip to the following sections.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"CRNs are defined by a set of species (with the amounts of these determining the system's state during simulations) and a set of reaction events (rules for how the state of the system changes). In real systems, the species amounts are discrete copy-numbers, describing the exact numbers of each species type present in the system (in systems biology this can e.g. be the number of a specific molecule present in a cell). Given rates for these reaction events, stochastic chemical kinetics provides a formula for simulating the system that recreates its real reaction process. During stochastic chemical kinetics simulations, the system's state is defined by discrete copy-numbers (denoting the number of each species present in the system). Next, at the occurrence of individual reaction events, the system's state is updated according to the occurred reaction. The result is a stochastic process. The most well-known approach for simulating stochastic chemical kinetics is Gillespie's algorithm.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"In practice, these jump simulations are computationally expensive. In many cases, copy-numbers are so large that they can be approximated as continuous concentrations, and the time-development of the system as a deterministic process. This creates an ordinary differential equation (ODE), and is the chemical reaction network form most people are most familiar with. The rule for how ODEs are generated from CRNs is called the reaction rate equation (RRE).","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Here, the RRE enables fast, approximate, and deterministic simulations of CRNs, while stochastic chemical kinetics enables exact, stochastic, simulations of the true process. An intermediary approach is to use the chemical Langevin equation (CLE) to formulate a stochastic differential equation (SDE). This approximates the system's state as continuous concentrations, but does not assume that its time development is deterministic. Generally, the CLE is used when copy-numbers are large enough that the continuous approximation holds, but not so large that the system's behaviour is deterministic. Generally, the advantage of SDE simulations (compared to jump ones) is that they are faster. Also, since the system state is continuous, interpretation of e.g. stability and steady state results from the deterministic (also continuous) domain is easier for SDEs (however one should be careful when making such interpretations).","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"These three different approaches are summed up in the following table:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n</style>\n<table class=\"tg\">\n<thead>\n  <tr>\n    <th class=\"tg-0pky\">Interpretation</th>\n    <th class=\"tg-0pky\">Reaction rate equation</th>\n    <th class=\"tg-0pky\">Chemical Langevin equation</th>\n    <th class=\"tg-0pky\">Stochastic chemical kinetics</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td class=\"tg-0pky\">Simulation form</td>\n    <td class=\"tg-0pky\">ODE simulations</td>\n    <td class=\"tg-0pky\">SDE simulations</td>\n    <td class=\"tg-0pky\">Jump simulations</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Example simulation methods</td>\n    <td class=\"tg-0pky\"><a href=\"https://en.wikipedia.org/wiki/Euler_method\">Euler</a>, <a href=\"https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods\">Runge-Kutta</a></td>\n    <td class=\"tg-0pky\"><a href=\"https://en.wikipedia.org/wiki/Euler%E2%80%93Maruyama_method\">Euler-Maruyama</a>, <a href=\"https://en.wikipedia.org/wiki/Milstein_method\">Milstein</a></td>\n    <td class=\"tg-0pky\"><a href=\"https://en.wikipedia.org/wiki/Gillespie_algorithm\">Gillespie</a>, <a href=\"https://pubmed.ncbi.nlm.nih.gov/16321569/\">Sorting direct</a></td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Species units</td>\n    <td class=\"tg-0pky\">Concentration</td>\n    <td class=\"tg-0pky\">Concentration</td>\n    <td class=\"tg-0pky\">Copy-numbers</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Deterministic/Stochastic</td>\n    <td class=\"tg-0pky\">Deterministic</td>\n    <td class=\"tg-0pky\">Stochastic</td>\n    <td class=\"tg-0pky\">Stochastic</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Applicability</td>\n    <td class=\"tg-0pky\">Large species amounts</td>\n    <td class=\"tg-0pky\"><span style=\"font-weight:400;font-style:normal\">Non-small species amounts</span></td>\n    <td class=\"tg-0pky\">Any species amounts</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Speed</td>\n    <td class=\"tg-0pky\">Typically fast</td>\n    <td class=\"tg-0pky\">Typically intermediate</td>\n    <td class=\"tg-0pky\">Typically slow</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Simulation package</td>\n    <td class=\"tg-0pky\"><a href=\"https://github.com/SciML/OrdinaryDiffEq.jl\">OrdinaryDiffEq.jl</a></td>\n    <td class=\"tg-0pky\"><a href=\"https://github.com/SciML/StochasticDiffEq.jl\">StochasticDiffEq.jl</a></td>\n    <td class=\"tg-0pky\"><a href=\"https://github.com/SciML/JumpProcesses.jl\">JumpProcesses.jl</a></td>\n  </tr>\n</tbody>\n</table>","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_ODEs","page":"Model Simulation Introduction","title":"Performing (ODE) simulations","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"The following section gives a (more throughout than [previous]) introduction of how to simulate Catalyst models. This is exemplified using ODE simulations (some ODE-specific options will also be discussed). Later on, we will describe things specific to SDE and jump simulations. All ODE simulations are performed using the OrdinaryDiffEq.jl package, which full documentation can be found here. A dedicated section giving advice on how to optimise ODE simulation performance can be found here","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"To perform any simulation, we must first define our model, as well as the simulation's initial conditions, time span, and parameter values. Here we will use a simple two-state model:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using Catalyst\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\nu0 = [:X1 => 100.0, :X2 => 200.0]\ntspan = (0.0, 5.0)\nps = [:k1 => 2.0, :k2 => 5.0]\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"To simulate the model we first bundle these up into an ODEProblem:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"oprob = ODEProblem(two_state_model, u0, tspan, ps)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Next, we can simulate the model (requires loading the OrdinaryDiffEq.jl package). Simulations are performed using the solve function.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using OrdinaryDiffEqDefault\nsol = solve(oprob)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Finally, the result can be plotted using the Plots.jl package's plot function:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using Plots\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"More information on how to interact with solution structures is provided here and on how to plot them here.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Some additional considerations:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"If a model without parameters has been declared, only the first three arguments must be provided to ODEProblem.\nWhile the first value of tspan will almost always be 0.0, other starting times (both negative and positive) are possible.","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_solver_options","page":"Model Simulation Introduction","title":"Designating solvers and solver options","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"While good defaults are generally selected, OrdinaryDiffEq enables the user to customise simulations through a long range of options that can be provided to the solve function. This includes specifying a solver algorithm, which can be provided as a second argument to solve (if none is provided, a suitable choice is automatically made). E.g. here we specify that the Rodas5P method should be used:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using OrdinaryDiffEqRosenbrock\nsol = solve(oprob, Rodas5P())\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"A full list of available solvers is provided here, and a discussion on optimal solver choices here.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Additional options can be provided as keyword arguments. E.g. the maxiters arguments determines the maximum number of simulation time steps (before the simulation is terminated). This defaults to 1e5, but can be modified through:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sol = solve(oprob; maxiters = 1e4)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Here follows a list of solver options which might be of interest to the user.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"adaptive: Toggles adaptive time stepping for valid methods. Default to true.\ndt: For non-adaptive simulations, sets the step size (also sets the initial step size for adaptive methods).\nsaveat: Determines the time points at which the simulation is saved. E.g. for saveat = 2.0 the simulation is saved every second time unit. If not given, the solution is saved after each time step.\nsave_idxs: Provides a vector of species whose values should be saved during the simulation. E.g. for save_idxs = [:X1], only the value of species X1 is saved.\nmaxiters: The maximum number of time steps of the simulation. If this number is reached, the simulation is terminated.\nseed: Sets a seed for stochastic simulations. Stochastic simulations with the same seed generate identical results.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"A full list of solver options can be found here.","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_ODEs_input_forms","page":"Model Simulation Introduction","title":"Alternative problem input forms","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Throughout Catalyst's documentation, we typically provide initial condition and parameter values as vectors. However, these can also be provided as tuples:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"u0 = (:X1 => 100.0, :X2 => 200.0)\ntspan = (0.0, 5.0)\nps = (:k1 => 2.0, :k2 => 5.0)\noprob = ODEProblem(two_state_model, u0, tspan, ps)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"or dictionaries:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"u0 = Dict([:X1 => 100.0, :X2 => 200.0])\ntspan = (0.0, 5.0)\nps = Dict([:k1 => 2.0, :k2 => 5.0])\noprob = ODEProblem(two_state_model, u0, tspan, ps)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"The forms used for u0 and ps does not need to be the same (but can e.g. be a vector and a tuple).","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"note: Note\nIt is possible to designate specific types for parameters. When this is done, the tuple form for providing parameter values should be preferred.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Throughout Catalyst's documentation, we typically provide the time span as a tuple. However, if the first time point is 0.0 (which is typically the case), this can be omitted. Here, we supply only the simulation endpoint to our ODEProblem:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"tend = 5.0\noprob = ODEProblem(two_state_model, u0, tend, ps)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_SDEs","page":"Model Simulation Introduction","title":"Performing SDE simulations","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Catalyst uses the StochasticDiffEq.jl package to perform SDE simulations. This section provides a brief introduction, with StochasticDiffEq's documentation providing a more extensive description. By default, Catalyst generates SDEs from CRN models using the chemical Langevin equation. A dedicated section giving advice on how to optimise SDE simulation performance can be found here.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"SDE simulations are performed in a similar manner to ODE simulations. The only exception is that an SDEProblem is created (rather than an ODEProblem). Furthermore, the StochasticDiffEq.jl package (rather than the OrdinaryDiffEq package) is required for performing simulations. Here we simulate the two-state model for the same parameter set as previously used:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using Catalyst, StochasticDiffEq, Plots\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\nu0 = [:X1 => 100.0, :X2 => 200.0]\ntspan = (0.0, 1.0)\nps = [:k1 => 2.0, :k2 => 5.0]\n\nsprob = SDEProblem(two_state_model, u0, tspan, ps)\nsol = solve(sprob, STrapezoid())\nsol = solve(sprob, STrapezoid(); seed = 123) # hide\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"we can see that while this simulation (unlike the ODE ones) exhibits some fluctuations.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"note: Note\nUnlike for ODE and jump simulations, there are no good heuristics for automatically selecting suitable SDE solvers. Hence, for SDE simulations a solver must be provided. STrapezoid will work for a large number of cases. When this is not the case, however, please check the list of available SDE solvers for a suitable alternative (making sure to select one compatible with non-diagonal noise and the [Ito interpretation]https://en.wikipedia.org/wiki/It%C3%B4_calculus).","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_SDEs_pitfalls","page":"Model Simulation Introduction","title":"Common SDE simulation pitfalls","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Next, let us reduce species amounts (using remake), thereby also increasing the relative amount of noise, we encounter a problem when the model is simulated:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sprob = remake(sprob; u0 = [:X1 => 0.33, :X2 => 0.66])\nsol = solve(sprob, STrapezoid())\nsol = solve(sprob, STrapezoid(); seed = 1234567) # hide\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Here, we receive a warning that the simulation was terminated. next, if we plot the solution:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"plot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"we note that the simulation didn't reach the designated final time point (t = 10). In this case we also note that species concentrations are very low (and sometimes, due to the relatively high amount of noise, even negative). This, combined with the early termination, suggests that we are simulating our model for too low species concentration for the assumptions of the CLE to hold. Instead, jump simulations should be used.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Next, let us consider a simulation for another parameter set:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sprob = remake(sprob; u0 = [:X1 => 100.0, :X2 => 200.0], p = [:k1 => 200.0, :k2 => 500.0])\nsol = solve(sprob, STrapezoid())\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sol = solve(sprob, STrapezoid(); seed = 12345) # hide\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Again, the simulation is aborted. This time, however, species concentrations are relatively large, so the CLE might still hold. What has happened this time is that the accuracy of the simulations has not reached its desired threshold. This can be deal with by reducing simulation tolerances:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sol = solve(sprob, STrapezoid(), abstol = 1e-1, reltol = 1e-1)\nsol = solve(sprob, STrapezoid(); seed = 12345, abstol = 1e-1, reltol = 1e-1) # hide\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_SDEs_fixed_dt","page":"Model Simulation Introduction","title":"SDE simulations with fixed time stepping","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"StochasticDiffEq implements SDE solvers with adaptive time stepping. However, when using a non-adaptive solver (or using the adaptive = false argument to turn adaptive time stepping off for an adaptive solver) a fixed time step dt must be designated. Here we simulate the same SDEProblem which we struggled with previously, but using the non-adaptive EM solver and a fixed dt:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sol = solve(sprob, EM(); dt = 0.001)\nsol = solve(sprob, EM(); dt = 0.001, seed = 1234567) # hide\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"We note that this approach also enables us to successfully simulate the SDE we previously struggled with.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Generally, using a smaller fixed dt provides a more exact simulation, but also increases simulation runtime.","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_SDEs_noise_saling","page":"Model Simulation Introduction","title":"Scaling the noise in the chemical Langevin equation","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"When using the CLE to generate SDEs from a CRN, it can sometimes be desirable to scale the magnitude of the noise. This can be done by introducing a noise scaling term, with each noise term generated by the CLE being multiplied with this term. A noise scaling term can be set using the @default_noise_scaling option:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"two_state_model = @reaction_network begin\n    @default_noise_scaling 0.1\n    (k1,k2), X1 <--> X2\nend\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Here, we set the noise scaling term to 0.1, reducing the noise with a factor 10 (noise scaling terms 10 increase the noise, while terms 10 reduce the noise). If we re-simulate the model using the low-concentration settings used previously, we see that the noise has been reduced (in fact by so much that the model can now be simulated without issues):","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"u0 = [:X1 => 100.0, :X2 => 200.0]\ntspan = (0.0, 1.0)\nps = [:k1 => 200.0, :k2 => 500.0]\nsprob = SDEProblem(two_state_model, u0, tspan, ps)\nsol = solve(sprob, STrapezoid())\nsol = solve(sprob, STrapezoid(); seed = 123) # hide\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"The @default_noise_scaling option can take any expression. This can be used to e.g. designate a noise scaling parameter:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"two_state_model = @reaction_network begin\n    @parameters η\n    @default_noise_scaling η\n    (k1,k2), X1 <--> X2\nend\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Now we can tune the noise through η's value. E.g. here we remove the noise entirely by setting η = 00 (thereby recreating an ODE simulation's behaviour):","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"u0 = [:X1 => 0.33, :X2 => 0.66, :η => 0.0]\ntspan = (0.0, 1.0)\nps = [:k1 => 2.0, :k2 => 5.0]\nsprob = SDEProblem(two_state_model, u0, tspan, ps)\nsol = solve(sprob, STrapezoid())\nsol = solve(sprob, STrapezoid(); seed = 123) # hide\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"note: Note\nAbove, Catalyst is unable to infer that η is a parameter from the @default_noise_scaling η option only. Hence, @parameters η is used to explicitly declare η to be a parameter (as discussed in more detail here).","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"It is possible to designate specific noise scaling terms for individual reactions through the noise_scaling reaction metadata. Here, CLE noise terms associated with a specific reaction are multiplied by that reaction's noise scaling term. Here we use this to turn off the noise in the X1 to X2 reaction:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"two_state_model = @reaction_network begin\n    k1, X1 --> X2, [noise_scaling = 0.0]\n    k2, X2 --> X1\nend\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"If the @default_noise_scaling option is used, that term is only applied to reactions without noise_scaling metadata.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"While the @default_noise_scaling option is unavailable for programmatically created models, the set_default_noise_scaling function can be used to achieve a similar effect.","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_jumps","page":"Model Simulation Introduction","title":"Performing jump simulations using stochastic chemical kinetics","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Catalyst uses the JumpProcesses.jl package to perform jump simulations. This section provides a brief introduction, with JumpProcesses's documentation providing a more extensive description.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Jump simulations are performed using so-called JumpProblems. Unlike ODEs and SDEs (for which the corresponding problem types can be created directly), jump simulations require first processing inputs into a correct format creating an intermediary JumpInputs. In this example, we first declare our two-state model and its initial conditions, time span, and parameter values.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using Catalyst, JumpProcesses, Plots\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\nu0 = [:X1 => 5, :X2 => 10]\ntspan = (0.0, 5.0)\nps = [:k1 => 2.0, :k2 => 5.0]\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"note: Note\nSince jump simulations typically simulate the integer copy-numbers of each species present in the system, we designate our initial conditions for jump simulations as integers. Decimal-numbered initial conditions (and thus jump simulations) are, however, also possible. While ODE and SDE simulations accept integer initial conditions, these will be converted to decimal numbers.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Next, we process these into a JumpInputs:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"jinput = JumpInputs(two_state_model, u0, tspan, ps)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"This is then used as input to a JumpProblem:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"jprob = JumpProblem(jinput)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"The JumpProblem can now be simulated using solve (just like any other problem type).","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"sol = solve(jprob)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"If we plot the solution we can see how the system's state does not change continuously, but instead in discrete jumps (due to the occurrence of the individual reactions of the system).","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using Plots\nplot(sol)","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_jumps_solver_designation","page":"Model Simulation Introduction","title":"Designating aggregators and simulation methods for jump simulations","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Jump simulations (just like ODEs and SDEs) are performed using stochastic simulation algorithms (SSAs) to generate exact samples of the underlying jump process. In JumpProcesses.jl and Catalyst, we call SSAs aggregators. These methods determine the time until, and type of, the next reaction in a system. A separate time-stepping method is then used to actually step from one reaction instance to the next.","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Several different aggregators are available (a full list is provided here). To designate a specific one, provide it as the second argument to the JumpProblem. E.g. to designate that the sorting direct method (SortingDirect) should be used, use:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"jprob = JumpProblem(jinput, SortingDirect())\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"Especially for large systems, the choice of aggregator can dramatically impact simulation performance.","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_jumps_variableratejumps","page":"Model Simulation Introduction","title":"Jump simulations where some rate depends on time","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"For some models, the rate terms of reactions may explicitly depend on time. E.g. consider the following circadian clock (inspired) model, where the production rate of some protein (P) depends on a sinusoid function:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"circadian_model = @reaction_network begin\n    A*(sin(2π*f*t - ϕ)+1)/2, 0 --> P\n    d, P --> 0\nend","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"This type of model will generate so called variable rate jumps (VariableRateJumps in JumpProcesses.jl). Such models can be simulated in Catalyst too, but note that now a method for time-stepping the solver must be provided to solve. Here ODE solvers should be given as they are used to handle integrating the explicitly time-dependent propensities for problems with variable rates, i.e. the proceeding example can be solved like","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"using OrdinaryDiffEqTsit5\nu0map = [:P => 0]\npmap = [:f => 1.0, :A => 2.0, :ϕ => 0.0, :d => 1.0]\ntspan = (0.0, 24.0)\njinputs = JumpInputs(circadian_model, u0map, tspan, pmap)\njprob = JumpProblem(jinputs)\nsol = solve(jprob, Tsit5())  # use the Tsit5 ODE solver to time-step\nplot(sol; idxs = :P, lw = 2)","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"","category":"page"},{"location":"model_simulation/simulation_introduction/#simulation_intro_citation","page":"Model Simulation Introduction","title":"Citation","text":"","category":"section"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"When you simulate Catalyst models in your research, please cite the corresponding paper(s) to support the simulation package authors. For ODE simulations:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"@article{DifferentialEquations.jl-2017,\n author = {Rackauckas, Christopher and Nie, Qing},\n doi = {10.5334/jors.151},\n journal = {The Journal of Open Research Software},\n keywords = {Applied Mathematics},\n note = {Exported from https://app.dimensions.ai on 2019/05/05},\n number = {1},\n pages = {},\n title = {DifferentialEquations.jl – A Performant and Feature-Rich Ecosystem for Solving Differential Equations in Julia},\n url = {https://app.dimensions.ai/details/publication/pub.1085583166 and http://openresearchsoftware.metajnl.com/articles/10.5334/jors.151/galley/245/download/},\n volume = {5},\n year = {2017}\n}","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"For SDE simulations:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"@article{rackauckas2017adaptive,\n  title={Adaptive methods for stochastic differential equations via natural embeddings and rejection sampling with memory},\n  author={Rackauckas, Christopher and Nie, Qing},\n  journal={Discrete and continuous dynamical systems. Series B},\n  volume={22},\n  number={7},\n  pages={2731},\n  year={2017},\n  publisher={NIH Public Access}\n}","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"For jump simulations:","category":"page"},{"location":"model_simulation/simulation_introduction/","page":"Model Simulation Introduction","title":"Model Simulation Introduction","text":"@misc{2022JumpProcesses,\n  author       = {Isaacson, S. A. and Ilin, V. and Rackauckas, C. V.},\n  title        = {{JumpProcesses.jl}},\n  howpublished = {\\url{https://github.com/SciML/JumpProcesses.jl/}},\n  year         = {2022}\n}\n@misc{zagatti_extending_2023,\n\ttitle = {Extending {JumpProcess}.jl for fast point process simulation with time-varying intensities},\n\turl = {http://arxiv.org/abs/2306.06992},\n\tdoi = {10.48550/arXiv.2306.06992},\n\tpublisher = {arXiv},\n\tauthor = {Zagatti, Guilherme Augusto and Isaacson, Samuel A. and Rackauckas, Christopher and Ilin, Vasily and Ng, See-Kiong and Bressan, Stéphane},\n\tyear = {2023},\n}","category":"page"},{"location":"model_creation/examples/basic_CRN_library/#basic_CRN_library","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"","category":"section"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"Below we will present various simple and established chemical reaction network (CRN) models. Each model is given some brief background, implemented using the @reaction_network DSL, and basic simulations are performed.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/#basic_CRN_library_bd","page":"Library of Basic Chemical Reaction Network Models","title":"Birth-death process","text":"","category":"section"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"The birth-death process is one of the simplest possible CRN models. It consists of a single component (X) which is both produced and degraded at linear rates:","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using Catalyst\nbd_process = @reaction_network begin\n    (p,d), ∅ <--> X\nend","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"Next, we define simulation conditions. Note that the initial condition is integer-valued (more natural than decimal numbers for jump simulations).","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"u0 = [:X => 1]\ntspan = (0.0, 10.0)\nps = [:p => 1.0, :d => 0.2]\nnothing # hide","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"We can now simulate our model using all three interpretations. First, we perform a reaction rate equation-based ODE simulation:","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using OrdinaryDiffEqDefault\noprob = ODEProblem(bd_process, u0, tspan, ps)\nosol = solve(oprob)\nnothing # hide","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"Next, a chemical Langevin equation-based SDE simulation:","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using StochasticDiffEq\nsprob = SDEProblem(bd_process, u0, tspan, ps)\nssol = solve(sprob, STrapezoid())\nssol = solve(sprob, STrapezoid(); seed = 12) # hide\nnothing # hide","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"Next, a stochastic chemical kinetics-based jump simulation:","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using JumpProcesses\njinput = JumpInputs(bd_process, u0, tspan, ps)\njprob = JumpProblem(jinput)\njsol = solve(jprob)\njsol = solve(jprob; seed = 12) # hide\nnothing # hide","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"Finally, we plot the results:","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using Plots\noplt = plot(osol; title = \"Reaction rate equation (ODE)\")\nsplt = plot(ssol; title = \"Chemical Langevin equation (SDE)\")\njplt = plot(jsol; title = \"Stochastic chemical kinetics (Jump)\")\nplot(oplt, splt, jplt; lw = 3, size=(800,700), layout = (3,1))","category":"page"},{"location":"model_creation/examples/basic_CRN_library/#basic_CRN_library_two_states","page":"Library of Basic Chemical Reaction Network Models","title":"Two-state model","text":"","category":"section"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"The two-state model describes a component (here called X) which can exist in two different forms (here called X₁ and X₂). It switches between these forms at linear rates. First, we simulate the model using both ODEs and SDEs:","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using Catalyst, OrdinaryDiffEqDefault, StochasticDiffEq, Plots\ntwo_state_model = @reaction_network begin\n    (k₁,k₂), X₁ <--> X₂\nend\n\nu0 = [:X₁ => 50.0, :X₂ => 50.0]\ntspan = (0.0, 1.0)\nps = [:k₁ => 2.0, :k₂ => 3.0]\n\noprob = ODEProblem(two_state_model, u0, tspan, ps)\nosol = solve(oprob)\noplt = plot(osol; title = \"Reaction rate equation (ODE)\")\n\nsprob = SDEProblem(two_state_model, u0, tspan, ps)\nssol = solve(sprob, STrapezoid())\nssol = solve(sprob, STrapezoid(); seed = 12) # hide\nsplt = plot(ssol; title = \"Chemical Langevin equation (SDE)\")\n\nplot(oplt, splt; lw = 3, size = (800,550), layout = (2,1))","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"What is interesting about this model is that it has a conserved quantity, where X₁ + X₂ remains constant throughout the simulation (both in deterministic and stochastic cases). We can show this by instead plotting this conserved quantity.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"@unpack X₁, X₂ = two_state_model\noplt = plot(osol; idxs = X₁ + X₂, title = \"Reaction rate equation (ODE)\")\nsplt = plot(ssol; idxs = X₁ + X₂, title = \"Chemical Langevin equation (SDE)\")\nplot(oplt, splt; lw = 3, ylimit = (99,101), size = (800,450), layout = (2,1))","category":"page"},{"location":"model_creation/examples/basic_CRN_library/#basic_CRN_library_mm","page":"Library of Basic Chemical Reaction Network Models","title":"Michaelis-Menten enzyme kinetics","text":"","category":"section"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"Michaelis-Menten enzyme kinetics is a simple description of an enzyme (E) transforming a substrate (S) into a product (P). Under certain assumptions, it can be simplified to a single function (a Michaelis-Menten function) and used as a reaction rate. Here we instead present the full system model:","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using Catalyst\nmm_system = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"Next, we perform ODE, SDE, and jump simulations of the model:","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"u0 = [:S => 301, :E => 100, :SE => 0, :P => 0]\ntspan = (0., 100.)\nps = [:kB => 0.00166, :kD => 0.0001, :kP => 0.1]\n\nusing OrdinaryDiffEqDefault\noprob = ODEProblem(mm_system, u0, tspan, ps)\nosol  = solve(oprob)\n\nusing StochasticDiffEq\nsprob = SDEProblem(mm_system, u0, tspan, ps)\nssol = solve(sprob, STrapezoid())\nssol = solve(sprob, STrapezoid(); seed = 12) # hide\n\nusing JumpProcesses\njinput = JumpInputs(mm_system, u0, tspan, ps)\njprob = JumpProblem(jinput)\njsol = solve(jprob)\njsol = solve(jprob; seed = 12) # hide\n\nusing Plots\noplt = plot(osol; title = \"Reaction rate equation (ODE)\")\nsplt = plot(ssol; title = \"Chemical Langevin equation (SDE)\")\njplt = plot(jsol; title = \"Stochastic chemical kinetics (Jump)\")\nplot(oplt, splt, jplt; lw = 2, size=(800,800), layout = (3,1))\nfullplt = plot(oplt, splt, jplt; lw = 2, size=(800,800), layout = (3,1), fmt = :png,\n    dpi = 200, bottom_margin = 3Plots.Measures.mm) # hide\nCatalyst.PNG(fullplt) # hide","category":"page"},{"location":"model_creation/examples/basic_CRN_library/#basic_CRN_library_sir","page":"Library of Basic Chemical Reaction Network Models","title":"SIR infection model","text":"","category":"section"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"The SIR model is the simplest model of the spread of an infectious disease. While the real system is very different from the chemical and cellular processes typically modelled with CRNs, it (and several other epidemiological systems) can be modelled using the same CRN formalism. The SIR model consists of three species: susceptible (S), infected (I), and removed (R) individuals, and two reaction events: infection and recovery.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using Catalyst\nsir_model = @reaction_network begin\n    α, S + I --> 2I\n    β, I --> R\nend","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"First, we perform a deterministic ODE simulation:","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using OrdinaryDiffEqDefault, Plots\nu0 = [:S => 99, :I => 1, :R => 0]\ntspan = (0.0, 500.0)\nps = [:α => 0.001, :β => 0.01]\n\n# Solve ODEs.\noprob = ODEProblem(sir_model, u0, tspan, ps)\nosol = solve(oprob)\nplot(osol; title = \"Reaction rate equation (ODE)\", size=(800,350))","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"Next, we perform 3 different Jump simulations. Note that for the stochastic model, the occurrence of an outbreak is not certain. Rather, there is a possibility that it fizzles out without a noteworthy peak.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using JumpProcesses\njinput = JumpInputs(sir_model, u0, tspan, ps)\njprob = JumpProblem(jinput)\n\njsol1 = solve(jprob)\njsol2 = solve(jprob)\njsol3 = solve(jprob)\njsol1 = solve(jprob, seed = 1) # hide\njsol2 = solve(jprob, seed = 2) # hide\njsol3 = solve(jprob, seed = 3) # hide\n\njplt1 = plot(jsol1; title = \"Outbreak\")\njplt2 = plot(jsol2; title = \"Outbreak\")\njplt3 = plot(jsol3; title = \"No outbreak\")\nplot(jplt1, jplt2, jplt3; lw = 3, size=(800,700), layout = (3,1))\nfullplt = plot(jplt1, jplt2, jplt3; lw = 3, size=(800,700), layout = (3,1), fmt = :png, dpi = 200) # hide\nCatalyst.PNG(fullplt) # hide","category":"page"},{"location":"model_creation/examples/basic_CRN_library/#basic_CRN_library_cc","page":"Library of Basic Chemical Reaction Network Models","title":"Chemical cross-coupling","text":"","category":"section"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"In chemistry, cross-coupling is when a catalyst combines two substrates to form a product. In this example, the catalyst (C) first binds one substrate (S₁) to form an intermediary complex (S₁C). Next, the complex binds the second substrate (S₂) to form another complex (CP). Finally, the catalyst releases the now-formed product (P). This system is an extended version of the Michaelis-Menten system presented earlier.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using Catalyst\ncc_system = @reaction_network begin\n    k₁, S₁ + C --> S₁C\n    k₂, S₁C + S₂ --> CP\n    k₃, CP --> C + P\nend","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"Below, we perform a simple deterministic ODE simulation of the system. Next, we plot both:","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"The concentration of the substrates and the product.\nThe concentration of the catalyst and the intermediaries.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"In two separate plots.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using OrdinaryDiffEqDefault, Plots\nu0 = [:S₁ => 1.0, :C => 0.05, :S₂ => 1.2, :S₁C => 0.0, :CP => 0.0, :P => 0.0]\ntspan = (0., 15.)\nps = [:k₁ => 5.0, :k₂ => 5.0, :k₃ => 100.0]\n\n# solve ODEs\noprob = ODEProblem(cc_system, u0, tspan, ps)\nosol  = solve(oprob)\n\nplt1 = plot(osol; idxs = [:S₁, :S₂, :P], title = \"Substrate and product dynamics\")\nplt2 = plot(osol; idxs = [:C, :S₁C, :CP], title = \"Catalyst and intermediaries dynamics\")\nplot(plt1, plt2; lw = 3, size = (800,600), layout = (2,1))","category":"page"},{"location":"model_creation/examples/basic_CRN_library/#basic_CRN_library_wilhelm","page":"Library of Basic Chemical Reaction Network Models","title":"The Wilhelm model","text":"","category":"section"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"The Wilhelm model was introduced in Wilhelm (2009) as the smallest CRN model (with constant rates) that exhibits bistability.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using Catalyst\nwilhelm_model = @reaction_network begin\n    k1, Y --> 2X\n    k2, 2X --> X + Y\n    k3, X + Y --> Y\n    k4, X --> 0\nend","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"We can simulate the model for two different initial conditions, demonstrating the existence of two different stable steady states.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using OrdinaryDiffEqDefault, Plots\nu0_1 = [:X => 1.5, :Y => 0.5]\nu0_2 = [:X => 2.5, :Y => 0.5]\ntspan = (0., 10.)\nps = [:k1 => 8.0, :k2 => 2.0, :k3 => 1.0, :k4 => 1.5]\n\noprob1 = ODEProblem(wilhelm_model, u0_1, tspan, ps)\noprob2 = ODEProblem(wilhelm_model, u0_2, tspan, ps)\nosol1 = solve(oprob1)\nosol2 = solve(oprob2)\nplot(osol1; lw = 4, idxs = :X, label = \"X(0) = 1.5\")\nplot!(osol2; lw = 4, idxs = :X, label = \"X(0) = 2.5\", yguide = \"X\", size = (800,350))\nplot!(bottom_margin = 3Plots.Measures.mm) # hide","category":"page"},{"location":"model_creation/examples/basic_CRN_library/#basic_CRN_library_self_activation","page":"Library of Basic Chemical Reaction Network Models","title":"Simple self-activation loop","text":"","category":"section"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"The simplest self-activation loop consists of a single species (here called X) which activates its own production. If its production rate is modelled as a Hill function with n1, the system may exhibit bistability.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using Catalyst\nsa_loop = @reaction_network begin\n    v₀ + hill(X,v,K,n), ∅ --> X\n    d, X --> ∅\nend","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"A simple example of such a loop is a transcription factor which activates its own gene. Here, v₀ represents a basic transcription rate (leakage) in the absence of the transcription factor.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"We simulate the self-activation loop from a single initial condition using both deterministic (ODE) and stochastic (jump) simulations. We note that while the deterministic simulation reaches a single steady state, the stochastic one switches between two different states.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using JumpProcesses, OrdinaryDiffEqDefault, Plots\nu0 = [:X => 4]\ntspan = (0.0, 1000.0)\nps = [:v₀ => 0.1, :v => 2.0, :K => 10.0, :n => 2, :d => 0.1]\n\noprob = ODEProblem(sa_loop, u0, tspan, ps)\nosol = solve(oprob)\n\njinput = JumpInputs(sa_loop, u0, tspan, ps)\njprob = JumpProblem(jinput)\njsol = solve(jprob)\njsol = solve(jprob, seed = 12) # hide\n\nfplt = plot(osol; lw = 3, label = \"Reaction rate equation (ODE)\")\nplot!(fplt, jsol; lw = 3, label = \"Stochastic chemical kinetics (Jump)\", yguide = \"X\", size = (800,350))\nplot!(fplt, bottom_margin = 3Plots.Measures.mm, left_margin=3Plots.Measures.mm) # hide\nplot!(fplt; fmt = :png, dpi = 200) # hide\nCatalyst.PNG(fplt) # hide","category":"page"},{"location":"model_creation/examples/basic_CRN_library/#basic_CRN_library_brusselator","page":"Library of Basic Chemical Reaction Network Models","title":"The Brusselator","text":"","category":"section"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"The Brusselator is a well-known (theoretical) CRN model able to produce oscillations (its name is a portmanteau of \"Brussels\" and \"oscillator\").","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using Catalyst\nbrusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"It is generally known to (for reaction rate equation-based ODE simulations) produce oscillations when B  1 + A^2. However, this result is based on models generated when combinatorial adjustment of rates is not performed. Since Catalyst automatically perform these adjustments, and one reaction contains a stoichiometric constant 1, the threshold will be different. Here, we trial two different values of B. In both cases, B  1 + A^2, however, in the second case the system can generate oscillations.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using OrdinaryDiffEqDefault, Plots\nu0 = [:X => 1.0, :Y => 1.0]\ntspan = (0., 50.)\nps1 = [:A => 1.0, :B => 1.0]\nps2 = [:A => 1.0, :B => 1.8]\n\noprob1 = ODEProblem(brusselator, u0, tspan, ps1)\noprob2 = ODEProblem(brusselator, u0, tspan, ps2)\nosol1  = solve(oprob1)\nosol2  = solve(oprob2)\noplt1 = plot(osol1; title = \"No Oscillation\")\noplt2 = plot(osol2; title = \"Oscillation\")\n\nplot(oplt1, oplt2; lw = 3, size = (800,600), layout = (2,1))","category":"page"},{"location":"model_creation/examples/basic_CRN_library/#basic_CRN_library_repressilator","page":"Library of Basic Chemical Reaction Network Models","title":"The Repressilator","text":"","category":"section"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"The Repressilator was introduced in Elowitz & Leibler (2000) as a simple system that can generate oscillations (most notably, they demonstrated this both in a model and in a synthetic in vivo implementation in Escherichia col). It consists of three genes, repressing each other in a cycle. Here, we will implement it using three species (X, Y, and Z) whose production rates are (repressing) Hill functions.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using Catalyst\nrepressilator = @reaction_network begin\n    hillr(Z,v,K,n), ∅ --> X\n    hillr(X,v,K,n), ∅ --> Y\n    hillr(Y,v,K,n), ∅ --> Z\n    d, (X, Y, Z) --> ∅\nend","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"Whether the Repressilator oscillates or not depends on its parameter values. Here, we will perform deterministic (ODE) simulations for two different values of K, showing that it oscillates for one value and not the other one. Next, we will perform stochastic (SDE) simulations for both K values, showing that the stochastic model can sustain oscillations in both cases. This is an example of the phenomena of noise-induced oscillation.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using OrdinaryDiffEqDefault, StochasticDiffEq, Plots\nu0 = [:X => 50.0, :Y => 15.0, :Z => 15.0]\ntspan = (0., 200.)\nps1 = [:v => 10.0, :K => 20.0, :n => 3, :d => 0.1]\nps2 = [:v => 10.0, :K => 50.0, :n => 3, :d => 0.1]\n\noprob1 = ODEProblem(repressilator, u0, tspan, ps1)\noprob2 = ODEProblem(repressilator, u0, tspan, ps2)\nosol1  = solve(oprob1)\nosol2  = solve(oprob2)\noplt1 = plot(osol1; title = \"Oscillation (ODE, K = 20)\")\noplt2 = plot(osol2; title = \"No oscillation (ODE, K = 50)\")\n\nsprob1 = SDEProblem(repressilator, u0, tspan, ps1)\nsprob2 = SDEProblem(repressilator, u0, tspan, ps2)\nssol1  = solve(sprob1, STrapezoid())\nssol2  = solve(sprob2, STrapezoid())\nssol1  = solve(sprob1, STrapezoid(); seed = 1) # hide\nssol2  = solve(sprob2, STrapezoid(); seed = 100) # hide\nsplt1 = plot(ssol1; title = \"Oscillation (SDE, K = 20)\")\nsplt2 = plot(ssol2; title = \"Oscillation (SDE, K = 50)\")\n\nplot(oplt1, oplt2, splt1, splt2; lw = 2, layout = (2,2), size = (800,600))","category":"page"},{"location":"model_creation/examples/basic_CRN_library/#basic_CRN_library_wr","page":"Library of Basic Chemical Reaction Network Models","title":"The Willamowski–Rössler model","text":"","category":"section"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"The Willamowski–Rössler model was introduced in Willamowski & Rössler (1979) as an example of a simple CRN model which exhibits chaotic behaviours. This means that small changes in initial conditions can produce relatively large changes in the system's trajectory.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using Catalyst\nwr_model = @reaction_network begin\n    k1, 2X --> 3X\n    k2, X --> 2X\n    k3, Z + 2X --> 2Z\n    k4, Y + X --> 2Y\n    k5, Y --> ∅\n    k6, 2Z --> ∅\n    k7, Z --> ∅\nend","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"Here we simulate the model for a single initial condition, showing both time-state space and phase space how it reaches a strange attractor.","category":"page"},{"location":"model_creation/examples/basic_CRN_library/","page":"Library of Basic Chemical Reaction Network Models","title":"Library of Basic Chemical Reaction Network Models","text":"using OrdinaryDiffEqDefault, Plots\nu0 = [:X => 1.5, :Y => 1.5, :Z => 1.5]\ntspan = (0.0, 50.0)\np = [:k1 => 2.1, :k2 => 0.7, :k3 => 2.9, :k4 => 1.1, :k5 => 1.0, :k6 => 0.5, :k7 => 2.7]\noprob = ODEProblem(wr_model, u0, tspan, p)\nsol = solve(oprob)\n\nplt1 = plot(sol; title = \"Time-state space\")\nplt2 = plot(sol; idxs = (:X, :Y, :Z), title = \"Phase space\")\nplot(plt1, plt2; layout = (1,2), size = (800,400))\nplot!(bottom_margin = 3Plots.Measures.mm) # hide","category":"page"},{"location":"faqs/#FAQs","page":"FAQs","title":"FAQs","text":"","category":"section"},{"location":"faqs/#How-to-index-solution-objects-using-symbolic-variables-and-observables?","page":"FAQs","title":"How to index solution objects using symbolic variables and observables?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"One can directly use symbolic variables to index into SciML solution objects. Moreover, observables can also be evaluated in this way. For example, consider the system","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst, OrdinaryDiffEqTsit5, Plots\nrn = @reaction_network ABtoC begin\n  (k₊,k₋), A + B <--> C\nend\nnothing    # hide","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Let's convert it to a system of ODEs, using the conservation laws of the system to eliminate two of the species:","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"osys = convert(ODESystem, rn; remove_conserved = true)\nosys = complete(osys)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Notice the resulting ODE system has just one ODE, while algebraic observables have been added for the two removed species (in terms of the conservation law constants, Γ[1] and Γ[2])","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"observed(osys)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Let's solve the system and see how to index the solution using our symbolic variables","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"u0 = [osys.A => 1.0, osys.B => 2.0, osys.C => 0.0]\nps = [osys.k₊ => 1.0, osys.k₋ => 1.0]\noprob = ODEProblem(osys, u0, (0.0, 10.0), ps)\nsol = solve(oprob, Tsit5())","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Suppose we want to plot just species C, without having to know its integer index in the unknown vector. We can do this using the symbolic variable C, which we can get at in several ways","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"sol[osys.C]","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"or","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"@unpack C = osys\nsol[C]","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"To evaluate C at specific times and plot it we can just do","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"t = range(0.0, 10.0, length = 101)\nplot(sol(t, idxs = C), label = \"C(t)\", xlabel = \"t\")","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"If we want to get multiple variables we can just do","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"@unpack A, B = osys\nsol(t, idxs = [A, B])","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Plotting multiple variables using the SciML plot recipe can be achieved like","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"plot(sol; idxs = [A, B])","category":"page"},{"location":"faqs/#faq_combinatoric_ratelaws","page":"FAQs","title":"How to disable rescaling of reaction rates in rate laws?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"As explained in the Reaction rate laws used in simulations section, for a reaction such as k, 2X --> 0, the generated rate law will rescale the rate constant, giving k*X^2/2 instead of k*X^2 for ODEs and k*X*(X-1)/2 instead of k*X*(X-1) for jumps. This can be disabled when directly converting a ReactionSystem. If rn is a generated ReactionSystem, we can do","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"osys = convert(ODESystem, rn; combinatoric_ratelaws=false)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Disabling these rescalings should work for all conversions of ReactionSystems to other ModelingToolkit.AbstractSystems.","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"When creating a ReactionSystem using the DSL, combinatoric rate laws can be disabled (for  the created system, and all systems derived from it) using the @combinatoric_ratelaws option (providing false as its only input):","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"rn = @reaction_network begin\n    @combinatoric_ratelaws false\n    k, 2X --> 0\nend\nnothing # hide","category":"page"},{"location":"faqs/#How-to-use-non-integer-stoichiometric-coefficients?","page":"FAQs","title":"How to use non-integer stoichiometric coefficients?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst\nrn = @reaction_network begin\n  k, 2.5*A --> 3*B\nend","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"or directly via","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"t = default_t()\n@parameters k b\n@species A(t) B(t) C(t) D(t)\nrx1 = Reaction(k,[B,C],[B,D], [2.5,1],[3.5, 2.5])\nrx2 = Reaction(2*k, [B], [D], [1], [2.5])\nrx3 = Reaction(2*k, [B], [D], [2.5], [2])\n@named mixedsys = ReactionSystem([rx1, rx2, rx3], t, [A, B, C, D], [k, b])\nmixedsys = complete(mixedsys)\nosys = convert(ODESystem, mixedsys; combinatoric_ratelaws = false)\nosys = complete(osys)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Note, when using convert(ODESystem, mixedsys; combinatoric_ratelaws=false) the combinatoric_ratelaws=false parameter must be passed. This is also true when calling ODEProblem(mixedsys,...; combinatoric_ratelaws=false). As described above, this disables Catalyst's standard rescaling of reaction rates when generating reaction rate laws, see also the Reaction rate laws used in simulations section. Leaving this keyword out for systems with floating point stoichiometry will give an error message.","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"For a more extensive documentation of using non-integer stoichiometric coefficients, please see the Symbolic Stochiometries section.","category":"page"},{"location":"faqs/#How-to-set-default-values-for-initial-conditions-and-parameters?","page":"FAQs","title":"How to set default values for initial conditions and parameters?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"How to set defaults when using the @reaction_network macro is described in more detail here. There are several ways to do this. Using the DSL, one can use the @species and @parameters options:","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst\nsir = @reaction_network sir begin\n    @species S(t)=999.0 I(t)=1.0 R(t)=0.0\n    @parameters β=1e-4 ν=0.01\n    β, S + I --> 2I\n    ν, I --> R\nend\nshow(stdout, MIME\"text/plain\"(), sir) # hide","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"When directly constructing a ReactionSystem, we can set the symbolic values to have the desired default values, and this will automatically be propagated through to the equation solvers:","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst, Plots, OrdinaryDiffEqTsit5\nt = default_t()\n@parameters β=1e-4 ν=.01\n@species S(t)=999.0 I(t)=1.0 R(t)=0.0\nrx1 = Reaction(β, [S, I], [I], [1,1], [2])\nrx2 = Reaction(ν, [I], [R])\n@named sir = ReactionSystem([rx1, rx2], t)\nsir = complete(sir)\noprob = ODEProblem(sir, [], (0.0, 250.0))\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"One can also build a mapping from symbolic parameter/species to value/initial condition and pass these to the ReactionSystem via the defaults keyword argument:","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"@parameters β ν\n@species S(t) I(t) R(t)\nrx1 = Reaction(β, [S,I], [I], [1,1], [2])\nrx2 = Reaction(ν, [I], [R])\ndefs = [β => 1e-4, ν => .01, S => 999.0, I => 1.0, R => 0.0]\n@named sir = ReactionSystem([rx1, rx2], t; defaults = defs)\nnothing # hide","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Finally, default values can also be added after creating the system via the setdefaults! command and passing a Symbol based mapping, like","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"sir = @reaction_network sir begin\n    β, S + I --> 2I\n    ν, I --> R\nend\nsetdefaults!(sir, [:β => 1e-4, :ν => .01, :S => 999.0, :I => 1.0, :R => 0.0])\nnothing # hide","category":"page"},{"location":"faqs/#How-to-specify-initial-conditions-and-parameters-values-for-ODEProblem-and-other-problem-types?","page":"FAQs","title":"How to specify initial conditions and parameters values for ODEProblem and other problem types?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"To explicitly pass initial conditions and parameters we can use mappings from Julia Symbols corresponding to each variable/parameter to their values, or from ModelingToolkit symbolic variables/parameters to their values. Using Symbols we have","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst, OrdinaryDiffEqTsit5\nrn = @reaction_network begin\n    α, S + I --> 2I\n    β, I --> R\nend\nu0 = [:S => 999.0, :I => 1.0, :R => 0.0]\np  = (:α => 1e-4, :β => .01)\nop1  = ODEProblem(rn, u0, (0.0, 250.0), p)\nnothing  # hide","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"while using ModelingToolkit symbolic variables we have","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"t = default_t()\n@parameters α β\n@species S(t) I(t) R(t)\nu0 = [S => 999.0, I => 1.0, R => 0.0]\np  = (α => 1e-4, β => .01)\nop2  = ODEProblem(rn, u0, (0.0, 250.0), p)\nnothing  # hide","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Note, while symbolic mappings as in the last example will work with any ModelingToolkit.AbstractSystem, for example if one converts rn to an ODESystem, Symbol-based mappings only work when passing a ReactionSystem directly into a problem type. That is, the following does not work","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"osys = convert(ODESystem, rn)\n\n# this fails\nu0 = [:S => 999.0, :I => 1.0, :R => 0.0]\np  = (:α => 1e-4, :β => .01)\nop  = ODEProblem(osys, u0, (0.0, 250.0), p)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"In this case one must either use a symbolic mapping as was used to make op2 in the second example, or one can use the symmap_to_varmap function to convert the Symbol mapping to a symbolic mapping. I.e. this works","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"osys = convert(ODESystem, rn)\nosys = complete(osys)\n\n# this works\nu0 = symmap_to_varmap(rn, [:S => 999.0, :I => 1.0, :R => 0.0])\np  = symmap_to_varmap(rn, (:α => 1e-4, :β => .01))\nop  = ODEProblem(osys, u0, (0.0, 250.0), p)\nnothing # hide","category":"page"},{"location":"faqs/#How-to-include-non-reaction-terms-in-equations-for-a-chemical-species?","page":"FAQs","title":"How to include non-reaction terms in equations for a chemical species?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"One method to add non-reaction terms into an ODE or algebraic equation for a chemical species is to add a new (non-species) unknown variable that represents those terms, let it be the rate of zero order reaction, and add a constraint equation. I.e., to add a force of (1 + sin(t)) to dAdt in a system with the reaction k, A --> 0, we can do","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst\nt = default_t()\n@variables f(t)\nrx1 = @reaction k, A --> 0\nrx2 = @reaction $f, 0 --> A\neq = f ~ (1 + sin(t))\n@named rs = ReactionSystem([rx1, rx2, eq], t)\nrs = complete(rs)\nosys = convert(ODESystem, rs)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"In the final ODE model, f can be eliminated by using ModelingToolkit.structural_simplify","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"osyss = structural_simplify(osys)\nfull_equations(osyss)","category":"page"},{"location":"faqs/#How-to-modify-generated-ODEs?","page":"FAQs","title":"How to modify generated ODEs?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Conversion to other ModelingToolkit.AbstractSystems allows the possibility to modify the system with further terms that are difficult to encode as a chemical reaction or a constraint equation. For example, an alternative method to the previous question for adding a forcing function, 1 + sin(t), to the ODE for dA/dt is","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst\nrn = @reaction_network begin\n    k, A --> 0\nend\nosys = convert(ODESystem, rn)\ndAdteq = equations(osys)[1]\nt      = ModelingToolkit.get_iv(osys)\ndAdteq = Equation(dAdteq.lhs, dAdteq.rhs + 1 + sin(t))\n\n# create a new ODESystem with the modified equation\n@named osys2  = ODESystem([dAdteq], t)","category":"page"},{"location":"faqs/#How-to-override-mass-action-kinetics-rate-laws?","page":"FAQs","title":"How to override mass action kinetics rate laws?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"While generally one wants the reaction rate law to use the law of mass action, so the reaction","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst\nrn = @reaction_network begin\n  k, X --> ∅\nend\nconvert(ODESystem, rn)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"occurs at the (ODE) rate dXdt = -kX, it is possible to override this by using any of the following non-filled arrows when declaring the reaction: <=, ⇐, ⟽, =>, ⇒, ⟾, ⇔, ⟺. This means that the reaction","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"rn = @reaction_network begin\n  k, X => ∅\nend\nconvert(ODESystem, rn)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"will occur at rate dXdt = -k (which might become a problem since X will be degraded at a constant rate even when very small or equal to 0).","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"Note, stoichiometric coefficients are still included, i.e. the reaction","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"rn = @reaction_network begin\n  k, 2*X ⇒ ∅\nend\nconvert(ODESystem, rn)","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"has rate dXdt = -2 k.","category":"page"},{"location":"faqs/#user_functions","page":"FAQs","title":"How to specify user-defined functions as reaction rates?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"The reaction network DSL can \"see\" user-defined functions that work with ModelingToolkit. e.g., this is should work","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst\nmyHill(x) = 2*x^3/(x^3+1.5^3)\nrn = @reaction_network begin\n  myHill(X), ∅ --> X\nend","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"In some cases, it may be necessary or desirable to register functions with Symbolics.jl before their use in Catalyst, see the discussion here.","category":"page"},{"location":"faqs/#How-can-I-turn-off-automatic-inferring-of-species-and-parameters-when-using-the-DSL?","page":"FAQs","title":"How can I turn off automatic inferring of species and parameters when using the DSL?","text":"","category":"section"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"This option can be set using the @require_declaration option inside @reaction_network. In this case all the species, parameters, and variables in the system must be pre-declared using one of the @species, @parameters, or @variables macros. For more information about what is inferred automatically and not, please see the section on @require_declaration.","category":"page"},{"location":"faqs/","page":"FAQs","title":"FAQs","text":"using Catalyst\nrn = @reaction_network begin\n    @require_declaration\n    @species A(t) B(t)\n    @parameters k1 k2\n    (k1, k2), A <--> B\nend","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/#interactive_brusselator","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"","category":"section"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"Catalyst can utilize the GLMakie.jl package for creating interactive visualizations of your reaction network dynamics. This tutorial provides a step-by-step guide to creating an interactive visualization of the Brusselator model, building upon the basic Brusselator example.","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/#setup_brusselator","page":"Interactive Simulation and Plotting","title":"Setting up the Brusselator model","text":"","category":"section"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"Let's again use the oscillating Brusselator model, extending the basic simulation plotting workflow we saw earlier. ","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"using Catalyst\nusing OrdinaryDiffEqTsit5","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"using GLMakie","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"using CairoMakie # hide\n\n# Define the Brusselator model\nbrusselator = @reaction_network begin\n    A, ∅ → X\n    1, 2X + Y → 3X\n    B, X → Y\n    1, X → ∅\nend\n\n# Initial parameter values and conditions\np = [:A => 1.0, :B => 4.0]\nu0 = [:X => 1.0, :Y => 0.0]\ntspan = (0.0, 50.0)\n\noprob = ODEProblem(brusselator, u0, tspan, p)\n\n# Function to solve the ODE\nfunction solve_brusselator(A, B, X0, Y0, prob = oprob)\n    p = [:A => A, :B => B]\n    u0 = [:X => X0, :Y => Y0]\n    newprob = remake(prob, p=p, u0=u0)\n    solve(newprob, Tsit5(), saveat = 0.1) \nend","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"This code sets up our Brusselator model using Catalyst.jl's @reaction_network macro. We also define initial parameters, initial conditions, create an ODEProblem, and define a function to solve the ODE with given parameters.  Setting saveat = 0.1 in the call to solve ensures the solution is saved with the desired temporal frequency we want for our later plots.","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"note: Note\nBe sure to set saveat to a value that is appropriate for your system; otherwise, the size of the solution can change during interactivity, which will cause dimension mismatch errors once we add our interactive elements.","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/#basic_static_plotting","page":"Interactive Simulation and Plotting","title":"Basic static plotting","text":"","category":"section"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"Let's start by creating a basic plot of our Brusselator model:","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"# Create the main figure\nfig = Figure(size = (800, 600), fontsize = 18);\n\n# Create an axis for the plot\nax = Axis(fig[1, 1], \n    title = \"Brusselator Model\", \n    xlabel = \"Time\", \n    ylabel = \"Concentration\")\n\n# Solve the ODE\nsol = solve_brusselator(1.0, 4.0, 1.0, 0.0)\n\n# Plot the solution\nlines!(ax, sol.t, sol[:X], label = \"X\", color = :blue, linewidth = 3)\nlines!(ax, sol.t, sol[:Y], label = \"Y\", color = :red, linewidth = 3)\n\n# Add a legend\naxislegend(ax, position = :rt)\n\n# Display the figure\nfig","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"The plot shows the concentrations of species X and Y over time. Notice the oscillatory behavior characteristic of the Brusselator model.","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/#adding_interactivity","page":"Interactive Simulation and Plotting","title":"Adding interactivity","text":"","category":"section"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"Now, let's add interactivity to our plot using Observables and sliders. We'll build this up step by step.","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/#creating_observables","page":"Interactive Simulation and Plotting","title":"Creating Observables","text":"","category":"section"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"Observables are a key concept in reactive programming and are central to how Makie.jl creates interactive visualizations. You can read more about them here.","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"# Create observables for parameters and initial conditions\nA = Observable(1.0)\nB = Observable(4.0)\nX0 = Observable(1.0)\nY0 = Observable(0.0)","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"An Observable is a container for a value that can change over time. When the value changes, any dependent computations are automatically updated.","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/#adding_sliders","page":"Interactive Simulation and Plotting","title":"Adding sliders and connecting to Observables","text":"","category":"section"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"Let's add sliders that will control our Observables:","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"# Create the main figure\nfig = Figure(size = (800, 600), fontsize = 18);\n\n# Create layout for plot and sliders\nplot_layout = fig[1, 1] = GridLayout()\nslider_layout = fig[2, 1] = GridLayout()\n\n# Create sliders\nslider_A = Slider(slider_layout[1, 1], range = 0.0:0.01:5.0, startvalue = to_value(A)) # to_value(A) unwraps the Observable to a value\nslider_B = Slider(slider_layout[2, 1], range = 0.0:0.01:5.0, startvalue = to_value(B))\nslider_X0 = Slider(slider_layout[3, 1], range = 0.0:0.01:5.0, startvalue = to_value(X0))\nslider_Y0 = Slider(slider_layout[4, 1], range = 0.0:0.01:5.0, startvalue = to_value(Y0))\n\n# Add labels for sliders\nLabel(slider_layout[1, 1, Left()], \"A\")\nLabel(slider_layout[2, 1, Left()], \"B\")\nLabel(slider_layout[3, 1, Left()], \"X₀\")\nLabel(slider_layout[4, 1, Left()], \"Y₀\")\n\n# Connect the values of the sliders to the observables\nconnect!(A, slider_A.value)\nconnect!(B, slider_B.value)\nconnect!(X0, slider_X0.value)\nconnect!(Y0, slider_Y0.value)","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"These sliders allow us to interactively change the parameters A and B, as well as the initial conditions X₀ and Y₀.","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/#reactive_plot","page":"Interactive Simulation and Plotting","title":"Creating a reactive plot","text":"","category":"section"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"Now, let's create a plot that reacts to changes in our sliders:","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"# Create an axis for the plot\nax = Axis(plot_layout[1, 1], \n    title = \"Brusselator Model\", \n    xlabel = \"Time\", \n    ylabel = \"Concentration\")\n\n# Create an observable for the solution\n# The `@lift` macro is used to create an Observable that depends on the observables `A`, `B`, `X0`, and `Y0`, and automatically updates when any of these observables change\nsolution = @lift(solve_brusselator($A, $B, $X0, $Y0))\n\n# Plot the solution\n# We don't use the ODESolution plot recipe here, as you've seen in the previous examples where only the solution and an `idxs` argument was passed to the plot method, because we are passing in an Observable wrapping the solution\nlines!(ax, lift(sol -> sol.t, solution), lift(sol -> sol[:X], solution), label = \"X\", color = :blue, linewidth = 3) # `lift` can either be used as a function or a macro\nlines!(ax, lift(sol -> sol.t, solution), lift(sol -> sol[:Y], solution), label = \"Y\", color = :red, linewidth = 3)\n\n# Add a legend\naxislegend(ax, position = :rt)\n\n# Display the figure\nfig","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"(Image: Interactive Brusselator Plot)","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"This plot will now update in real-time as you move the sliders, allowing for interactive exploration of the Brusselator's behavior under different conditions. (Note the figure above is not interactive, but for illustrative purposes to show what you should see locally.)","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/#adding_phase_plot","page":"Interactive Simulation and Plotting","title":"Adding a phase plot","text":"","category":"section"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"To gain more insight into the system's behavior, let's enhance our visualization by adding a phase plot, along with some other improvements:","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"# Create the main figure\nfig = Figure(size = (1200, 800), fontsize = 18);\n\n# Create main layout: plots on top, sliders at bottom\nplot_grid = fig[1, 1] = GridLayout()\nslider_grid = fig[2, 1] = GridLayout()\n\n# Create sub-grids for plots\ntime_plot = plot_grid[1, 1] = GridLayout()\nphase_plot = plot_grid[1, 2] = GridLayout()\n\n# Create axes for the time series plot and phase plot\nax_time = Axis(time_plot[1, 1], \n    title = \"Brusselator Model - Time Series\", \n    xlabel = \"Time\", \n    ylabel = \"Concentration\")\n\nax_phase = Axis(phase_plot[1, 1], \n    title = \"Brusselator Model - Phase Plot\", \n    xlabel = \"X\", \n    ylabel = \"Y\")\n\n# Create sub-grids for sliders\nparam_grid = slider_grid[1, 1] = GridLayout()\nic_grid = slider_grid[1, 2] = GridLayout()\n\n# Create observables for parameters and initial conditions\nA = Observable{Float64}(1.0) # We can specify the type of the Observable value, which can help with type stability and performance\nB = Observable{Float64}(4.0)\nX0 = Observable{Float64}(1.0)\nY0 = Observable{Float64}(0.0)\n\n# Create sliders with labels and group titles\nLabel(param_grid[1, 1:2], \"Parameters\", fontsize = 22)\nslider_A = Slider(param_grid[2, 2], range = 0.0:0.01:5.0, startvalue = to_value(A))\nslider_B = Slider(param_grid[3, 2], range = 0.0:0.01:5.0, startvalue = to_value(B))\nLabel(param_grid[2, 1], \"A\")\nLabel(param_grid[3, 1], \"B\")\n\nLabel(ic_grid[1, 1:2], \"Initial Conditions\", fontsize = 22)\nslider_X0 = Slider(ic_grid[2, 2], range = 0.0:0.01:5.0, startvalue = to_value(X0))\nslider_Y0 = Slider(ic_grid[3, 2], range = 0.0:0.01:5.0, startvalue = to_value(Y0))\nLabel(ic_grid[2, 1], \"X₀\")\nLabel(ic_grid[3, 1], \"Y₀\")\n\n# Connect sliders to observables\nconnect!(A, slider_A.value)\nconnect!(B, slider_B.value)\nconnect!(X0, slider_X0.value)\nconnect!(Y0, slider_Y0.value)\n\n# Create an observable for the solution. \nsolution = @lift(solve_brusselator($A, $B, $X0, $Y0))\n\n# Plot the time series\nlines!(ax_time, lift(sol -> sol.t, solution), lift(sol -> sol[:X], solution), label = \"X\", color = :blue, linewidth = 3) \nlines!(ax_time, lift(sol -> sol.t, solution), lift(sol -> sol[:Y], solution), label = \"Y\", color = :red, linewidth = 3)\n\n# Plot the phase plot\nphase_plot_obj = lines!(ax_phase, lift(sol -> sol[:X], solution), lift(sol -> sol[:Y], solution), \n                        color = lift(sol -> sol.t, solution), colormap = :viridis)\n\n# Add a colorbar for the phase plot\nColorbar(phase_plot[1, 2], phase_plot_obj, label = \"Time\")\n\n# Add legends\naxislegend(ax_time, position = :rt)\n\n# Adjust layout to your liking\ncolgap!(plot_grid, 20)\nrowgap!(fig.layout, 20)\ncolgap!(param_grid, 10)\ncolgap!(ic_grid, 10)\n\n# Display the figure\nfig","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"This will create a visualization with both time series and phase plots:","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"(Image: Interactive Brusselator Plot with Time Series and Phase Plot)","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/#common_makie_plotting_options","page":"Interactive Simulation and Plotting","title":"Common plotting options","text":"","category":"section"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"Various plotting options can be provided as optional arguments to the lines! command. Common options include:","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"linewidth or lw: Determine plot line widths.\nlinestyle: Determines plot line style.\ncolor: Determines the line colors.\nlabel: Determines label texts displayed in the legend.","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"For example:","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"lines!(ax_time, lift(sol -> sol.t, solution), lift(sol -> sol[:X], solution), \n       label = \"X\", color = :green, linewidth = 2, linestyle = :dash)","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/#extending_interactive_visualization","page":"Interactive Simulation and Plotting","title":"Extending the interactive visualization","text":"","category":"section"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"You can further extend this visualization by:","category":"page"},{"location":"model_simulation/examples/interactive_brusselator_simulation/","page":"Interactive Simulation and Plotting","title":"Interactive Simulation and Plotting","text":"Adding other interactive elements, such as buttons or dropdown menus to control different aspects of the simulation or visualization.\nAdding additonal axes to the plot, such as plotting the derivatives of the species.\nColor coding the slider and slider labels to match the plot colors.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/#parameter_estimation","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"","category":"section"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"In this example we will use Optimization.jl to fit the parameters of an oscillatory system (the Brusselator) to data. Here, special consideration is taken to avoid reaching a local minimum. Instead of fitting the entire time series directly, we will start with fitting parameter values for the first period, and then use those as an initial guess for fitting the next (and then these to find the next one, and so on). Using this procedure is advantageous for oscillatory systems, and enables us to reach the global optimum.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"First, we fetch the required packages.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"using Catalyst\nusing OrdinaryDiffEqRosenbrock\nusing Optimization\nusing OptimizationOptimisers # Required for the ADAM optimizer.\nusing SciMLSensitivity # Required for `Optimization.AutoZygote()` automatic differentiation option.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Next, we declare our model, the Brusselator oscillator.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"brusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend\np_real = [:A => 1., :B => 2.]\nnothing # hide","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"We simulate our model, and from the simulation generate sampled data points (to which we add noise). We will use this data to fit the parameters of our model.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"u0 = [:X => 1.0, :Y => 1.0]\ntspan = (0.0, 30.0)\n\nsample_times = range(tspan[1]; stop = tspan[2], length = 100)\nprob = ODEProblem(brusselator, u0, tspan, p_real)\nsol_real = solve(prob, Rosenbrock23(); tstops = sample_times)\nsample_vals = Array(sol_real(sample_times))\nsample_vals .*= (1 .+ .1 * rand(Float64, size(sample_vals)) .- .05)\nnothing   # hide","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"We can plot the real solution, as well as the noisy samples.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"using Plots\ndefault(; lw = 3, framestyle = :box, size = (800, 400))\n\nplot(sol_real; legend = nothing, color = [:darkblue :darkred])\nscatter!(sample_times, sample_vals'; color = [:blue :red], legend = nothing)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Next, we create a function to fit the parameters using the ADAM optimizer. For a given initial estimate of the parameter values, pinit, this function will fit parameter values, p, to our data samples. We use tend to indicate the time interval over which we fit the model.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"function optimise_p(pinit, tend)\n    function loss(p, _)\n        newtimes = filter(<=(tend), sample_times)\n        newprob = remake(prob; tspan = (0.0, tend), p = p)\n        sol = Array(solve(newprob, Rosenbrock23(); saveat = newtimes))\n        loss = sum(abs2, sol .- sample_vals[:, 1:size(sol,2)])\n        return loss, sol\n    end\n\n    # optimize for the parameters that minimize the loss\n    optf = OptimizationFunction(loss, Optimization.AutoZygote())\n    optprob = OptimizationProblem(optf, pinit)\n    sol = solve(optprob, ADAM(0.1); maxiters = 100)\n\n    # return the parameters we found\n    return sol.u\nend\nnothing # hide","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Next, we will fit a parameter set to the data on the interval (0, 10).","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate = optimise_p([5.0, 5.0], 10.0)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"We can compare this to the real solution, as well as the sample data","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"newprob = remake(prob; tspan = (0., 10.), p = p_estimate)\nsol_estimate = solve(newprob, Rosenbrock23())\nplot(sol_real; color = [:blue :red], label = [\"X real\" \"Y real\"], linealpha = 0.2)\nscatter!(sample_times, sample_vals'; color = [:blue :red],\n         label = [\"Samples of X\" \"Samples of Y\"], alpha = 0.4)\nplot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,\n                    label = [\"X estimated\" \"Y estimated\"], xlimit = tspan)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Next, we use this parameter estimate as the input to the next iteration of our fitting process, this time on the interval (0, 20).","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate = optimise_p(p_estimate, 20.)\nnewprob = remake(prob; tspan = (0., 20.), p = p_estimate)\nsol_estimate = solve(newprob, Rosenbrock23())\nplot(sol_real; color = [:blue :red], label = [\"X real\" \"Y real\"], linealpha = 0.2)\nscatter!(sample_times, sample_vals'; color = [:blue :red],\n         label = [\"Samples of X\" \"Samples of Y\"], alpha = 0.4)\nplot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,\n                    label = [\"X estimated\" \"Y estimated\"], xlimit = tspan)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"Finally, we use this estimate as the input to fit a parameter set on the full time interval of the sampled data.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate = optimise_p(p_estimate, 30.0)\n\nnewprob = remake(prob; tspan = (0., 30.0), p = p_estimate)\nsol_estimate = solve(newprob, Rosenbrock23())\nplot(sol_real; color = [:blue :red], label = [\"X real\" \"Y real\"], linealpha = 0.2)\nscatter!(sample_times, sample_vals'; color = [:blue :red],\n         label = [\"Samples of X\" \"Samples of Y\"], alpha = 0.4)\nplot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,\n                    label = [\"X estimated\" \"Y estimated\"], xlimit = tspan)","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"The final parameter estimate is then","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"which is close to the actual parameter set of [1.0, 2.0].","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/#Why-we-fit-the-parameters-in-iterations","page":"Fitting Parameters for an Oscillatory System","title":"Why we fit the parameters in iterations","text":"","category":"section"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"As previously mentioned, the reason we chose to fit the model on a smaller interval to begin with, and then extend the interval, is to avoid getting stuck in a local minimum. Here specifically, we chose our initial interval to be smaller than a full cycle of the oscillation. If we had chosen to fit a parameter set on the full interval immediately we would have obtained poor fit and an inaccurate estimate for the parameters.","category":"page"},{"location":"inverse_problems/examples/ode_fitting_oscillation/","page":"Fitting Parameters for an Oscillatory System","title":"Fitting Parameters for an Oscillatory System","text":"p_estimate = optimise_p([5.0,5.0], 30.0)\n\nnewprob = remake(prob; tspan = (0.0,30.0), p = p_estimate)\nsol_estimate = solve(newprob, Rosenbrock23())\nplot(sol_real; color = [:blue :red], label = [\"X real\" \"Y real\"], linealpha = 0.2)\nscatter!(sample_times,sample_vals'; color = [:blue :red],\n         label = [\"Samples of X\" \"Samples of Y\"], alpha = 0.4)\nplot!(sol_estimate; color = [:darkblue :darkred], linestyle = :dash,\n                    label = [\"X estimated\" \"Y estimated\"], xlimit = tspan)","category":"page"},{"location":"model_creation/parametric_stoichiometry/#parametric_stoichiometry","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"","category":"section"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Catalyst supports stoichiometric coefficients that involve parameters, species, or even general expressions. In this tutorial we show several examples of how to use symbolic stoichiometries, and discuss several caveats to be aware of.","category":"page"},{"location":"model_creation/parametric_stoichiometry/#Using-symbolic-stoichiometry","page":"Symbolic Stochiometries","title":"Using symbolic stoichiometry","text":"","category":"section"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Let's first consider a simple reversible reaction where the number of reactants is a parameter, and the number of products is the product of two parameters.","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"using Catalyst, Latexify, OrdinaryDiffEqTsit5, ModelingToolkit, Plots\nrevsys = @reaction_network revsys begin\n    @parameters m::Int64 n::Int64\n    k₊, m*A --> (m*n)*B\n    k₋, B --> A\nend\nreactions(revsys)","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Notice, as described in the Reaction rate laws used in simulations section, the default rate laws involve factorials in the stoichiometric coefficients. For this reason we explicitly specify m and n as integers (as otherwise ModelingToolkit will implicitly assume they are floating point).","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"As always the @reaction_network macro defaults to setting all symbols neither used as a reaction substrate nor a product to be parameters. Hence, in this example we have two species (A and B) and four parameters (k₊, k₋, m, and n). In addition, the stoichiometry is applied to the rightmost symbol in a given term, i.e. in the first equation the substrate A has stoichiometry m and the product B has stoichiometry m*n. For example, in","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"rn = @reaction_network begin\n    k, A*C --> 2B\n    end\nreactions(rn)","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"we see two species, (B,C), with A treated as a parameter representing the stoichiometric coefficient of C, i.e.","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"rx = reactions(rn)[1]\nrx.substrates[1],rx.substoich[1]","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"We could have equivalently specified our systems directly via the Catalyst API. For example, for revsys we would could use","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"t = default_t()\n@parameters k₊ k₋ m::Int n::Int\n@species A(t), B(t)\nrxs = [Reaction(k₊, [A], [B], [m], [m*n]),\n       Reaction(k₋, [B], [A])]\nrevsys2 = ReactionSystem(rxs,t; name=:revsys)\nrevsys2 == revsys","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"or","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"rxs2 = [(@reaction k₊, $m*A --> ($m*$n)*B),\n        (@reaction k₋, B --> A)]\nrevsys3 = ReactionSystem(rxs2,t; name=:revsys)\nrevsys3 == revsys","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Here we interpolate in the pre-declared m and n symbolic variables using $m and $n to ensure the parameter is known to be integer-valued. The @reaction macro again assumes all symbols are parameters except the substrates or reactants (i.e. A and B). For example, in @reaction k, F*A + 2(H*G+B) --> D, the substrates are (A,G,B) with stoichiometries (F,2*H,2).","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Let's now convert revsys to ODEs and look at the resulting equations:","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"osys = convert(ODESystem, revsys)\nosys = complete(osys)\nequations(osys)\nshow(stdout, MIME\"text/plain\"(), equations(osys)) # hide","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Specifying the parameter and initial condition values,","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"p  = (revsys.k₊ => 1.0, revsys.k₋ => 1.0, revsys.m => 2, revsys.n => 2)\nu₀ = [revsys.A => 1.0, revsys.B => 1.0]\noprob = ODEProblem(osys, u₀, (0.0, 1.0), p)\nnothing # hide","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"we can now solve and plot the system","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"sol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"An alternative approach to avoid the issues of using mixed floating point and integer variables is to disable the rescaling of rate laws as described in Reaction rate laws used in simulations section. This requires passing the combinatoric_ratelaws=false keyword to convert or to ODEProblem (if directly building the problem from a ReactionSystem instead of first converting to an ODESystem). For the previous example this gives the following (different) system of ODEs where we now let m and n be floating point valued parameters (the default):","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"revsys = @reaction_network revsys begin\n    k₊, m*A --> (m*n)*B\n    k₋, B --> A\nend\nosys = convert(ODESystem, revsys; combinatoric_ratelaws = false)\nosys = complete(osys)\nequations(osys)\nshow(stdout, MIME\"text/plain\"(), equations(osys)) # hide","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Since we no longer have factorial functions appearing, our example will now run with m and n treated as floating point parameters:","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"p  = (revsys.k₊ => 1.0, revsys.k₋ => 1.0, revsys.m => 2.0, revsys.n => 2.0)\noprob = ODEProblem(osys, u₀, (0.0, 1.0), p)\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"model_creation/parametric_stoichiometry/#Gene-expression-with-randomly-produced-amounts-of-protein","page":"Symbolic Stochiometries","title":"Gene expression with randomly produced amounts of protein","text":"","category":"section"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"As a second example, let's build the negative feedback model from MomentClosure.jl that involves a bursty reaction that produces a random amount of protein.","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"In our model G₋ will denote the repressed state, and G₊ the active state where the gene can transcribe. P will denote the protein product of the gene. We will assume that proteins are produced in bursts that produce m proteins, where m is a (shifted) geometric random variable with mean b. To define m we must register the Distributions.Geometric distribution from Distributions.jl with Symbolics.jl, after which we can use it in symbolic expressions:","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"using Distributions: Geometric\n@register_symbolic Geometric(b)\n@parameters b\nm = rand(Geometric(1/b)) + 1\nnothing # hide","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Note, as we require the shifted geometric distribution, we add one to Distributions.jl's Geometric random variable (which includes zero).","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"We can now define our model","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"burstyrn = @reaction_network burstyrn begin\n    k₊, G₋ --> G₊\n    k₋*P^2, G₊ --> G₋\n    kₚ, G₊ --> G₊ + $m*P\n    γₚ, P --> ∅\nend\nreactions(burstyrn)\nshow(stdout, MIME\"text/plain\"(), reactions(burstyrn)) # hide","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"The parameter b does not need to be explicitly declared in the @reaction_network macro as it is detected when the expression rand(Geometric(1/b)) + 1 is substituted for m.","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"We next convert our network to a jump process representation","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"using JumpProcesses\njsys = convert(JumpSystem, burstyrn; combinatoric_ratelaws = false)\njsys = complete(jsys)\nequations(jsys)\nshow(stdout, MIME\"text/plain\"(), equations(jsys)) # hide","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Notice, the equations of jsys have three MassActionJumps for the first three reactions, and one ConstantRateJump for the last reaction. If we examine the ConstantRateJump more closely we can see the generated rate and affect! functions for the bursty reaction that makes protein","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"equations(jsys)[4].rate\nshow(stdout, MIME\"text/plain\"(), equations(jsys)[4].rate) # hide","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"equations(jsys)[4].affect!\nshow(stdout, MIME\"text/plain\"(), equations(jsys)[4].affect!) # hide","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Finally, we can now simulate our JumpSystem","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"pmean = 200\nbval = 70\nγₚval = 1\nk₋val = 0.001\nk₊val = 0.05\nkₚval = pmean * γₚval * (k₋val * pmean^2 + k₊val) / (k₊val * bval)\np = symmap_to_varmap(jsys, (:k₊ => k₊val, :k₋ => k₋val, :kₚ => kₚval,\n                            :γₚ => γₚval, :b => bval))\nu₀ = symmap_to_varmap(jsys, [:G₊ => 1, :G₋ => 0, :P => 1])\ntspan = (0., 6.0)   # time interval to solve over\ndprob = DiscreteProblem(jsys, u₀, tspan, p)\njprob = JumpProblem(jsys, dprob, Direct())\nsol = solve(jprob)\nplot(sol.t, sol[jsys.P], legend = false, xlabel = \"time\", ylabel = \"P(t)\")","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"To double check our results are consistent with MomentClosure.jl, let's calculate and plot the average amount of protein (which is also plotted in the MomentClosure.jl tutorial).","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"t = default_t()\nfunction getmean(jprob, Nsims, tv)\n    Pmean = zeros(length(tv))\n    @variables P(t)\n    for n in 1:Nsims\n        sol = solve(jprob)\n        Pmean .+= sol(tv, idxs=P)\n    end\n    Pmean ./= Nsims\nend\ntv = range(tspan[1],tspan[2],step=.1)\npsim_mean = getmean(jprob, 20000, tv)\nplot(tv, psim_mean; ylabel = \"average of P(t)\", xlabel = \"time\",\n                    xlim = (0.0,6.0), legend = false)","category":"page"},{"location":"model_creation/parametric_stoichiometry/","page":"Symbolic Stochiometries","title":"Symbolic Stochiometries","text":"Comparing, we see similar averages for P(t).","category":"page"},{"location":"#doc_index","page":"Home","title":"Catalyst.jl for Reaction Network Modeling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst.jl is a symbolic modeling package for analysis and high-performance simulation of chemical reaction networks. Catalyst defines symbolic ReactionSystems, which can be created programmatically or easily specified using Catalyst's domain-specific language (DSL). Leveraging ModelingToolkit.jl and Symbolics.jl, Catalyst enables large-scale simulations through auto-vectorization and parallelism. Symbolic ReactionSystems can be used to generate ModelingToolkit-based models, allowing the easy simulation and parameter estimation of mass action ODE models, Chemical Langevin SDE models, stochastic chemical kinetics jump process models, and more. Generated models can be used with solvers throughout the broader Julia and SciML ecosystems, including higher-level SciML packages (e.g. for sensitivity analysis, parameter estimation, machine learning applications, etc).","category":"page"},{"location":"#doc_index_features","page":"Home","title":"Features","text":"","category":"section"},{"location":"#doc_index_features_catalyst","page":"Home","title":"Features of Catalyst","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Catalyst DSL provides a simple and readable format for manually specifying reaction network models using chemical reaction notation.\nCatalyst ReactionSystems provides a symbolic representation of reaction networks, built on ModelingToolkit.jl and Symbolics.jl.\nThe Catalyst.jl API provides functionality for building networks programmatically and for composing multiple networks together.\nLeveraging ModelingToolkit, generated models can be converted to symbolic reaction rate equation ODE models, symbolic Chemical Langevin Equation models, and symbolic stochastic chemical kinetics (jump process) models. These can be simulated using any DifferentialEquations.jl ODE/SDE/jump solver, and can be used within EnsembleProblems for carrying out parallelized parameter sweeps and statistical sampling. Plot recipes are available for visualization of all solutions.\nNon-integer (e.g. Float64) stoichiometric coefficients are supported for generating ODE models, and symbolic expressions for stoichiometric coefficients are supported for all system types.\nA network analysis suite permits the computation of linkage classes, deficiencies, reversibility, and other network properties.\nConservation laws can be detected and utilized to reduce system sizes, and to generate non-singular Jacobians (e.g. during conversion to ODEs, SDEs, and steady state equations).\nCatalyst reaction network models can be coupled with differential and algebraic equations (which are then incorporated during conversion to ODEs, SDEs, and steady state equations).\nModels can be coupled with events that affect the system and its state during simulations.\nBy leveraging ModelingToolkit, users have a variety of options for generating optimized system representations to use in solvers. These include construction of dense or sparse Jacobians, multithreading or parallelization of generated derivative functions, automatic classification of reactions into optimized jump types for Gillespie type simulations, automatic construction of dependency graphs for jump systems, and more.\nSymbolics.jl symbolic expressions and Julia Exprs can be obtained for all rate laws and functions determining the deterministic and stochastic terms within resulting ODE, SDE, or jump models.\nSteady states (and their stabilities) can be computed for model ODE representations.","category":"page"},{"location":"#doc_index_features_composed","page":"Home","title":"Features of Catalyst composing with other packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OrdinaryDiffEq.jl Can be used to numerically solve generated reaction rate equation ODE models.\nStochasticDiffEq.jl can be used to numerically solve generated Chemical Langevin Equation SDE models.\nJumpProcesses.jl can be used to numerically sample generated Stochastic Chemical Kinetics Jump Process models.\nSupport for parallelization of all simulations, including parallelization of ODE simulations on GPUs using DiffEqGPU.jl.\nLatexify can be used to generate LaTeX expressions corresponding to generated mathematical models or the underlying set of reactions.\nGraphviz can be used to generate and visualize reaction network graphs (reusing the Graphviz interface created in Catlab.jl).\nModel steady states can be computed through homotopy continuation using HomotopyContinuation.jl (which can find all steady states of systems with multiple ones), by forward ODE simulations using SteadyStateDiffEq.jl), or by numerically solving steady-state nonlinear equations using NonlinearSolve.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BifurcationKit.jl can be used to compute bifurcation diagrams of model steady states (including finding periodic orbits).","category":"page"},{"location":"","page":"Home","title":"Home","text":"DynamicalSystems.jl can be used to compute model basins of attraction, Lyapunov spectrums, and other dynamical system properties.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<!–- StructuralIdentifiability.jl can be used to perform structural identifiability analysis.–>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Optimization.jl, DiffEqParamEstim.jl, and PEtab.jl can all be used to fit model parameters to data.\nGlobalSensitivity.jl can be used to perform global sensitivity analysis of model behaviors.\nSciMLSensitivity.jl can be used to compute local sensitivities of functions containing forward model simulations.","category":"page"},{"location":"#doc_index_features_other_packages","page":"Home","title":"Features of packages built upon Catalyst","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst ReactionSystems can be imported from SBML files via SBMLImporter.jl and SBMLToolkit.jl, and from BioNetGen .net files and various stoichiometric matrix network representations using ReactionNetworkImporters.jl.\nMomentClosure.jl allows generation of symbolic ModelingToolkit ODESystems that represent moment closure approximations to moments of the Chemical Master Equation, from reaction networks defined in Catalyst.\nFiniteStateProjection.jl allows the construction and numerical solution of Chemical Master Equation models from reaction networks defined in Catalyst.\nDelaySSAToolkit.jl can augment Catalyst reaction network models with delays, and can simulate the resulting stochastic chemical kinetics with delays models.","category":"page"},{"location":"#doc_index_documentation","page":"Home","title":"How to read this documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Catalyst documentation is separated into sections describing Catalyst's various features. Where appropriate, some sections will also give advice on best practices for various modeling workflows, and provide links with further reading. Each section also contains a set of relevant example workflows. Finally, the API section contains a list of all functions exported by Catalyst (as well as descriptions of them and their inputs and outputs).","category":"page"},{"location":"","page":"Home","title":"Home","text":"New users are recommended to start with either the Introduction to Catalyst and Julia for New Julia users or Introduction to Catalyst sections (depending on whether they are familiar with Julia programming or not). This should be enough to carry out many basic Catalyst workflows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation contains code which is dynamically run whenever it is built. If you copy the code and run it in your Julia environment it should work. The exact Julia environment that is used in this documentation can be found here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For most code blocks in this documentation, the output of the last line of code is printed at the of the block, e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"1 + 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"and","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Catalyst # hide\n@reaction_network begin\n    (p,d), 0 <--> X\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, in some situations (e.g. when output is extensive, or irrelevant to what is currently being described) we have disabled this, e.g. like here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"1 + 2\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"and here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@reaction_network begin\n    (p,d), 0 <--> X\nend\nnothing # hide","category":"page"},{"location":"#doc_index_installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst is an officially registered Julia package, which can be installed through the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Catalyst\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Many Catalyst features require the installation of additional packages. E.g. for ODE-solving and simulation plotting","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(\"OrdinaryDiffEqDefault\")\nPkg.add(\"Plots\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"is also needed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is strongly recommended to run Catalyst in its own environment with the minimal set of needed packages. For example, to install Catalyst and Plots in a new environment named catalyst_project (saved in the current directory) one can say","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.activate(\"catalyst_project\")\nPkg.add(\"Catalyst\")\nPkg.add(\"Plots\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"If one would rather just create a temporary environment that is not saved when exiting Julia you can say","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.activate(; temp = true)\nPkg.add(\"Catalyst\")\nPkg.add(\"Plots\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"A more thorough guide for setting up Catalyst and installing Julia packages can be found here.","category":"page"},{"location":"#doc_index_example","page":"Home","title":"Illustrative example","text":"","category":"section"},{"location":"#doc_index_example_ode","page":"Home","title":"Deterministic ODE simulation of Michaelis-Menten enzyme kinetics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here we show a simple example where a model is created using the Catalyst DSL, and then simulated as an ordinary differential equation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Fetch required packages.\nusing Catalyst, OrdinaryDiffEqDefault, Plots\n\n# Create model.\nmodel = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\nend\n\n# Create an ODE that can be simulated.\nu0 = [:S => 50.0, :E => 10.0, :SE => 0.0, :P => 0.0]\ntspan = (0., 200.)\nps = [:kB => 0.01, :kD => 0.1, :kP => 0.1]\node = ODEProblem(model, u0, tspan, ps)\n\n# Simulate ODE and plot results.\nsol = solve(ode)\nplot(sol; lw = 5)","category":"page"},{"location":"#doc_index_example_jump","page":"Home","title":"Stochastic jump simulations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The same model can be used as input to other types of simulations. E.g. here we instead generate and simulate a stochastic chemical kinetics jump process model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Create and simulate a jump process (here using Gillespie's direct algorithm).\n# The initial conditions are now integers as we track exact populations for each species.\nusing JumpProcesses\nu0_integers = [:S => 50, :E => 10, :SE => 0, :P => 0]\njinput = JumpInputs(model, u0_integers, tspan, ps)\njprob = JumpProblem(jinput)\njump_sol = solve(jprob)\njump_sol = solve(jprob; seed = 1234) # hide\nplot(jump_sol; lw = 2)","category":"page"},{"location":"#doc_index_elaborate_example","page":"Home","title":"More elaborate example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the above example, we used basic Catalyst workflows to simulate a simple model. Here we instead show how various Catalyst features can compose to create a much more advanced model. Our model describes how the volume of a cell (V) is affected by a growth factor (G). The growth factor only promotes growth while in its phosphorylated form (G^P). The phosphorylation of G (G to G^P) is promoted by sunlight (modeled as the cyclic sinusoid k_a (sin(t) + 1)), which phosphorylates the growth factor (producing G^P). When the cell reaches a critical volume (V_m) it undergoes cell division. First, we declare our model:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Catalyst\ncell_model = @reaction_network begin\n    @parameters Vₘ g\n    @equations begin\n        D(V) ~ g*Gᴾ\n    end\n    @continuous_events begin\n        [V ~ Vₘ] => [V ~ V/2]\n    end\n    kₚ*(sin(t)+1)/V, G --> Gᴾ\n    kᵢ/V, Gᴾ --> G\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"We now study the system as a Chemical Langevin Dynamics SDE model, which can be generated as follows","category":"page"},{"location":"","page":"Home","title":"Home","text":"u0 = [:V => 25.0, :G => 50.0, :Gᴾ => 0.0]\ntspan = (0.0, 20.0)\nps = [:Vₘ => 50.0, :g => 0.3, :kₚ => 100.0, :kᵢ => 60.0]\nsprob = SDEProblem(cell_model, u0, tspan, ps)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This problem encodes the following stochastic differential equation model:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\ndG(t) =  - left( frack_p(sin(t)+1)V(t) G(t) + frack_iV(t) G^P(t) right) dt - sqrtfrack_p (sin(t)+1)V(t) G(t)  dW_1(t) + sqrtfrack_iV(t) G^P(t)  dW_2(t) \ndG^P(t) = left( frack_p(sin(t)+1)V(t) G(t) - frack_iV(t) G^P(t) right) dt + sqrtfrack_p (sin(t)+1)V(t) G(t)  dW_1(t) - sqrtfrack_iV(t) G^P(t)  dW_2(t) \ndV(t) = left(g  G^P(t)right) dt\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the dW_1(t) and dW_2(t) terms represent independent Brownian Motions, encoding the noise added by the Chemical Langevin Equation. Finally, we can simulate and plot the results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using StochasticDiffEq, Plots\nsol = solve(sprob, EM(); dt = 0.05)\nsol = solve(sprob, EM(); dt = 0.05, seed = 1234) # hide\nplot(sol; xguide = \"Time (au)\", lw = 2)","category":"page"},{"location":"#doc_index_help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Catalyst developers are active on the Julia Discourse and the Julia Slack channels #sciml-bridged and #sciml-sysbio. For bugs or feature requests, open an issue.","category":"page"},{"location":"#doc_index_citation","page":"Home","title":"Supporting and Citing Catalyst.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The software in this ecosystem was developed as part of academic research. If you would like to help support it, please star the repository as such metrics may help us secure funding in the future. If you use Catalyst as part of your research, teaching, or other activities, we would be grateful if you could cite our work:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{CatalystPLOSCompBio2023,\n doi = {10.1371/journal.pcbi.1011530},\n author = {Loman, Torkel E. AND Ma, Yingbo AND Ilin, Vasily AND Gowda, Shashi AND Korsbo, Niklas AND Yewale, Nikhil AND Rackauckas, Chris AND Isaacson, Samuel A.},\n journal = {PLOS Computational Biology},\n publisher = {Public Library of Science},\n title = {Catalyst: Fast and flexible modeling of reaction networks},\n year = {2023},\n month = {10},\n volume = {19},\n url = {https://doi.org/10.1371/journal.pcbi.1011530},\n pages = {1-19},\n number = {10},\n}","category":"page"},{"location":"#doc_index_reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/#periodic_event_simulation_example","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"","category":"section"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"This tutorial will describe how to simulate systems with periodic events in ODEs and jump simulations (SDEs use identical syntax). We will consider a model with a circadian rhythm, where a parameter represents the level of light. While outdoor light varies smoothly, in experimental settings a lamp is often simply turned on/off every 12 hours. Here we will model this toggling of the light using a periodic event that is triggered every 12 hours.","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/#periodic_event_simulation_example_ode","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a circadian periodic event in an ODE simulation","text":"","category":"section"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"We will consider a simple circadian model, consisting of a single protein (X), which is phosphorylated (X to Xᴾ) in the presence of light (l). Here, the light parameter can either be 0 (night) or 1 (day). We can model this using a simple periodic event which switches the value of l every 12 hours (here, % is the remainder operator).","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"using Catalyst\ncircadian_model = @reaction_network begin\n    @discrete_events begin\n        12 => [l ~ (l + 1)%2]\n    end\n (kₚ*l,kᵢ), X <--> Xᴾ\nend","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"We can now simulate this model, observing how a 24-hour cycle is reached","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"using OrdinaryDiffEqDefault, Plots\nu0 = [:X => 150.0, :Xᴾ => 50.0]\nps = [:kₚ => 0.1, :kᵢ => 0.1, :l => 1.0]\ntspan = (0.0, 100.0)\noprob = ODEProblem(circadian_model, u0, tspan, ps)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/#periodic_event_simulation_example_ode-2","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a circadian periodic event in a jump simulation","text":"","category":"section"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"We can define periodic events in an identical manner for jump simulations. Let's reuse our previously defined network, but now simulate it as a stochastic chemical kinetics jump process model","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"using JumpProcesses\nu0 = [:X => 150, :Xᴾ => 50]  # define u0 as integers now\njinput = JumpInputs(circadian_model, u0, tspan, ps)\njprob = JumpProblem(jinput)\njsol = solve(jprob)\nplot(jsol)\nCatalyst.PNG(plot(jsol; fmt = :png, dpi = 200)) # hide","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"Sometimes we might want to setup a more complicated condition than simply that our event occurs at a fixed time or with a fixed frequency. For example, suppose we want to skip the first event at time t = 12 and then have the event be periodic after that point every 12 units of time. We can do so using a more general discrete callback as follows","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"circadian_model = @reaction_network begin\n    @discrete_events begin\n        ((t % 12 == 0) & (t > 12)) => [l ~ (l + 1)%2]\n    end\n    (kₚ*l,kᵢ), X <--> Xᴾ\nend","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"Here our condition ((t % 12 == 0) & (t > 12)) determines when the event occurs, evaluating to true when t is a multiple of 12 that is also larger than 12. We now finish specifying our model","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"using JumpProcesses\nu0 = [:X => 150, :Xᴾ => 50]\nps = [:kₚ => 0.1, :kᵢ => 0.1, :l => 1.0]\ntspan = (0.0, 100.0)\njinput = JumpInputs(circadian_model, u0, tspan, ps)\njprob = JumpProblem(jinput)\nnothing # hide","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"Next, if we simulate our model, we note that the events do not seem to be triggered","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"sol = solve(jprob)\nplot(sol)\nCatalyst.PNG(plot(sol; fmt = :png, dpi = 200)) # hide","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"The reason is that general discrete callbacks' conditions are only checked at the end of each simulation time step, and the probability that these will coincide with the callback's trigger times (t = 12 24 36 ) is infinitely small. Hence, we must directly instruct our simulation to stop at these time points. We can do this using the tstops argument:","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"tstops = range(12.0, tspan[2]; step = 12.0)\nsol = solve(jprob; tstops)\nplot(sol)\nCatalyst.PNG(plot(sol; fmt = :png, dpi = 200)) # hide","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/#periodic_event_simulation_plotting_light","page":"Modelling a periodic event during ODE and jump simulations","title":"Plotting the light level","text":"","category":"section"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"Sometimes when simulating models with periodic parameters, one would like to plot the parameter's value across the simulation. For this, there are two potential strategies. One includes creating a saving callback. The other one, which we will demonstrate here, includes turning the parameter l to a variable (so that its value is recorded throughout the simulation):","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"circadian_model = @reaction_network begin\n    @variables l(t)\n    @discrete_events begin\n        12 => [l ~ (l + 1)%2]\n    end\n (kₚ*l,kᵢ), X <--> Xᴾ\nend\nnothing # hide","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"Next, we simulate our model like before (but providing l's value as an initial condition):","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"u0 = [:X => 150.0, :Xᴾ => 50.0, :l => 1.0]\nps = [:kₚ => 0.1, :kᵢ => 0.1]\noprob = ODEProblem(circadian_model, u0, (0.0, 100.0), ps)\nsol = solve(oprob)\nnothing # hide","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"If we directly plot l's value, it will be too small (compared to X and Xᴾ to be discernible). We instead @unpack our variables, and then plot a re-scaled version:","category":"page"},{"location":"model_simulation/examples/periodic_events_simulation/","page":"Modelling a periodic event during ODE and jump simulations","title":"Modelling a periodic event during ODE and jump simulations","text":"@unpack X, Xᴾ, l = circadian_model\nplot(sol; idxs = [X, Xᴾ, 150*l], labels = [\"X\" \"Xᴾ\" \"Light amplitude\"])","category":"page"},{"location":"model_simulation/ode_simulation_performance/#ode_simulation_performance","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"We have previously described how to perform ODE simulations of chemical reaction network (CRN) models. These simulations are typically fast and require little additional consideration. However, when a model is simulated many times (e.g. as a part of solving an inverse problem), or is very large, simulation run times may become noticeable. Here we will give some advice on how to improve performance for these cases [1].","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Generally, there are few good ways to, before a simulation, determine the best options. Hence, while we below provide several options, if you face an application for which reducing run time is critical (e.g. if you need to simulate the same ODE many times), it might be required to manually trial these various options to see which yields the best performance (BenchmarkTools.jl's @btime macro is useful for this purpose). It should be noted that the default options typically perform well, and it is primarily for large models where investigating alternative options is worthwhile. All ODE simulations of Catalyst models are performed using the OrdinaryDiffEq.jl package, which documentation provides additional advice on performance.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Generally, this short checklist provides a quick guide for dealing with ODE performance:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"If performance is not critical, use the default solver choice and do not worry further about the issue.\nIf improved performance would be useful, read about solver selection (both in this tutorial and OrdinaryDiffEq's documentation) and then try a few different solvers to find one with good performance.\nIf you have a large ODE (approximately 100 variables or more), try the various options for efficient Jacobian computation (noting that some are non-trivial to use, and should only be investigated if truly required).\nIf you plan to simulate your ODE many times, try parallelise it on CPUs or GPUs (with preference for the former, which is easier to use).","category":"page"},{"location":"model_simulation/ode_simulation_performance/#ode_simulation_performance_stiffness","page":"Advice for performant ODE simulations","title":"Regarding stiff and non-stiff problems and solvers","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Generally, ODE problems can be categorised into stiff ODEs and non-stiff ODEs. This categorisation is important due to stiff ODEs requiring specialised solvers. A common cause of failure to simulate an ODE is the use of a non-stiff solver for a stiff problem. There is no exact way to determine whether a given ODE is stiff or not, however, systems with several different time scales (e.g. a CRN with both slow and fast reactions) typically generate stiff ODEs.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Here we simulate the (stiff) Brusselator model using the Tsit5 solver (which is designed for non-stiff ODEs):","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using Catalyst, OrdinaryDiffEqTsit5, Plots\n\nbrusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend\n\nu0 = [:X => 1.0, :Y => 0.0]\ntspan = (0.0, 20.0)\nps = [:A => 400.0, :B => 2000.0]\noprob = ODEProblem(brusselator, u0, tspan, ps)\n\nsol1 = solve(oprob, Tsit5())\nplot(sol1)\nCatalyst.PNG(plot(sol1; fmt = :png, dpi = 200)) # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"We get a warning, indicating that the simulation was terminated. Furthermore, the resulting plot ends at t  12, meaning that the simulation was not completed (as the simulation's endpoint is t = 20). Indeed, we can confirm this by checking the return code of the solution object:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"sol1.retcode","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Next, we instead try the Rodas5P solver (which is designed for stiff problems):","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using OrdinaryDiffEqRosenbrock\nsol2 = solve(oprob, Rodas5P())\nplot(sol2)","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"This time the simulation was successfully completed, which can be confirmed by checking the return code:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"sol2.retcode","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Generally, ODE solvers can be divided into explicit and implicit solvers. Roughly, explicit solvers are better for non-stiff problems, with implicit solvers being required for stiff problems. While we could use implicit solvers for all problems (to guarantee successful simulations irrespective of stiffness), these are typically less performant (as compared to the explicit solvers) on equations that are non-stiff. An important property of implicit solvers is that they require the computation of a Jacobian as part of their routine. This means that the various options for efficient Jacobian computation described later in this tutorial are only relevant to implicit solvers.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Finally, we should note that stiffness is not tied to the model equations only. If we change the parameter values of our previous Brusselator model to [:A => 1.0, :B => 4.0], the non-stiff Tsit5 solver can successfully simulate it.","category":"page"},{"location":"model_simulation/ode_simulation_performance/#ode_simulation_performance_solvers","page":"Advice for performant ODE simulations","title":"ODE solver selection","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"OrdinaryDiffEq implements an unusually large number of ODE solvers, with the performance of the simulation heavily depending on which one is chosen. These are provided as the second argument to the solve command, e.g. here we use the Tsit5 solver to simulate a simple birth-death process:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using Catalyst, OrdinaryDiffEqTsit5\n\nbd_model = @reaction_network begin\n    (p,d), 0 <--> X\nend\nu0 = [:X => 0.1]\ntspan = (0.0, 1.0)\nps = [:p => 1.0, :d => 0.2]\n\noprob = ODEProblem(bd_model, u0, tspan, ps)\nsolve(oprob, Tsit5())\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"If no solver argument is provided to solve, and the OrdinaryDiffEqDefault sub-library or meta OrdinaryDiffEq library are loaded, then one is automatically selected:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using OrdinaryDiffEqDefault\nsolve(oprob)\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"While the default choice is typically enough for most single simulations, if performance is important, it can be worthwhile exploring the available solvers to find one that is especially suited for the given problem. A complete list of possible ODE solvers, with advice on optimal selection, can be found here. This section will give some general advice.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"The most important part of solver selection is to select one appropriate for the problem's stiffness. Generally, the Tsit5 solver is good for non-stiff problems, and Rodas5P for stiff problems. For large stiff problems (with many species), FBDF can be a good choice. We can illustrate the impact of these choices by simulating our birth-death process using the Tsit5, Vern7 (an explicit solver yielding low error in the solution), Rodas5P, and FBDF solvers (benchmarking their respective performance using BenchmarkTools.jl):","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using BenchmarkTools \nusing OrdinaryDiffEqTsit5, OrdinaryDiffEqRosenbrock, OrdinaryDiffEqVerner, OrdinaryDiffEqBDF\n@btime solve(oprob, Tsit5())\n@btime solve(oprob, Vern7())\n@btime solve(oprob, Rodas5P())\n@btime solve(oprob, FBDF())","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"If you perform the above benchmarks on your machine, and check the results, you will note that the fastest solver is several times faster than the slowest one (FBDF, which is a poor choice for this ODE).","category":"page"},{"location":"model_simulation/ode_simulation_performance/#ode_simulation_performance_error","page":"Advice for performant ODE simulations","title":"Simulation error, tolerance, and solver selection","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Numerical ODE simulations approximate an ODEs' continuous solutions as discrete vectors. This introduces errors in the computed solution. The magnitude of these errors can be controlled by setting solver tolerances. By reducing the tolerance, solution errors will be reduced, however, this will also increase simulation run times. The (absolute and relative) tolerance of a solver can be tuned through the abstol and reltol arguments. Here we see how run time increases with larger tolerances:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"@btime solve(oprob, Tsit5(); abstol=1e-6, reltol=1e-6)\n@btime solve(oprob, Tsit5(); abstol=1e-12, reltol=1e-12)","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"It should be noted, however, that the result of the second simulation is a lot more accurate. Thus, ODE solver performance cannot be determined solely from run time, but is a composite of run time and error. Benchmarks comparing solver performance (by plotting the run time as a function of the error) for various CRN models can be found in the SciMLBenchmarks repository.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Generally, whether solution error is a consideration depends on the application. If you want to compute the trajectory of an expensive space probe as it is sent from Earth, to slingshot Jupiter, and then reach Pluto a few years later, ensuring a minimal error will be essential. However, if you want to simulate a simple CRN to determine whether it oscillates for a given parameter set, a small error will not constitute a problem. An important aspect with regard to error is that it affects the selection of the optimal solver. E.g. if tolerance is low (generating larger errors) the Rosenbrock23 method performs well for small, stiff, problems (again, more details can be found in OrdinaryDiffEq's documentation).","category":"page"},{"location":"model_simulation/ode_simulation_performance/#ode_simulation_performance_jacobian","page":"Advice for performant ODE simulations","title":"Jacobian computation options for implicit solvers","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"As previously mentioned, implicit ODE solvers require the computation of the system's Jacobian. The reason is (roughly) that, in each time step, these solvers need to solve a non-linear equation to find the simulation's value at the next timestep (unlike explicit solvers, which compute the value at the next time step directly). Typically this is done using the Newton-Raphson method, which requires the Jacobian. Especially for large systems, this can be computationally expensive (and a potential strain on available memory), in which case one might consider various Jacobian-computation options (as described below). A throughout tutorial on simulating a large, stiff, ODE can be found here.","category":"page"},{"location":"model_simulation/ode_simulation_performance/#ode_simulation_performance_symbolic_jacobian","page":"Advice for performant ODE simulations","title":"Building the Jacobian symbolically","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"By default, OrdinaryDiffEq computes the Jacobian using automatic differentiation (however, using finite differences is also possible). Since Catalyst builds its ODEs symbolically, it is able to compute an analytic Jacobian symbolically. Typically, this is only advantageous when you are also using a sparse Jacobian.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"To use this option, simply set jac = true when constructing an ODEProblem:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using Catalyst, OrdinaryDiffEqDefault\n\nbrusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend\nu0 = [:X => 1.0, :Y => 0.0]\ntspan = (0.0, 20.0)\nps = [:A => 10.0, :B => 40.0]\n\noprob = ODEProblem(brusselator, u0, tspan, ps; jac = true)\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/#ode_simulation_performance_sparse_jacobian","page":"Advice for performant ODE simulations","title":"Using a sparse Jacobian","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"For a system with n variables, the Jacobian will be an ntimes n matrix. This means that, as n becomes large, the Jacobian can become very large, potentially causing a significant strain on memory. In these cases, most Jacobian entries are typically 0. This means that a sparse Jacobian (rather than a dense one, which is the default) can be advantageous. To designate sparse Jacobian usage, simply provide the sparse = true option when constructing an ODEProblem:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"oprob = ODEProblem(brusselator, u0, tspan, ps; sparse = true)\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/#ode_simulation_performance_symbolic_jacobian_linear_solver","page":"Advice for performant ODE simulations","title":"Linear solver selection","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"When implicit solvers use e.g. the Newton-Raphson method to (at each simulation time step) solve a (typically non-linear) equation, they actually solve a linearised version of this equation. For this, they use a linear solver, the choice of which can impact performance. To specify one, we use the linsolve option (given to the solver function, not the solve command). E.g. to use the KLUFactorization linear solver (which requires loading the LinearSolve.jl package) we run","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using LinearSolve, OrdinaryDiffEqRosenbrock\nsolve(oprob, Rodas5P(linsolve = KLUFactorization()))\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"A full list of potential linear solvers can be found here. Typically, the default choice performs well.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"A unique approach to the linear solvers is to use a matrix-free Newton-Krylov method. These do not actually compute the Jacobian, but rather the effect of multiplying it with a vector. They are typically advantageous for large systems (with large Jacobians), and can be designated using the KrylovJL_GMRES linear solver:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"solve(oprob, Rodas5P(linsolve = KrylovJL_GMRES()))\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Since these methods do not depend on a Jacobian, certain Jacobian options (such as computing it symbolically) are irrelevant to them.","category":"page"},{"location":"model_simulation/ode_simulation_performance/#ode_simulation_performance_preconditioners","page":"Advice for performant ODE simulations","title":"Designating preconditioners for Jacobian-free linear solvers","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"When an implicit method solves a linear equation through an (iterative) matrix-free Newton-Krylov method, the rate of convergence depends on the numerical properties of the matrix defining the linear system. To speed up convergence, a preconditioner can be applied to both sides of the linear equation, attempting to create an equation that converges faster. Preconditioners are only relevant when using matrix-free Newton-Krylov methods.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"In practice, preconditioners are implemented as functions with a specific set of arguments. How to implement these is non-trivial, and we recommend reading OrdinaryDiffEq's documentation pages here and here. In this example, we will define an Incomplete LU preconditioner (which requires the IncompleteLU.jl package):","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using IncompleteLU\nfunction incompletelu(W, du, u, p, t, newW, Plprev, Prprev, solverdata)\n    if newW === nothing || newW\n        Pl = ilu(convert(AbstractMatrix, W), τ = 50.0)\n    else\n        Pl = Plprev\n    end\n    Pl, nothing\nend\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Next, incompletelu can be supplied to our solver using the precs argument:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"solve(oprob, Rodas5P(linsolve = KrylovJL_GMRES(), precs = incompletelu, concrete_jac = true))\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Finally, we note that when using preconditioners with a matrix-free method (like KrylovJL_GMRES, which is also the only case when these are relevant), the concrete_jac = true argument is required.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Generally, the use of preconditioners is only recommended for advanced users who are familiar with the concepts. However, for large systems, if performance is essential, they can be worth looking into.","category":"page"},{"location":"model_simulation/ode_simulation_performance/#ode_simulation_performance_conservation_laws","page":"Advice for performant ODE simulations","title":"Elimination of system conservation laws","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Previously, we have described how Catalyst, when it generates ODEs, is able to detect and eliminate conserved quantities. In certain cases, doing this can improve performance. E.g. in the following example we will eliminate the single conserved quantity in a two-state model. This results in a differential algebraic equation with a single differential equation and a single algebraic equation (as opposed to two differential equations). However, as the algebraic equation is fully determined by the ODE solution, Catalyst moves it to be an observable and our new system therefore only contains one ODE that must be solved numerically. Conservation laws can be eliminated by providing the remove_conserved = true option to ODEProblem:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using Catalyst, OrdinaryDiffEqTsit5\n\n# Declare model.\nrs = @reaction_network begin\n    (k₁,k₂), X₁ <--> X₂\nend\n\n# Generate and simulate and ODE (while eliminating any conserved quantities).\nu0 = [:X₁ => 2.0, :X₂ => 3.0]\nps = [:k₁ => 1.0, :k₂ => 2.0]\noprob = ODEProblem(rs, u0, (0.0, 10.0), ps; remove_conserved = true)\nsol = solve(oprob)\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Conservation law elimination is not expected to ever impact performance negatively; it simply results in a (possibly) lower-dimensional system of ODEs to solve. However, eliminating conserved species may have minimal performance benefits; it is model-dependent whether elimination results in faster ODE solving times and/or increased solution accuracy.","category":"page"},{"location":"model_simulation/ode_simulation_performance/#ode_simulation_performance_parallelisation","page":"Advice for performant ODE simulations","title":"Parallelisation on CPUs and GPUs","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Whenever an ODE is simulated a large number of times (e.g. when investigating its behaviour for different parameter values), the best way to improve performance is to parallelise the simulation over multiple processing units. Indeed, an advantage of the Julia programming language is that it was designed after the advent of parallel computing, making it well-suited for this task. Roughly, parallelisation can be divided into parallelisation on CPUs and on GPUs. CPU parallelisation is most straightforward, while GPU parallelisation requires specialised ODE solvers (which Catalyst have access to).","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Both CPU and GPU parallelisation require first building an EnsembleProblem (which defines the simulations you wish to perform) and then supplying this with the correct parallelisation options. EnsembleProblems have previously been introduced in Catalyst's documentation (but in the context of convenient bundling of similar simulations, rather than to improve performance), with a more throughout description being found in OrdinaryDiffEq's documentation. Finally, a general documentation of parallel computing in Julia is available here.","category":"page"},{"location":"model_simulation/ode_simulation_performance/#ode_simulation_performance_parallelisation_CPU","page":"Advice for performant ODE simulations","title":"CPU parallelisation","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"For this example (and the one for GPUs), we will consider a modified Michaelis-Menten enzyme kinetics model, which describes an enzyme (E) that converts a substrate (S) to a product (P):","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using Catalyst\nmm_model = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\n    d, S --> ∅\nend","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"The model can be simulated, showing how P is produced from S:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using OrdinaryDiffEqTsit5, Plots\nu0 = [:S => 1.0, :E => 1.0, :SE => 0.0, :P => 0.0]\ntspan = (0.0, 50.0)\nps = [:kB => 1.0, :kD => 0.1, :kP => 0.5, :d => 0.1]\noprob = ODEProblem(mm_model, u0, tspan, ps)\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Due to the degradation of S, if the production rate is not high enough, the total amount of P produced is reduced. For this tutorial, we will investigate this effect for a range of values of kP. This will require a large number of simulations (for various kP values), which we will parallelise on CPUs (this section) and GPUs (next section).","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"To parallelise our simulations, we first need to create an EnsembleProblem. These describe which simulations we wish to perform. The input to this is:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"The ODEProblem corresponds to the model simulation (SDEProblem and JumpProblems can also be supplied, enabling the parallelisation of these problem types).\nA function, prob_func, describing how to modify the problem for each simulation. If we wish to simulate the same, unmodified problem, in each simulation (primarily relevant for stochastic simulations), this argument is not required.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Here, prob_func takes 3 arguments:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"prob: The problem that it modifies at the start of each individual run (which will be the same as EnsembleProblem's first argument).\ni: The index of the specific simulation (in the array of all simulations that are performed).\nrepeat: The repeat of a specific simulation in the array. We will not use this option in this example, however, it is discussed in more detail here.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"and output the ODEProblem simulated in the i'th simulation.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Let us assume that we wish to simulate our model 100 times, for kP = 001 002  099 10. We define our prob_func using remake:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"function prob_func(prob, i, repeat)\n    return remake(prob; p = [:kP => 0.01*i])\nend\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Next, we can create our EnsembleProblem:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"eprob = EnsembleProblem(oprob; prob_func)\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"We can now solve our ODEProblem using the same syntax we would normally use to solve the original ODEProblem, with the exception that an additional argument, trajectories, is required (which denotes how many simulations should be performed).","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"esol = solve(eprob, Tsit5(); trajectories = 100)\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"To access the i'th solution we use esol.u[i]. To e.g. plot the 47'th solution we use:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"plot(esol.u[47])","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"To extract the amount of P produced in each simulation, and plot this against the corresponding kP value, we can use:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"plot(0.01:0.01:1.0, map(sol -> sol[:P][end], esol.u), xguide = \"kP\", yguide = \"P produced\", label=\"\")\nplot!(left_margin = 3Plots.Measures.mm) # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Above, we have simply used EnsembleProblem as a convenient interface to run a large number of similar simulations. However, these problems have the advantage that they allow the passing of an ensemble algorithm to the solve command, which describes a strategy for parallelising the simulations. By default, EnsembleThreads is used. This parallelises the simulations using multithreading (parallelisation within a single process), which is typically advantageous for small problems on shared memory devices. An alternative is EnsembleDistributed which instead parallelises the simulations using multiprocessing (parallelisation across multiple processes). To do this, we simply supply this additional solver to the solve command:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"esol = solve(eprob, Tsit5(), EnsembleDistributed(); trajectories = 100)","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"To utilise multiple processes, you must first give Julia access to these. You can check how many processes are available using the nprocs (which requires the Distributed.jl package):","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using Distributed\nnprocs()","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Next, more processes can be added using addprocs. E.g. here we add an additional 4 processes:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"addprocs(4)","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Powerful personal computers and HPC clusters typically have a large number of available additional processes that can be added to improve performance.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"While EnsembleThreads and EnsembleDistributed cover the main cases, additional ensemble algorithms exist. A more throughout description of these can be found here.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Finally, it should be noted that OrdinaryDiffEq, if additional processes are available, automatically parallelises the linear solve part of implicit simulations. It is thus possible to see performance improvements from adding additional processes when running single simulations, not only multiple parallelised ones (this effect is primarily noticeable for large systems with many species).","category":"page"},{"location":"model_simulation/ode_simulation_performance/#ode_simulation_performance_parallelisation_GPU","page":"Advice for performant ODE simulations","title":"GPU parallelisation","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"GPUs are different from CPUs in that they are much more restricted in what computations they can carry out. However, unlike CPUs, they are typically available in far larger numbers. Their original purpose is for rendering graphics (which typically involves solving a large number of very simple computations, something CPUs with their few, but powerful, cores are unsuited for). Recently, they have also started to be applied to other problems, such as ODE simulations. Generally, GPU parallelisation is only worthwhile when you have a very large number of parallel simulations to run (and access to good GPU resources, either locally or on a cluster).","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Generally, we can parallelise EnsembleProblems across several GPUs in a very similar manner to how we parallelised them across several CPUs, but by using a different ensemble algorithm (such as EnsembleGPUArray). However, there are some additional requirements:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"GPU parallelisation requires the DiffEqGPU.jl package.\nDepending on which GPU hardware is used, a specific back-end package has to be installed and imported (e.g. CUDA for NVIDIA's GPUs or Metal for Apple's).\nFor some cases, we must use a special ODE solver supporting simulations on GPUs.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Furthermore (while not required) to receive good performance, we should also make the following adaptations:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"By default, Julia's decimal numbers are implemented as Float64s, however, using Float32s is advantageous on GPUs. Ideally, all initial conditions and parameter values should be specified using these.\nWe should designate all our vectors (i.e. initial conditions and parameter values) as static vectors.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"We will assume that we are using the CUDA GPU hardware, so we will first load the CUDA.jl backend package, as well as DiffEqGPU:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using CUDA, DiffEqGPU","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Which backend package you should use depends on your available hardware, with the alternatives being listed here.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Next, we declare our model and ODEProblem. However, we make all values Float64 (by appending f0 to them) and all vectors static (by adding @SVector before their declaration, something which requires the StaticArrays package).","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"using Catalyst, OrdinaryDiffEqDefault, StaticArrays\n\nmm_model = @reaction_network begin\n    kB, S + E --> SE\n    kD, SE --> S + E\n    kP, SE --> P + E\n    d, S --> ∅\nend\n@unpack S, E, SE, P, kB, kD, kP, d = mm_model\n\nusing OrdinaryDiffEqDefault, Plots\nu0 = @SVector [S => 1.0f0, E => 1.0f0, SE => 0.0f0, P => 0.0f0]\ntspan = (0.0f0, 50.0f0)\np = @SVector [kB => 1.0f0, kD => 0.1f0, kP => 0.5f0, d => 0.1f0]\noprob = ODEProblem(mm_model, u0, tspan, p)\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"When we declare our prob_func and EnsembleProblem we need to ensure that the updated ODEProblem uses Float32:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"function prob_func(prob, i, repeat)\n    return remake(prob; p = [:kP => 0.0001f0*i])\nend\neprob = EnsembleProblem(oprob; prob_func = prob_func)\nnothing # hide","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Here have we increased the number of simulations to 10,000, since this is a more appropriate number for GPU parallelisation (as compared to the 100 simulations we performed in our CPU example).","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"note: Note\nCurrently, declaration of static vectors requires symbolic, rather than symbol, form for species and parameters. Hence, we here first @unpack these before constructing u0 and ps using @SVector.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"We can now simulate our model using a GPU-based ensemble algorithm. Currently, two such algorithms are available, EnsembleGPUArray and EnsembleGPUKernel. Their differences are that","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Only EnsembleGPUKernel requires arrays to be static arrays (although it is still advantageous for EnsembleGPUArray).\nWhile EnsembleGPUArray can use standard ODE solvers, EnsembleGPUKernel requires specialised versions (such as GPUTsit5). A list of available such solvers can be found here.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Generally, it is recommended to use EnsembleGPUArray for large models (that have at least 100 variables), and EnsembleGPUKernel for smaller ones. Here we simulate our model using both approaches (noting that EnsembleGPUKernel requires GPUTsit5):","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"esol1 = solve(eprob, Tsit5(), EnsembleGPUArray(CUDA.CUDABackend()); trajectories = 10000)\nesol2 = solve(eprob, GPUTsit5(), EnsembleGPUKernel(CUDA.CUDABackend()); trajectories = 10000)","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Note that we have to provide the CUDA.CUDABackend() argument to our ensemble algorithms (to designate our GPU backend, in this case, CUDA).","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"Just like OrdinaryDiffEq is able to utilise parallel CPU processes to speed up the linear solve part of ODE simulations, GPUs can also be used. More details on this can be found here. This is only recommended when ODEs are very large (at least 1,000 species), which is typically not the case for CRNs.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"For more information on differential equation simulations on GPUs in Julia, please read DiffEqGPU's documentation. Furthermore, if performance is critical, this tutorial provides information on how to redesign your simulation code to make it more suitable for GPU simulations.","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"","category":"page"},{"location":"model_simulation/ode_simulation_performance/#Citation","page":"Advice for performant ODE simulations","title":"Citation","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"If you use GPU simulations in your research, please cite the following paper to support the authors of the DiffEqGPU package:","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"@article{utkarsh2024automated,\n  title={Automated translation and accelerated solving of differential equations on multiple GPU platforms},\n  author={Utkarsh, Utkarsh and Churavy, Valentin and Ma, Yingbo and Besard, Tim and Srisuma, Prakitr and Gymnich, Tim and Gerlach, Adam R and Edelman, Alan and Barbastathis, George and Braatz, Richard D and others},\n  journal={Computer Methods in Applied Mechanics and Engineering},\n  volume={419},\n  pages={116591},\n  year={2024},\n  publisher={Elsevier}\n}","category":"page"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"","category":"page"},{"location":"model_simulation/ode_simulation_performance/#References","page":"Advice for performant ODE simulations","title":"References","text":"","category":"section"},{"location":"model_simulation/ode_simulation_performance/","page":"Advice for performant ODE simulations","title":"Advice for performant ODE simulations","text":"[1]: E. Hairer, G. Wanner, Solving Ordinary Differential Equations II, Springer (1996).","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/#bifurcation_diagrams","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"","category":"section"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Bifurcation diagrams describe how, for a dynamical system, the quantity and type of its steady states change as a parameter is varied[1]. When using Catalyst-generated models, these can be computed with the BifurcationKit.jl package. Catalyst provides a simple interface for creating BifurcationKit compatible BifurcationProblems from ReactionSystems.","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"This tutorial briefly introduces how to use Catalyst with BifurcationKit through basic examples, with BifurcationKit.jl providing a more extensive documentation. Especially for more complicated systems, where careful tuning of algorithm options might be required, reading the BifurcationKit documentation is recommended. Finally, BifurcationKit provides many additional features not described here, including computation of periodic orbits, tracking of bifurcation points along secondary parameters, and bifurcation computations for PDEs.","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/#Basic-example","page":"Bifurcation Diagrams","title":"Basic example","text":"","category":"section"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"For this example, we will use a modified version of the model from Wilhelm (2009)[2] (which demonstrates a bistable switch as the parameter k1 is varied). We declare the model using Catalyst:","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using Catalyst\nwilhelm_2009_model = @reaction_network begin\n    k1, Y --> 2X\n    k2, 2X --> X + Y\n    k3, X + Y --> Y\n    k4, X --> 0\n    k5, 0 --> X\nend","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Next we will create a BifurcationProblem. In addition to the ReactionSystem, we need to provide:","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"The bifurcation parameter (the parameter which is varied in the bifurcation diagram).\nA full model parameter set. This includes the values of all non-bifurcation parameters, but also a value for the bifurcation parameter (which corresponds to the point in parameter space from which the computation of the bifurcation diagram starts).\nAn initial guess of the steady state values of the system at the provided parameter set. Using this point as a starting guess for root finding, BifurcationKit calculates an initial steady state from which to compute the bifurcation diagram. Hence, this guess does not need to be very exact (but may be important if the system exhibits multistability for the initial parameter set).\nThe species or statistic we wish to plot on the y-axis of the bifurcation diagram (a custom value can be provided by using the record_from_solution argument).","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"We combine all this information to form a BifurcationProblem:","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using BifurcationKit\nbif_par = :k1\nu_guess = [:X => 5.0, :Y => 2.0]\np_start = [:k1 => 4.0, :k2 => 1.0, :k3 => 1.0, :k4 => 1.5, :k5 => 1.25]\nplot_var = :X\nbprob = BifurcationProblem(wilhelm_2009_model, u_guess, p_start, bif_par; plot_var=plot_var)\nnothing # hide","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"BifurcationKit computes bifurcation diagrams using the bifurcationdiagram function. From an initial point in the diagram, it tracks the solution (using a continuation algorithm) until the entire diagram is computed (BifurcationKit's continuation can be used for other purposes, however, this tutorial focuses on bifurcation diagram computation). The continuation settings are provided in a ContinuationPar structure. In this example, we will only specify three settings, p_min and p_max (which sets the minimum and maximum values over which the bifurcation parameter is varied) and max_steps (the maximum number of continuation steps to take as the bifurcation diagram is tracked). We wish to compute a bifurcation diagram over the interval (20200), and will use the following settings:","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"p_span = (2.0, 20.0)\nopts_br = ContinuationPar(p_min = p_span[1], p_max = p_span[2], max_steps = 1000)\nnothing # hide","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Finally, we compute our bifurcation diagram using:","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"bif_dia = bifurcationdiagram(bprob, PALC(), 2, opts_br; bothside = true)\nnothing # hide","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Where PALC() designates that we wish to use the pseudo arclength continuation method to track our solution. The third argument (2) designates the maximum number of recursions when branches of branches are computed (branches appear as continuation encounters certain bifurcation points). For diagrams with highly branched structures (rare for many common small chemical reaction networks) this input is important. Finally, bothside = true designates that we wish to perform continuation on both sides of the initial point (which is typically the case). ","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"We can plot our bifurcation diagram using the Plots.jl package:","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using Plots\nplot(bif_dia; xguide = \"k1\", yguide = \"X\")","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Here, the steady state concentration of X is shown as a function of k1's value. Stable steady states are shown with thick lines, unstable ones with thin lines. The two fold bifurcation points are marked with \"bp\".","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/#Additional-ContinuationPar-options","page":"Bifurcation Diagrams","title":"Additional ContinuationPar options","text":"","category":"section"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Most of the options required by the bifurcationdiagram function are provided through the ContinuationPar structure. For full details, please read the BifurcationKit documentation. However, a few common options, and how they affect the continuation computation, are described here:","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"p_min and p_max: Set the interval over which the bifurcation diagram is computed (with the continuation stopping if it reaches these bounds).\ndsmin and dsmax: The minimum and maximum length of the continuation steps (in the bifurcation parameter's value).\nmax_steps: The maximum number of continuation steps. If a bifurcation diagram looks incomplete, try increasing this value.\nnewton_options: Options for the Newton's method that BifurcationKit uses to find steady states. This can be created using NewtonPar(tol = 1e-9, max_iterations = 100) which here sets the tolerance (to 1e-9) and the maximum number of newton iterations (to 100).","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"The previous bifurcation diagram can be computed, with these various options specified, in the following way:","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"p_span = (2.0, 20.0)\nopt_newton = NewtonPar(tol = 1e-9, max_iterations = 1000)\nopts_br = ContinuationPar(p_min = p_span[1], p_max = p_span[2], \n                          dsmin = 0.001, dsmax = 0.01, max_steps = 1000,\n                          newton_options = opt_newton)\nbif_dia = bifurcationdiagram(bprob, PALC(), 2, opts_br; bothside = true)\nnothing # hide","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"(however, in this case these additional settings have no significant effect on the result)","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/#Bifurcation-diagrams-with-disjoint-branches","page":"Bifurcation Diagrams","title":"Bifurcation diagrams with disjoint branches","text":"","category":"section"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Let's consider the previous case, but instead compute the bifurcation diagram over the interval (20150):","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"p_span = (2.0, 15.0)\nopts_br = ContinuationPar(p_min = p_span[1], p_max = p_span[2], max_steps = 1000)\nbif_dia = bifurcationdiagram(bprob, PALC(), 2, opts_br; bothside = true)\nplot(bif_dia; xguide = \"k1\", yguide = \"X\")","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Here, in the bistable region, we only see a single branch. The reason is that the continuation algorithm starts at our initial guess (here made at k1 = 40 for (XY) = (5020)) and tracks the diagram from there. However, with the upper bound set at k1=150 the bifurcation diagram has a disjoint branch structure, preventing the full diagram from being computed by continuation alone. In this case it could be solved by increasing the bound from k1=150, however, this is not possible in all cases. In these cases, deflation can be used. This is described in the BifurcationKit documentation.","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/#Systems-with-conservation-laws","page":"Bifurcation Diagrams","title":"Systems with conservation laws","text":"","category":"section"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Some systems are under-determined at steady state, so that for a given parameter set they have an infinite number of possible steady state solutions, preventing bifurcation diagrams from being computed. Similar to when we compute steady states for fixed parameter values, we can utilise Catalyst's ability to detect and eliminate conservation laws to resolve this issue. This requires us to provide information of the species concentrations at which we wish to compute the bifurcation diagram (to determine the values of conserved quantities). These are provided to the BifurcationProblem using the u0 argument.","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"To illustrate this, we will create a simple model of a kinase that is produced and degraded (at rates p and d). The kinase facilitates the phosphorylation of a protein (X), which is dephosphorylated at a constant rate. For this system, we will compute a bifurcation diagram, showing how the concentration of the phosphorylated protein (Xp) depends on the degradation rate of the kinase (d). We will set the total amount of protein (X+Xp) to 10.","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using BifurcationKit, Catalyst, Plots\nkinase_model = @reaction_network begin\n    (p, d), 0 <--> K\n    (K*kP,kD), X <--> Xp\nend\n\nu_guess = [:K => 1.0, :X => 1.0, :Xp => 1.0]\np_start = [:p => 1.0, :d => 0.5, :kP => 2.0, :kD => 5.0]\nu0 = [:X => 1.0, :Xp => 0.0]\nbprob = BifurcationProblem(kinase_model, u_guess, p_start, :d; plot_var = :Xp, u0)\n\np_span = (0.1, 10.0)\nopts_br = ContinuationPar(p_min = p_span[1], p_max = p_span[2], max_steps = 1000)\nbif_dia = bifurcationdiagram(bprob, PALC(), 2, opts_br; bothside = true)\nplot(bif_dia; xguide = \"d\", yguide = \"Xp\")","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"This bifurcation diagram does not contain any interesting features (such as bifurcation points), and only shows how the steady state concentration of Xp is reduced as d increases. ","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Finally, for additional clarity, we reiterate the purpose of the two u arguments used:","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"u_guess: A guess of the initial steady states (which BifurcationKit uses to find its starting point). Typically, most trivial guesses work (e.g. setting all species concentrations to 1.0). u_guess does not have to fulfill the conserved concentrations provided in u0.\nu0: Used to compute the concentrations of any conserved quantities (e.g. in our example X + Xp = 10). Technically, values are only required for species that are involved in conservation laws (in our case we do not need to provide a value for K). However, sometimes determining which species are actually involved in conservation laws can be difficult, and it might be easier to simply provide concentrations for all species.","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/#bifurcation_kit_citation","page":"Bifurcation Diagrams","title":"Citation","text":"","category":"section"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"If you use this functionality in your research, please cite the following paper to support the author of the BifurcationKit package:","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"@misc{veltz:hal-02902346,\n  title = {{BifurcationKit.jl}},\n  author = {Veltz, Romain},\n  url = {https://hal.archives-ouvertes.fr/hal-02902346},\n  institution = {{Inria Sophia-Antipolis}},\n  year = {2020},\n  month = Jul,\n  keywords = {pseudo-arclength-continuation ; periodic-orbits ; floquet ; gpu ; bifurcation-diagram ; deflation ; newton-krylov},\n  pdf = {https://hal.archives-ouvertes.fr/hal-02902346/file/354c9fb0d148262405609eed2cb7927818706f1f.tar.gz},\n  hal_id = {hal-02902346},\n  hal_version = {v1},\n}","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/#References","page":"Bifurcation Diagrams","title":"References","text":"","category":"section"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"[1]: Yuri A. Kuznetsov, Elements of Applied Bifurcation Theory, Springer (2023).","category":"page"},{"location":"steady_state_functionality/bifurcation_diagrams/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"[2]: Thomas Wilhelm, The smallest chemical reaction system with bistability, BMC Systems Biology (2009).","category":"page"},{"location":"inverse_problems/behaviour_optimisation/#behaviour_optimisation","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"","category":"section"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"In previous tutorials we have described how to use PEtab.jl and Optimization.jl for parameter fitting. This involves solving an optimisation problem (to find the parameter set yielding the best model-to-data fit). There are, however, other situations that require solving optimisation problems. Typically, these involve the creation of a custom objective function, which minimizer can then be found using Optimization.jl. In this tutorial we will describe this process, demonstrating how parameter space can be searched to find values that achieve a desired system behaviour. Many options used here are described in more detail in the tutorial on using Optimization.jl for parameter fitting. A more throughout description of how to solve these problems is provided by Optimization.jl's documentation and the literature[1].","category":"page"},{"location":"inverse_problems/behaviour_optimisation/#behaviour_optimisation_IFFL_example","page":"Optimization for non-data fitting purposes","title":"Maximising the pulse amplitude of an incoherent feed forward loop","text":"","category":"section"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"Incoherent feedforward loops (network motifs where a single component both activates and deactivates a downstream component) are able to generate pulses in response to step inputs[2]. In this tutorial we will consider such an incoherent feedforward loop, attempting to generate a system with as prominent a response pulse as possible.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"Our model consists of 3 species: X (the input node), Y (an intermediary), and Z (the output node). In it, X activates the production of both Y and Z, with Y also deactivating Z. When X is activated, there will be a brief time window where Y is still inactive, and Z is activated. However, as Y becomes active, it will turn Z off. This creates a pulse of Z activity. To trigger the system, we create an event, which increases the production rate of X (pX) by a factor of 10 at time t = 10.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"using Catalyst\nincoherent_feed_forward = @reaction_network begin\n    @discrete_events [10.0] => [pX ~ 10*pX]\n    pX, 0 --> X\n    pY*X, 0 --> Y\n    pZ*X/Y, 0 --> Z\n    1.0, (X,Y,Z) --> 0\nend","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"To demonstrate this pulsing behaviour we will simulate the system for an example parameter set. We select an initial condition (u0) so the system begins in a steady state.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"using OrdinaryDiffEqDefault, Plots\nexample_p = [:pX => 0.1, :pY => 1.0, :pZ => 1.0]\ntspan = (0.0, 50.0)\nexample_u0 = [:X => 0.1, :Y => 0.1, :Z => 1.0]\n\noprob = ODEProblem(incoherent_feed_forward, example_u0, tspan, example_p)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"Here we note that, while X and Y reach new steady state levels in response to the increase in pX, Z resumes to its initial concentration after the pulse.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"We will now attempt to find the parameter set (pXpYpZ) which maximises the response pulse amplitude (defined by the maximum activity of Z subtracted by its steady state activity). To do this, we create a custom objective function:","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"function pulse_amplitude(p, _)\n    p = Dict([:pX => p[1], :pY => p[2], :pZ => p[2]])\n    u0 = [:X => p[:pX], :Y => p[:pX]*p[:pY], :Z => p[:pZ]/p[:pY]^2]\n    oprob_local = remake(oprob; u0, p)\n    sol = solve(oprob_local; verbose = false, maxiters = 10000)\n    SciMLBase.successful_retcode(sol) || return Inf\n    return -(maximum(sol[:Z]) - sol[:Z][1])\nend\nnothing # hide","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"This objective function takes two arguments (a parameter value p, and an additional one which we will ignore but is discussed in a note here). It first calculates the new initial steady state concentration for the given parameter set. Next, it creates an updated ODEProblem using the steady state as initial conditions and the, to the objective function provided, input parameter set.  Finally, Optimization.jl finds the function's minimum value, so to find the maximum relative pulse amplitude, we make our objective function return the negative pulse amplitude.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"As described in our tutorial on parameter fitting using Optimization.jl we use remake, verbose = false, maxiters = 10000, and a check on the simulations return code, all providing various advantages to the optimisation procedure (as explained in that tutorial).","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"Just like for parameter fitting, we create an OptimizationProblem using our objective function, and some initial guess of the parameter values. We also set upper and lower bounds for each parameter using the lb and ub optional arguments (in this case limiting each parameter's value to the interval (01100)).","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"using Optimization\ninitial_guess = [1.0, 1.0, 1.0]\nopt_prob = OptimizationProblem(pulse_amplitude, initial_guess; lb = [1e-1, 1e-1, 1e-1], ub = [1e1, 1e1, 1e1])\nnothing # hide","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"note: Note\nAs described in a previous section on Optimization.jl, OptimizationProblems do not support setting parameter values using maps. We must instead set initial_guess values using a vector. Next, in the first line of our objective function, we reshape the parameter values to the common form used across Catalyst (e.g. [:pX => p[1], :pY => p[2], :pZ => p[2]], however, here we use a dictionary to easier compute the steady state initial condition). We also note that the order used in this array corresponds to the order we give each parameter's bounds in lb and ub, and the order in which their values occur in the output solution.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"As previously described, Optimization.jl supports a wide range of optimisation algorithms. Here we use one from BlackBoxOptim.jl:","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"using OptimizationBBO\nopt_sol = solve(opt_prob, BBO_adaptive_de_rand_1_bin_radiuslimited())\nnothing # hide","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"Finally, we plot a simulation using the found parameter set (stored in opt_sol.u):","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"ps_res = Dict([:pX => opt_sol.u[1], :pY => opt_sol.u[2], :pZ => opt_sol.u[2]])\nu0_res = [:X => ps_res[:pX], :Y => ps_res[:pX]*ps_res[:pY], :Z => ps_res[:pZ]/ps_res[:pY]^2]\noprob_res = remake(oprob; u0 = u0_res, p = ps_res)\nsol_res = solve(oprob_res)\nplot(sol_res; idxs = :Z)","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"For this model, it turns out that Z's maximum pulse amplitude is equal to twice its steady state concentration. Hence, the maximisation of its pulse amplitude is equivalent to maximising its steady state concentration.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/#behaviour_optimisation_options","page":"Optimization for non-data fitting purposes","title":"Other optimisation options","text":"","category":"section"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"How to use Optimization.jl is discussed in more detail in this tutorial. This includes options such as using automatic differentiation, setting constraints, and setting optimisation solver options. Finally, it discusses the advantages of carrying out the fitting in logarithmic space, something which can be advantageous for the problem described above as well.","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"","category":"page"},{"location":"inverse_problems/behaviour_optimisation/#structural_identifiability_citation","page":"Optimization for non-data fitting purposes","title":"Citation","text":"","category":"section"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"If you use this functionality in your research, please cite the following paper to support the authors of the Optimization.jl package:","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"@software{vaibhav_kumar_dixit_2023_7738525,\n\tauthor = {Vaibhav Kumar Dixit and Christopher Rackauckas},\n\tmonth = mar,\n\tpublisher = {Zenodo},\n\ttitle = {Optimization.jl: A Unified Optimization Package},\n\tversion = {v3.12.1},\n\tdoi = {10.5281/zenodo.7738525},\n  \turl = {https://doi.org/10.5281/zenodo.7738525},\n\tyear = 2023\n}","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"","category":"page"},{"location":"inverse_problems/behaviour_optimisation/#References","page":"Optimization for non-data fitting purposes","title":"References","text":"","category":"section"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"[1]: Mykel J. Kochenderfer, Tim A. Wheeler Algorithms for Optimization, The MIT Press (2019).","category":"page"},{"location":"inverse_problems/behaviour_optimisation/","page":"Optimization for non-data fitting purposes","title":"Optimization for non-data fitting purposes","text":"[2]: Lea Goentoro, Oren Shoval, Marc W Kirschner, Uri Alon The incoherent feedforward loop can provide fold-change detection in gene regulation, Molecular Cell (2009).","category":"page"},{"location":"model_creation/chemistry_related_functionality/#chemistry_functionality","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"While Catalyst has primarily been designed around the modelling of biological systems, reaction network models are also common in chemistry. This section describes two types of functionality, that while of general interest, should be especially useful in the modelling of chemical systems.","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"The @compound option, which enables the user to designate that a specific species is composed of certain subspecies.\nThe balance_reaction function, which enables the user to balance a reaction so the same number of components occur on both sides.","category":"page"},{"location":"model_creation/chemistry_related_functionality/#chemistry_functionality_compounds","page":"Chemistry-related functionality","title":"Modelling with compound species","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/#Creating-compound-species-programmatically","page":"Chemistry-related functionality","title":"Creating compound species programmatically","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"We will first show how to create compound species through programmatic model construction, and then demonstrate using the DSL. To create a compound species, use the @compound macro, first designating the compound, followed by its components (and their stoichiometries). In this example, we will create a CO₂ molecule, consisting of one C atom and two O atoms. First, we create species corresponding to the components:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"using Catalyst\nt = default_t()\n@species C(t) O(t)\nnothing # hide","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Next, we create the CO2 compound species:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@compound CO2 ~ C + 2O","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Here, the compound is the first argument to the macro, followed by its component (with the left-hand and right-hand sides separated by a ~ sign). While non-compound species (such as C and O) have their independent variable (in this case t) designated, independent variables are generally not designated for compounds (these are instead directly inferred from their components). Components with non-unitary stoichiometries have this value written before the component (generally, the rules for designating the components of a compound are identical to those of designating the substrates or products of a reaction). The created compound, CO2, is also a species, and can be used wherever e.g. C can be used:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"isspecies(CO2)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"In its metadata, however, is stored information of its components, which can be retrieved using the components (returning a vector of its component species) and coefficients (returning a vector with each component's stoichiometry) functions:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"components(CO2)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"coefficients(CO2)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Alternatively, we can retrieve the components and their stoichiometric coefficients as a single vector using the component_coefficients function:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"component_coefficients(CO2)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Finally, it is possible to check whether a species is a compound using the iscompound function:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"iscompound(CO2)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Compound components that are also compounds are allowed, e.g. we can create a carbonic acid compound (H₂CO₃) that consists of CO₂ and H₂O:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@species H(t)\n@compound H2O ~ 2H + O\n@compound H2CO3 ~ CO2 + H2O","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"When multiple compounds are created, they can be created simultaneously using the @compounds macro, e.g. the previous code-block can be re-written as:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@species H(t)\n@compounds begin\n    H2O ~ 2H + O\n    H2CO3 ~ CO2 + H2O\nend","category":"page"},{"location":"model_creation/chemistry_related_functionality/#Creating-compound-species-within-the-DSL","page":"Chemistry-related functionality","title":"Creating compound species within the DSL","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"It is also possible to declare species as compound species within the @reaction_network DSL, using the @compounds options:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"rn = @reaction_network begin\n    @species C(t) H(t) O(t)\n    @compounds begin\n        C2O ~ C + 2O\n        H2O ~ 2H + O\n        H2CO3 ~ CO2 + H2O\n    end\n    (k1,k2), H2O + CO2 <--> H2CO3\nend","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"When creating compound species using the DSL, it is important to note that every component must be known to the system as a species, either by being declared using the @species or @compound options, or by appearing in a reaction. E.g. the following is not valid","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"rn = @reaction_network begin\n    @compounds begin\n        C2O ~ C + 2O\n        H2O ~ 2H + O\n        H2CO3 ~ CO2 + H2O\n    end\n    (k1,k2), H2O+ CO2 <--> H2CO3\nend","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"as the components C, H, and O are not declared as species anywhere. Please also note that only @compounds can be used as an option in the DSL, not @compound.","category":"page"},{"location":"model_creation/chemistry_related_functionality/#Designating-metadata-and-default-values-for-compounds","page":"Chemistry-related functionality","title":"Designating metadata and default values for compounds","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Just like for normal species, it is possible to designate metadata and default values for compounds. Metadata is provided after the compound name, but separated from it by a ,:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@compound (CO2, [unit=\"mol\"]) ~ C + 2O\nnothing # hide","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Default values are designated using =, and provided directly after the compound name.:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@compound (CO2 = 2.0) ~ C + 2O\nnothing # hide","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"If both default values and meta data are provided, the metadata is provided after the default value:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"@compound (CO2 = 2.0, [unit=\"mol\"]) ~ C + 2O\nnothing # hide","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"In all of these cases, the left-hand side must be enclosed within ().","category":"page"},{"location":"model_creation/chemistry_related_functionality/#Compounds-with-multiple-independent-variables","page":"Chemistry-related functionality","title":"Compounds with multiple independent variables","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"While we generally do not need to specify independent variables for compound, if the components (together) have more than one independent variable, this must be done:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"t = default_t()\n@parameters s\n@species N(s) O(t) \n@compound NO2(t,s) ~ N + 2O","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Here, NO2 depend both on a spatial independent variable (s) and a time one (t). This is required since, while multiple independent variables can be inferred, their internal order cannot (and must hence be provided by the user).","category":"page"},{"location":"model_creation/chemistry_related_functionality/#Balancing-chemical-reactions","page":"Chemistry-related functionality","title":"Balancing chemical reactions","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"One use of defining a species as a compound is that they can be used to balance reactions so that the number of components are the same on both sides. Catalyst provides the balance_reaction function, which takes a reaction, and returns a balanced version. E.g. let us consider a reaction when carbon dioxide is formed from carbon and oxide C + O --> CO2. Here, balance_reaction enables us to find coefficients creating a balanced reaction (in this case, where the number of carbon and oxygen atoms are the same on both sides). To demonstrate, we first created the unbalanced reactions:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"rx = @reaction k, C + O --> $CO2","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Here, the reaction rate (k) is not involved in the reaction balancing. We use interpolation for CO2, ensuring that the CO2 used in the reaction is the same one we previously defined as a compound of C and O. Next, we call the balance_reaction function","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"balance_reaction(rx)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"which correctly finds the (rather trivial) solution C + 2O --> CO2. Here we note that balance_reaction actually returns a vector. The reason is that, in some cases, the reaction balancing problem does not have a single obvious solution. Typically, a single solution is the obvious candidate (in which case this is the vector's only element). However, when this is not the case, the vector instead contain several reactions (from which a balanced reaction cab be generated).","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Let us consider a more elaborate example, the reaction between ammonia (NH₃) and oxygen (O₂) to form nitrogen monoxide (NO) and water (H₂O). Let us first create the components and the unbalanced reaction:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"using Catalyst # hide\nt = default_t()\n@species N(t) H(t) O(t) \n@compounds begin\n    NH3 ~ N + 3H\n    O2 ~ 2O\n    NO ~ N + O\n    H2O ~ 2H + O\nend\nunbalanced_reaction = @reaction k, $NH3 + $O2 --> $NO + $H2O","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"We can now create a balanced version (where the amount of H, N, and O is the same on both sides):","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"balanced_reaction = balance_reaction(unbalanced_reaction)[1]","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Reactions declared as a part of a ReactionSystem (e.g. using the DSL) can be retrieved for balancing using the reactions function. Please note that balancing these will not mutate the ReactionSystem, but a new reaction system will need to be created using the balanced reactions.","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"note: Note\nReaction balancing is currently not supported for reactions involving compounds of compounds.","category":"page"},{"location":"model_creation/chemistry_related_functionality/#Balancing-full-systems","page":"Chemistry-related functionality","title":"Balancing full systems","text":"","category":"section"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"It is possible to balance all the reactions of a reaction system simultaneously using the balance_system function. Here, the output is a new system, where all reactions are balanced. E.g. We can use it to balance this system of methane formation/combustion:","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"rs = @reaction_network begin\n    @species C(t) O(t) H(t)\n    @compounds begin\n        H2(t) ~ 2H\n        CH4(t) ~ C + 4H\n        O2(t) ~ 2O\n        CO2(t) ~ C + 2O\n        H2O(t) ~ 2H + O\n    end\n    1.0, C + H2 --> CH4\n    2.0, CH4 + O2 --> CO2 + H2O\nend\nrs_balanced = balance_system(rs)","category":"page"},{"location":"model_creation/chemistry_related_functionality/","page":"Chemistry-related functionality","title":"Chemistry-related functionality","text":"Except for the modified reaction stoichiometries, the new system is identical to the previous one.","category":"page"},{"location":"spatial_modelling/spatial_ode_simulations/#spatial_lattice_ode_simulations","page":"Spatial ODE simulations","title":"Spatial ODE simulations","text":"","category":"section"},{"location":"spatial_modelling/spatial_ode_simulations/","page":"Spatial ODE simulations","title":"Spatial ODE simulations","text":"Our introduction to spatial lattice simulations has already provided an extensive description of how to simulate LatticeReactionSystems using ODEs. Further tutorials have also shown how to retrieve values from simulations and or how to plot them. Here we will build on this, primarily discussing strategies for increasing ODE simulation performance. This is especially important for spatial simulations, as these typically are more computationally demanding as compared to non-spatial ones. While focusing on non-spatial simulations, this ODE performance tutorial is also be useful to read.","category":"page"},{"location":"spatial_modelling/spatial_ode_simulations/#spatial_lattice_ode_simulations_solvers","page":"Spatial ODE simulations","title":"Solver selection for spatial ODE simulations","text":"","category":"section"},{"location":"spatial_modelling/spatial_ode_simulations/","page":"Spatial ODE simulations","title":"Spatial ODE simulations","text":"Previously we have described how to select ODE solvers, and how this can impact simulation performance. This is especially relevant for spatial simulations. For stiff problems, FBDF is a good first solver to try. For non-stiff problems, ROCK2 is instead a good first alternative. However, it is still worthwhile to explore a range of alternative solvers.","category":"page"},{"location":"spatial_modelling/spatial_ode_simulations/#spatial_lattice_ode_simulations_jacobians","page":"Spatial ODE simulations","title":"Jacobian options for spatial ODE simulations","text":"","category":"section"},{"location":"spatial_modelling/spatial_ode_simulations/","page":"Spatial ODE simulations","title":"Spatial ODE simulations","text":"We have previously described how, when implicit solvers are used to solve stiff ODEs, the strategy for computing the system Jacobian is important. This is especially the case for spatial simulations, where the Jacobian often is large and highly sparse. Catalyst implements special methods for spatial Jacobians. To utilise these, provide the jac = true argument to your ODEProblem when it is created (if jac = false, which is the default, automatic differentiation will be used for Jacobian computation). Here we simulate a Brusselator while designating to use Catalyst's computed Jacobian:","category":"page"},{"location":"spatial_modelling/spatial_ode_simulations/","page":"Spatial ODE simulations","title":"Spatial ODE simulations","text":"using Catalyst, OrdinaryDiffEqBDF\nbrusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend\ndiffusion_rx = @transport_reaction D X\nlattice = CartesianGrid((20,20))\nlrs = LatticeReactionSystem(brusselator, [diffusion_rx], lattice)\n\nu0 = [:X => rand(20, 20), :Y => 10.0]\ntspan = (0.0, 1.0)\nps = [:A => 1.0, :B => 4.0, :D => 0.2]\noprob = ODEProblem(lrs, u0, tspan, ps; jac = true)\nsol = solve(oprob, FBDF())\nnothing # hide","category":"page"},{"location":"spatial_modelling/spatial_ode_simulations/","page":"Spatial ODE simulations","title":"Spatial ODE simulations","text":"For large systems, building a dense Jacobian can be problematic, in which case a sparse Jacobian can be designated using sparse = true: ","category":"page"},{"location":"spatial_modelling/spatial_ode_simulations/","page":"Spatial ODE simulations","title":"Spatial ODE simulations","text":"oprob = ODEProblem(lrs, u0, tspan, ps; jac = true, sparse = true)\nsol = solve(oprob, FBDF())\nnothing # hide","category":"page"},{"location":"spatial_modelling/spatial_ode_simulations/","page":"Spatial ODE simulations","title":"Spatial ODE simulations","text":"It is possible to use sparse = true while jac = false, in which case a sparse Jacobian is computed using automatic differentiation. ","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"When simulating a model, one begins with creating a problem. Next, a simulation is performed on the problem, during which the simulation's state is recorded through an integrator. Finally, the simulation output is returned as a solution. This tutorial describes how to access (or modify) the state (or parameter) values of problem, integrator, and solution structures.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Generally, when we have a structure simulation_struct and want to interface with the unknown (or parameter) x, we use simulation_struct[:x] to access the value. For situations where a value is accessed (or changed) a large number of times, it can improve performance to first create a specialised getter/setter function.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_problems","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problem objects","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"We begin by demonstrating how we can interface with problem objects. First, we create an ODEProblem representation of a chemical cross-coupling model (where a catalyst, C, couples two substrates, S₁ and S₂, to form a product, P).","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"using Catalyst\ncc_system = @reaction_network begin\n    k₁, S₁ + C --> S₁C\n    k₂, S₁C + S₂ --> CP\n    k₃, CP --> C + P\nend\n\nu0 = [:S₁ => 1.0, :C => 0.05, :S₂ => 1.2, :S₁C => 0.0, :CP => 0.0, :P => 0.0]\ntspan = (0., 10.0)\nps = [:k₁ => 5.0, :k₂ => 5.0, :k₃ => 100.0] \noprob = ODEProblem(cc_system, u0, tspan, ps)\nnothing    # hide","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"We can find a species's (or variable's) initial condition value by simply indexing with the species of interest as input. Here we check the initial condition value of C:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[:C]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"An almost identical notation can be used for parameters, however, here we use oprob.ps (rather than oprob): with the notation being identical for parameters:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob.ps[:k₁]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"To retrieve several species initial condition (or parameter) values, simply give a vector input. Here we check the values of the two substrates (S₁ and S₂):","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[[:S₁, :S₂]]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"A problem's time span can be accessed through the tspan field:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob.tspan","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"note: Note\nHere we have used an ODEProblemto demonstrate all interfacing functionality. However, identical workflows work for the other problem types.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_problems_remake","page":"Interfacing problems, integrators, and solutions","title":"Remaking problems using the remake function","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"To modify a problem, the remake function should be used. It takes an already created problem, and returns a new, updated, one (the input problem is unchanged). The remake function takes the following inputs:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"The problem that it remakes.\n(optionally) u0: A vector with initial conditions that should be updated. The vector takes the same form as normal initial condition vectors, but does not need to be complete (in which case only a subset of the initial conditions are updated).\n(optionally) tspan: An updated time span (using the same format as time spans normally are given in).\n(optionally) p: A vector with parameters that should be updated. The vector takes the same form as normal parameter vectors, but does not need to be complete (in which case only a subset of the parameters are updated).","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Here we modify our problem to increase the initial condition concentrations of the two substrates (S₁ and S₂), and also confirm that the new problem is different from the old (unchanged) one:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"using OrdinaryDiffEqDefault\noprob_new = remake(oprob; u0 = [:S₁ => 5.0, :S₂ => 2.5])\noprob_new != oprob","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Here, we instead use remake to simultaneously update all three fields:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob_new_2 = remake(oprob; u0 = [:C => 0.2], tspan = (0.0, 20.0), p = [:k₁ => 2.0, :k₂ => 2.0])\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Typically, when using remake to update a problem, the common workflow is to overwrite the old one with the output. E.g. to set the value of k₁ to 5.0 in oprob, you would do:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob = remake(oprob; p = [:k₁ => 5.0])\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_integrators","page":"Interfacing problems, integrators, and solutions","title":"Interfacing integrator objects","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"During a simulation, the solution is stored in an integrator object. Here, we will describe how to interface with these. The almost exclusive circumstance when integrator-interfacing is relevant is when simulation events are implemented through callbacks. However, to demonstrate integrator indexing in this tutorial, we will create one through the init function (while circumstances where one might want to use init function exist, since integrators are automatically created during simulations, these are rare).","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"integrator = init(oprob)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"We can interface with our integrator using an identical syntax as was used for problems. The primary exception is that there is no remake function for integrators. Instead, we can update species and parameter values using normal indexing. Here we update, and then check the values of, first the species C and then the parameter k₁:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"integrator[:C] = 0.0\nintegrator[:C]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"or a parameter:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"integrator.ps[:k₂] = 1.0\nintegrator.ps[:k₂]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Note that here, species-interfacing yields (or changes) a simulation's current value for a species, not its initial condition.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"If you are interfacing with jump simulation integrators, you must always call reset_aggregated_jumps!(integrator) afterwards.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_solutions","page":"Interfacing problems, integrators, and solutions","title":"Interfacing solution objects","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Finally, we consider solution objects. First, we simulate our problem:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol = solve(oprob)\nnothing # hide","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Next, we can access the simulation's values using the same notation as previously. When we access a species's, its values across the full simulation is returned as a vector:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol[:P]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Parameter values can also be accessed (however, here we only get a single value):","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol.ps[:k₃]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Unlike for problems and integrators, species or parameter values of solutions cannot be changed. ","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"A vector with the time values for all simulation time steps can be retrieved using","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol.t","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"To find simulation values at a specific time point, simply use this time point as input to your solution object (treating it as a function). I.e. here we get our simulation's values at time t = 10","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol(1.0)","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"This works whenever the simulations actually stopped at time t = 10 (if not, an interpolated value is returned). To get the simulation's values for a specific subset of species, we can use the idxs optional argument. I.e. here we get the value of C at time t = 10","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"sol(1.0; idxs = [:C])","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_functions","page":"Interfacing problems, integrators, and solutions","title":"Interfacing using specialised getter/setter functions","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Internally, species and parameter values are stored in vectors. Whenever e.g. oprob[:C] is called, Julia must first find which index in the storage vector C is stored in. Next, its value can be retrieved. If oprob[:C] is called a large number of times, this index must be found in each call. If a large number of such accesses are carried out, and performance is essential, it can be worthwhile to pre-compute a function to carry this out.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"There exist four different functions, each returning a function for performing a specific type of interfacing:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"ModelingToolkit.getu: For accessing species values.\nModelingToolkit.getp: For accessing parameter values.\nModelingToolkit.setu: For changing species values.\nModelingToolkit.setp: For changing parameter values.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"For each species (or parameter) we wish to interface with, a new interfacing function must be created. Here we first creates a function for retrieving the value of C, and then use it for this purpose:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"get_C = ModelingToolkit.getu(oprob, :C)\nget_C(oprob)","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Here, getu (as well as getp, setu, and setp) first takes the structure we wish to interface with, and then the target quantity. When using setu and setp, in the second step, we must also provide the update value:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"set_C = ModelingToolkit.setu(oprob, :C)\nset_C(oprob, 0.2)\nget_C(oprob)","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Like when indexing-based interfacing is used, these functions also work with vectors:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"get_S = ModelingToolkit.getu(oprob, [:S₁, :S₂])\nget_S(oprob)","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_symbolic_representation","page":"Interfacing problems, integrators, and solutions","title":"Interfacing using symbolic representations","text":"","category":"section"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"When e.g. programmatic modelling is used, species and parameters can be represented as symbolic variables. These can be used to index a problem, just like symbol-based representations can. Here we create a simple two-state model programmatically, and use its symbolic variables to check, and update, an initial condition:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"using Catalyst, OrdinaryDiffEqDefault\nt = default_t()\n@species X1(t) X2(t)\n@parameters k1 k2\nrxs = [\n    Reaction(k1, [X1], [X2]),\n    Reaction(k2, [X2], [X1])\n]\n@named two_state_model = ReactionSystem(rxs, t)\ntwo_state_model = complete(two_state_model)\n\nu0 = [X1 => 2.0, X2 => 0.0]\ntspan = (0.0, 1.0)\nps = [k1 => 1.0, k2 => 2.0]\noprob = ODEProblem(two_state_model, u0, tspan, ps)\n\noprob = remake(oprob; u0 = [X1 => 5.0])\noprob[X1]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Symbolic variables can be used to access or update species or parameters for all the cases when Symbols can (including when using remake or e.g. getu).","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"An advantage when quantities are represented as symbolic variables is that symbolic expressions can be formed and used to index a structure. E.g. here we check the combined initial concentration of X (X1 + X2) in our two-state problem:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[X1 + X2]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"Just like symbolic variables can be used to directly interface with a structure, symbolic variables stored in ReactionSystem models can be used:","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"oprob[two_state_model.X1 + two_state_model.X2]","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"This can be used to form symbolic expressions using model quantities when a model has been created using the DSL (as an alternative to @unpack). Alternatively, creating an observable, and then interface using its Symbol representation, is also possible.","category":"page"},{"location":"model_simulation/simulation_structure_interfacing/","page":"Interfacing problems, integrators, and solutions","title":"Interfacing problems, integrators, and solutions","text":"warning: Warning\nWhen accessing a simulation structure using symbolic variables from a ReactionSystem model, such as rn.A for rn a ReactionSystem and A a species within it, ensure that the model is complete.","category":"page"},{"location":"model_creation/conservation_laws/#conservation_laws","page":"Working with conservation laws","title":"Working with conservation laws","text":"","category":"section"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"Catalyst can detect, and eliminate for differential-equation based models, conserved quantities, i.e. linear combinations of species which are conserved via the chemistry. This functionality is both automatically utilised by Catalyst (e.g. to remove singular Jacobians during steady state computations), but is also available for users to utilise directly (e.g. to potentially improve simulation performance).","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"To illustrate conserved quantities, let us consider the following two-state model:","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"using Catalyst\nrs = @reaction_network begin\n (k₁,k₂), X₁ <--> X₂\nend","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"If we simulate it, we note that while the concentrations of X₁ and X₂ change throughout the simulation, the total concentration of X (= X₁ + X₂) is constant:","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"using OrdinaryDiffEqDefault, Plots\nu0 = [:X₁ => 80.0, :X₂ => 20.0]\nps = [:k₁ => 10.0, :k₂ => 2.0]\noprob = ODEProblem(rs, u0, (0.0, 1.0), ps)\nsol = solve(oprob)\nplot(sol; idxs = [rs.X₁, rs.X₂, rs.X₁ + rs.X₂], label = [\"X₁\" \"X₂\" \"X₁ + X₂ (a conserved quantity)\"])","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"This makes sense, as while X is converted between two different forms (X₁ and X₂), it is neither produced nor degraded. That is, it is a conserved quantity. Next, if we consider the ODE that our model generates:","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"using Latexify\nlatexify(rs; form = :ode)","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"we note that it essentially generates the same equation twice (i.e. fracdX₁(t)dt = -fracdX₂(t)dt). By designating our conserved quantity X₁ + X₂ = Γ, we can rewrite our differential equation model as a differential-algebraic equation (with a single differential equation and a single algebraic equation):","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"fracdX₁(t)dt = - k₁X₁(t) + k₂(-X₁(t) + Γ) \nX₂(t) = -X₁(t) + Γ","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"Using Catalyst, it is possible to detect any such conserved quantities and eliminate them from the system. Here, when we convert our ReactionSystem to an ODESystem, we provide the remove_conserved = true argument to instruct Catalyst to perform this elimination:","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"osys = convert(ODESystem, rs; remove_conserved = true)","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"We note that the output system only contains a single (differential) equation and can hence be solved with an ODE solver. The second (algebraic) equation is stored as an observable, and can be retrieved using the observed function:","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"observed(osys)","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"Using the unknowns function we can confirm that the ODE only has a single unknown variable:","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"unknowns(osys)","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"Next, using parameters we note that an additional parameter, Γ[1] has been added to the system:","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"parameters(osys)","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"Here, Catalyst encodes all conserved quantities in a single, vector-valued, parameter called Γ.","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"Practically, the remove_conserved = true argument can be provided when a ReactionSystem is converted to an ODEProblem:","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"using OrdinaryDiffEqDefault, Plots\nu0 = [:X₁ => 80.0, :X₂ => 20.0]\nps = [:k₁ => 10.0, :k₂ => 2.0]\noprob = ODEProblem(rs, u0, (0.0, 1.0), ps; remove_conserved = true)\nnothing # hide","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"Here, while Γ[1] becomes a parameter of the new system, it has a default value equal to the corresponding conservation law. Hence, its value is computed from the initial condition [:X₁ => 80.0, :X₂ => 20.0], and does not need to be provided in the parameter vector. Next, we can simulate and plot our model using normal syntax:","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"sol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"note: Note\nAny species eliminated using remove_conserved = true will not be plotted by default. However, it can be added to the plot using the idxs plotting option. E.g. here we would use plot(sol; idxs = [:X₁, :X₂]) to plot both species.","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"danger: Danger\nCurrently, there is a bug in MTK where the parameters, Γ, associated with conservation laws are not updated properly in response to remake (or other problem-updating functions, such as getu). Hence, problems created using remove_conserved = true should not be modified, i.e. by changing initial conditions or the values of the Γ's directly. Instead, to change these values new problems must be generated with the new initial condition map.","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"While X₂ is an observable (and not unknown) of the ODE, we can access it just like if remove_conserved = true had not been used:","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"sol[:X₂]","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"note: Note\nGenerally, remove_conserved = true should not change any model workflows. I.e. anything that works without this option should also work when an ODEProblem is created using remove_conserved = true.","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"note: Note\nThe remove_conserved = true option is available when creating SDEProblems, NonlinearProblems, and SteadyStateProblems (and their corresponding systems). However, it cannot be used when creating JumpProblems.","category":"page"},{"location":"model_creation/conservation_laws/#conservation_laws_accessors","page":"Working with conservation laws","title":"Conservation law accessor functions","text":"","category":"section"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"For any given ReactionSystem model, we can use conservationlaw_constants to compute all of a system's conserved quantities:","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"conservationlaw_constants(rs)","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"Next, the conservedequations function can be used to compute the algebraic equations produced when a system's conserved quantities are eliminated:","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"conservedequations(rs)","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"Finally, the conservationlaws function yields a m times n matrix, where n is a system's number of species, m its number of conservation laws, and element (ij) corresponds to the copy number of the jth species that occurs in the ith conserved quantity:","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"conservationlaws(rs)","category":"page"},{"location":"model_creation/conservation_laws/","page":"Working with conservation laws","title":"Working with conservation laws","text":"I.e. in this case we have a single conserved quantity, which contains a single copy each of the system's two species.","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/#hodgkin_huxley_equation","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"","category":"section"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"This tutorial shows how to construct a Catalyst ReactionSystem that includes a coupled ODE, corresponding to the Hodgkin–Huxley model for an excitable cell. The Hodgkin–Huxley model is a mathematical model that describes how action potentials in neurons are initiated and propagated. It is a continuous-time dynamical system given by a coupled system of nonlinear differential equations that model the electrical characteristics of excitable cells such as neurons and muscle cells.","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We'll present two different approaches for constructing the model. The first will show how it can be built entirely within a single DSL model, while the second illustrates another work flow, showing how separate models containing the chemistry and the dynamics of the transmembrane potential can be combined into a complete model.","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We begin by importing some necessary packages:","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"using ModelingToolkit, Catalyst, NonlinearSolve, Plots, OrdinaryDiffEqRosenbrock","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/#Building-the-model-via-the-Catalyst-DSL","page":"Hodgkin-Huxley Equation","title":"Building the model via the Catalyst DSL","text":"","category":"section"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"Let's build a simple Hodgkin-Huxley model for a single neuron, with the voltage, V(t), included as a coupled ODE. We first specify the transition rates for three gating variables, m(t), n(t) and h(t).","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"s xleftrightarrowbeta_s(V(t))alpha_s(V(t)) s quad s in mnh","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"Here each gating variable is used in determining the fraction of active (i.e. open) or inactive (m = 1 - m, n = 1 -n, h = 1 - h) sodium (m and h) and potassium (n) channels.","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"The transition rate functions, which depend on the voltage, V(t), are given by","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"function αₘ(V)\n    theta = (V + 45) / 10\n    ifelse(theta == 0.0, 1.0, theta/(1 - exp(-theta)))\nend\nβₘ(V) = 4*exp(-(V + 70)/18)\n\nαₕ(V) = .07 * exp(-(V + 70)/20)\nβₕ(V) = 1/(1 + exp(-(V + 40)/10))\n\nfunction αₙ(V)\n    theta = (V + 60) / 10\n    ifelse(theta == 0.0, .1, .1*theta / (1 - exp(-theta)))\nend\nβₙ(V) = .125 * exp(-(V + 70)/80)\nnothing # hide","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We also declare a function to represent an applied current in our model, which we will use to perturb the system and create action potentials. ","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"Iapp(t,I₀) = I₀ * sin(2*pi*t/30)^2","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We now declare a ReactionSystem that encompasses the Hodgkin-Huxley model. Note, we will also give the (default) values for our parameters as part of constructing the model to avoid having to specify them later on via parameter maps.","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"hhmodel = @reaction_network hhmodel begin\n    @parameters begin\n        C = 1.0 \n        ḡNa = 120.0 \n        ḡK = 36.0 \n        ḡL = .3 \n        ENa = 45.0 \n        EK = -82.0 \n        EL = -59.0 \n        I₀ = 0.0\n    end\n\n    @variables V(t)\n\n    (αₙ(V), βₙ(V)), n′ <--> n\n    (αₘ(V), βₘ(V)), m′ <--> m\n    (αₕ(V), βₕ(V)), h′ <--> h\n    \n    @equations begin\n        D(V) ~ -1/C * (ḡK*n^4*(V-EK) + ḡNa*m^3*h*(V-ENa) + ḡL*(V-EL)) + Iapp(t,I₀)\n    end\nend","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"For now we turn off the applied current by setting its amplitude, I₀, to zero.","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"hhmodel is now a ReactionSystem that is coupled to an internal constraint ODE for dVdt. Let's now solve to steady-state, as we can then use these resting values as an initial condition before applying a current to create an action potential.","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"tspan = (0.0, 50.0)\nu₀ = [:V => -70, :m => 0.0, :h => 0.0, :n => 0.0,\n\t  :m′ => 1.0, :n′ => 1.0, :h′ => 1.0]\noprob = ODEProblem(hhmodel, u₀, tspan)\nhhsssol = solve(oprob, Rosenbrock23())\nnothing # hide","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"From the artificial initial condition we specified, the solution approaches the physiological steady-state via firing one action potential:","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"plot(hhsssol, idxs = hhmodel.V)","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We now save this steady-state to use as the initial condition for simulating how a resting neuron responds to an applied current. We save the steady-state values as a mapping from the symbolic variables to their steady-states that we can later use as an initial condition:","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"u_ss = unknowns(hhmodel) .=> hhsssol(tspan[2], idxs = unknowns(hhmodel))\nnothing # hide","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"Finally, starting from this resting state let's solve the system when the amplitude of the stimulus is non-zero and see if we get action potentials","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"tspan = (0.0, 50.0)\n@unpack V,I₀ = hhmodel\noprob = ODEProblem(hhmodel, u_ss, tspan, [I₀ => 10.0])\nsol = solve(oprob)\nplot(sol, idxs = V, legend = :outerright)","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We observe three action potentials due to the steady applied current.","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/#Building-the-model-via-composition-of-separate-systems-for-the-ion-channel-and-transmembrane-voltage-dynamics","page":"Hodgkin-Huxley Equation","title":"Building the model via composition of separate systems for the ion channel and transmembrane voltage dynamics","text":"","category":"section"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"As an illustration of how one can construct models from individual components, we now separately construct and compose the model components.","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We start by defining systems to model each ionic current:","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"IKmodel = @reaction_network IKmodel begin\n    @parameters ḡK = 36.0 EK = -82.0 \n    @variables V(t) Iₖ(t)\n    (αₙ(V), βₙ(V)), n′ <--> n\n    @equations Iₖ ~ ḡK*n^4*(V-EK)\nend\n\nINamodel = @reaction_network INamodel begin\n    @parameters ḡNa = 120.0 ENa = 45.0 \n    @variables V(t) Iₙₐ(t)\n    (αₘ(V), βₘ(V)), m′ <--> m\n    (αₕ(V), βₕ(V)), h′ <--> h\n    @equations Iₙₐ ~ ḡNa*m^3*h*(V-ENa) \nend\n\nILmodel = @reaction_network ILmodel begin\n    @parameters ḡL = .3 EL = -59.0 \n    @variables V(t) Iₗ(t)\n    @equations Iₗ ~ ḡL*(V-EL)\nend\nnothing # hide","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We next define the voltage dynamics with unspecified values for the currents","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"hhmodel2 = @reaction_network hhmodel2 begin\n    @parameters C = 1.0 I₀ = 0.0\n    @variables V(t) Iₖ(t) Iₙₐ(t) Iₗ(t)\n    @equations D(V) ~ -1/C * (Iₖ + Iₙₐ + Iₗ) + Iapp(t,I₀)\nend\nnothing # hide","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"Finally, we extend the hhmodel with the systems defining the ion channel currents","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"@named hhmodel2 = extend(IKmodel, hhmodel2)\n@named hhmodel2 = extend(INamodel, hhmodel2)\n@named hhmodel2 = extend(ILmodel, hhmodel2)\nhhmodel2 = complete(hhmodel2)","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"Let's again solve the system starting from the previously calculated resting state, using the same applied current as above (to verify we get the same figure). Note, we now run structural_simplify from ModelingToolkit to eliminate the algebraic equations for the ionic currents when constructing the ODEProblem:","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"@unpack I₀,V = hhmodel2\noprob = ODEProblem(hhmodel2, u_ss, tspan, [I₀ => 10.0]; structural_simplify = true)\nsol = solve(oprob)\nplot(sol, idxs = V, legend = :outerright)","category":"page"},{"location":"model_creation/examples/hodgkin_huxley_equation/","page":"Hodgkin-Huxley Equation","title":"Hodgkin-Huxley Equation","text":"We observe the same solutions as from our original model.","category":"page"},{"location":"model_creation/compositional_modeling/#compositional_modeling","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"","category":"section"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst supports the construction of models in a compositional fashion, based on ModelingToolkit's subsystem functionality. In this tutorial we'll see how we can construct the earlier repressilator model by composing together three identically repressed genes, and how to use compositional modeling to create compartments.","category":"page"},{"location":"model_creation/compositional_modeling/#completeness_note","page":"Compositional Modeling of Reaction Systems","title":"A note on completeness","text":"","category":"section"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst ReactionSystem can either be complete or incomplete. When created using the @reaction_network DSL they are created as complete. Here, only complete ReactionSystems can be used to create the various problem types (e.g. ODEProblem). However, only incomplete ReactionSystems can be composed using the features described below. Hence, for compositional modeling, ReactionSystem must be created as incomplete, and later set to complete before simulation.","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"To create a ReactionSystems for use in compositional modeling via the DSL, simply use the @network_component macro instead of @reaction_network:","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"using Catalyst\ndegradation_component = @network_component begin\n  d, X --> 0\nend","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Alternatively one can just build the ReactionSystem via the symbolic interface.","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"@parameters d\nt = default_t()\n@species X(t)\nrx = Reaction(d, [X], nothing)\n@named degradation_component = ReactionSystem([rx], t)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"We can test whether a system is complete using the ModelingToolkit.iscomplete function:","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"ModelingToolkit.iscomplete(degradation_component)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"To mark a system as complete, after which it should be considered as representing a finalized model, use the complete function","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"degradation_component_complete = complete(degradation_component)\nModelingToolkit.iscomplete(degradation_component_complete)","category":"page"},{"location":"model_creation/compositional_modeling/#Compositional-modeling-tooling","page":"Compositional Modeling of Reaction Systems","title":"Compositional modeling tooling","text":"","category":"section"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst supports two ModelingToolkit interfaces for composing multiple ReactionSystems together into a full model. The first mechanism allows for extending an existing system by merging in a second system via the extend command","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"using Catalyst\nbasern = @network_component rn1 begin\n  k, A + B --> C\nend\nnewrn = @network_component rn2 begin\n  r, C --> A + B\nend\n@named rn = extend(newrn, basern)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Here we extended basern with newrn giving a system with all the reactions. Note, if a name is not specified via @named or the name keyword then rn will have the same name as newrn.","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"The second main compositional modeling tool is the use of subsystems. Suppose we now add to basern two subsystems, newrn and newestrn, we get a different result:","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"newestrn = @network_component rn3 begin\n  v, A + D --> 2D\nend\n@named rn = compose(basern, [newrn, newestrn])","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Here we have created a new ReactionSystem that adds newrn and newestrn as subsystems of basern. The variables and parameters in the sub-systems are considered distinct from those in other systems, and so are namespaced (i.e. prefaced) by the name of the system they come from.","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"We can see the subsystems of a given system by","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"ModelingToolkit.get_systems(rn)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"They naturally form a tree-like structure","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"using Plots, GraphRecipes\nplot(TreePlot(rn), method=:tree, fontsize=12, nodeshape=:ellipse)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"(Image: rn network with subsystems)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"We could also have directly constructed rn using the same reaction as in basern as","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"t = default_t()\n@parameters k\n@species A(t), B(t), C(t)\nrxs = [Reaction(k, [A,B], [C])]\n@named rn = ReactionSystem(rxs, t; systems = [newrn, newestrn])","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst provides several different accessors for getting information from a single system, or all systems in the tree. To get the species, parameters, and reactions only within a given system (i.e. ignoring subsystems), we can use","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst.get_species(rn)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"ModelingToolkit.get_ps(rn)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Catalyst.get_rxs(rn)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"To see all the species, parameters and reactions in the tree we can use","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"species(rn)   # or unknowns(rn)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"parameters(rn)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"reactions(rn)   # or equations(rn)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"If we want to collapse rn down to a single system with no subsystems we can use","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"flatrn = Catalyst.flatten(rn)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"where","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"ModelingToolkit.get_systems(flatrn)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"More about ModelingToolkit's interface for compositional modeling can be found in the ModelingToolkit docs.","category":"page"},{"location":"model_creation/compositional_modeling/#Compositional-model-of-the-repressilator","page":"Compositional Modeling of Reaction Systems","title":"Compositional model of the repressilator","text":"","category":"section"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Let's apply the tooling we've just seen to create the repressilator in a more modular fashion. We start by defining a function that creates a negatively repressed gene, taking the repressor as input","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"function repressed_gene(; R, name)\n  @network_component $name begin\n    hillr($R,α,K,n), ∅ --> m\n    (δ,γ), m <--> ∅\n    β, m --> m + P\n    μ, P --> ∅\n  end\nend\nnothing # hide","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Here we assume the user will pass in the repressor species as a ModelingToolkit variable, and specify a name for the network. We use Catalyst's interpolation ability to substitute the value of these variables into the DSL (see Interpolation of Julia Variables). To make the repressilator we now make three genes, and then compose them together","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"t = default_t()\n@species G3₊P(t)\n@named G1 = repressed_gene(; R=ParentScope(G3₊P))\n@named G2 = repressed_gene(; R=ParentScope(G1.P))\n@named G3 = repressed_gene(; R=ParentScope(G2.P))\n@named repressilator = ReactionSystem(t; systems=[G1,G2,G3])","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Notice, in this system each gene is a child node in the system graph of the repressilator","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"plot(TreePlot(repressilator), method=:tree, fontsize=12, nodeshape=:ellipse)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"(Image: repressilator tree plot)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"In building the repressilator we needed to use two new features. First, we needed to create a symbolic variable that corresponds to the protein produced by the third gene before we created the corresponding system. We did this via @variables G3₊P(t). We also needed to set the scope where each repressor lived. Here ParentScope(G3₊P), ParentScope(G1.P), and ParentScope(G2.P) signal Catalyst that these variables will come from parallel systems in the tree that have the same parent as the system being constructed (in this case the top-level repressilator system).","category":"page"},{"location":"model_creation/compositional_modeling/#Compartment-based-models","page":"Compositional Modeling of Reaction Systems","title":"Compartment-based models","text":"","category":"section"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Finally, let's see how we can make a compartment-based model. Let's create a simple eukaryotic gene expression model with negative feedback by protein dimers. Transcription and gene inhibition by the protein dimer occurs in the nucleus, translation and dimerization occur in the cytosol, and nuclear import and export reactions couple the two compartments. We'll include volume parameters for the nucleus and cytosol, and assume we are working with species having units of number of molecules. Rate constants will have their common concentration units, i.e. if V denotes the volume of a compartment then","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Reaction Type Example Rate Constant Units Effective rate constant (units of per time)\nZero order varnothing oversetalphato A concentration / time alpha V\nFirst order A oversetbetato B (time)⁻¹ beta\nSecond order A + B oversetgammato C (concentration × time)⁻¹ gammaV","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"In our model we'll therefore add the conversions of the last column to properly account for compartment volumes:","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"# transcription and regulation\nnuc = @network_component nuc begin\n  α, G --> G + M\n  (κ₊/V,κ₋), D + G <--> DG\nend\n\n# translation and dimerization\ncyto = @network_component cyto begin\n  β, M --> M + P\n  (k₊/V,k₋), 2P <--> D\n  σ, P --> 0\n  μ, M --> 0\nend\n\n# export reactions,\n# γ,δ=probability per time to be exported/imported\nmodel = @network_component model begin\n  γ, $(nuc.M) --> $(cyto.M)\n  δ, $(cyto.D) --> $(nuc.D)\nend\n@named model = compose(model, [nuc, cyto])","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"A graph of the resulting network is","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"Graph(model)","category":"page"},{"location":"model_creation/compositional_modeling/","page":"Compositional Modeling of Reaction Systems","title":"Compositional Modeling of Reaction Systems","text":"(Image: graph of gene regulation model)","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"In the introduction to Catalyst we described how the @reaction_network macro can be used to create chemical reaction network (CRN) models. This macro enables a so-called domain-specific language (DSL) for creating CRN models. This tutorial will give a basic introduction on how to create Catalyst models using this macro (from now onwards called \"the Catalyst DSL\"). A follow-up tutorial will describe some of the DSL's more advanced features.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"The Catalyst DSL generates a ReactionSystem (the julia structure Catalyst uses to represent CRN models). These can be created through alternative methods (e.g. programmatically or compositionally). Previous and following tutorials describe how to simulate models once they have been created using the DSL. This tutorial will solely focus on model creation.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Before we begin, we will first load the Catalyst package (which is required to run the code).","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"using Catalyst","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_quick_start","page":"The Catalyst DSL - Introduction","title":"Quick-start summary","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"The DSL is initiated through the @reaction_network macro, which is followed by one line for each reaction. Each reaction consists of a rate, followed lists first of the substrates and next of the products. E.g. a Michaelis-Menten enzyme kinetics system can be written as","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn = @reaction_network begin\n    (kB,kD), S + E <--> SE\n    kP, SE --> P + E\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here, <--> is used to create a bi-directional reaction (with forward rate kP and backward rate kD). Next, the model (stored in the variable rn) can be used as input to various types of simulations.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_basic_syntax","page":"The Catalyst DSL - Introduction","title":"Basic syntax","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"The basic syntax of the DSL is","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"using Catalyst # hide\nrn = @reaction_network begin\n    2.0, X --> Y\n    1.0, Y --> X\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here, you start with @reaction_network begin, next list all of the model's reactions, and finish with end. Each reaction consists of","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"A rate.\nA (potentially empty) set of substrates.\nA (potentially empty) set of products.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Each reaction line declares, in order, the rate, the substrate(s), and the product(s). The rate is separated from the substrate(s) by a ,, and the substrate(s) from the production by a --> (other arrows, however, are also possible). In the above example, our model consists of two reactions. In the first one, X (the single substrate) becomes Y (the single product) at rate 2.0. In the second reaction, Y becomes X at rate 1.0.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Finally, rn = is used to store the model in the variable rn (a normal Julia variable, which does not need to be called rn).","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_parameters_basics","page":"The Catalyst DSL - Introduction","title":"Defining parameters and species in the DSL","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Typically, the rates are not constants, but rather parameters (which values can be set e.g. at the beginning of each simulation). To set parametric rates, simply use whichever symbol you wish to represent your parameter with. E.g. to set the above rates to a and b, we use:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn1 = @reaction_network begin\n    a, X --> Y\n    b, Y --> X\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here we have used single-character symbols to designate all species and parameters. Multi-character symbols, however, are also permitted. E.g. we could call the rates kX and kY:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn1 = @reaction_network begin\n    kX, X --> Y\n    kY, Y --> X\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Generally, anything that is a permitted Julia variable name can be used to designate a species or parameter in Catalyst.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_reactions","page":"The Catalyst DSL - Introduction","title":"Different types of reactions","text":"","category":"section"},{"location":"model_creation/dsl_basics/#dsl_description_reactions_multiples","page":"The Catalyst DSL - Introduction","title":"Reactions with multiple substrates or products","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Previously, our reactions have had a single substrate and a single product. However, reactions with multiple substrates and/or products are possible. Here, all the substrates (or products) are listed and separated by a +. E.g. to create a model where X and Y bind (at rate kB) to form XY (which then can dissociate, at rate kD, to form XY) we use:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn2 = @reaction_network begin\n    kB, X + Y --> XY\n    kD, XY --> X + Y\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Reactions can have any number of substrates and products, and their names do not need to have any relationship to each other, as demonstrated by the following mock model:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn3 = @reaction_network begin\n    k, X + Y + Z --> A + B + C + D\nend","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_reactions_degradation_and_production","page":"The Catalyst DSL - Introduction","title":"Reactions with degradation or production","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Some reactions have no products, in which case the substrate(s) are degraded (i.e. removed from the system). To denote this, set the reaction's right-hand side to 0. Similarly, some reactions have no substrates, in which case the product(s) are produced (i.e. added to the system). This is denoted by setting the left-hand side to 0. E.g. to create a model where a single species X is both created (in the first reaction) and degraded (in a second reaction), we use:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn4 = @reaction_network begin\n    p, 0 --> X\n    d, X --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_reactions_stoichiometries","page":"The Catalyst DSL - Introduction","title":"Reactions with non-unitary stoichiometries","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Reactions may include multiple copies of the same reactant (i.e. a substrate or a product). To specify this, the reactant is preceded by a number indicating its number of copies (also called the reactant's stoichiometry). E.g. to create a model where two copies of X dimerise to form X2 (which then dissociate back to two X copies) we use:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn5 = @reaction_network begin\n    kB, 2X --> X2\n    kD, X2 --> 2X\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Reactants whose stoichiometries are not defined are assumed to have stoichiometry 1. Any integer number can be used, furthermore, decimal numbers and parameters can also be used as stoichiometries. A discussion of non-unitary (i.e. not equal to 1) stoichiometries affecting the created model can be found here.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Stoichiometries can be combined with () to define them for multiple reactants. Here, the following (mock) model declares the same reaction twice, both with and without this notation:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn6 = @reaction_network begin\n    k, 2X + 3(Y + 2Z) --> 5(V + W)\n    k, 2X + 3Y + 6Z --> 5V + 5W\nend","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_reaction_bundling","page":"The Catalyst DSL - Introduction","title":"Bundling of similar reactions","text":"","category":"section"},{"location":"model_creation/dsl_basics/#dsl_description_reaction_bundling_reversible","page":"The Catalyst DSL - Introduction","title":"Bi-directional (or reversible) reactions","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"As is the case for the following two-state model:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn7 = @reaction_network begin\n    k1, X1 --> X2\n    k2, X2 --> X1\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"it is common that reactions occur in both directions (so-called bi-directional reactions). Here, it is possible to bundle the reactions into a single line by using the <--> arrow. When we do this, the rate term must include two separate rates (one for each direction, these are enclosed by a () and separated by a ,). I.e. the two-state model can be declared using:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn7 = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here, the first rate (k1) denotes the forward rate and the second rate (k2) the backwards rate.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Catalyst also permits writing pure backwards reactions. These use identical syntax to forward reactions, but with the <-- arrow:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn8 = @reaction_network begin\n    k, X <-- Y\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here, the substrate(s) are on the right-hand side and the product(s) are on the left-hand side. Hence, the above model can be written identically using:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn8 = @reaction_network begin\n    k, Y --> X\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Generally, using forward reactions is clearer than backwards ones, with the latter typically never being used.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_reaction_bundling_similar","page":"The Catalyst DSL - Introduction","title":"Bundling similar reactions on a single line","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"There exist additional situations where models contain similar reactions (e.g. systems where all system components degrade at identical rates). Reactions which share either rates, substrates, or products can be bundled into a single line. Here, the parts which are different for the reactions are written using (,) (containing one separate expression for each reaction). E.g., let us consider the following model where species X and Y both degrade at the rate d:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn8 = @reaction_network begin\n    d, X --> 0\n    d, Y --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"These share both their rates (d) and products (0), however, the substrates are different (X and Y). Hence, the reactions can be bundled into a single line using the common rate and product expression while providing separate substrate expressions:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn8 = @reaction_network begin\n    d, (X,Y) --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"This declaration of the model is identical to the previous one. Reactions can share any subset of the rate, substrate, and product expression (the cases where they share all or none, however, do not make sense to use). I.e. if the two reactions also have different degradation rates:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn9 = @reaction_network begin\n    dX, X --> 0\n    dY, Y --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"This can be represented using:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn9 = @reaction_network begin\n    (dX,dY), (X,Y) --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"It is possible to use bundling for any number of reactions. E.g. in the following model we bundle the conversion of a species X between its various forms (where all reactions use the same rate k):","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn10 = @reaction_network begin\n    k, (X0,X1,X2,X3) --> (X1,X2,X3,X4)\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"It is possible to combine bundling with bi-directional reactions. In this case, the rate is first split into the forward and backwards rates. These may then (or may not) indicate several rates. We exemplify this using the two following two (identical) networks, created with and without bundling.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn11 = @reaction_network begin\n    kf, S --> P1\n    kf, S --> P2\n    kb_1, P1 --> S\n    kb_2, P2 --> S\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn11 = @reaction_network begin\n    (kf, (kb_1, kb_2)), S <--> (P1,P2)\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Like when we designated stoichiometries, reaction bundling can be applied very generally to create some truly complicated reactions:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn12 = @reaction_network begin\n    ((pX, pY, pZ),d), (0, Y0, Z0) <--> (X, Y, Z1+Z2)\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"However, like for the above model, bundling reactions too zealously can reduce (rather than improve) a model's readability.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_nonconstant_rates","page":"The Catalyst DSL - Introduction","title":"Non-constant reaction rates","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"So far we have assumed that all reaction rates are constant (being either a number of a parameter). Non-constant rates that depend on one (or several) species are also possible. More generally, the rate can be any valid expression of parameters and species.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Let us consider a model with an activator (A, which degraded at a constant rate) and a protein (P). The production rate of P depends both on A and a parameter (kP). We model this through:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_13 = @reaction_network begin\n    d, A --> 0\n    kP*A, 0 --> P\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here, P's production rate will be reduced as A decays. We can print the ODE this model produces with Latexify:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"using Latexify\nlatexify(rn_13; form = :ode)","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"In this case, we can generate an equivalent model by instead adding A as both a substrate and a product to P's production reaction:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_13_alt = @reaction_network begin\n    d, A --> 0\n    kp, A --> A + P\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"We can confirm that this generates the same ODE:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"latexify(rn_13_alt; form = :ode)","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Here, while these models will generate identical ODE, SDE, and jump simulations, the chemical reaction network models themselves are not equivalent. Generally, as pointed out in the two notes below, using the second form is preferable.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"warning: Warning\nWhile rn_13 and rn_13_alt will generate equivalent simulations, for jump simulations, the first model will have reduced performance as it generates a less performant representation of the system in JumpProcesses. It is generally recommended to write pure mass action reactions such that there is just a single constant within the rate constant expression for optimal performance of jump process simulations.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"danger: Danger\nCatalyst automatically infers whether quantities appearing in the DSL are species or parameters (as described here). Generally, anything that does not appear as a reactant is inferred to be a parameter. This means that if you want to model a reaction activated by a species (e.g. kp*A, 0 --> P), but that species does not occur as a reactant, it will be interpreted as a parameter. This can be handled by manually declaring the system species.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Above we used a simple example where the rate was the product of a species and a parameter. However, any valid Julia expression of parameters, species, and values can be used. E.g the following is a valid model:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_14 = @reaction_network begin\n    2.0 + X^2, 0 --> X + Y\n    k1 + k2^k3, X --> ∅\n    pi * X/(sqrt(2) + Y), Y → ∅\nend","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_nonconstant_rates_functions","page":"The Catalyst DSL - Introduction","title":"Using functions in rates","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"It is possible for the rate to contain Julia functions. These can either be functions from Julia's standard library:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_16 = @reaction_network begin\n    d, A --> 0\n    kp*sqrt(A), 0 --> P\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"or ones defined by the user:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"custom_function(p1, p2, X) = (p1 + X) / (p2 + X)\nrn_17 = @reaction_network begin\n    d, A --> 0\n    custom_function(k1,k2,E), 0 --> P\nend","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_nonconstant_rates_available_functions","page":"The Catalyst DSL - Introduction","title":"Pre-defined functions","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Two functions frequently used within systems biology are the Michaelis-Menten and Hill functions. These are pre-defined in Catalyst and can be called using mm(X,v,K) and hill(X,v,K,n). E.g. a self-activation loop where X activates its own production through a Hill function can be created using:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_18 = @reaction_network begin\n    hill(X,v,K,n), 0 --> P\n    d, X --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Catalyst comes with the following predefined functions:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"The Michaelis-Menten function: mm(XvK) = v * X(X + K).\nThe repressive Michaelis-Menten function: mmr(XvK) = v * K(X + K).\nThe Hill function: hill(XvKn) = v * (X^n)(X^n + K^n).\nThe repressive Hill function: hillr(XvKn) = v * (K^n)(X^n + K^n).\nThe activating/repressive Hill function: hillar(XYvKn) = v * (X^n)(X^n + Y^n + K^n).","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_nonconstant_rates_time","page":"The Catalyst DSL - Introduction","title":"Time-dependant rates","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Previously we have assumed that the rates are independent of the time variable, t. However, time-dependent reactions are also possible. Here, simply use t to represent the time variable. E.g., to create a production/degradation model where the production rate decays as time progresses, we can use:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_14 = @reaction_network begin\n    kp/(1 + t), 0 --> P\n    d, P --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Like previously, t can be part of any valid expression. E.g. to create a reaction with a cyclic rate (e.g. to represent a circadian system) we can use:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_15 = @reaction_network begin\n    A*(sin(2π*f*t - ϕ)+1)/2, 0 --> P\n    d, P --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"warning: Warning\nModels with explicit time-dependent rates require additional steps to correctly convert to stochastic chemical kinetics jump process representations. See here for guidance on manually creating such representations. Enabling Catalyst to handle this seamlessly is work in progress.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_stoichiometries","page":"The Catalyst DSL - Introduction","title":"Non-standard stoichiometries","text":"","category":"section"},{"location":"model_creation/dsl_basics/#dsl_description_stoichiometries_decimal","page":"The Catalyst DSL - Introduction","title":"Non-integer stoichiometries","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Previously all stoichiometric constants have been integer numbers, however, decimal numbers are also permitted. Here we create a birth-death model where each production reaction produces 1.5 units of X:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_16 = @reaction_network begin\n    p, 0 --> 1.5X\n    d, X --> 0\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"It is also possible to have non-integer stoichiometric coefficients for substrates. However, in this case the combinatoric_ratelaw = false option must be used. We note that non-integer stoichiometric coefficients do not make sense in most fields, however, this feature is available for use for models where it does make sense.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_stoichiometries_parameters","page":"The Catalyst DSL - Introduction","title":"Parametric stoichiometries","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"It is possible for stoichiometric coefficients to be parameters. E.g. here we create a generic polymerisation system where n copies of X bind to form Xn:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_17 = @reaction_network begin\n    (kB,kD), n*X <--> Xn\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Now we can designate the value of n through a parameter when we e.g. create an ODEProblem:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"u0 = [:X => 5.0, :Xn => 1.0]\nps = [:kB => 1.0, :kD => 0.1, :n => 4]\noprob = ODEProblem(rn_17, u0, (0.0, 1.0), ps)\nnothing # hide","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_symbols","page":"The Catalyst DSL - Introduction","title":"Using special symbols","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Julia permits any Unicode characters to be used in variable names, thus Catalyst can use these as well. Below we describe some cases where this can be useful. No functionality is, however, tied to this.","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_symbols_empty_set","page":"The Catalyst DSL - Introduction","title":"Using ∅ in degradation/production reactions","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Previously, we described how 0 could be used to create degradation or production reactions. Catalyst permits the user to instead use the ∅ symbol. E.g. the production/degradation system can alternatively be written as:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn4 = @reaction_network begin\n    p, ∅ --> X\n    d, X --> ∅\nend","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_symbols_arrows","page":"The Catalyst DSL - Introduction","title":"Using special arrow symbols","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Catalyst uses -->, <-->, and <-- to denote forward, bi-directional, and backwards reactions, respectively. Several unicode representations of these arrows are available. Here,","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":">, →, ↣, ↦, ⇾, ⟶, ⟼, ⥟, ⥟, ⇀, and ⇁ can be used to represent forward reactions.\n↔, ⟷, ⇄, ⇆, ⇌, ⇋, , and ⇔ can be used to represent bi-directional reactions.\n<, ←, ↢, ↤, ⇽, ⟵, ⟻, ⥚, ⥞, ↼, , and ↽ can be used to represent backwards reactions.","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"E.g. the production/degradation system can alternatively be written as:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn4 = @reaction_network begin\n    p, ∅ → X\n    d, X → ∅\nend","category":"page"},{"location":"model_creation/dsl_basics/#dsl_description_symbols_special","page":"The Catalyst DSL - Introduction","title":"Using special symbols to denote species or parameters","text":"","category":"section"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"A range of possible characters are available which can be incorporated into species and parameter names. This includes, but is not limited to:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"Greek letters (e.g α, σ, τ, and Ω).\nSuperscript and subscript characters (to create e.g. k₁, k₂, Xₐ, and Xᴾ).\nNon-latin, non-greek, letters (e.g. ä, Д, س, and א).\nOther symbols (e.g. £, ℂ, ▲, and ♠).","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"An example of how this can be used to create a neat-looking model can be found in Schwall et al. (2021) where it was used to model a sigma factor V circuit in the bacteria Bacillus subtilis:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"σᵛ_model = @reaction_network begin\n    v₀ + hill(σᵛ,v,K,n), ∅ → σᵛ + A\n    kdeg, (σᵛ, A, Aσᵛ) → ∅\n    (kB,kD), A + σᵛ ↔ Aσᵛ\n    L, Aσᵛ → σᵛ\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"This functionality can also be used to create less serious models:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"rn_13 = @reaction_network begin\n    🍦, 😢 --> 😃\nend","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"It should be noted that the following symbols are not permitted to be used as species or parameter names:","category":"page"},{"location":"model_creation/dsl_basics/","page":"The Catalyst DSL - Introduction","title":"The Catalyst DSL - Introduction","text":"pi and π (used in Julia to denote 3.1415926535897...).\nℯ (used in Julia to denote Euler's constant).\nt (used to denote the time variable).\n∅ (used for production/degradation reactions).\nim (used in Julia to represent complex numbers).\nnothing (used in Julia to denote nothing).\nΓ (used by Catalyst to represent conserved quantities).","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/#math_models_in_catalyst","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"","category":"section"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"We now describe the types of mathematical models that Catalyst can generate from chemical reaction networks (CRNs), corresponding to reaction rate equation (RRE) ordinary differential equation (ODE) models, Chemical Langevin equation (CLE) stochastic differential equation (SDE) models, and stochastic chemical kinetics (jump process) models. For each we show the abstract representations for the models that Catalyst can support, along with concrete examples. Note that we restrict ourselves to models involving only chemical reactions, and do not consider more general models that Catalyst can support such as coupling in non-reaction ODEs, algebraic equations, or events. Please see the broader documentation for more details on how Catalyst supports such functionality.","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"note: Note\nThis documentation assumes you have already read the Introduction to Catalyst tutorial.","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/#General-Chemical-Reaction-Notation","page":"Mathematical Models Catalyst can Generate","title":"General Chemical Reaction Notation","text":"","category":"section"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"Suppose we have a reaction network with K reactions and M species, with the species labeled by S_1, S_2, dots, S_M. We denote by","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"mathbfX(t) = beginpmatrix X_1(t)  vdots  X_M(t)) endpmatrix","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"the state vector for the amount of each species, i.e. X_m(t) represents the amount of species S_m at time t. This could be either a concentration or a count (i.e. \"number of molecules\" units), but for consistency between modeling representations we will assume the latter in the remainder of this introduction.","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"The kth chemical reaction is given by","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"alpha_1^k S_1 + alpha_2^k S_2 + dots alpha_M^k S_M to beta_1^k S_1 + beta_2^k S_2 + dots beta_M^k S_M","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"with alpha^k = (alpha_1^kdotsalpha_M^k) its substrate stoichiometry vector, beta^k = (beta_1^kdotsbeta_M^k) its product stoichiometry vector, and nu^k = beta^k - alpha^k its net stoichiometry vector. nu^k corresponds to the change in mathbfX(t) when reaction k occurs, i.e. mathbfX(t) to mathbfX(t) + nu^k. Along with the stoichiometry vectors, we assume each reaction has a reaction rate law (ODEs/SDEs) or propensity (jump process) function, a_k(mathbfX(t)t).","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"As explained in the Catalyst introduction, for a mass action reaction where the preceding reaction has a fixed rate constant, k, this function would be the rate law","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"a_k(mathbfX(t)) = k prod_m=1^M frac(X_m(t))^alpha_m^kalpha_m^k","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"for RRE ODE and CLE SDE models, and the propensity function","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"a_k(mathbfX(t)) = k prod_m=1^M fracX_m(t) (X_m(t)-1) dots (X_m(t)-alpha_m^k+1)alpha_m^k","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"for stochastic chemical kinetics jump process models.","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/#Rate-Law-vs.-Propensity-Example:","page":"Mathematical Models Catalyst can Generate","title":"Rate Law vs. Propensity Example:","text":"","category":"section"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"For the reaction 2A + B oversetkto 3 C we would have","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"mathbfX(t) = (A(t) B(t) C(t))","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"with alpha_1 = 2, alpha_2 = 1, alpha_3 = 0, beta_1 = 0, beta_2 = 0, beta_3 = 3, nu_1 = -2, nu_2 = -1, and nu_3 = 3. For an ODE/SDE model we would have the rate law","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"a(mathbfX(t)) = frack2 A^2 B","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"while for a jump process model we would have the propensity function","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"a(mathbfX(t)) = frack2 A (A-1) B","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"Note, if the combinatoric factors are already included in one's rate constants, the implicit rescaling of rate constants can be disabled through use of the combinatoric_ratelaws = false argument to Base.convert or whatever Problem is being generated, i.e.","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"rn = @reaction_network ...\nosys = convert(ODESystem, rn; combinatoric_ratelaws = false)\noprob = ODEProblem(osys, ...)\n\n# or\noprob = ODEProblem(rn, ...; combinatoric_ratelaws = false)","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"In this case our ODE/SDE rate law would be","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"a(mathbfX(t)) = k A^2 B","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"while the jump process propensity function is","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"a(mathbfX(t)) = k A (A-1) B","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/#math_models_in_catalyst_rre_odes","page":"Mathematical Models Catalyst can Generate","title":"Reaction Rate Equation (RRE) ODE Models","text":"","category":"section"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"The RRE ODE models Catalyst creates for a general system correspond to the coupled system of ODEs given by","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"fracd X_mdt =sum_k=1^K nu_m^k a_k(mathbfX(t)t) quad m = 1dotsM","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"These models can be generated by creating ODEProblems from Catalyst ReactionSystems, and solved using the solvers in OrdinaryDiffEq.jl. Similarly, creating NonlinearProblems or SteadyStateProblems will generate the coupled algebraic system of steady-state equations associated with a RRE ODE model, i.e.","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"0 =sum_k=1^K nu_m^k a_k(barmathbfX) quad m = 1dotsM","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"for a steady-state barmathbfX. Note, here we have assumed the rate laws are autonomous so that the equations are well-defined.","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/#RRE-ODE-Example","page":"Mathematical Models Catalyst can Generate","title":"RRE ODE Example","text":"","category":"section"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"Let's see the generated ODEs for the following network","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"using Catalyst, ModelingToolkit, Latexify\nrn = @reaction_network begin\n    k₁, 2A + B --> 3C\n    k₂, A --> 0\n    k₃, 0 --> A\nend\nosys = convert(ODESystem, rn)","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"Likewise, the following drops the combinatoric scaling factors, giving unscaled ODEs","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"osys = convert(ODESystem, rn; combinatoric_ratelaws = false)","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/#Chemical-Langevin-Equation-(CLE)-SDE-Models","page":"Mathematical Models Catalyst can Generate","title":"Chemical Langevin Equation (CLE) SDE Models","text":"","category":"section"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"The CLE SDE models Catalyst creates for a general system correspond to the coupled system of SDEs given by","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"d X_m = sum_k=1^K nu_m^k a_k(mathbfX(t)t) dt + sum_k=1^K nu_m^k sqrta_k(mathbfX(t)t) dW_k(t) quad m = 1dotsM","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"where each W_k(t) represents an independent, standard Brownian Motion. Realizations of these processes can be generated by creating SDEProblems from Catalyst ReactionSystems, and sampling the processes using the solvers in StochasticDiffEq.jl.","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/#CLE-SDE-Example","page":"Mathematical Models Catalyst can Generate","title":"CLE SDE Example","text":"","category":"section"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"Consider the same network as above,","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"rn = @reaction_network begin\n    k₁, 2A + B --> 3C\n    k₂, A --> 0\n    k₃, 0 --> A\nend","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"We obtain the CLE SDEs","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"beginalign\ndA(t) = left(- k_1 A^2 B - k_2 A + k_3 right) dt\n - 2 sqrttfrack_12 A^2 B  dW_1(t)  - sqrtk_2 A  dW_2(t) + sqrtk_3  dW_3(t)\n\ndB(t) = - frack_12 A^2 B  dt - sqrtfrack_12 A^2 B  dW_1(t) \ndC(t) = frac32 k_1 A^2 B  dt + 3 sqrtfrack_12 A^2 B  dW_1(t)\nendalign","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/#Stochastic-Chemical-Kinetics-Jump-Process-Models","page":"Mathematical Models Catalyst can Generate","title":"Stochastic Chemical Kinetics Jump Process Models","text":"","category":"section"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"The stochastic chemical kinetics jump process models Catalyst creates for a general system correspond to the coupled system of jump processes, in the time change representation, given by","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"X_m(t) = X_m(0) + sum_k=1^K nu_m^k Y_kleft( int_0^t a_k(mathbfX(s^-)s)  ds right) quad m = 1dotsM","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"Here each Y_k(t) denotes an independent unit rate Poisson counting process with Y_k(0) = 0, which counts the number of times the kth reaction has occurred up to time t. Realizations of these processes can be generated by creating JumpProblems from Catalyst ReactionSystems, and sampling the processes using the solvers in JumpProcesses.jl.","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"Let P(mathbfxt) = operatornameProbmathbfX(t) = mathbfx represent the probability the state of the system, mathbfX(t), has the concrete value mathbfx at time t. The forward equation, i.e. Chemical Master Equation (CME), associated with mathbfX(t) is then the coupled system of ODEs over all possible values for mathbfx given by","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"fracdPdt(mathbfxt) = sum_k=1^k left a_k(mathbfx - nu^kt) P(mathbfx - nu^kt) - a_k(mathbfxt) P(mathbfxt) right","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"While Catalyst does not currently support generating and solving for P(mathbfxt), for sufficiently small models the FiniteStateProjection.jl package can be used to generate and solve such models directly from Catalyst ReactionSystems.","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/#Stochastic-Chemical-Kinetics-Jump-Process-Example","page":"Mathematical Models Catalyst can Generate","title":"Stochastic Chemical Kinetics Jump Process Example","text":"","category":"section"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"Consider the same network as above,","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"rn = @reaction_network begin\n    k₁, 2A + B --> 3C\n    k₂, A --> 0\n    k₃, 0 --> A\nend","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"The time change process representation would be","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"beginalign*\nA(t) = A(0) - 2 Y_1left( frack_12 int_0^t A(s^-)(A(s^-)-1) B(s^-)  ds right) - Y_2 left( k_2 int_0^t A(s^-)  ds right) + Y_3 left( k_3 t right) \nB(t) = B(0) - Y_1left( frack_12 int_0^t A(s^-)(A(s^-)-1) B(s^-)  ds right) \nC(t) = C(0) + 3 Y_1left( frack_12 int_0^t A(s^-)(A(s^-)-1) B(s^-)  ds right)\nendalign*","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"while the CME would be the coupled (infinite) system of ODEs over all realizable values of the non-negative integers a, b, and c given by","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"beginalign*\nfracdPdt(abct) = lefttfrack_12 (a+2) (a+1) (b+1) P(a+2b+1c-3t) - tfrack_12 a (a-1) b P(abct)right \nphantom= + leftk_2 (a+1) P(a+1bct) - k_2 a P(abct)right \nphantom= + leftk_3 P(a-1bct) - k_3 P(abct)right\nendalign*","category":"page"},{"location":"introduction_to_catalyst/math_models_intro/","page":"Mathematical Models Catalyst can Generate","title":"Mathematical Models Catalyst can Generate","text":"If we initially have A(0) = a_0, B(0) = b_0, and C(0) = c_0 then we would have one ODE for each of possible state (abc) where a in 01dots (i.e. a can be any non-negative integer), b in 01dotsb_0, and c in c_0 c_0 + 1dots c_0 + 3 b_0. Other initial conditions would lead to different possible ranges for a, b, and c.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The Catalyst tool for the modelling of chemical reaction networks is based in the Julia programming language[1][2]. While experience in Julia programming is advantageous for using Catalyst, it is not necessary for accessing most of its basic features. This tutorial serves as an introduction to Catalyst for those unfamiliar with Julia, while also introducing some basic Julia concepts. Anyone who plans on using Catalyst extensively is recommended to familiarise oneself more thoroughly with the Julia programming language. A collection of resources for learning Julia can be found here, and a full documentation is available here. A more practical (but also extensive) guide to Julia programming can be found here.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Julia can be downloaded here. Generally, it is recommended to use the juliaup tool to install and update Julia. Furthermore, Visual Studio Code is a good IDE with extensive Julia support, and a good default choice.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Users who are already familiar with Julia can skip to the Introduction to Catalyst tutorial.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#Basic-Julia-usage","page":"Introduction to Catalyst and Julia for New Julia users","title":"Basic Julia usage","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"On the surface, Julia has many similarities to languages like MATLAB, Python, and R.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Values can be assigned to variables through = sign. Values (possibly stored in variables) can be used for most basic computations.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"length = 2.0\nwidth = 4.0\narea = length * width","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Functions take one or more inputs (enclosed by ()) and return some output. E.g. the min function returns the minimum of two values.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"min(1.0, 3.0)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Julia has a specific help mode, which can be queried for information about any function (including those defined by Catalyst).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Each Julia variable has a specific type, designating what type of value it contains. While not directly required to use Catalyst, this is useful to be aware of. To learn the type of a specific variable, use the typeof function. More information about types can be found here.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"typeof(1.0)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, Float64 denotes decimal-valued numbers. Integer-valued numbers instead have the Int64 type.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"typeof(1)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"There exists a large number of Julia types (with even more being defined by various packages). Additional examples include Strings (defined by enclosing text within \" \"):","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"\"Hello world!\"","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"and Symbols (defined by pre-appending an expression with :):","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":":Julia","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, we note that the first time some code is run in Julia, it has to be compiled. However, this is only required once per Julia session. Hence, the second time the same code is run, it runs much faster. E.g. try running this line of code first one time, and then one additional time. You will note that the second run is much faster.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"rand(100, 100)^3.5\nnothing # hide","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"(This code creates a random 100x100 matrix, and takes it to the power of 3.5)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"This is useful to know when you e.g. declare, simulate, or plot, a Catalyst model. The first time you run a command there might be a slight delay. However, subsequent runs will be much quicker. This holds even if you make minor adjustments before the second run (such as changing simulation initial conditions).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages_intro","page":"Introduction to Catalyst and Julia for New Julia users","title":"Installing and activating packages","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Due to its native package manager (Pkg), and a registry of almost all packages of relevancy, package management in Julia is unusually easy. Here, we will briefly describe how to install and activate Catalyst (and two additional packages relevant to this tutorial).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"To import a Julia package into a session, you can use the using PackageName command (where PackageName is the name of the package you wish to import). However, before you can do so, it must first be installed on your computer. This is done through the Pkg.add(\"PackageName\") command:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Pkg\nPkg.add(\"Catalyst\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, the Julia package manager package (Pkg) is by default installed on your computer when Julia is installed, and can be activated directly. Next, we install an ODE solver from a sub-library of the larger OrdinaryDiffEq package, and install the Plots package for making graphs. We will import the recommended default solver from the OrdinaryDiffEqDefault sub-library. A full list of OrdinaryDiffEq solver sublibraries can be found on the sidebar of this page.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pkg.add(\"OrdinaryDiffEqDefault\")\nPkg.add(\"Plots\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Once a package has been installed through the Pkg.add command, this command does not have to be repeated if we restart our Julia session. We can now import all three packages into our current session with:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Catalyst\nusing OrdinaryDiffEqDefault\nusing Plots","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, if we restart Julia, these using commands must be rerun.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"A more comprehensive (but still short) introduction to package management in Julia is provided at the end of this documentation page. It contains some useful information and is hence highly recommended reading. For a more detailed introduction to Julia package management, please read the Pkg documentation.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#Simulating-a-basic-Catalyst-model","page":"Introduction to Catalyst and Julia for New Julia users","title":"Simulating a basic Catalyst model","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Now that we have some basic familiarity with Julia, and have installed and imported the required packages, we will create and simulate a basic chemical reaction network model using Catalyst.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Catalyst models are created through the @reaction_network macro. For more information on macros, please read the Julia documentation on macros. This documentation is, however, rather advanced (and not required to use Catalyst). We instead recommend that you simply familiarise yourself with the Catalyst syntax, without studying in detail how macros work and what they are.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The @reaction_network command is followed by the begin keyword, which is followed by one line for each reaction of the model. Each reaction consists of a reaction rate, followed by the reaction itself. The reaction contains a set of substrates and a set of products (what is consumed and produced by the reaction, respectively). These are separated by a --> arrow. Finally, the model ends with the end keyword.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, we create a simple birth-death model, where a single species (X) is created at rate b, and degraded at rate d. The model is stored in the variable rn.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"rn = @reaction_network begin\n    b, 0 --> X\n    d, X --> 0\nend","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"For more information on how to use the Catalyst model creator (also known as the Catalyst DSL), please read the corresponding documentation.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Next, we wish to simulate our model. To do this, we need to provide some additional information to the simulator. This is","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The initial condition. That is, the concentration (or copy numbers) of each species at the start of the simulation.\nThe time span. That is, the time frame over which we wish to run the simulation.\nThe parameter values. That is, the values of the model's parameters for this simulation.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The initial condition is given as a Vector. This is a type which collects several different values. To declare a vector, the values are specific within brackets, [], and separated by ,. Since we only have one species, the vector holds a single element. In this element, we set the value of X using the :X => 1.0 syntax. Here, we first denote the name of the species (with a : pre-appended, which creates a Symbol), next follows a => and then the value of X. Since we wish to simulate the concentration of X over time, we will let the initial condition be decimal valued.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"u0 = [:X => 1.0]","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The timespan sets the time point at which we start the simulation (typically 0.0 is used) and the final time point of the simulation. These are combined into a two-valued tuple. Tuples are similar to vectors, but are enclosed by () and not []. Again, we will let both time points be decimal valued.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"tspan = (0.0, 10.0)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, the parameter values are, like the initial conditions, given in a vector. Since we have two parameters (b and d), the parameter vector has two values. We use a similar notation for setting the parameter values as the initial condition (first the parameter, then an arrow, then the value).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"params = [:b => 1.0, :d => 0.2]","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Please read here for more information on vectors and tuples.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Next, before we can simulate our model, we bundle all the required information together in a so-called ODEProblem. Note that the order in which the input (the model, the initial condition, the timespan, and the parameter values) is provided to the ODEProblem matters. E.g. the parameter values cannot be provided as the first argument, but have to be the fourth argument. Here, we save our ODEProblem in the oprob variable.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"oprob = ODEProblem(rn, u0, tspan, params)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"We can now simulate our model. We do this by providing the ODEProblem to the solve function. We save the output to the sol variable.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"sol = solve(oprob)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, we can plot the solution through the plot function.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"plot(sol)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, the plot shows the time evolution of the concentration of the species X from its initial condition.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"For more information about the numerical simulation package, please see the DifferentialEquations documentation. For more information about the plotting package, please see the Plots documentation.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#Additional-modelling-example","page":"Introduction to Catalyst and Julia for New Julia users","title":"Additional modelling example","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"To make this introduction more comprehensive, we here provide another example, using a more complicated model. Instead of simulating our model as concentrations evolve over time, we will now simulate the individual reaction events through the Gillespie algorithm (a common approach for adding noise to models).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Remember (unless we have restarted Julia) we do not need to activate our packages (through the using command) again. However, we do need to install, and then import, the JumpProcesses package (just to perform Gillespie, and other jump, simulations)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pkg.add(\"JumpProcesses\")\nusing JumpProcesses","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"This time, we will declare a so-called SIR model for an infectious disease. Note that even if this model does not describe a set of chemical reactions, it can be modelled using the same framework. The model consists of 3 species:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"S, the amount of susceptible individuals.\nI, the amount of infected individuals.\nR, the amount of recovered (or removed) individuals.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"It also has 2 reaction events:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Infection, where a susceptible individual meets an infected individual and also becomes infected.\nRecovery, where an infected individual recovers from the infection.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Each reaction is also associated with a specific rate (corresponding to a parameter).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"b, the infection rate.\nk, the recovery rate.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"We declare the model using the @reaction_network macro, and store it in the sir_model variable.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"sir_model = @reaction_network begin\n    b, S + I --> 2I\n    k, I --> R\nend","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Note that the first reaction contains two different substrates (separated by a + sign). While there is only a single product (I), two copies of I are produced. The 2 in front of the product I denotes this.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Next, we declare our initial condition, time span, and parameter values. Since we want to simulate the individual reaction events that discretely change the state of our model, we want our initial conditions to be integer-valued. We will start with a mostly susceptible population, but to which a single infected individual has been introduced.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"u0 = [:S => 50, :I => 1, :R => 0]\ntspan = (0.0, 10.0)\nparams = [:b => 0.2, :k => 1.0]\nnothing # hide","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Previously we have bundled this information into an ODEProblem (denoting a deterministic ordinary differential equation). Now we wish to simulate our model as a jump process (where each reaction event corresponds to a discrete change in the state of the system). We do this by first processing the inputs to work in a jump model – an extra step needed for jump models that can be avoided for ODE/SDE models – and then creating a JumpProblem from the inputs:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using JumpProcesses # hide\njinput = JumpInputs(sir_model, u0, tspan, params)\njprob = JumpProblem(jinput)\nnothing # hide","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, we can now simulate our model using the solve function, and plot the solution using the plot function.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"sol = solve(jprob)\nsol = solve(jprob; seed=1234) # hide\nplot(sol)","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Exercise: Try simulating the model several times. Note that the epidemic doesn't always take off, but sometimes dies out without spreading through the population. Try changing the infection rate (b), determining how this value affects the probability that the epidemic goes through the population.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages","page":"Introduction to Catalyst and Julia for New Julia users","title":"Package management in Julia","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"We have previously introduced how to install and activate Julia packages. While this is enough to get started with Catalyst, for long-term users, there are some additional considerations for a smooth experience. These are described here.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages_environments","page":"Introduction to Catalyst and Julia for New Julia users","title":"Setting up a new Julia environment","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Whenever you run Julia, it will run in a specific environment. You can specify any folder on your computer as a Julia environment. Some modes of running Julia will automatically use the environment corresponding to the folder you start Julia in. Others (or if you start Julia in a folder without an environment), will use your default environment. In these cases you can, during your session, switch to another environment. While it is possible to not worry about environments (and always use the default one), this can lead to long-term problems as more packages are installed.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"To activate your current folder as an environment, run the following commands:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Pkg\nPkg.activate(\".\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"This will:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"If your current folder (which can be displayed using the pwd() command) is not designated as a possible Julia environment, designate it as such.\nSwitch your current Julia session to use the current folder's environment.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"note: Note\nIf you check any folder which has been designated as a Julia environment, it contains a Project.toml and a Manifest.toml file. These store all information regarding the corresponding environment. For non-advanced users, it is recommended to never touch these files directly (and instead do so using various functions from the Pkg package, the important ones which are described in the next two subsections).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages_installing","page":"Introduction to Catalyst and Julia for New Julia users","title":"Installing and importing packages in Julia","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Package installation and import have been described previously. However, for the sake of this extended tutorial, let us repeat the description by demonstrating how to install the Latexify.jl package (which enables e.g. displaying Catalyst models in Latex format). First, we import the Julia Package manager (Pkg) (which is required to install Julia packages):","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Pkg","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Latexify is a registered package, so it can be installed directly using:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pkg.add(\"Latexify\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Finally, to import Latexify into our current Julia session we use:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Latexify","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, using Latexify must be rerun whenever you restart a Julia session. However, you only need to run Pkg.add(\"Latexify\") once to install it on your computer (but possibly additional times to add it to new environments, see the next section).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#catalyst_for_new_julia_users_packages_environment_importance","page":"Introduction to Catalyst and Julia for New Julia users","title":"Why environments are important","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"We have previously described how to set up new Julia environments, how to install Julia packages, and how to import them into a current session. Let us say that you were to restart Julia in a new folder and activate this as a separate environment. If you then try to import Latexify through using Latexify you will receive an error claiming that Latexify was not found. The reason is that the Pkg.add(\"Latexify\") command actually carries out two separate tasks:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"If Latexify is not already installed on your computer, install it.\nAdd Latexify as an available package to your current environment.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Here, while Catalyst has previously been installed on your computer, it has not been added to the new environment you created. To do so, simply run","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"using Pkg\nPkg.add(\"Latexify\")","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"after which Catalyst can be imported through using Latexify. You can get a list of all packages available in your current environment using:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pkg.status()","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"So, why is this required, and why cannot we simply import any package installed on our computer? The reason is that most packages depend on other packages, and these dependencies may be restricted to only specific versions of these packages. This creates complicated dependency graphs that restrict what versions of what packages are compatible with each other. When you use Pkg.add(\"PackageName\"), only a specific version of that package is actually added (the latest possible version as permitted by the dependency graph). Here, Julia environments both define what packages are available and their respective versions (these versions are also displayed by the Pkg.status() command). By doing this, Julia can guarantee that the packages (and their versions) specified in an environment are compatible with each other.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"The reason why all this is important is that it is highly recommended to, for each project, define a separate environment. To these, only add the required packages. General-purpose environments with a large number of packages often, in the long term, produce package incompatibility issues. While these might not prevent you from installing all desired package, they often mean that you are unable to use the latest version of some packages.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"note: Note\nA not-infrequent cause for reported errors with Catalyst (typically the inability to replicate code in tutorials) is package incompatibilities in large environments preventing the latest version of Catalyst from being installed. Hence, whenever an issue is encountered, it is useful to run Pkg.status() to check whenever the latest version of Catalyst is being used.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Some additional useful Pkg commands are:","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"Pk.rm(\"PackageName\") removes a package from the current environment.\nPkg.update(\"PackageName\"): updates the designated package.\nPkg.update(): updates all packages.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"note: Note\nA useful feature of Julia's environment system is that enables the exact definition of what packages and versions were used to execute a script. This supports e.g. reproducibility in academic research. Here, by providing the corresponding Project.toml and Manifest.toml files, you can enable someone to reproduce the exact program used to perform some set of analyses.","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#Feedback","page":"Introduction to Catalyst and Julia for New Julia users","title":"Feedback","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"If you are a new Julia user who has used this tutorial, and there was something you struggled with or would have liked to have explained better, please raise an issue. That way, we can continue improving this tutorial. The same goes for any part of the Catalyst documentation: It is written to help new users understand how to use the package, and if it is not doing so successfully we would like to know!","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/#References","page":"Introduction to Catalyst and Julia for New Julia users","title":"References","text":"","category":"section"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"[1]: Torkel E. Loman, Yingbo Ma, Vasily Ilin, Shashi Gowda, Niklas Korsbo, Nikhil Yewale, Chris Rackauckas, Samuel A. Isaacson, Catalyst: Fast and flexible modeling of reaction networks, PLOS Computational Biology (2023).","category":"page"},{"location":"introduction_to_catalyst/catalyst_for_new_julia_users/","page":"Introduction to Catalyst and Julia for New Julia users","title":"Introduction to Catalyst and Julia for New Julia users","text":"[2]: Jeff Bezanson, Alan Edelman, Stefan Karpinski, Viral B. Shah, Julia: A Fresh Approach to Numerical Computing, SIAM Review (2017).","category":"page"},{"location":"spatial_modelling/spatial_jump_simulations/#spatial_lattice_jump_simulations","page":"Spatial jump simulations","title":"Spatial jump simulations","text":"","category":"section"},{"location":"spatial_modelling/spatial_jump_simulations/","page":"Spatial jump simulations","title":"Spatial jump simulations","text":"Our introduction to spatial lattice simulations has already described how to simulate LatticeReactionSystems using ODEs. Jump simulations of LatticeReactionSystem are carried out using an almost identical approach. However, just like for non-spatial models, we must first create a DiscreteProblem, which is then used as input to our JumpProblem. Furthermore, a spatial jump aggregator (like NSM) can be used. Spatial jump simulations in Catalyst are built on top of JumpProcesses.jl's spatial jump simulators, more details on which can be found here.","category":"page"},{"location":"spatial_modelling/spatial_jump_simulations/","page":"Spatial jump simulations","title":"Spatial jump simulations","text":"Below we perform a spatial jump simulation of a simple birth-death process. Note that we use our LatticeReactionSystem as input to both our DiscreteProblem and JumpProblem, and that we provide the spatial NSM jump aggregator to JumpProblem.","category":"page"},{"location":"spatial_modelling/spatial_jump_simulations/","page":"Spatial jump simulations","title":"Spatial jump simulations","text":"using Catalyst, JumpProcesses\nbd_model = @reaction_network begin\n    (p,d), 0 <--> X\nend\ndiffusion_rx = @transport_reaction D X\nlattice = CartesianGrid((10,10))\nlrs = LatticeReactionSystem(bd_model, [diffusion_rx], lattice)\n\nu0 = [:X => 0]\ntspan = (0.0, 200.0)\nps = [:p => 10.0, :d => 1.0, :D => 0.1]\ndprob = DiscreteProblem(lrs, u0, tspan, ps)\njprob = JumpProblem(lrs, dprob, NSM())\nsol = solve(jprob, SSAStepper())\nnothing # hide","category":"page"},{"location":"spatial_modelling/spatial_jump_simulations/","page":"Spatial jump simulations","title":"Spatial jump simulations","text":"We can now access the values of sol using the interfaces described here, and plot it using the functions described here.","category":"page"},{"location":"spatial_modelling/spatial_jump_simulations/","page":"Spatial jump simulations","title":"Spatial jump simulations","text":"Currently, the only available spatial jump aggregators are NSM and DirectCRDirect, with DirectCRDirect expected to perform better for large networks.","category":"page"},{"location":"spatial_modelling/spatial_jump_simulations/","page":"Spatial jump simulations","title":"Spatial jump simulations","text":"note: Note\nCurrently, spatial jump simulations are only supported when all reaction of the non-spatial ReactionSystem are MassActionJumps, i.e. have constant rates. This means that reactions with e.g. Michaelis-Menten rates are currently not supported.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Within the Catalyst DSL, each line can represent either a reaction or an option. The previous DSL tutorial described how to create reactions. This one will focus on options. These are typically used to supply a model with additional information. Examples include the declaration of initial condition/parameter default values, or the creation of observables. ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"All option designations begin with a declaration starting with @, followed by its input. E.g. the @observables option allows for the generation of observables. Each option can only be used once within each use of @reaction_network. This tutorial will also describe some additional advanced DSL features that do not involve using an option. ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"As a first step, we import Catalyst (which is required to run the tutorial):","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_declaring_species_and_parameters","page":"The Catalyst DSL - Advanced Features and Options","title":"Explicit specification of network species and parameters","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Previously, we mentioned that the DSL automatically determines which symbols correspond to species and which to parameters. This is done by designating everything that appears as either a substrate or a product as a species, and all remaining quantities as parameters (i.e. those only appearing within rates or stoichiometric constants). Sometimes, one might want to manually override this default behaviour for a given symbol. I.e. consider the following model, where the conversion of a protein P from its inactive form (Pᵢ) to its active form (Pₐ) is catalysed by an enzyme (E). Using the most natural description:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"catalysis_sys = @reaction_network begin\n    k*E, Pᵢ --> Pₐ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"E (as well as k) will be considered a parameter, something we can confirm directly:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"parameters(catalysis_sys)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"If we want E to be considered a species, we can designate this using the @species option:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"catalysis_sys = @reaction_network begin\n    @species E(t)\n    k*E, Pᵢ --> Pₐ\nend\nparameters(catalysis_sys)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"note: Note\nWhen declaring species using the @species option, the species symbol must be followed by (t). The reason is that species are time-dependent variables, and this time-dependency must be explicitly specified (designation of non-t dependant species is also possible).","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Similarly, the @parameters option can be used to explicitly designate something as a parameter:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"catalysis_sys = @reaction_network begin\n    @parameters k\n    k*E, Pᵢ --> Pₐ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Here, while k is explicitly defined as a parameter, no information is provided about E. Hence, the default case will be used (setting E to a parameter). The @species and @parameter options can be used simultaneously (although a quantity cannot be declared both as a species and a parameter). They may be followed by a full list of all species/parameters, or just a subset.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"While designating something which would default to a parameter as a species is straightforward, the reverse (creating a parameter which occurs as a substrate or product) is more involved. This is, however, possible, and described here.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Rather than listing all species/parameters on a single line after the options, a begin ... end block can be used (listing one species/parameter on each line). E.g. in the following example we use this notation to explicitly designate all species and parameters of the system:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"catalysis_sys = @reaction_network begin\n    @species begin \n        E(t)\n        Pᵢ(t)\n        Pₐ(t)\n    end\n    @parameters begin\n        k\n    end\n    k*E, Pᵢ --> Pₐ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A side-effect of using the @species and @parameter options is that they specify the order in which the species and parameters are stored. I.e. lets check the order of the parameters in the parameters in the following dimerisation model:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"dimerisation = @reaction_network begin\n    (p,d), 0 <--> X\n    (kB,kD), 2X <--> X2\nend\nparameters(dimerisation)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"The default order is typically equal to the order with which the parameters (or species) are encountered in the DSL (this is, however, not guaranteed). If we specify the parameters using @parameters, the order used within the option is used instead:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"dimerisation = @reaction_network begin\n    @parameters kB kD p d\n    (p,d), 0 <--> X\n    (kB,kD), 2X <--> X2\nend\nparameters(dimerisation)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"danger: Danger\nGenerally, Catalyst and the SciML ecosystem do not guarantee that parameter and species order are preserved throughout various operations on a model. Writing programs that depend on these orders is strongly discouraged. There are, however, some legacy packages which still depend on order (one example can be found here). In these situations, this might be useful. However, in these cases, it is recommended that the user is extra wary, and also checks the order manually. ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"note: Note\nThe syntax of the @species and @parameters options is identical to that used by the @species and @parameters macros used in programmatic modelling in Catalyst (for e.g. designating metadata or initial conditions). Hence, if one has learnt how to specify species/parameters using either approach, that knowledge can be transferred to the other one.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Generally, there are four main reasons for specifying species/parameters using the @species and @parameters options:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"To designate a quantity, that would otherwise have defaulted to a parameter, as a species.\nTo designate default values for parameters/species initial conditions (described here).\nTo designate metadata for species/parameters (described here).\nTo designate a species or parameters that do not occur in reactions, but are still part of the model (e.g a parametric initial condition)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"warning: Warning\nCatalyst's DSL automatically infer species and parameters from the input. However, it only does so for quantities that appear in reactions. Until now this has not been relevant. However, this tutorial will demonstrate cases where species/parameters that are not part of reactions are used. These must be designated using either the @species or @parameters options (or the @variables option, which is described later).","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_default_vals","page":"The Catalyst DSL - Advanced Features and Options","title":"Setting default values for species and parameters","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"When declaring species/parameters using the @species and @parameters options, one can also assign them default values (by appending them with = followed by the desired default value). E.g here we set X's default initial condition value to 10, and p and d's default values to 10 and 02, respectively:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nrn = @reaction_network begin\n    @species X(t)=1.0\n    @parameters p=1.0 d=0.1\n    (p,d), 0 <--> X\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Next, if we simulate the model, we do not need to provide values for species or parameters that have default values. In this case all have default values, so both u0 and ps can be empty vectors:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using OrdinaryDiffEqDefault, Plots\nu0 = []\ntspan = (0.0, 10.0)\np = []\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is still possible to provide values for some (or all) initial conditions/parameters in u0/ps (in which case these overrides the default values):","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"u0 = [:X => 4.0]\np = [:d => 0.5]\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is also possible to declare a model with default values for only some initial conditions/parameters:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nrn = @reaction_network begin\n    @species X(t)=1.0\n    (p,d), 0 <--> X\nend\n\ntspan = (0.0, 10.0)\np = [:p => 1.0, :d => 0.2]\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_parametric_initial_conditions","page":"The Catalyst DSL - Advanced Features and Options","title":"Setting parametric initial conditions","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"In the previous section, we designated default values for initial conditions and parameters. However, the right-hand side of the designation accepts any valid expression (not only numeric values). While this can be used to set up some advanced default values, the most common use case is to designate a species's initial condition as a parameter. E.g. in the following example we represent the initial condition of X using the parameter X₀. ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    @species X(t)=X₀\n    @parameters X₀\n    (p,d), 0 <--> X\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Please note that as the parameter X₀ does not occur as part of any reactions, Catalyst's DSL cannot infer whether it is a species or a parameter. This must hence be explicitly declared. We can now simulate our model while providing X's value through the X₀ parameter:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using OrdinaryDiffEqTsit5\nu0 = []\np = [:X₀ => 1.0, :p => 1.0, :d => 0.5]\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is still possible to designate X's value in u0, in which case this overrides the default value.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"u0 = [:X => 0.5]\np = [:X₀ => 1.0, :p => 1.0, :d => 0.5]\noprob = ODEProblem(rn, u0, tspan, p)\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Please note that X₀ is still a parameter of the system, and as such its value must still be designated to simulate the model (even if it is not actually used).","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_species_and_parameters_metadata","page":"The Catalyst DSL - Advanced Features and Options","title":"Designating metadata for species and parameters","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Catalyst permits the user to define metadata for species and parameters. This permits the user to assign additional information to these, which can be used for a variety of purposes. Some Catalyst features depend on using metadata (with each such case describing specifically how this is done). Here we will introduce how to set metadata, and describe some common metadata types. ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Whenever a species/parameter is declared using the @species/@parameters options, it can be followed by a [] within which the metadata is given. Each metadata entry consists of the metadata's name, followed by a =, followed by its value. E.g. the description metadata allows you to attach a String to a species/parameter. Here we create a simple model where we add descriptions to all species and parameters.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\ntwo_state_system = @reaction_network begin\n    @species Xᵢ(t) [description=\"X's inactive form\"] Xₐ(t) [description=\" X's active form\"]\n    @parameters kA [description=\"Activation rate\"] kD [description=\"Deactivation rate\"]\n    (ka,kD), Xᵢ <--> Xₐ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A metadata can be given to only a subset of a system's species/parameters, and a quantity can be given several metadata entries. To give several metadata, separate each by a ,. Here we only provide a description for kA, for which we also provide a bounds metadata,","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"two_state_system = @reaction_network begin\n    @parameters kA [description=\"Activation rate\", bounds=(0.01,10.0)]\n    (ka,kD), Xᵢ <--> Xₐ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is possible to add both default values and metadata to a parameter/species. In this case, first provide the default value, and next the metadata. I.e. to in the above example set kA's default value to 10 we use","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"two_state_system = @reaction_network begin\n    @parameters kA=1.0 [description=\"Activation rate\", bounds=(0.01,10.0)]\n    (ka,kD), Xᵢ <--> Xₐ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"When designating metadata for species/parameters in begin ... end blocks the syntax changes slightly. Here, a , must be inserted before the metadata (but after any potential default value). I.e. a version of the previous example can be written as","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"two_state_system = @reaction_network begin\n    @parameters begin\n        kA, [description=\"Activation rate\", bounds=(0.01,10.0)]\n        kD = 1.0, [description=\"Deactivation rate\"]\n    end\n    (kA,kD), Xᵢ <--> Xₐ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Each metadata has its own getter functions. E.g. we can get the description of the parameter kA using ModelingToolkit.getdescription:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"ModelingToolkit.getdescription(two_state_system.kA)","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_constant_species","page":"The Catalyst DSL - Advanced Features and Options","title":"Designating constant-valued/fixed species parameters","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Catalyst enables the designation of parameters as constantspecies. These parameters can be used as species in reactions, however, their values are not changed by the reaction and remain constant throughout the simulation (unless changed by e.g. the occurrence of an event. Practically, this is done by setting the parameter's isconstantspecies metadata to true. Here, we create a simple reaction where the species X is converted to Xᴾ at rate k. By designating X as a constant species parameter, we ensure that its quantity is unchanged by the occurrence of the reaction.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nrn = @reaction_network begin\n    @parameters X [isconstantspecies=true]\n    k, X --> Xᴾ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"We can confirm that Xᴾ is the only species of the system:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"species(rn)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Here, the produced model is actually identical to if X had simply been a parameter in the reaction's rate:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    k*X, 0 --> Xᴾ\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A common use-case for constant species is when modelling systems where some species are present in such surplus that their amounts the reactions' effect on it is negligible. A system which is commonly modelled this way is the Brusselator.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_parameter_types","page":"The Catalyst DSL - Advanced Features and Options","title":"Designating parameter types","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Sometimes it is desired to designate that a parameter should have a specific type. When supplying this parameter's value to e.g. an ODEProblem, that parameter will then be restricted to that specific type. Designating a type is done by appending the parameter with :: followed by its type. E.g. in the following example we specify that the parameter n (the number of X molecules in the Xn polymer) must be an integer (Int64)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\npolymerisation_network = @reaction_network begin\n    @parameters n::Int64\n    (kB,kD), n*X <--> Xn\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Generally, when simulating models with mixed parameter types, it is recommended to declare parameter values as tuples, rather than vectors, e.g.:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"ps = (:kB => 0.2, :kD => 1.0, :n => 2)\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"If a parameter has a type, metadata, and a default value, they are designated in the following order:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"polymerisation_network = @reaction_network begin\n    @parameters n::Int64 = 2 [description=\"Parameter n, an integer with defaults value 2.\"]\n    (kB,kD), n*X <--> Xn\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_vector_variables","page":"The Catalyst DSL - Advanced Features and Options","title":"Vector-valued species or parameters","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Sometimes, one wishes to declare a large number of similar parameters or species. This can be done by creating them as vectors. E.g. below we create a two-state system. However, instead of declaring X1 and X2 (and k1 and k2) as separate entities, we declare them as vectors:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\ntwo_state_model = @reaction_network begin\n    @parameters k[1:2]\n    @species (X(t))[1:2]\n    (k[1],k[2]), X[1] <--> X[2]\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Now, we can also declare our initial conditions and parameter values as vectors as well:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using OrdinaryDiffEqDefault, Plots # hide\nu0 = [:X => [0.0, 2.0]]\ntspan = (0.0, 1.0)\nps = [:k => [1.0, 2.0]]\noprob = ODEProblem(two_state_model, u0, tspan, ps)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_require_dec","page":"The Catalyst DSL - Advanced Features and Options","title":"Turning off species, parameter, and variable inference","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"In some cases it may be desirable for Catalyst to not infer species and parameters from the DSL, as in the case of reaction networks with very many variables, or as a sanity check that variable names are written correctly. To turn off inference, simply use the @require_declaration option when using the @reaction_network DSL. This will require every single variable, species, or parameter used within the DSL to be explicitly declared using the @variable, @species, or @parameter options. In the case that the DSL parser encounters an undeclared symbolic, it will error with an UndeclaredSymbolicError and print the reaction or equation that the undeclared symbolic was found in. ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst\nrn = @reaction_network begin\n    @require_declaration\n    (k1, k2), A <--> B\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Running the code above will yield the following error: ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"LoadError: UndeclaredSymbolicError: Unrecognized variables A detected in reaction expression: \"((k1, k2), A <--> B)\". Since the flag @require_declaration is declared, all species must be explicitly declared with the @species macro.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"In order to avoid the error in this case all the relevant species and parameters will have to be declared.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"# The following case will not error. \nusing Catalyst\nt = default_t()\nrn = @reaction_network begin\n    @require_declaration\n    @species A(t) B(t)\n    @parameters k1 k2\n    (k1, k2), A <--> B\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"The following cases in which the DSL would normally infer variables will all throw errors if @require_declaration is set and the variables are not explicitly declared.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Occurrence of an undeclared species in a reaction, as in the example above.\nOccurrence of an undeclared parameter in a reaction rate expression, as in the reaction line k*n, A --> B.\nOccurrence of an undeclared parameter in the stoichiometry of a species, as in the reaction line k, n*A --> B.\nOccurrence of an undeclared differential variable on the LHS of a coupled differential equation, as in A in @equations D(A) ~ A^2.\nOccurrence of an undeclared observable in an @observables expression, such as @observables X1 ~ A + B.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_naming","page":"The Catalyst DSL - Advanced Features and Options","title":"Naming reaction networks","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Each reaction network model has a name. It can be accessed using the nameof function. By default, some generic name is used:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nrn = @reaction_network begin\n    (p,d), 0 <--> X\nend\nnameof(rn)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A specific name can be given as an argument between the @reaction_network and the begin. E.g. to name a network my_network we can use:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network my_network begin\n    (p,d), 0 <--> X\nend\nnameof(rn)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A consequence of generic names being used by default is that networks, even if seemingly identical, by default are not. E.g.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn1 = @reaction_network begin\n    (p,d), 0 <--> X\nend\nrn2 = @reaction_network begin\n    (p,d), 0 <--> X\nend\nrn1 == rn2","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"The reason can be confirmed by checking that their respective (randomly generated) names are different:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"nameof(rn1) == nameof(rn2)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"By designating the networks to have the same name, however, identity is achieved.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn1 = @reaction_network my_network begin\n    (p,d), 0 <--> X\nend\nrn2 = @reaction_network my_network begin\n    (p,d), 0 <--> X\nend\nrn1 == rn2","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"If you wish to check for identity, and wish that models that have different names but are otherwise identical, should be considered equal, you can use the isequivalent function.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Setting model names is primarily useful for hierarchical modelling, where network names are appended to the display names of subnetworks' species and parameters.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_observables","page":"The Catalyst DSL - Advanced Features and Options","title":"Creating observables","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Sometimes one might want to use observable variables. These are variables with values that can be computed directly from a system's state (rather than having their values implicitly given by reactions or equations). Observables can be designated using the @observables option. Here, the @observables option is followed by a begin ... end block with one line for each observable. Each line first gives the observable, followed by a ~ (not a =!), followed by an expression describing how to compute it.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Let us consider a model where two species (X and Y) can bind to form a complex (XY, which also can dissociate back into X and Y). If we wish to create a representation for the total amount of X and Y in the system, we can do this by creating observables Xtot and Ytot:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nrn = @reaction_network begin\n    @observables begin\n        Xtot ~ X + XY\n        Ytot ~ Y + XY\n    end\n    (kB,kD), X + Y <--> XY\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"We can now simulate our model using normal syntax (initial condition values for observables should not, and can not, be provided):","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using OrdinaryDiffEqTsit5\nu0 = [:X => 1.0, :Y => 2.0, :XY => 0.0]\ntspan = (0.0, 10.0)\nps = [:kB => 1.0, :kD => 1.5]\noprob = ODEProblem(rn, u0, tspan, ps)\nsol = solve(oprob, Tsit5())\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Next, we can use symbolic indexing of our solution object, but with the observable as input. E.g. we can use ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"sol[:Xtot]\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"to get a vector with Xtot's value throughout the simulation. We can also use","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Plots\nplot(sol; idxs = :Xtot)\nplot!(ylimit = (minimum(sol[:Xtot])*0.95, maximum(sol[:Xtot])*1.05)) # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"to plot the observables (rather than the species).","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Observables can be defined using complicated expressions containing species, parameters, and variables (but not other observables). In the following example (which uses a parametric stoichiometry) X polymerises to form a complex Xn containing n copies of X. Here, we create an observable describing the total number of X molecules in the system:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    @observables Xtot ~ X + n*Xn\n    (kB,kD), n*X <--> Xn\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"note: Note\nIf only a single observable is declared, the begin ... end block is not required and the observable can be declared directly after the @observables option.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Metadata can be supplied to an observable directly after its declaration (but before its formula). If so, the metadata must be separated from the observable with a ,, and the observable plus the metadata encapsulated by (). E.g. to add a description metadata to our observable we can use","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    @observables (Xtot, [description=\"The total amount of X in the system.\"]) ~ X + n*Xn\n    (kB,kD), n*X <--> Xn\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Observables are by default considered variables (not species). To designate them as a species, they can be pre-declared using the @species option. I.e. Here Xtot becomes a species:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    @species Xtot(t)\n    @observables Xtot ~ X + n*Xn  \n    (kB,kD), n*X <--> Xn\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Some final notes regarding observables:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"The left-hand side of the observable declaration must contain a single symbol only (with the exception of metadata, which can also be supplied).\nAll quantities appearing on the right-hand side must be declared elsewhere within the @reaction_network call (either by being part of a reaction, or through the @species, @parameters, or @variables options).\nObservables may not depend on other observables.\nObservables have their dependent variable(s) automatically assigned as the union of the dependent variables of the species and variables on which it depends.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_ivs","page":"The Catalyst DSL - Advanced Features and Options","title":"Specifying non-time independent variables","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Catalyst's ReactionSystem models depend on a time independent variable, and potentially one or more spatial independent variables. By default, the independent variable t is used. We can declare another independent variable (which is automatically used as the default one) using the @ivs option. E.g. to use τ instead of t we can use","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nrn = @reaction_network begin\n    @ivs τ\n    (ka,kD), Xᵢ <--> Xₐ\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"We can confirm that Xᵢ and Xₐ depend on τ (and not t):","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"species(rn)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is possible to designate several independent variables using @ivs. If so, the first one is considered the default (time) independent variable, while the following one(s) are considered spatial independent variable(s). If we want some species to depend on a non-default independent variable, this has to be explicitly declared:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    @ivs τ x\n    @species X(τ) Y(x)\n    (p1,d1), 0 <--> X\n    (p2,d2), 0 <--> Y\nend\nspecies(rn)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is also possible to have species which depends on several independent variables:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n    @ivs t x\n    @species Xᵢ(t,x) Xₐ(t,x)\n    (ka,kD), Xᵢ <--> Xₐ\nend\nspecies(rn)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"note: Note\nSetting spatial independent variables is primarily intended for the modelling of spatial systems on continuous domains. Catalyst's support for this is currently under development. Hence, the utility of specifying spatial independent variables is limited.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_reaction_metadata","page":"The Catalyst DSL - Advanced Features and Options","title":"Setting reaction metadata","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is possible to supply reactions with metadata, containing some additional information of the reaction. A reaction's metadata follows after its declaration (first using the metadata's name, then a =, then its value) and is encapsulated by [] (where individual entries are separated by ,). Here, we add a description metadata to the reactions of a birth-death process:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nbd_model = @reaction_network begin\n    p, 0 --> X, [description=\"Production reaction\"]\n    d, X --> 0, [description=\"Degradation reaction\"]\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"When bundling reactions, reaction metadata can be bundled using the same rules as rates. Bellow we re-declare our birth-death process, but on a single line:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"bd_model = @reaction_network begin\n    (p,d), 0 <--> X, ([description=\"Production reaction\"], [description=\"Degradation reaction\"])\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Here we declare a model where we also provide a misc metadata (which can hold any quantity we require) to our birth reaction:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"bd_model = @reaction_network begin\n    p, 0 --> X, [description=\"Production reaction\", misc=:value]\n    d, X --> 0, [description=\"Degradation reaction\"]\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A reaction's metadata can be accessed using specific functions, e.g. Catalyst.hasdescription and Catalyst.getdescription can be used to check if a reaction have a description metadata, and to retrieve it, respectively:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rx = @reaction p, 0 --> X, [description=\"A production reaction\"]\nCatalyst.getdescription(rx)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"A list of all available reaction metadata can be found in the api.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_symbolics_and_DSL","page":"The Catalyst DSL - Advanced Features and Options","title":"Working with symbolic variables and the DSL","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"We have previously described how Catalyst represents its models symbolically (enabling e.g. symbolic differentiation of expressions stored in models). While Catalyst utilises this for many internal operation, these symbolic representations can also be accessed and harnessed by the user. Primarily, doing so is much easier during programmatic (as opposed to DSL-based) modelling. Indeed, the section on programmatic modelling goes into more details about symbolic representation in models, and how these can be used. It is, however, also ways to utilise these methods during DSL-based modelling. Below we briefly describe two methods for doing so.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_symbolics_and_DSL_unpack","page":"The Catalyst DSL - Advanced Features and Options","title":"Using @unpack to extract symbolic variables from ReactionSystems","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Let us consider a simple birth-death process created using the DSL:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nbd_model = @reaction_network begin\n    (p,d), 0 <--> X\nend\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Since we have not explicitly declared p, d, and X using @parameters and @species, we cannot represent these symbolically (only using Symbols). If we wish to do so, however, we can fetch these into our current scope using the @unpack macro:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"@unpack p, d, X = bd_model\nnothing # hide","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"This lists first the quantities we wish to fetch (does not need to be the model's full set of parameters and species), then =, followed by the model variable. p, d and X are now symbolic variables in the current scope, just as if they had been declared using @parameters or @species. We can confirm this:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"X","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Next, we can now use these to e.g. designate initial conditions and parameter values for model simulations:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using OrdinaryDiffEqDefault, Plots # hide\nu0 = [X => 0.1]\ntspan = (0.0, 10.0)\nps = [p => 1.0, d => 0.2]\noprob = ODEProblem(bd_model, u0, tspan, ps)\nsol = solve(oprob)\nplot(sol)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"warning: Warning\nJust like when using @parameters and @species, @unpack will overwrite any variables in the current scope which share name with the imported quantities.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_symbolics_and_DSL_interpolation","page":"The Catalyst DSL - Advanced Features and Options","title":"Interpolating variables into the DSL","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Catalyst's DSL allows Julia variables to be interpolated for the network name, within rate constant expressions, or for species/stoichiometries within reactions. Using the lower-level symbolic interface we can then define symbolic variables and parameters outside of @reaction_network, which can then be used within expressions in the DSL. ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Interpolation is carried out by pre-appending the interpolating variable with a $. For example, here we declare the parameters and species of a birth-death model, and interpolate these into the model:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nt = default_t()\n@species X(t)\n@parameters p d\nbd_model = @reaction_network begin\n    ($p, $d), 0 <--> $X\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Additional information (such as default values or metadata) supplied to p, d, and X is carried through to the DSL. However, interpolation for this purpose is of limited value, as such information can be declared within the DSL. However, it is possible to interpolate larger algebraic expressions into the DSL, e.g. here","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"@species X1(t) X2(t) X3(t) E(t)\n@parameters d\nd_rate = d/(1 + E)\ndegradation_model = @reaction_network begin\n    $d_rate, X1 --> 0\n    $d_rate, X2 --> 0\n    $d_rate, X3 --> 0\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"we declare an expression d_rate, which then can be inserted into the DSL via interpolation.","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is also possible to use interpolation in combination with the @reaction macro. E.g. the reactions of the above network can be declared individually using","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rxs = [\n    @reaction $d_rate, $X1 --> 0\n    @reaction $d_rate, $X2 --> 0\n    @reaction $d_rate, $X3 --> 0\n]\nnothing # hide ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"note: Note\nWhen using interpolation, expressions like 2$spec won't work; the multiplication symbol must be explicitly included like 2*$spec.","category":"page"},{"location":"model_creation/dsl_advanced/#dsl_advanced_options_disable_ma","page":"The Catalyst DSL - Advanced Features and Options","title":"Disabling mass action for reactions","text":"","category":"section"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"As described previously, Catalyst uses mass action kinetics to generate ODEs from reactions. Here, each reaction generates a term for each of its reactants, which consists of the reaction's rate, substrates, and the reactant's stoichiometry. E.g. the following reaction:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Catalyst # hide\nrn = @reaction_network begin\n  k, X --> ∅\nend","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"generates a single term -k*X:","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"using Latexify\nlatexify(rn; form = :ode)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"It is possible to remove the substrate contribution by using any of the following non-filled arrows when declaring the reaction: <=, ⇐, ⟽, =>, ⇒, ⟾, ⇔, ⟺. This means that the reaction","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n  k, X => ∅\nend\nlatexify(rn; form = :ode)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"will occur at rate dXdt = -k (which might become a problem since X will be degraded at a constant rate even when very small or equal to 0). This functionality allows the user to fully customise the ODEs generated by their models. ","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"Note, stoichiometric coefficients are still included, i.e. the reaction","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"rn = @reaction_network begin\n  k, 2*X ⇒ ∅\nend\nlatexify(rn; form = :ode)","category":"page"},{"location":"model_creation/dsl_advanced/","page":"The Catalyst DSL - Advanced Features and Options","title":"The Catalyst DSL - Advanced Features and Options","text":"has rate dXdt = -2 k.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/#lattice_simulation_plotting","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"","category":"section"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"To aid the investigation of spatial simulations we have implemented several helper functions for creating plots and animation of these simulations. The development of these functions are currently under development. Currently, Catalyst exports three different such functions:","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"lattice_plot: Which plots a lattice simulation at a specified time point.\nlattice_animation: Which creates an animation of a lattice simulation across the entire time series.\nlattice_kymograph: Which, for a 1d Cartesian or masked lattice based simulation, creates a kymograph of the simulation across time and space.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"The first two functions can be applied to graph and 1d and 2d Cartesian and masked lattice based simulations, while lattice_kymograph can only be applied to 1d Cartesian and masked lattice based simulations. Currently, there is no functionality for plotting simulations based on 3d Cartesian and masked lattice. Here we will demonstrate all plotting functions using ODE simulations, but they work equally well for jump simulations.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"note: Note\nThe plotting interfaces used for non-spatial Catalyst simulations have seen lots of work to ensure high quality plots. However, the corresponding functions for spatial simulations are primarily intended to aid the user to investigate their simulation results. Thus, they might not be fully suitable for e.g. creating publication-quality graphics. If you are using these functions, please let us now. This helps inform us whether continued development of spatial modelling features is worthwhile. ","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"note: Note\nTo create animations we use Makie.jl, which is an alternative plotting package to Plots.jl (which is typically the preferred plotting package within the context of Catalyst). Generally, Makie is good at creating animations, hence we use it here (however, it is also a popular competitor to Plots.jl for general-purpose plotting). ","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"warning: Warning\nThese plotting interfaces are a work in progress. Hence, they and their interfaces may see more change that Catalyst features typically do. This include the possibility of breaking changes without breaking releases to Catalyst.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/#lattice_simulation_plotting_1d_grids","page":"Plotting Spatial Simulations","title":"Animation and plotting of 1d Cartesian or masked lattice simulations","text":"","category":"section"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"Let us consider a spatial simulation on a 1d Cartesian grid lattice:","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"using Catalyst, OrdinaryDiffEqDefault\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\ndiffusion_rx = @transport_reaction D X1\nlattice = CartesianGrid(10)\nlrs = LatticeReactionSystem(two_state_model, [diffusion_rx], lattice)\n\nX1_0 = ones(10)\nX1_0[5] = 10.0\nu0 = [:X1 => X1_0, :X2 => 1.0]\ntspan = (0.0, 5.0)\nps = [:k1 => 1.0, :k2 => 2.0, :D => 0.5]\noprob = ODEProblem(lrs, u0, tspan, ps)\nsol = solve(oprob)\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"To plot the simulation at a specific time point we use the lattice_plot function. In addition to the simulation we wish to plot, it takes the species we wish to plot and the LatticeReactionSystem which generated the simulation as arguments. It also takes the time point at which we wish to plot the simulation as an additional argument (if not provided, the simulation will be plotted at the final time point). To use the lattice_plot function (or any other of Catalyst's spatial plotting functions) we also need to load the CairoMakie package (here, import CairoMakie is enough, and using CairoMakie is not required).","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"import CairoMakie\nlattice_plot(sol, :X1, lrs; t = 2.0)","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"If we instead wish to create an animation of our solution across the entire simulation, we can use the lattice_animation function. This takes a fourth required argument, a file to which the animation is saved.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"lattice_animation(sol, :X1, lrs, \"lattice_simulation_1d.mp4\")","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"(Image: ) Since we animate the solution across the entire simulation, we do not need to provide a t value. However, there are some additional (optional) arguments we might wish to provide:","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"nframes = 200: The number of frames in the animation (these are evenly samples across the simulation).\nframerate = 20: The frame rate of the animation.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"Finally, we can display a kymograph of our simulation across the full time span using lattice_kymograph.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"lattice_kymograph(sol, :X1, lrs)","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"Here, we require neither a filename nor a t to be provided. However, the nframes argument can still be used to determine how frequently (in time) we wish to sample our simulation.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"For more information of either function, and additional optional arguments, please read their corresponding api sections (lattice_plot, lattice_animation, and lattice_kymograph).","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/#lattice_simulation_plotting_2d_grids","page":"Plotting Spatial Simulations","title":"Animation and plotting of 2d Cartesian or masked lattice simulations","text":"","category":"section"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"Two-dimensional lattice simulations can be plotted in the same manner as one-dimensional ones. However, instead of displaying a species's value as a line plot, it is displayed as a heatmap. E.g. here we simulate a spatial Brusselator model and display the value of X at a designated time point.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"using Catalyst, OrdinaryDiffEqBDF\nbrusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend\ndiffusion_rx = @transport_reaction D X\nlattice = CartesianGrid((20,20))\nlrs = LatticeReactionSystem(brusselator, [diffusion_rx], lattice)\n\nu0 = [:X => rand(20, 20), :Y => 10.0]\ntspan = (0.0, 20.0)\nps = [:A => 1.0, :B => 4.0, :D => 0.2]\noprob = ODEProblem(lrs, u0, tspan, ps; jac = true, sparse = true)\nsol = solve(oprob, FBDF())\n\nimport CairoMakie\nlattice_plot(sol, :X, lrs; t = 18.0)","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"Here, the intensity of the colour scale describes X's value in each compartment. The color scale is normalised across the entire simulation (not the plotted time step).","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"An animation of the solution can be created in a similar manner as for the one-dimensional case:","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"lattice_animation(sol, :X, lrs, \"lattice_simulation_2d.mp4\")","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"(Image: )","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"Again, please check the API pages for the lattice_plot and lattice_animation functions to see more details of their various options.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/#lattice_simulation_plotting_graphs","page":"Plotting Spatial Simulations","title":"Animation and plotting of graph lattice simulations","text":"","category":"section"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"Finally, we consider lattice simulations on graph lattices. We first simulate a simple birth-death process on a (6-node cyclic) graph lattice.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"using Catalyst, Graphs, OrdinaryDiffEqDefault\nrs = @reaction_network begin\n    (p,d), 0 <--> X\nend\ndiffusion_rx = @transport_reaction D X\nlattice = cycle_graph(6)\nlrs = LatticeReactionSystem(rs, [diffusion_rx], lattice)\n\nu0 = [:X => rand(6)]\ntspan = (0.0, 1.0)\nps = [:p => 1.0, :d => 0.5, :D => 0.1]\noprob = ODEProblem(lrs, u0, tspan, ps)\nosol = solve(oprob)\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"As for Cartesian and masked lattice-based simulations we can plot this simulation using the lattice_plot function. In this case, however, we need to first load both CairoMakie and the GraphMakie packages.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"import CairoMakie, GraphMakie\nlattice_plot(osol, :X, lrs)","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"Here we provide no t argument, and hence plot the solution at the final time point. As for 2d simulations, a colour scale described X's concentration in each compartment. Some arguments, are not relevant when plotting simulations on Cartesian and masked lattices, but which are relevant to graph lattices are:","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"node_size: Sets the size of each compartment in the plot.\nlayout: A vector of x and y values which can be used to determine the position of each compartment in the plot.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"E.g. here we manually set where each compartment should be plotted:","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"isq2 = 1/sqrt(2)\nlayout = [(0, 0), (isq2, isq2), (isq2, 1 + isq2), (0, 1 + 2isq2), (-isq2, 1 + isq2), (-isq2, isq2)]\nlattice_plot(osol, :X, lrs; layout)","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"Finally, animations of graph lattice simulation work similarly to 2d ones, but accept the additional arguments relevant to plotting graphs.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/#lattice_simulation_plotting_notes","page":"Plotting Spatial Simulations","title":"Final notes","text":"","category":"section"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"If you are using these interfaces, but there is some feature that is missing, you might wish to consider modifying the original code. This can be found here, from which you can copy any code you need to make your own plotting interfaces. If you do so, please provide any feedback by raising an issue on the Catalyst GitHub page. As mentioned, these plotting interfaces are a work in progress, and input from users is valuable to improve them further. Many of Makie's plotting arguments, even those not described here, are handled by these functions, and someone familiar with the package should be able to use these to customise the plots further.","category":"page"},{"location":"spatial_modelling/lattice_simulation_plotting/","page":"Plotting Spatial Simulations","title":"Plotting Spatial Simulations","text":"It should also be noted that these interfaces has note been optimised for performance, and the generation of an animation can often surpass 1 second for larger models. Again, this can likely be improved, and if performance is an problem do raise an issue, in which case an additional effort can be made to improve performance.","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/#programmatic_generative_linear_pathway","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"","category":"section"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"This example will show how to use programmatic, generative, modelling to model a system implicitly. I.e. rather than listing all system reactions explicitly, the reactions are implicitly generated from a simple set of rules. This example is specifically designed to show how programmatic modelling enables generative workflows (demonstrating one of its advantages as compared to DSL-based modelling). In our example, we will model linear pathways, so we will first introduce these. Next, we will model them first using the DSL, and then using a generative programmatic workflow.","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/#programmatic_generative_linear_pathway_intro","page":"Programmatic, generative, modelling of a linear pathway","title":"Linear pathways","text":"","category":"section"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"Linear pathways consists of a series of species (X_0, X_1, X_2, ..., X_n) where each activates the subsequent one[1]. These are often modelled through the following reaction system:","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"X_i-1tauhspace033cm  to X_i\n1tauhspace033cm X_i to ","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"for i = 1  n, where the activation of X_1 depends on some input species X_0. ","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"A common use of these linear pathways is the implementation of time delays. Consider a species X(t) which is activated by species X_0(t). This can be modelled by making the production rate of X(t) a function of the time-delayed value of X_0(t):","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"f(X_0(t-tau))hspace033cm  to X","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"This is a so-called discrete-delay (which will generate a delay differential equation). However, in reality, X(t) probably does not depend on only f(X_0(t-tau)), but rather a distribution of previous X_0(t) values. This can be modelled through a distributed delays","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"f(int_0^inf X_0(t-tau)g(tau) dtau)hspace033cm  to X","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"for some kernel g(tau). Here, a common kernel is a gamma distribution, which generates a gamma-distributed delay:","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"g(tau alpha beta) = fracbeta^alphatau^alpha-1Gamma(alpha)e^-betatau","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"When this is converted to an ODE, this generates an integro-differential equation. These (as well as the simpler delay differential equations) can be difficult to solve and analyse (especially when SDE or jump simulations are desired). Here, the linear chain trick can be used to instead model the delay as a linear pathway of the form described above[2]. A result by Fargue shows that this is equivalent to a gamma-distributed delay, where alpha is equivalent to n (the number of species in our linear pathway) and beta to %\\tau$ (the delay length term)[3]. While modelling time delays using the linear chain trick introduces additional system species, it is often advantageous as it enables simulations using standard ODE, SDE, and Jump methods.","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/#programmatic_generative_linear_pathway_dsl","page":"Programmatic, generative, modelling of a linear pathway","title":"Modelling linear pathways using the DSL","text":"","category":"section"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"It is known that two linear pathways have similar delays if the following equality holds:","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"frac1tau_1 n_1 = frac1tau_2 n_2","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"However, the shape of the delay depends on the number of intermediaries (n). Here we wish to investigate this shape for two choices of n (n = 3 and n = 10). We do so by implementing two models using the DSL, one for each n. ","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"using Catalyst\n\nlp_n3 = @reaction_network begin\n    1/τ, X0 --> 0\n    (X0/τ, 1/τ), 0 <--> X1\n    (X1/τ, 1/τ), 0 <--> X2\n    (X2/τ, 1/τ), 0 <--> X3\nend\n\nlp_n10 = @reaction_network begin\n    1/τ, X0 --> 0\n    (X0/τ, 1/τ), 0 <--> X1\n    (X1/τ, 1/τ), 0 <--> X2\n    (X2/τ, 1/τ), 0 <--> X3\n    (X3/τ, 1/τ), 0 <--> X4\n    (X4/τ, 1/τ), 0 <--> X5\n    (X5/τ, 1/τ), 0 <--> X6\n    (X6/τ, 1/τ), 0 <--> X7\n    (X7/τ, 1/τ), 0 <--> X8\n    (X8/τ, 1/τ), 0 <--> X9\n    (X9/τ, 1/τ), 0 <--> X10\nend\nnothing # hide","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"Next, we prepare an ODE for each model (scaling the initial concentration of X_0 and the value of tau appropriately for each model).","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"using OrdinaryDiffEqDefault, Plots\nu0_n3 = [:X0 => 3*1.0, :X1 => 0.0, :X2 => 0.0, :X3 => 0.0]\nps_n3 = [:τ => 1.0/3]\noprob_n3 = ODEProblem(lp_n3, u0_n3, (0.0, 5.0), ps_n3)\n\nu0_n10 = [:X0 => 10*1.0, :X1 => 0.0, :X2 => 0.0, :X3 => 0.0, :X4 => 0.0, :X5 => 0.0, :X6 => 0.0, :X7 => 0.0, :X8 => 0.0, :X9 => 0.0, :X10 => 0.0]\nps_n10 = [:τ => 1.0/10.0]\noprob_n10 = ODEProblem(lp_n10, u0_n10, (0.0, 5.0), ps_n10)\nnothing # hide","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"Finally, we plot the concentration of the final species in each linear pathway, noting that while the two pulses both peak at t = 10, their shapes depend on n.","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"sol_n3 = solve(oprob_n3)\nsol_n10 = solve(oprob_n10)\nplot(sol_n3; idxs = :X3, label = \"n = 3\")\nplot!(sol_n10; idxs = :X10, label = \"n = 10\")","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/#programmatic_generative_linear_pathway_generative","page":"Programmatic, generative, modelling of a linear pathway","title":"Modelling linear pathways using programmatic, generative, modelling","text":"","category":"section"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"Above, we investigated the impact of linear pathways' lengths on their behaviours. Since the models were implemented using the DSL, we had to implement a new model for each pathway (in each case writing out all reactions). Here, we will instead show how programmatic modelling can be used to generate pathways of arbitrary lengths.","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"First, we create a function, generate_lp, which creates a linear pathway model of length n. It utilises vector variables to create an arbitrary number of species, and also creates an observable for the final species of the chain.","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"using Catalyst # hide\nt = default_t()\n@parameters τ\nfunction generate_lp(n)\n    # Creates a vector `X` with n+1 species.\n    @species (X(t))[1:n+1]\n    @species Xend(t)\n\n    # Generate\n    #     (1) A degradation reaction for the input species.\n    #     (2) Production reactions for all intermediary species.\n    #     (2) Degradation reactions for all intermediary species.\n    rxs = [\n        Reaction(1/τ, [X[1]], []);\n        [Reaction(X[i]/τ, [], [X[i+1]]) for i in 1:n];\n        [Reaction(1/τ, [X[i+1]], []) for i in 1:n]     \n    ]\n\n    # Assembly and return a complete `ReactionSystem` (including an observable for the final species).\n    @named lp_n = ReactionSystem(rxs, t; observed = [Xend ~ X[end]])\n    return complete(lp_n)\nend\nnothing # hide","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"Next, we create a function that generates an ODEProblem (with appropriate initial conditions and parameter values) for arbitrarily lengthed linear pathway models.","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"function generate_oprob(n)\n    lp = generate_lp(n)\n    X_init = fill(0.0, n + 1)\n    X_init[1] = n * 1.0\n    u0 = [lp.X => X_init]\n    ps = [τ => 1.0 / n]\n    return ODEProblem(lp, u0, (0.0, 5.0), ps)\nend\nnothing # hide","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"We can now simulate linear pathways of arbitrary lengths using a simple syntax. We use this to recreate our previous result from the DSL:","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"using OrdinaryDiffEqDefault, Plots # hide\nsol_n3 = solve(generate_oprob(3))\nsol_n10 = solve(generate_oprob(10))\nplot(sol_n3; idxs = :Xend, label = \"n = 3\")\nplot!(sol_n10; idxs = :Xend, label = \"n = 10\")","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"If we wish to investigate the behaviour of a pathway with a different length, we can easily add this to the plot","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"sol_n20 = solve(generate_oprob(20))\nplot!(sol_n20; idxs = :Xend, label = \"n = 20\")","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/#References","page":"Programmatic, generative, modelling of a linear pathway","title":"References","text":"","category":"section"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"[1]: N. Korsbo, H. Jönsson It’s about time: Analysing simplifying assumptions for modelling multi-step pathways in systems biology, PLoS Computational Biology (2020).","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"[2]: J. Metz, O. Diekmann The Abstract Foundations of Linear Chain Trickery (1991).","category":"page"},{"location":"model_creation/examples/programmatic_generative_linear_pathway/","page":"Programmatic, generative, modelling of a linear pathway","title":"Programmatic, generative, modelling of a linear pathway","text":"[3]: D. Fargue Reductibilite des systemes hereditaires a des systemes dynamiques (regis par des equations differentielles aux derivees partielles), Comptes rendus de l'Académie des Sciences (1973).","category":"page"},{"location":"model_creation/constraint_equations/#constraint_equations","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"","category":"section"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"In many applications one has additional algebraic or differential equations for non-chemical species that can be coupled to a chemical reaction network model. Catalyst supports coupled differential and algebraic equations, and currently allows conversion of such coupled systems to ModelingToolkit ODESystems and NonlinearSystems. Likewise, one often needs events that can occur when a set condition is reached, such as providing a drug treatment at a specified time, or turning off production of cells once the population reaches a given level. Catalyst supports the event representation provided by ModelingToolkit, see here, allowing for both continuous and discrete events (though only the latter are supported when converting to JumpSystems currently).","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"In this tutorial we'll illustrate how to make use of constraint equations and events. Let's consider a model of a cell with volume V(t) that grows at a rate lambda. For now we'll assume the cell can grow indefinitely. We'll also keep track of one protein P(t), which is produced at a rate proportional V and can be degraded.","category":"page"},{"location":"model_creation/constraint_equations/#constraint_equations_coupling_constraints","page":"Constraint Equations and Events","title":"Coupling ODE constraints via extending a system","text":"","category":"section"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"There are several ways we can create our Catalyst model with the two reactions and ODE for V(t). One approach is to use compositional modeling, create separate ReactionSystems and ODESystems with their respective components, and then extend the ReactionSystem with the ODESystem. Let's begin by creating these two systems.","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Here, to create differentials with respect to time (for our differential equations), we must import the time differential operator from Catalyst. We do this through D = default_time_deriv(). Here, D(V) denotes the differential of the variable V with respect to time.","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"using Catalyst, OrdinaryDiffEqTsit5, Plots\nt = default_t()\nD = default_time_deriv()\n\n# set the growth rate to 1.0\n@parameters λ = 1.0\n\n# set the initial volume to 1.0\n@variables V(t) = 1.0\n\n# build the ODESystem for dV/dt\neq = [D(V) ~ λ * V]\n@named osys = ODESystem(eq, t)\n\n# build the ReactionSystem with no protein initially\nrn = @reaction_network begin\n    @species P(t) = 0.0\n    $V,   0 --> P\n    1.0, P --> 0\nend","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Notice, here we interpolated the variable V with $V to ensure we use the same symbolic unknown variable in the rn as we used in building osys. See the doc section on interpolation of variables for more information.","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"We can now merge the two systems into one complete ReactionSystem model using ModelingToolkit.extend:","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"@named growing_cell = extend(osys, rn)\ngrowing_cell = complete(growing_cell)","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"We see that the combined model now has both the reactions and ODEs as its equations. To solve and plot the model we proceed like normal","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"oprob = ODEProblem(growing_cell, [], (0.0, 1.0))\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"model_creation/constraint_equations/#Coupling-ODE-constraints-via-directly-building-a-ReactionSystem","page":"Constraint Equations and Events","title":"Coupling ODE constraints via directly building a ReactionSystem","text":"","category":"section"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"As an alternative to the previous approach, we could have constructed our ReactionSystem all at once by directly using the symbolic interface:","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"using Catalyst, OrdinaryDiffEqTsit5, Plots\nt = default_t()\nD = default_time_deriv()\n\n@parameters λ = 1.0\n@variables V(t) = 1.0\neq = D(V) ~ λ * V\nrx1 = @reaction $V, 0 --> P\nrx2 = @reaction 1.0, P --> 0\n@named growing_cell = ReactionSystem([rx1, rx2, eq], t)\nsetdefaults!(growing_cell, [:P => 0.0])\ngrowing_cell = complete(growing_cell)\n\noprob = ODEProblem(growing_cell, [], (0.0, 1.0))\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"model_creation/constraint_equations/#constraint_equations_events","page":"Constraint Equations and Events","title":"Adding events","text":"","category":"section"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Our current model is unrealistic in assuming the cell will grow exponentially forever. Let's modify it such that the cell divides in half every time its volume reaches a size of 2. We also assume we lose half of the protein upon division. Note, we will only keep track of one cell, and hence follow a specific  lineage of the system. To do this we can create a continuous event using the ModelingToolkit symbolic event interface and attach it to our system. Please see the associated ModelingToolkit tutorial for more details on the types of events that can be represented symbolically. A lower-level approach for creating events via the DifferentialEquations.jl callback interface is illustrated here tutorial.","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Let's first create our equations and unknowns/species again","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"using Catalyst, OrdinaryDiffEqTsit5, Plots\nt = default_t()\nD = default_time_deriv()\n\n@parameters λ = 1.0\n@variables V(t) = 1.0\n@species P(t) = 0.0\neq = D(V) ~ λ * V\nrx1 = @reaction $V, 0 --> $P\nrx2 = @reaction 1.0, $P --> 0","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Before creating our ReactionSystem we make the event.","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"# every 1.0 time unit we half the volume of the cell and the number of proteins\ncontinuous_events = [V ~ 2.0] => [V ~ V/2, P ~ P/2]","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"We can now create and simulate our model","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"@named rs = ReactionSystem([rx1, rx2, eq], t; continuous_events)\nrs = complete(rs)\n\noprob = ODEProblem(rs, [], (0.0, 10.0))\nsol = solve(oprob, Tsit5())\nplot(sol)\nCatalyst.PNG(plot(sol; fmt = :png, dpi = 200)) # hide","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"We can also model discrete events. Similar to our example with continuous events, we start by creating reaction equations, parameters, variables, and unknowns.","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"t = default_t()\n@parameters k_on switch_time k_off\n@species A(t) B(t)\n\nrxs = [(@reaction k_on, A --> B), (@reaction k_off, B --> A)]","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Now we add an event such that at time t (switch_time), k_on is set to zero.","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"discrete_events = (t == switch_time) => [k_on ~ 0.0]\n\nu0 = [:A => 10.0, :B => 0.0]\ntspan = (0.0, 4.0)\np = [k_on => 100.0, switch_time => 2.0, k_off => 10.0]","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Simulating our model,","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"@named rs2 = ReactionSystem(rxs, t, [A, B], [k_on, k_off, switch_time]; discrete_events)\nrs2 = complete(rs2)\n\noprob = ODEProblem(rs2, u0, tspan, p)\nsol = solve(oprob, Tsit5(); tstops = 2.0)\nplot(sol)","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"Note that for discrete events we need to set a stop time via tstops so that the ODE solver can step exactly to the specific time of our event. In the previous example we just manually set the numeric value of the parameter in the tstops kwarg to solve, however, it can often be convenient to instead get the value of the parameter from oprob and pass this numeric value. This helps ensure consistency between the value passed via p and/or symbolic defaults and what we pass as a tstop to solve. We can do this as","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"switch_time_val = oprob.ps[:switch_time]\nsol = solve(oprob, Tsit5(); tstops = switch_time_val)\nplot(sol)","category":"page"},{"location":"model_creation/constraint_equations/","page":"Constraint Equations and Events","title":"Constraint Equations and Events","text":"For a detailed discussion on how to directly use the lower-level but more flexible DifferentialEquations.jl event/callback interface, see the tutorial on event handling using callbacks.","category":"page"},{"location":"model_simulation/ensemble_simulations/#ensemble_simulations","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"","category":"section"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"In many contexts, a single model is re-simulated under similar conditions. Examples include:","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"Performing Monte Carlo simulations of a stochastic model to gain insight in its behaviour.\nScanning a model's behaviour for different parameter values and/or initial conditions.","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"While this can be handled using for loops, it is typically better to first create an EnsembleProblem, and then perform an ensemble simulation. Advantages include a more concise interface and the option for automatic simulation parallelisation. Here we provide a short tutorial on how to perform parallel ensemble simulations, with a more extensive documentation being available here.","category":"page"},{"location":"model_simulation/ensemble_simulations/#ensemble_simulations_monte_carlo","page":"Ensemble/Monte Carlo Simulations","title":"Monte Carlo simulations using unmodified conditions","text":"","category":"section"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"We will first consider Monte Carlo simulations where the simulation conditions are identical in-between simulations. First, we declare a simple self-activation loop model","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"using Catalyst\nsa_model = @reaction_network begin\n    v0 + hill(X,v,K,n), ∅ --> X\n    deg, X --> ∅\nend\nu0 = [:X => 10.0]\ntspan = (0.0, 1000.0)\nps = [:v0 => 0.1, :v => 2.5, :K => 40.0, :n => 4.0, :deg => 0.01]\nnothing # hide","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"We wish to simulate it as an SDE. Rather than performing a single simulation, however, we want to perform multiple ones. Here, we first create a normal SDEProblem, and use it as the single input to a EnsembleProblem (EnsembleProblem are created similarly for ODE and jump simulations, but the ODEProblem or JumpProblem is used instead).","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"using StochasticDiffEq\nsprob = SDEProblem(sa_model, u0, tspan, ps)\neprob = EnsembleProblem(sprob)\nnothing # hide","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"Next, the EnsembleProblem can be used as input to the solve command. Here, we use exactly the same inputs that we use for single simulations, however, we add a trajectories argument to denote how many simulations we wish to carry out. Here we perform 10 simulations:","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"sols = solve(eprob, STrapezoid(); trajectories = 10)\nnothing # hide","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"Finally, we can use our ensemble simulation solution as input to plot (just like normal simulations):","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"using Plots\nplot(sols)","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"Here, each simulation is displayed as an individual trajectory.","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"note: Note\nWhile not used here, the la plotting option (which modifies line transparency) can help improve the plot visual when a large number of (overlapping) lines are plotted.","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"Various convenience functions are available for analysing and plotting ensemble simulations (a full list can be found [here]). Here, we use these to first create an EnsembleSummary (retrieving each simulation's value at time points 0.0, 1.0, 2.0, ... 1000.0). Next, we use this as an input to the plot command, which automatically plots the mean X activity across the ensemble, while also displaying the 5% and 95% quantiles as the shaded area:","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"e_sumary = EnsembleAnalysis.EnsembleSummary(sols, 0.0:1.0:1000.0)\nplot(e_sumary)","category":"page"},{"location":"model_simulation/ensemble_simulations/#ensemble_simulations_varying_conditions","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble simulations using varying simulation conditions","text":"","category":"section"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"Previously, we assumed that each simulation used the same initial conditions and parameter values. If this is not the case (when e.g. performing a parameter scan), a prob_func optional argument must be supplied to the EnsembleProblem, this describes how the problem should be modified for each individual simulation of the ensemble.","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"Here, we first create an ODEProblem of our previous self-activation loop:","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"using OrdinaryDiffEqTsit5\noprob = ODEProblem(sa_model, u0, tspan, ps)\nnothing # hide","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"Next, we wish to simulate the model for a range of initial conditions of X`. To do this we create a problem function, which takes the following arguments:","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"prob: The problem given to our EnsembleProblem (which is the problem that prob_func modifies in each iteration).\ni: The number of this specific Monte Carlo iteration in the interval 1:trajectories.\nrepeat: The iteration of the repeat of the simulation. Typically 1, but potentially higher if the simulation re-running option is used.","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"Here we will use the following problem function (utilising remake), which will provide a uniform range of initial concentrations of X:","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"function prob_func(prob, i, repeat)\n    remake(prob; u0 = [:X => i * 5.0])\nend\nnothing # hide","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"Next, we create our EnsembleProblem, and simulate it 10 times:","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"eprob = EnsembleProblem(oprob; prob_func)\nsols = solve(eprob, Tsit5(); trajectories = 10)\nplot(sols)","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"Here we see that the deterministic model (unlike the stochastic one), only activates for some initial conditions (while other tends to an inactive state).","category":"page"},{"location":"model_simulation/ensemble_simulations/","page":"Ensemble/Monte Carlo Simulations","title":"Ensemble/Monte Carlo Simulations","text":"The EnsembleProblem constructor accepts a few additional optional options (output_func, reduction, u_init, and safetycopy), which are described in more detail here. These can be used to e.g. rerun an individual simulation which does not fulfil some condition, or extract and save only some selected information from a simulation (rather than the full simulation).","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Catalyst supports the expansion of non-spatial ReactionSystems (created using e.g. the @reaction_network DSL) to spatial domains. Spatial simulation of Catalyst models is a work in progress. Currently, the following is supported:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Spatial ODE and Jump simulations.\nDiscrete spatial domains.\nConstant-rate transportation reactions (species moving spatially at constant rates). ","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Features for which support is planned in future updates include:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Models on continuous domains with automatic discretisation (these models can already be simulated if the user provides a discretisation).\nSDE simulations.\nTransport reactions with non-constant rates as well as more general spatial reactions.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"This tutorial introduces spatial modelling on discrete domains, here called lattices. It describes the basics of creating and simulating such models. To do so, it uses ODE simulations as examples. Additional tutorials provide further details on how to interact with spatial simulation structures and plot spatial simulations, and also provide further details on ODE and jump simulations, respectively.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_example","page":"Introduction to Spatial Modelling with Catalyst","title":"Basic example of a spatial simulation on a discrete domain","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"To perform discrete-space spatial simulations, the user must first define a LatticeReactionSystem. These combine:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"A (non-spatial) ReactionSystem(@ref) model (created using standard Catalyst syntax).\nA vector of spatial reactions, describing how species can move spatially across the domain.\nA lattice defining the spatial domain's compartments and how they are connected.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Here, as an example, we will simulate a spatial two-state model. To do so, we first define our (non-spatial) model, the spatial reactions, and the lattice. These are then bundled into a LatticeReactionSystem.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"using Catalyst\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\ndiffusion_rx = @transport_reaction D X1\nlattice = CartesianGrid((5,5))\nlrs = LatticeReactionSystem(two_state_model, [diffusion_rx], lattice)\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"This model contains:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"A single spatial reaction, a transport reaction where X1 moves at constant rate D between adjacent compartments.\nA 2d Cartesian grid of 5x5 compartments to simulate our model on.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"More details on spatial reactions are available here. In addition to Cartesian grid lattices (in 1, 2, and 3 dimensions), masked and unstructured (graph) lattices are also supported. The different lattice types described in more detail here.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Once created, LatticeReactionSystems can be used as input to various problem types, which then can be simulated using the same syntax as non-spatial models. Here, we prepare an ODE simulation by creating an ODEProblem:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"u0 = [:X1 => rand(5, 5), :X2 => 2.0]\ntspan = (0.0, 10.0)\nps = [:k1 => 1.0, :k2 => 2.0, :D => 0.2]\noprob = ODEProblem(lrs, u0, tspan, ps)\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"In this example we used non-uniform values for X1's initial condition, but uniform values for the remaining initial condition and parameter values. More details of uniform and non-uniform initial conditions and parameter values are provided here. We also note that the diffusion reaction introduces a new parameter, D (determining X1's diffusion rate), whose value must be designated in the parameter vector. ","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"We can now simulate our model:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"using OrdinaryDiffEqDefault\nsol = solve(oprob)\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"We note that simulations of spatial models are often computationally expensive. Advice on the performance of spatial ODE simulations is provided here. ","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Finally, we can access \"X1's value across the simulation using","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"lat_getu(sol, :X1, lrs)","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"and plot the simulation using","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"import CairoMakie\nlattice_animation(sol, :X1, lrs, \"lattice_simulation_2d.mp4\")","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"(Image: ) More information on how to retrieve values from spatial simulations can be found here, and for plotting them, here. Finally, a list of functions for querying LatticeReactionSystems for various properties can be found here.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_spatial_reactions","page":"Introduction to Spatial Modelling with Catalyst","title":"Spatial reactions","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Spatial reactions describe reaction events which involve species across two connected compartments. Currently, only so-called transportation reactions are supported. These consist of:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"A rate at which the reaction occurs. As for non-spatial reactions, this can be any expression. However, currently, it may only consist of parameters and other constants. \nA single species which is transported from one compartment to an adjacent one.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"At the occurrence of a transport reaction, the specific species moves to the adjacent compartment. Many common spatial models can be represented using transport reactions only. These can model phenomena such as diffusion or constant flux. A transportation reaction can be created using the @transportation_reaction macro. E.g. above we used","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"using Catalyst # hide\ndiffusion_rx = @transport_reaction D X1\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"to create a reaction where species X moves at a constant rate D between adjacent compartments (in the ODE this creates terms Dcdot X1_i, where X1_i is the concentration of X1 in compartment i). Transport reactions may have rates depending on several parameters. E.g. to model a system with two species X1 and X2, where both species are transported at a rate which depends both on the species, but also on some non-uniform parameter which is unique to each connection (e.g. representing the area connecting two cells in a tissue) we could do:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"dr_X1 = @transport_reaction D1*a X1\ndr_X2 = @transport_reaction D2*a X2\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"note: Note\nAny species which occurs is occurs in a transport reaction that is used to construct a LatticeReactionSystem must also occur in the corresponding non-spatial ReactionSystem.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_spatial_reactions_programmatic","page":"Introduction to Spatial Modelling with Catalyst","title":"Creating transport reactions programmatically","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"If models are created programmatically it is also possible to create transportation reactions programmatically. To do so, use the TransportReaction constructor, providing first the rate and then the transported species:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"@variables t\n@species X1(t) X2(t)\n@parameters k1 k2 D [edgeparameter=true]\ntr_X = TransportReaction(D, X1)\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Note that in this example, we specifically designate D as an edge parameter.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_lattices","page":"Introduction to Spatial Modelling with Catalyst","title":"Defining discrete spatial domains (lattices)","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Discrete spatial domains can represent:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Systems which are composed of a (finite number of) compartments, where each compartment can be considered well-mixed (e.g. can be modelled non-spatially) and where (potentially) species can move between adjacent compartments. Tissues, where each compartment corresponds to a biological cell, are examples of such systems.\nSystems that are continuous in nature, but have been approximated as a discrete domain. Future Catalyst updates will include the ability for the definition, and automatic discretisation, of continuous domains. Currently, however, the user has to perform this discretisation themselves.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Catalyst supports three distinct types of lattices:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Cartesian lattices. These are grids where each grid point corresponds to a compartment. Spatial transportation is permitted between adjacent compartments.\nMasked lattices. In these grids, only a subset of the grid point actually corresponds to compartments. Spatial transportation is permitted between adjacent compartments.\nUnstructured (or graph) lattices. These are defined by graphs, where vertices correspond to compartments and edges connect adjacent compartments.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Here, Cartesian lattices are a subset of the masked lattices, which are a subset of the unstructured lattices. If possible, it is advantageous to use as narrow a lattice definition as possible (this may both improve simulation performance and simplify syntax). Cartesian and masked lattices can be defined as one, two, and three-dimensional. By default, these lattices assume that diagonally neighbouring compartments are non-adjacent (do not permit direct movement of species in between themselves). To change this, provide the diagonally_adjacent = true argument to your LatticeReactionSystem when it is created.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_lattices_cartesian","page":"Introduction to Spatial Modelling with Catalyst","title":"Defining Cartesian lattices","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"A Cartesian lattice is defined using the CartesianGrid function, which takes a single argument. For a 1d grid, simply provide the length of the grid as a single argument:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"using Catalyst # hide\ncgrid_1d = CartesianGrid(5)\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"For 2d and 3d grids, we instead provide a Tuple with the length of the grid in each dimension:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"cgrid_2d = CartesianGrid((3, 9))\ncgrid_3d = CartesianGrid((2, 4, 8))\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_lattices_masked","page":"Introduction to Spatial Modelling with Catalyst","title":"Defining masked lattices","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Masked lattices are defined through 1d, 2d, or 3d Boolean arrays. Each position in the array is true if it corresponds to a compartment, and false if it does not. E.g. to define a 1d grid corresponding to two disjoint sets, each with 3 compartments, use:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"rgrid_1d = [true, true, true, false, true, true, true]\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"To define a 2d grid corresponding to the shape of an (laying) \"8\", we can use:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"rgrid_2d = [\n    true  true  true  true  true;\n    true  false true  false true;\n    true  true  true  true  true\n]\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Finally, a 4x5x6 3d grid of randomly distributed compartments can be created using:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"rgrid_3d = rand([true, false], 4, 5, 6)\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_lattices_graph","page":"Introduction to Spatial Modelling with Catalyst","title":"Defining unstructured lattices","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"To define unstructured lattices, we must first import the Graphs.jl package. Next, we can either use some pre-defined formula for building graphs, or build a graph from scratch. Here we create a cyclic graph (where each compartment is connected to exactly two other compartments):","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"using Graphs\ncycle_graph(7)\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Since graphs can represent any network of connected compartments, they do not have dimensions (like Cartesian or masked lattices). Another feature of graph lattices is that they can have non-symmetric connections, i.e. pairs of compartments where spatial movement of species is only permitted in one direction (in practice, this can be done for Cartesian and masked lattices as well, by defining non-uniform spatial rates and setting them to zero in one direction). This can be done by using a directed graph as input. E.g. here we define a directed cyclic graph, where movement is only allowed in one direction of the cycle:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"cycle_digraph(7)\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_simulation_inputs","page":"Introduction to Spatial Modelling with Catalyst","title":"Non-uniform initial conditions and parameter values","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"For spatial models, initial conditions and parameter values are provided similarly as for non-spatial models. Wherever a single value is provided, it is used uniformly across the lattice. E.g. if we, for our previous two-state model, set","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"u0 = [:X1 => 1.0, :X2 => 2.0]\nps = [:k1 => 1.0, :k2 => 2.0, :D => 0.2]\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"The initial condition will be 10 for X1 across compartments, and 20 for X2. Furthermore, for each simulation, in each compartment, the value of 10 will be used for k1 and 20 for k2. Finally, the transportation rate of X1 (set by the parameter D) will be 02 across all connections. To set non-uniform values, non-scalar values must be provided in the map. How to do this depends on how the lattice was defined. Furthermore, some parameters that are part of spatial reactions may have their value tied to connections between compartments, rather than compartments (we call these edge parameters). These are handled slightly differently. How to designate parameters as either edge parameters or compartment parameters is described here.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Below we describe how to set non-uniform values in the various cases.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_simulation_inputs_cartesian","page":"Introduction to Spatial Modelling with Catalyst","title":"Non-uniform compartment values for Cartesian lattices","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"To provide non-uniform values across a Cartesian lattice, simply provide the values in an array of the same dimension and size as the Cartesian lattice. E.g. for a 5x10 Cartesian lattice:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"using Catalyst # hide\nccart_lattices = CartesianGrid((5, 10))\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"random values (uniformly distributed between 0 and 1) can be provided using","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"[:X1 => rand(5, 10), :X2 => 10.0]\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Non-uniform values for parameters (which values are tied to compartments) are provided similarly.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_simulation_inputs_masked","page":"Introduction to Spatial Modelling with Catalyst","title":"Non-uniform compartment values for masked lattices","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Non-uniform values for masked lattices are provided in the same manner as for Cartesian lattices (however, values at coordinates that do not hold compartments are ignored). E.g. To provide random values for a masked lattice contained within a 5x10 Cartesian lattices we can again set:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"[:X1 => rand(5, 10), :X2 => 10.0]\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"If we want, it is also possible to provide the values as a sparse array with values only in the coordinates that corresponds to compartments.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_simulation_inputs_graphs","page":"Introduction to Spatial Modelling with Catalyst","title":"Non-uniform compartment values for unstructured lattices","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"In graphs (which are used to represent unstructured lattices) each vertex (i.e. compartment) has a specific index. To set non-uniform values for unstructured lattices, provide a vector where the i'th value corresponds to the value in the compartment with index i in the graph. E.g. for a graph with 5 vertexes, where we want X to be zero in all compartments bar one (where it is 10) we use:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"[:X1 => [0.0, 0.0, 0.0, 0.0, 1.0], :X2 => 10.0]\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_simulation_inputs_edge_parameters","page":"Introduction to Spatial Modelling with Catalyst","title":"Non-uniform values for edge-parameters","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Adjacent compartments are connected by edges (with which compartments are connected by edges being defined by the lattice). For unstructured lattices, it is possible (if a directed graph was used) to have edges from one compartment to another, but not in the opposite direction. For a lattice with N compartments, edge values are set by a NxN matrix, where value (ij) corresponds to the parameter's values in the edge going from compartment i to compartment j. This matrix can be either sparse or non-sparse. In the latter cases, values corresponding to non-existing edges are ignored. ","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Let's consider a 1d Cartesian lattice with 4 compartments. Here, an edge parameter's values are provided in a 4x4 matrix. For the Brusselator model described previously, D's value was tied to edges. If we wish to set the value of D to various values between 01 and 04 we can do:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"ps = [:k1 => 1.0, :k2 => 2.0, \n      :D => [\n        0.0 0.1 0.0 0.0;\n        0.1 0.0 0.2 0.0;\n        0.0 0.2 0.0 0.3;\n        0.0 0.0 0.3 0.0]\n]\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Here, the value at index ij corresponds to D's value in the edge from compartment i to compartment j. 0.0 is used for elements that do not correspond to an edge. The make_edge_p_values and make_directed_edge_values provide convenient interfaces for generating non-uniform edge parameter values.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_simulation_edge_parameters","page":"Introduction to Spatial Modelling with Catalyst","title":"Edge parameters and compartment parameters","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Parameters can be divided into edge parameters and compartment parameters (initial condition values are always tied to compartments). Here, edge parameters have their values tied to edges, while compartment parameters have their values tied to compartments. All parameters that are part of the rates (or stoichiometries) of non-spatial reactions must be compartment parameters. Parameters that are part of spatial reactions can be either compartment parameters or edge parameters. When a spatial reaction's rate is computed, edge parameters fetch their values for from the edge of the transition, and compartment parameters from the compartment from which the edge originates.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"When a LatticeReactionSystem is created, its parameters is the union of all parameters occurring in the (non-spatial) ReactionSystem and in all spatial reactions. By default, parameters occurring only in spatial reactions are considered edge parameters (and if they occur in the non-spatial ReactionSystem they are considered compartment parameters). It is, however, possible to designate a parameter specifically as an edge parameter (or not), by using the edgeparameter metadata. E.g. to designate that D (when declared in a non-spatial ReactionSystem using the DSL) is an edge parameter, not a compartment parameter, we use:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"using Catalyst # hide\ntwo_state_model = @reaction_network begin\n    @parameters D [edgeparameter=true]\n    (k1,k2), X1 <--> X2\nend\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"To learn the compartment and edge parameters of a LatticeReaction, the vertex_parameters and edge_parameters functions can be used:","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"two_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\ndiffusion_rx = @transport_reaction D X1\nlattice = CartesianGrid((20,20))\nlrs = LatticeReactionSystem(two_state_model, [diffusion_rx], lattice)\nedge_parameters(lrs)","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/#spatial_lattice_modelling_intro_limitations","page":"Introduction to Spatial Modelling with Catalyst","title":"Spatial modelling limitations","text":"","category":"section"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"Many features which are supported for non-spatial ReactionSystems are currently unsupported for LatticeReactionSystems. This includes observables, algebraic and differential equations, hierarchical models, and events. It is possible that these features will be supported in the future. Furthermore, removal of conserved quantities is not supported when creating spatial ODEProblems.","category":"page"},{"location":"spatial_modelling/lattice_reaction_systems/","page":"Introduction to Spatial Modelling with Catalyst","title":"Introduction to Spatial Modelling with Catalyst","text":"If you are using Catalyst's features for spatial modelling, please give us feedback on how we can improve these features. Additionally, just letting us know that you use these features is useful, as it helps inform us whether continued development of spatial modelling features is worthwhile. ","category":"page"},{"location":"model_creation/programmatic_CRN_construction/#programmatic_CRN_construction","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"","category":"section"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"While the DSL provides a simple interface for creating ReactionSystems, it can often be convenient to build or augment a ReactionSystem programmatically. In this tutorial we show how to build the repressilator model of the Introduction to Catalyst tutorial directly using symbolic variables, and then summarize the basic API functionality for accessing information stored within ReactionSystems.","category":"page"},{"location":"model_creation/programmatic_CRN_construction/#Directly-building-the-repressilator-with-ReactionSystems","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Directly building the repressilator with ReactionSystems","text":"","category":"section"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"We first load Catalyst","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"using Catalyst","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"and then define symbolic variables for each parameter and species in the system (the latter corresponding to a variable or unknown in ModelingToolkit terminology)","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"t = default_t()\n@parameters α K n δ γ β μ\n@species m₁(t) m₂(t) m₃(t) P₁(t) P₂(t) P₃(t)\nnothing    # hide","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Note: each species is declared as a function of time. Here, we first import the time independent variable, and stores it in t, using t = default_t(), and then use it to declare out species.","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"note: Note\nFor users familiar with ModelingToolkit, chemical species must be declared    via the @species macro, and not the ModelingToolkit.@variables macro.    @species wraps @variables, adding additional metadata to the symbolic    variables that represent species which is used internally in Catalyst.","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Next, we specify the chemical reactions that comprise the system using Catalyst Reactions","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rxs = [Reaction(hillr(P₃,α,K,n), nothing, [m₁]),\n       Reaction(hillr(P₁,α,K,n), nothing, [m₂]),\n       Reaction(hillr(P₂,α,K,n), nothing, [m₃]),\n       Reaction(δ, [m₁], nothing),\n       Reaction(γ, nothing, [m₁]),\n       Reaction(δ, [m₂], nothing),\n       Reaction(γ, nothing, [m₂]),\n       Reaction(δ, [m₃], nothing),\n       Reaction(γ, nothing, [m₃]),\n       Reaction(β, [m₁], [m₁,P₁]),\n       Reaction(β, [m₂], [m₂,P₂]),\n       Reaction(β, [m₃], [m₃,P₃]),\n       Reaction(μ, [P₁], nothing),\n       Reaction(μ, [P₂], nothing),\n       Reaction(μ, [P₃], nothing)]\nnothing    # hide","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Here we use nothing where the DSL used varnothing. Finally, we are ready to construct our ReactionSystem as","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"@named repressilator = ReactionSystem(rxs, t)\nnothing     # hide","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Notice, the model is named repressilator. A name must always be specified when directly constructing a ReactionSystem (the DSL will auto-generate one if left out). Using @named when constructing a ReactionSystem causes the name of the system to be the same as the name of the variable storing the system. Alternatively, one can use the name = :repressilator keyword argument to the ReactionSystem constructor.","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"warning: Warning\nAll ReactionSystems created via the symbolic interface (i.e. by calling ReactionSystem with some input, rather than using @reaction_network) are not marked as complete. To simulate them, they must first be marked as complete, indicating to Catalyst and ModelingToolkit that they represent finalized models. This can be done using the complete function, i.e. by calling repressilator = complete(repressilator). An expanded description on completeness can be found here.","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"We can check that this is the same model as the one we defined via the DSL as follows (this requires that we use the same names for rates, species and the system)","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"repressilator2 = @reaction_network repressilator begin\n    hillr(P₃,α,K,n), ∅ --> m₁\n    hillr(P₁,α,K,n), ∅ --> m₂\n    hillr(P₂,α,K,n), ∅ --> m₃\n    (δ,γ), m₁ <--> ∅\n    (δ,γ), m₂ <--> ∅\n    (δ,γ), m₃ <--> ∅\n    β, m₁ --> m₁ + P₁\n    β, m₂ --> m₂ + P₂\n    β, m₃ --> m₃ + P₃\n    μ, P₁ --> ∅\n    μ, P₂ --> ∅\n    μ, P₃ --> ∅\nend\nrepressilator == repressilator2","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"For more options in building ReactionSystems, see the ReactionSystem API docs. For a more extensive example of how to programmatically create a ReactionSystem, see the Smoluchowski Coagulation Equation example.","category":"page"},{"location":"model_creation/programmatic_CRN_construction/#More-general-Reactions","page":"Programmatic Construction of Symbolic Reaction Systems","title":"More general Reactions","text":"","category":"section"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"In the example above all the specified Reactions were first or zero order. The three-argument form of Reaction implicitly assumes all species have a stoichiometric coefficient of one, i.e. for substrates [S₁,...,Sₘ] and products [P₁,...,Pₙ] it has the possible forms","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"# rate, S₁ + ... + Sₘ --> P₁ + ... + Pₙ\nReaction(rate, [S₁,...,Sₘ], [P₁,...,Pₙ])\n\n# rate, S₁ + ... + Sₘ --> ∅\nReaction(rate, [S₁,...,Sₘ], nothing)\n\n# rate, ∅ --> P₁ + ... + Pₙ\nReaction(rate, nothing, [P₁,...,Pₙ])","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"To allow for other stoichiometric coefficients we also provide a five argument form","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"# rate, α₁*S₁ + ... + αₘ*Sₘ --> β₁*P₁ + ... + βₙ*Pₙ\nReaction(rate, [S₁,...,Sₘ], [P₁,...,Pₙ], [α₁,...,αₘ], [β₁,...,βₙ])\n\n# rate, α₁*S₁ + ... + αₘ*Sₘ --> ∅\nReaction(rate, [S₁,...,Sₘ], nothing, [α₁,...,αₘ], nothing)\n\n# rate, ∅ --> β₁*P₁ + ... + βₙ*Pₙ\nReaction(rate, nothing, [P₁,...,Pₙ], nothing, [β₁,...,βₙ])","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Finally, we note that the rate constant, rate above, does not need to be a constant or fixed function, but can be a general symbolic expression:","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"t = default_t()\n@parameters α, β\n@species A(t), B(t)\nrx = Reaction(α + β*t*A, [A], [B])","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"See the FAQs for info on using general user-specified functions for the rate constant.","category":"page"},{"location":"model_creation/programmatic_CRN_construction/#The-@reaction-macro-for-constructing-Reactions","page":"Programmatic Construction of Symbolic Reaction Systems","title":"The @reaction macro for constructing Reactions","text":"","category":"section"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"In some cases one wants to build reactions incrementally, as in the repressilator example, but it would be nice to still have a short hand as in the @reaction_network DSL. In this case one can construct individual reactions using the @reaction macro.","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"For example, the repressilator reactions could also have been constructed like","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"t = default_t()\n@species P₁(t) P₂(t) P₃(t)\nrxs = [(@reaction hillr($P₃,α,K,n), ∅ --> m₁),\n       (@reaction hillr($P₁,α,K,n), ∅ --> m₂),\n       (@reaction hillr($P₂,α,K,n), ∅ --> m₃),\n       (@reaction δ, m₁ --> ∅),\n       (@reaction γ, ∅ --> m₁),\n       (@reaction δ, m₂ --> ∅),\n       (@reaction γ, ∅ --> m₂),\n       (@reaction δ, m₃ --> ∅),\n       (@reaction γ, ∅ --> m₃),\n       (@reaction β, m₁ --> m₁ + P₁),\n       (@reaction β, m₂ --> m₂ + P₂),\n       (@reaction β, m₃ --> m₃ + P₃),\n       (@reaction μ, P₁ --> ∅),\n       (@reaction μ, P₂ --> ∅),\n       (@reaction μ, P₃ --> ∅)]\n@named repressilator = ReactionSystem(rxs, t)","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Note, there are a few differences when using the @reaction macro to specify one reaction versus using the full @reaction_network macro to create a ReactionSystem. First, only one reaction (i.e. a single forward arrow type) can be used, i.e. reversible arrows like <--> will not work (since they define more than one reaction). Second, the @reaction macro does not have an option for designating what should be considered a species or parameter, and instead assumes that any symbol that appears as either a substrate or a product is a species, and everything else (including stoichiometric coefficients) are parameters. As such, the following are equivalent","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx = @reaction hillr(P,α,K,n), A --> B","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"is equivalent to","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"t = default_t()\n@parameters P α K n\n@variables A(t) B(t)\nrx = Reaction(hillr(P,α,K,n), [A], [B])","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Here (P,α,K,n) are parameters and (A,B) are species.","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"This behavior is the reason that in the repressilator example above we pre-declared (P₁(t),P₂(t),P₃(t)) as variables, and then used them via interpolating their values into the rate law expressions using $ in the macro. This ensured they were properly treated as species and not parameters. See the @reaction macro docstring for more information.","category":"page"},{"location":"model_creation/programmatic_CRN_construction/#Basic-querying-of-ReactionSystems","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Basic querying of ReactionSystems","text":"","category":"section"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"The Catalyst.jl API provides a large variety of functionality for querying properties of a reaction network. Here we go over a few of the most useful basic functions. Given the repressillator defined above we have that","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"species(repressilator)","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"parameters(repressilator)","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"reactions(repressilator)","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"We can test if a Reaction is mass action, i.e. the rate does not depend on t or other species, as","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"# Catalyst.hillr(P₃(t), α, K, n), ∅ --> m₁\nrx1 = reactions(repressilator)[1]\nismassaction(rx1,repressilator)","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"while","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"# δ, m₁ --> ∅\nrx2 = reactions(repressilator)[4]\nismassaction(rx2,repressilator)","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Similarly, we can determine which species a reaction's rate law will depend on like","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rn = @reaction_network begin\n       k*W, 2X + 3Y --> 5Z + W\n     end\ndependents(reactions(rn)[1], rn)","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Basic stoichiometry matrices can be obtained from a ReactionSystem as","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"substoichmat(repressilator)","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"prodstoichmat(repressilator)","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"netstoichmat(repressilator)","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Here the (ij) entry gives the corresponding stoichiometric coefficient of species i for reaction j.","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"Finally, we can directly access fields of individual reactions like","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.rate","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.substrates","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.products","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.substoich","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.prodstoich","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"rx1.netstoich","category":"page"},{"location":"model_creation/programmatic_CRN_construction/","page":"Programmatic Construction of Symbolic Reaction Systems","title":"Programmatic Construction of Symbolic Reaction Systems","text":"See the Catalyst.jl API for much more detail on the various querying and analysis functions provided by Catalyst.","category":"page"},{"location":"model_creation/model_visualisation/#visualisation","page":"Model Visualisation","title":"Model Visualisation","text":"","category":"section"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"Catalyst-created ReactionSystem models can be visualised either as LaTeX code (of either the model reactions or its equations) or as a network graph. This section describes both functionalities.","category":"page"},{"location":"model_creation/model_visualisation/#visualisation_latex","page":"Model Visualisation","title":"Displaying models using LaTeX","text":"","category":"section"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"Once a model has been created, the Latexify.jl package can be used to generate LaTeX code of the model. This can either be used for easy model inspection (e.g. to check which equations are being simulated), or to generate code which can be directly pasted into a LaTeX document.","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"Let us consider a simple Brusselator model:","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"using Catalyst\nbrusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"To display its reaction (using LaTeX formatting) we run latexify with our model as input:","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"using Latexify\nlatexify(brusselator)\nbrusselator # hide","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"Here, we note that the output of latexify(brusselator) is identical to how a model is displayed by default. Indeed, the reason is that Catalyst internally uses Latexify's latexify function to display its models. It is also possible to display the ODE equations a model would generate by adding the form = :ode argument:","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"latexify(brusselator; form = :ode)","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"note: Note\nInternally, latexify(brusselator; form = :ode) calls latexify(convert(ODESystem, brusselator)). Hence, if you have already generated the ODESystem corresponding to your model, it can be used directly as input to latexify.","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"note: Note\nIt should be possible to also generate SDEs through the form = :sde input. This feature is, however, currently broken.","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"If you wish to copy the output to your clipboard (e.g. so that you can paste it into a LaTeX document), run copy_to_clipboard(true) before you run latexify. A more throughout description of Latexify's features can be found in its documentation.","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"note: Note\nFor a model to be nicely displayed you have to use an IDE that actually supports this (such as a notebook). Other environments (such as the Julia REPL) will simply return the full LaTeX code which would generate the desired expression. ","category":"page"},{"location":"model_creation/model_visualisation/#visualisation_graphs","page":"Model Visualisation","title":"Displaying model networks","text":"","category":"section"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"A network graph showing a Catalyst model's species and reactions can be displayed using the Graph function. This first requires Graphviz to be installed and command line accessible. Here, we first declare a Brusselator model and then displays its network topology:","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"using Catalyst\nbrusselator = @reaction_network begin\n    A, ∅ --> X\n    1, 2X + Y --> 3X\n    B, X --> Y\n    1, X --> ∅\nend\nGraph(brusselator)\nnothing # hide","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"(Image: \"Brusselator Graph\")","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"The network graph represents species as blue nodes and reactions as orange dots. Black arrows from species to reactions indicate substrates, and are labelled with their respective stoichiometries. Similarly, black arrows from reactions to species indicate products (also labelled with their respective stoichiometries). If there are any reactions where a species affect the rate, but does not participate as a reactant, this is displayed with a dashed red arrow. This can be seen in the following Repressilator model:","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"repressilator = @reaction_network begin\n    hillr(Z,v,K,n), ∅ --> X\n    hillr(X,v,K,n), ∅ --> Y\n    hillr(Y,v,K,n), ∅ --> Z\n    d, (X, Y, Z) --> ∅\nend\nGraph(repressilator)\nnothing # hide","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"(Image: \"Repressilator Graph\")","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"A generated graph can be saved using the savegraph function:","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"repressilator_graph = Graph(repressilator)\nsavegraph(repressilator_graph, \"repressilator_graph.png\")","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"Finally, a network's reaction complexes (and the reactions in between these) can be displayed using the complexgraph(brusselator) function:","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"complexgraph(brusselator)\nnothing # hide","category":"page"},{"location":"model_creation/model_visualisation/","page":"Model Visualisation","title":"Model Visualisation","text":"(Image: \"Repressilator Complex Graph\") Here, reaction complexes are displayed as blue nodes, and reactions in between these as black arrows.","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/#lattice_simulation_structure_interaction","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"","category":"section"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"We have previously described how to retrieve species and parameter values stored in non-spatial problems, integrators, and solutions. This section describes similar workflows for simulations based on LatticeReactionSystems.","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Generally, while for non-spatial systems these operations can typically be done by indexing a structure directly, e.g. through","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"sol[:X]","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"there are no equally straightforward interfaces for spatial simulations. Typically, helper functions have to be used, e.g","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"lat_getu(sol, :X, lrs)","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Furthermore, there are some cases of interfacing which are currently not supported (e.g. updating parameter values in JumpProblems). It is likely that these interfaces will be improved in the future (i.e. by introducing a similar syntax to the current non-spatial one). Finally, we note that many of the functions presented below have not been as extensively optimised for performance as other parts of the Catalyst package. Hence, you should take care when designing workflows which requires using them a large number of times.","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"note: Note\nBelow we will describe various features using ODE simulations as examples. However, all interfaces (unless where else is stated) work identically for jump simulations.","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/#lattice_simulation_structure_interaction_simulation_species","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Retrieving values from lattice simulations","text":"","category":"section"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Let us consider a simulation of a LatticeReactionSystem:","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"using Catalyst, OrdinaryDiffEqDefault\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\ndiffusion_rx = @transport_reaction D X1\nlattice = CartesianGrid((2,3))\nlrs = LatticeReactionSystem(two_state_model, [diffusion_rx], lattice)\n\nu0 = [:X1 => [0.0 0.0 0.0; 2.0 2.0 2.0], :X2 => 0.0]\ntspan = (0.0, 1.0)\nps = [:k1 => 2.0, :k2 => 1.0, :D => 0.1]\noprob = ODEProblem(lrs, u0, tspan, ps)\nsol = solve(oprob)\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"To retrieve the values of X1 across the simulation we use the lat_getu function. It takes three arguments:","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"The solution objects from which we wish to retrieve values.\nThe species which values we wish to retrieve.\nThe LatticeReactionSystem which was simulated.","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"lat_getu(sol, :X1, lrs)","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Here, the output is a vector with X1's value at each simulation time step. How the species's value is represented at each time step depends on the lattice which was originally used to create the LatticeReactionSystem:","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"For Cartesian lattices, an array of the same size as the Cartesian lattice is used. Each array element corresponds to the species's value in the corresponding compartment.\nFor masked lattices, a sparse array of the same size as the masked lattice is used. Each filled array element corresponds to the species's value in the corresponding compartment. Unfilled array elements correspond to positions without compartments.\nFor unstructured (graph) lattices, vectors are used. The i'th element in the vectors corresponds to the species's value in the i'th compartment.","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Unlike for non-spatial simulations, lat_getu does not take vector (e.g. lat_getu(sol, [:X1, :X2], lrs)) or symbolic expression (e.g. lat_getu(sol, [X1 + X2], lrs)) inputs. However, it is possible to use symbolic variables as input (e.g. lat_getu(sol, two_state_model.X1, lrs)).","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/#lattice_simulation_structure_interaction_simulation_species_ts","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Retrieving lattice simulations values at specific time points","text":"","category":"section"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Just like for non-spatial solutions, it is possible to access the simulation's values at designated time points. This is possible even if the simulation did not stop at those specific time points (in which case an interpolated value is returned). To do this, the desired time points to sample are provided as a vector to lat_getu using the optional argument t. E.g. here we retrieve the simulation's (interpolated) values at time points 0.5 and 0.75:","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"lat_getu(sol, :X1, lrs; t = [0.5, 0.75])","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/#lattice_simulation_structure_interaction_prob_int_species","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Retrieving and updating species values in problems and integrators","text":"","category":"section"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Let us consider a spatial ODEProblem","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"using Catalyst, OrdinaryDiffEqDefault\ntwo_state_model = @reaction_network begin\n    (k1,k2), X1 <--> X2\nend\ndiffusion_rx = @transport_reaction D X1\nlattice = CartesianGrid((2,3))\nlrs = LatticeReactionSystem(two_state_model, [diffusion_rx], lattice)\n\nu0 = [:X1 => [0.0 0.0 0.0; 2.0 2.0 2.0], :X2 => 0.0]\ntspan = (0.0, 1.0)\nps = [:k1 => 2.0, :k2 => 1.0, :D => 0.1]\noprob = ODEProblem(lrs, u0, tspan, ps)\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"We can retrieve the species values stored in oprob using the lat_getu function. It uses identical syntax as for simulations (except that you cannot specify a time point). However, it returns a single set of species values (while for simulations it returns a vector across different time steps):","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"lat_getu(oprob, :X1, lrs)","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Again, the format used corresponds to the lattice used to create the original LatticeReactionSystem. Here, even if a species has homogeneous values, the full format is used.","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"lat_getu(oprob, :X2, lrs)","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"For both problems and integrators, species values can be updated using the lat_setu! function. It uses a similar syntax as lat_getu, but takes a fourth argument which is the new values to use for the designated species:","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"lat_setu!(oprob, :X1, lrs, [1.0 2.0 3.0; 4.0 5.0 6.0])","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Here, the same format (which depends on the used lattice) is used for the species's new values, as which is used when initially designating their initial conditions. I.e. to make X1's initial condition values uniform we can call","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"lat_setu!(oprob, :X1, lrs, 1.0)","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"note: Note\nIt is currently not possible to change a species value at a single compartment only. To do so, you must first retrieve its values across all compartments using lat_getu, then modify this at the desired compartment, and then use the modified version as input to lat_setu!.","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Species values in integrators can be interfaced with using identical syntax as for problems.","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/#lattice_simulation_structure_interaction_prob_int_parameters","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Retrieving and updating parameter values in problems and integrators","text":"","category":"section"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Retrieval and updating of parameter values for problems and integrators works similarly as for species, but with the following differences:","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"The lat_getp and lat_setp! functions are used.\nIt is currently not possible to interface with parameter values of JumpProblems and their integrators.\nAfter parameter values are modified, the rebuild_lat_internals! function must be applied before the problem/integrator can be used for further analysis.\nUpdating of edge parameters is limited and uses a different interface. ","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Let us consider the spatial ODEProblem we previously declared. We can check the value of k1 by using lat_getp","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"lat_getp(oprob, :k1, lrs)","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Next, we can update it using lat_setp! (here we also confirm that it now has the updated values):","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"lat_setp!(oprob, :k1, lrs, [1.0 2.0 3.0; 4.0 5.0 6.0])\nlat_getp(oprob, :k1, lrs)","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"If we now were to simulate oprob, the simulation would not take the updated value of k1 into account. For our changes to take effect we might first need to call rebuild_lat_internals! with oprob as an input","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"rebuild_lat_internals!(oprob)","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"There are two different circumstances when rebuild_lat_internals! must be called:","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"When modifying the value of an edge parameter.\nWhen changing a parameter from having spatially uniform values to spatially non-uniform values, or the other way around.","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Parameter values of integrators can be interfaced with just like for problems (this is primarily relevant when using callbacks). Again, after doing so, the rebuild_lat_internals! function might need to be applied to the integrator.","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/#lattice_simulation_structure_interaction_prob_int_parameters_edge_ps","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Retrieving and updatingedge  parameter values in problems and integrators","text":"","category":"section"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"The lat_getp and lat_setp! functions cannot currently be applied to edge parameters. Instead, to access the value of an edge parameter, use ","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"oprob.ps[:D]","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"To update an edge parameter's value, use","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"oprob.ps[:D] = [0.2]\nnothing # hide","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"This interface is somewhat limited, and the following aspects should be noted:","category":"page"},{"location":"spatial_modelling/lattice_simulation_structure_ interaction/","page":"Interfacing with Lattice Problems, Integrators, and Solutions","title":"Interfacing with Lattice Problems, Integrators, and Solutions","text":"Edge parameter values can only be interfaced with if the edge parameter's value is spatially uniform.\nWhen accessing an (spatially uniform) edge parameter's value, its single value will be encapsulated in a vector.\nWhen setting an (spatially uniform) edge parameter's value, you must encapsulate the new value in a vector.","category":"page"}]
}
