<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Structural Identifiability Analysis · Catalyst.jl</title><meta name="title" content="Structural Identifiability Analysis · Catalyst.jl"/><meta property="og:title" content="Structural Identifiability Analysis · Catalyst.jl"/><meta property="twitter:title" content="Structural Identifiability Analysis · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/inverse_problems/structural_identifiability/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/inverse_problems/structural_identifiability/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/inverse_problems/structural_identifiability/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li></ul></li><li><span class="tocitem">Model Creation and Properties</span><ul><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li></ul></li></ul></li><li><span class="tocitem">Model simulation</span><ul><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for performant ODE simulations</a></li></ul></li><li><span class="tocitem">Steady state analysis</span><ul><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li class="is-active"><a class="tocitem" href>Structural Identifiability Analysis</a><ul class="internal"><li><a class="tocitem" href="#Global-identifiability-analysis"><span>Global identifiability analysis</span></a></li><li><a class="tocitem" href="#Local-identifiability-analysis"><span>Local identifiability analysis</span></a></li><li><a class="tocitem" href="#Finding-identifiable-functions"><span>Finding identifiable functions</span></a></li><li><a class="tocitem" href="#Creating-StructuralIdentifiability-compatible-ODE-models-from-Catalyst-ReactionSystems"><span>Creating StructuralIdentifiability compatible ODE models from Catalyst <code>ReactionSystem</code>s</span></a></li><li><a class="tocitem" href="#Notes-on-systems-with-conservation-laws"><span>Notes on systems with conservation laws</span></a></li><li><a class="tocitem" href="#Systems-with-exponent-parameters"><span>Systems with exponent parameters</span></a></li><li><a class="tocitem" href="#structural_identifiability_citation"><span>Citation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><span class="tocitem">Spatial modelling</span></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Inverse Problems</a></li><li class="is-active"><a href>Structural Identifiability Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Structural Identifiability Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/inverse_problems/structural_identifiability.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="structural_identifiability"><a class="docs-heading-anchor" href="#structural_identifiability">Structural Identifiability Analysis</a><a id="structural_identifiability-1"></a><a class="docs-heading-anchor-permalink" href="#structural_identifiability" title="Permalink"></a></h1><p>During parameter fitting, parameter values are inferred from data. Parameter identifiability refers to whether inferring parameter values for a given model is mathematically feasible. Ideally, parameter fitting should always be accompanied with an identifiability analysis of the problem. </p><p>Identifiability can be divided into <em>structural</em> and <em>practical</em> identifiability<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. Structural identifiability considers only the mathematical model, and which parameters are and are not inherently identifiable due to model structure. Practical identifiability also considers the available data, and determines what system quantities can be inferred from it. In the idealised case of an infinite amount of non-noisy data, practical identifiability converges to structural identifiability. Generally, structural identifiability is assessed before parameters are fitted, while practical identifiability is assessed afterwards.</p><p>Structural identifiability (which is what this tutorial considers) can be illustrated by the following differential equation: <span>${dx \over dt} = p1*p2*x(t)$</span> where, however much data is collected on <span>$x$</span>, it is impossible to determine the distinct values of <span>$p1$</span> and <span>$p2$</span>. Hence, these parameters are non-identifiable (however, their product, <span>$p1*p2$</span>, <em>is</em> identifiable).</p><p>Catalyst contains a special extension for carrying out structural identifiability analysis of generated reaction rate equation ODE models using the <a href="https://github.com/SciML/StructuralIdentifiability.jl">StructuralIdentifiability.jl</a> package. This enables StructuralIdentifiability&#39;s <code>assess_identifiability</code>, <code>assess_local_identifiability</code>, and <code>find_identifiable_functions</code> functions to be called directly on Catalyst <code>ReactionSystem</code>s. It also implements specialised routines to make these more efficient when applied to reaction network models (e.g. by improving runtimes). How to use these functions is described in the following tutorial, with <a href="https://docs.sciml.ai/StructuralIdentifiability/stable/">StructuralIdentifiability providing a more extensive documentation</a>. </p><p>Structural identifiability can be divided into <em>local</em> and <em>global</em> identifiability. If a model quantity is locally identifiable, it means that its true value can be determined down to a finite-number of possible options. This also means that there is some limited region around the quantity&#39;s true value where this true value is the only possible value (and hence, within this region, the quantity is fully identifiable). Globally identifiable quantities&#39; values, on the other hand, can be uniquely determined. Again, while identifiability can be confirmed structurally for a quantity, it does not necessarily mean that it is practically identifiable for some given data.</p><p>Generally, there are three types of quantities for which identifiability can be assessed.</p><ul><li>Parameters (e.g. <span>$p1$</span> and <span>$p2$</span>).</li><li>Full variable trajectories (e.g. <span>$x(t)$</span>).</li><li>Variable initial conditions (e.g. <span>$x(0)$</span>). </li></ul><p>StructuralIdentifiability currently assesses identifiability for the first two only (however, if <span>$x(t)$</span> is identifiable, then <span>$x(0)$</span> will be as well).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently, the StructuralIdentifiability.jl extension only considers structural identifiability for the ODE generated by the reaction rate equation. It is possible that for the SDE model (generated by the chemical Langevin equation) and the jump model (generated by stochastic chemical kinetics) the identifiability of model quantities is different.</p></div></div><h2 id="Global-identifiability-analysis"><a class="docs-heading-anchor" href="#Global-identifiability-analysis">Global identifiability analysis</a><a id="Global-identifiability-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Global-identifiability-analysis" title="Permalink"></a></h2><h3 id="Basic-example"><a class="docs-heading-anchor" href="#Basic-example">Basic example</a><a id="Basic-example-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-example" title="Permalink"></a></h3><p>Global identifiability can be assessed using the <code>assess_identifiability</code> function. For each model quantity (parameters and variables), it will assess whether they are:</p><ul><li>Globally identifiable.</li><li>Locally identifiable.</li><li>Unidentifiable.</li></ul><p>To it, we provide our <code>ReactionSystem</code> model and a list of quantities that we are able to measure. Here, we consider a Goodwind oscillator (a simple 3-component model, where the three species <span>$M$</span>, <span>$E$</span>, and <span>$P$</span> are produced and degraded, which may exhibit oscillations)<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. Let us say that we are able to measure the concentration of <span>$M$</span>, we then designate this using the <code>measured_quantities</code> argument. We can now assess identifiability in the following way:</p><pre><code class="language-julia hljs">using Catalyst, Logging, StructuralIdentifiability
gwo = @reaction_network begin
    (pₘ/(1+P), dₘ), 0 &lt;--&gt; M
    (pₑ*M,dₑ), 0 &lt;--&gt; E
    (pₚ*E,dₚ), 0 &lt;--&gt; P
end
assess_identifiability(gwo; measured_quantities = [:M], loglevel = Logging.Error)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{SymbolicUtils.BasicSymbolic{Real}, Symbol} with 9 entries:
  M(t) =&gt; :globally
  E(t) =&gt; :nonidentifiable
  P(t) =&gt; :globally
  pₘ   =&gt; :globally
  dₘ   =&gt; :globally
  pₑ   =&gt; :nonidentifiable
  dₑ   =&gt; :locally
  pₚ   =&gt; :nonidentifiable
  dₚ   =&gt; :locally</code></pre><p>From the output, we find that <code>E(t)</code>, <code>pₑ</code>, and <code>pₚ</code> (the trajectory of <span>$E$</span>, and the production rates of <span>$E$</span> and <span>$P$</span>, respectively) are non-identifiable. Next, <code>dₑ</code> and <code>dₚ</code> (the degradation rates of <span>$E$</span> and <span>$P$</span>, respectively) are locally identifiable. Finally, <code>P(t)</code>, <code>M(t)</code>, <code>pₘ</code>, and <code>dₘ</code> (the trajectories of <code>P</code> and <code>M</code>, and the production and degradation rate of <code>M</code>, respectively) are all globally identifiable. We note that we also imported the Logging.jl package, and provided the <code>loglevel = Logging.Error</code> input argument. StructuralIdentifiability functions generally provide a large number of output messages. Hence, we will use this argument (which requires the Logging package) throughout this tutorial to decrease the amount of printed text.</p><p>Next, we also assess identifiability in the case where we can measure all three species concentrations:</p><pre><code class="language-julia hljs">assess_identifiability(gwo; measured_quantities = [:M, :P, :E], loglevel = Logging.Error)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{SymbolicUtils.BasicSymbolic{Real}, Symbol} with 9 entries:
  M(t) =&gt; :globally
  E(t) =&gt; :globally
  P(t) =&gt; :globally
  pₘ   =&gt; :globally
  dₘ   =&gt; :globally
  pₑ   =&gt; :globally
  dₑ   =&gt; :globally
  pₚ   =&gt; :globally
  dₚ   =&gt; :globally</code></pre><p>in which case all species trajectories and parameters become identifiable.</p><h3 id="Indicating-known-parameters"><a class="docs-heading-anchor" href="#Indicating-known-parameters">Indicating known parameters</a><a id="Indicating-known-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Indicating-known-parameters" title="Permalink"></a></h3><p>In the previous case we assumed that all parameters are unknown, however, this is not necessarily true. If there are parameters with known values, we can supply these using the <code>known_p</code> argument. Providing this additional information might also make other, previously unidentifiable, parameters identifiable. Let us consider the previous example, where we measure the concentration of <span>$M$</span> only, but now assume we also know the production rate of <span>$E$</span> (<span>$pₑ$</span>):</p><pre><code class="language-julia hljs">assess_identifiability(gwo; measured_quantities = [:M], known_p = [:pₑ], loglevel = Logging.Error)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{SymbolicUtils.BasicSymbolic{Real}, Symbol} with 9 entries:
  M(t) =&gt; :globally
  E(t) =&gt; :locally
  P(t) =&gt; :globally
  pₘ   =&gt; :globally
  dₘ   =&gt; :globally
  pₑ   =&gt; :globally
  dₑ   =&gt; :locally
  pₚ   =&gt; :globally
  dₚ   =&gt; :locally</code></pre><p>Not only does this turn the previously non-identifiable <code>pₑ</code> (globally) identifiable (which is obvious, given that its value is now known), but this additional information improve identifiability for several other network components.</p><p>To, in a similar manner, indicate that certain initial conditions are known is a work in progress. Hopefully this feature should be an available in the near future.</p><h3 id="Providing-non-trivial-measured-quantities"><a class="docs-heading-anchor" href="#Providing-non-trivial-measured-quantities">Providing non-trivial measured quantities</a><a id="Providing-non-trivial-measured-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Providing-non-trivial-measured-quantities" title="Permalink"></a></h3><p>Sometimes, ones may not have measurements of species, but rather some combinations of species (or possibly parameters). To account for this, <code>measured_quantities</code> accepts any algebraic expression (and not just single species). To form such expressions, species and parameters have to first be <code>@unpack</code>&#39;ed from the model. Say that we have a model where an enzyme (<span>$E$</span>) is converted between an active and inactive form, which in turns activates the production of a product, <span>$P$</span>:</p><pre><code class="language-julia hljs">rs = @reaction_network begin
    (kA,kD), Eᵢ &lt;--&gt; Eₐ
    (Eₐ, d), 0 &lt;--&gt;P
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{E_i} &amp;\xrightleftharpoons[kD]{kA} \mathrm{E_a} \\
\varnothing &amp;\xrightleftharpoons[d]{E_a} \mathrm{P}  
 \end{align*}
 \]</p><p>If we can measure the total amount of <span>$E$</span> (<span>$=Eᵢ+Eₐ$</span>), as well as the amount of <span>$P$</span>, we can use the following to assess identifiability:</p><pre><code class="language-julia hljs">@unpack Eᵢ, Eₐ = rs
assess_identifiability(rs; measured_quantities = [Eᵢ + Eₐ, :P], loglevel = Logging.Error)</code></pre><h3 id="Assessing-identifiability-for-specified-quantities-only"><a class="docs-heading-anchor" href="#Assessing-identifiability-for-specified-quantities-only">Assessing identifiability for specified quantities only</a><a id="Assessing-identifiability-for-specified-quantities-only-1"></a><a class="docs-heading-anchor-permalink" href="#Assessing-identifiability-for-specified-quantities-only" title="Permalink"></a></h3><p>By default, StructuralIdentifiability assesses identifiability for all parameters and variables. It is, however, possible to designate precisely which quantities you want to check using the <code>funcs_to_check</code> option. This both includes selecting a smaller subset of parameters and variables to check, or defining customised expressions. Let us consider the Goodwind from previously, and say that we would like to check whether the production parameters (<span>$pₘ$</span>, <span>$pₑ$</span>, and <span>$pₚ$</span>) and the total amount of the three species (<span>$P + M + E$</span>) are identifiable quantities. Here, we would first unpack these (allowing us to form algebraic expressions) and then use the following code:</p><pre><code class="language-julia hljs">@unpack pₘ, pₑ, pₚ, M, E, P = gwo
assess_identifiability(gwo; measured_quantities = [:M], funcs_to_check = [pₘ, pₑ, pₚ, M + E + P], loglevel = Logging.Error)</code></pre><h3 id="Probability-of-correctness"><a class="docs-heading-anchor" href="#Probability-of-correctness">Probability of correctness</a><a id="Probability-of-correctness-1"></a><a class="docs-heading-anchor-permalink" href="#Probability-of-correctness" title="Permalink"></a></h3><p>The identifiability methods used can, in theory, produce erroneous results. However, it is possible to adjust the lower bound for the probability of correctness using the argument <code>prob_threshold</code> (by default set to <code>0.99</code>, that is, at least a <span>$99\%$</span> chance of correctness). We can e.g. increase the bound through:</p><pre><code class="language-julia hljs">assess_identifiability(gwo; measured_quantities=[:M], prob_threshold = 0.999, loglevel = Logging.Error)</code></pre><p>giving a minimum bound of <span>$99.9\%$</span> chance of correctness. In practise, the bounds used by StructuralIdentifiability are very conservative, which means that while the minimum guaranteed probability of correctness in the default case is <span>$99\%$</span>, in practise it is much higher. While increasing the value of <code>prob_threshold</code> increases the certainty of correctness, it will also increase the time required to assess identifiability.</p><h2 id="Local-identifiability-analysis"><a class="docs-heading-anchor" href="#Local-identifiability-analysis">Local identifiability analysis</a><a id="Local-identifiability-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Local-identifiability-analysis" title="Permalink"></a></h2><p>Local identifiability can be assessed through the <code>assess_local_identifiability</code> function. While this is already determined by <code>assess_identifiability</code>, assessing local identifiability only has the advantage that it is easier to compute. Hence, there might be models where global identifiability analysis fails (or takes a prohibitively long time), where instead <code>assess_local_identifiability</code> can be used. This function takes the same inputs as <code>assess_identifiability</code> and returns, for each quantity, <code>true</code> if it is locally identifiable (or <code>false</code> if it is not). Here, for the Goodwind oscillator, we assesses it for local identifiability only:</p><pre><code class="language-julia hljs">assess_local_identifiability(gwo; measured_quantities = [:M], loglevel = Logging.Error)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{SymbolicUtils.BasicSymbolic{Real}, Bool} with 9 entries:
  M(t) =&gt; 1
  E(t) =&gt; 0
  P(t) =&gt; 1
  pₘ   =&gt; 1
  dₘ   =&gt; 1
  pₑ   =&gt; 0
  dₑ   =&gt; 1
  pₚ   =&gt; 0
  dₚ   =&gt; 1</code></pre><p>We note that the results are consistent with those produced by <code>assess_identifiability</code> (with globally or locally identifiable quantities here all being assessed as at least locally identifiable).</p><h2 id="Finding-identifiable-functions"><a class="docs-heading-anchor" href="#Finding-identifiable-functions">Finding identifiable functions</a><a id="Finding-identifiable-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-identifiable-functions" title="Permalink"></a></h2><p>Finally, StructuralIdentifiability provides the <code>find_identifiable_functions</code> function. Rather than determining the identifiability of each parameter and unknown of the model, it finds a set of identifiable functions, such as any other identifiable expression of the model can be generated by these. Let us again consider the Goodwind oscillator, using the <code>find_identifiable_functions</code> function we find that identifiability can be reduced to five globally identifiable expressions:</p><pre><code class="language-julia hljs">find_identifiable_functions(gwo; measured_quantities = [:M], loglevel = Logging.Error)</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
d_m \\
p_m \\
d_e d_p \\
p_e p_p \\
d_e + d_p \\
\end{array}
\right]
\end{equation}
 \]</p><p>Again, these results are consistent with those produced by <code>assess_identifiability</code>. There, <code>pₑ</code> and <code>pₚ</code> where found to be globally identifiable. Here, they correspond directly to identifiable expressions. The remaining four parameters (<code>pₘ</code>, <code>dₘ</code>, <code>dₑ</code>, and <code>dₚ</code>) occur as part of more complicated composite expressions.</p><p><code>find_identifiable_functions</code> tries to simplify its output functions to create nice expressions. The degree to which it does this can be adjusted using the <code>simplify</code> keywords. Using the <code>:weak</code>, <code>:standard</code> (default), and <code>:strong</code> arguments, increased simplification can be forced (at the expense of longer runtime).</p><h2 id="Creating-StructuralIdentifiability-compatible-ODE-models-from-Catalyst-ReactionSystems"><a class="docs-heading-anchor" href="#Creating-StructuralIdentifiability-compatible-ODE-models-from-Catalyst-ReactionSystems">Creating StructuralIdentifiability compatible ODE models from Catalyst <code>ReactionSystem</code>s</a><a id="Creating-StructuralIdentifiability-compatible-ODE-models-from-Catalyst-ReactionSystems-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-StructuralIdentifiability-compatible-ODE-models-from-Catalyst-ReactionSystems" title="Permalink"></a></h2><p>While the functionality described above covers the vast majority of analysis that user might want to perform, the StructuralIdentifiability package supports several additional features. While these does not have inherent Catalyst support, we do provide the <code>make_si_ode</code> function to simplify their use. Similar to the previous functions, it takes a <code>ReactionSystem</code>, lists of measured quantities, and known parameter values. The output is a <a href="https://docs.sciml.ai/StructuralIdentifiability/stable/tutorials/creating_ode/#Defining-the-model-using-@ODEmodel-macro">ODE of the standard form supported by StructuralIdentifiability</a>. It can be created using the following syntax:</p><pre><code class="language-julia hljs">si_ode = make_si_ode(gwo; measured_quantities = [:M])</code></pre><p>and then used as input to various StructuralIdentifiability functions. In the following example we use StructuralIdentifiability&#39;s <code>print_for_DAISY</code> function, printing the model as an expression that can be used by the <a href="https://daisy.dei.unipd.it/">DAISY</a> software for identifiability analysis<sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.</p><pre><code class="language-julia hljs">print_for_DAISY(si_ode)</code></pre><h2 id="Notes-on-systems-with-conservation-laws"><a class="docs-heading-anchor" href="#Notes-on-systems-with-conservation-laws">Notes on systems with conservation laws</a><a id="Notes-on-systems-with-conservation-laws-1"></a><a class="docs-heading-anchor-permalink" href="#Notes-on-systems-with-conservation-laws" title="Permalink"></a></h2><p>Several reaction network models, such as</p><pre><code class="language-julia hljs">rs = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X1} &amp;\xrightleftharpoons[k2]{k1} \mathrm{X2}  
 \end{align*}
 \]</p><p>contain conservation laws (in this case <span>$Γ = X1 + X2$</span>, where <span>$Γ = X1(0) + X2(0)$</span> is a constant). Because the presence of such conservation laws makes structural identifiability analysis prohibitively computationally expensive (for all but the simplest of cases), these are automatically eliminated by Catalyst (removing one ODE from the resulting ODE system for each conservation law). For the <code>assess_identifiability</code> and <code>assess_local_identifiability</code> functions, this will be unnoticed by the user. However, for the <code>find_identifiable_functions</code> and <code>make_si_ode</code> functions, this may result in one, or several, parameters of the form <code>Γ[i]</code> (where <code>i</code> is an integer) appearing in the produced expressions. These correspond to the conservation law constants and can be found through</p><pre><code class="language-julia hljs">conservedequations(rs)</code></pre><p class="math-container">\[ \begin{align}
\mathrm{X2}\left( t \right) =&amp;  - \mathrm{X1}\left( t \right) + \Gamma_1
\end{align}
 \]</p><p>E.g. if you run:</p><pre><code class="language-julia hljs">find_identifiable_functions(rs; measured_quantities = [:X1, :X2])</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
\Gamma_1 \\
k2 \\
k1 \\
\end{array}
\right]
\end{equation}
 \]</p><p>we see that <code>Γ[1]</code> (<code>= X1(0) + X2(0)</code>) is detected as an identifiable expression. If we want to disable this feature for any function, we can use the <code>remove_conserved = false</code> option:</p><pre><code class="language-julia hljs">find_identifiable_functions(rs; measured_quantities = [:X1, :X2], remove_conserved = false)</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
k2 \\
k1 \\
\end{array}
\right]
\end{equation}
 \]</p><h2 id="Systems-with-exponent-parameters"><a class="docs-heading-anchor" href="#Systems-with-exponent-parameters">Systems with exponent parameters</a><a id="Systems-with-exponent-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Systems-with-exponent-parameters" title="Permalink"></a></h2><p>Structural identifiability cannot currently be applied to systems with parameters (or species) in exponents. E.g. this</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    (hill(X,v,K,n),d), 0 &lt;--&gt; X
end
assess_identifiability(rn; measured_quantities = [:X])</code></pre><p>is currently not possible. Hopefully this will be a supported feature in the future. For now, such expressions will have to be rewritten to not include such exponents. For some cases, e.g. <code>10^k</code> this is trivial. However, it is also possible generally (but more involved and often includes introducing additional variables). </p><hr/><h2 id="structural_identifiability_citation"><a class="docs-heading-anchor" href="#structural_identifiability_citation">Citation</a><a id="structural_identifiability_citation-1"></a><a class="docs-heading-anchor-permalink" href="#structural_identifiability_citation" title="Permalink"></a></h2><p>If you use this functionality in your research, please cite the following paper to support the authors of the StructuralIdentifiability package:</p><pre><code class="nohighlight hljs">@article{structidjl,
  author  = {Dong, R. and Goodbrake, C. and Harrington, H. and Pogudin G.},
  title   = {Differential Elimination for Dynamical Models via Projections with Applications to Structural Identifiability},
  journal = {SIAM Journal on Applied Algebra and Geometry},
  url     = {https://doi.org/10.1137/22M1469067},
  year    = {2023}
  volume  = {7},
  number  = {1},
  pages   = {194-235}
}</code></pre><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://www.sciencedirect.com/science/article/pii/S1364815218307278">Guillaume H.A. Joseph et al., <em>Introductory overview of identifiability analysis: A guide to evaluating whether you have the right type of data for your modeling purpose</em>, Environmental Modelling &amp; Software (2019).</a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://www.sciencedirect.com/science/article/pii/0065257165900671?via%3Dihub">Goodwin B.C., <em>Oscillatory Behavior in Enzymatic Control Processes</em>, Advances in Enzyme Regulation (1965).</a></li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a><a href="https://www.sciencedirect.com/science/article/abs/pii/S0169260707001605">Bellu G., et al., <em>DAISY: A new software tool to test global identifiability of biological and physiological systems</em>, Computer Methods and Programs in Biomedicine (2007).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../behaviour_optimisation/">« Optimization for non-data fitting purposes</a><a class="docs-footer-nextpage" href="../global_sensitivity_analysis/">Global Sensitivity Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 7 June 2024 16:04">Friday 7 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
