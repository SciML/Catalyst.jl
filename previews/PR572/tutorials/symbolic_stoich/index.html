<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parametric Stoichiometry · Catalyst.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/tutorials/symbolic_stoich/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Catalyst for new Julia users</span><ul><li><a class="tocitem" href="../../catalyst_for_new_julia_users/intro_to_catalyst/">Introduction to Catalyst and Julia for new Julia users</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../using_catalyst/">Using Catalyst</a></li><li><a class="tocitem" href="../dsl/">The Reaction DSL</a></li><li><a class="tocitem" href="../reaction_systems/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../basic_examples/">Basic Chemical Reaction Network Examples</a></li><li><a class="tocitem" href="../compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li class="is-active"><a class="tocitem" href>Parametric Stoichiometry</a><ul class="internal"><li><a class="tocitem" href="#Using-Symbolic-Stoichiometry"><span>Using Symbolic Stoichiometry</span></a></li><li><a class="tocitem" href="#Gene-expression-with-randomly-produced-amounts-of-protein"><span>Gene expression with randomly produced amounts of protein</span></a></li></ul></li><li><a class="tocitem" href="../reaction_network_representation/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../homotopy_continuation_tutorial/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../bifurcation_diagram/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../parameter_estimation/">Parameter Estimation</a></li><li><a class="tocitem" href="../generating_reactions_programmatically/">Smoluchowski Coagulation Equation</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/catalyst_api/">Catalyst.jl API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Parametric Stoichiometry</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parametric Stoichiometry</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/tutorials/symbolic_stoich.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Parametric-Stoichiometry"><a class="docs-heading-anchor" href="#Parametric-Stoichiometry">Parametric Stoichiometry</a><a id="Parametric-Stoichiometry-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Stoichiometry" title="Permalink"></a></h1><p>Catalyst supports stoichiometric coefficients that involve parameters, species, or even general expressions. In this tutorial we show several examples of how to use parametric stoichiometry, and discuss several caveats to be aware of.</p><p><em>Note, this tutorial requires ModelingToolkit v8.5.4 or greater to work properly.</em></p><h2 id="Using-Symbolic-Stoichiometry"><a class="docs-heading-anchor" href="#Using-Symbolic-Stoichiometry">Using Symbolic Stoichiometry</a><a id="Using-Symbolic-Stoichiometry-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Symbolic-Stoichiometry" title="Permalink"></a></h2><p>Let&#39;s first consider a simple reversible reaction where the number of reactants is a parameter, and the number of products is the product of two parameters. </p><pre><code class="language- hljs">using Catalyst, Latexify, DifferentialEquations, ModelingToolkit, Plots
revsys = @reaction_network revsys begin
    k₊, m*A --&gt; (m*n)*B
    k₋, B --&gt; A
end k₊ k₋ m n
reactions(revsys)</code></pre><p>Note, as always the <code>@reaction_network</code> macro sets all symbols not declared to be parameters to be species, so that in this example we have two species, <code>A</code> and <code>B</code>, and four parameters. In addition, the stoichiometry is applied to the right most symbol in a given term, i.e. in the first equation the substrate <code>A</code> has stoichiometry <code>m</code> and the product <code>B</code> has stoichiometry <code>m*n</code>. For example, in</p><pre><code class="language- hljs">rn = @reaction_network begin
    k, A*C --&gt; 2B
    end k
reactions(rn)</code></pre><p>we see three species, <code>(A,B,C)</code>, however, <code>A</code> is treated as the stoichiometric coefficient of <code>C</code>, i.e.</p><pre><code class="language- hljs">rx = reactions(rn)[1]
rx.substrates[1],rx.substoich[1]</code></pre><p>We could have equivalently specified our systems directly via the Catalyst API. For example, for <code>revsys</code> we would could use</p><pre><code class="language- hljs">@parameters k₊,k₋,m,n
@variables t, A(t), B(t)
rxs = [Reaction(k₊,[A],[B],[m],[m*n]),
       Reaction(k₋,[B],[A])] 
revsys2 = ReactionSystem(rxs,t; name=:revsys)
revsys2 == revsys</code></pre><p>which can be simplified using the <code>@reaction</code> macro to</p><pre><code class="language- hljs">rxs2 = [(@reaction k₊, m*A --&gt; (m*n)*B),
        (@reaction k₋, B --&gt; A)]
revsys3 = ReactionSystem(rxs2,t; name=:revsys)
revsys3 == revsys</code></pre><p>Note, the <code>@reaction</code> macro assumes all symbols are parameters except the right most symbols in the reaction line (i.e. <code>A</code> and <code>B</code>). For example, in  <code>@reaction k, F*A + 2(H*G+B) --&gt; D</code>, the substrates are <code>(A,G,B)</code> with stoichiometries <code>(F,2*H,2)</code>.</p><p>Let&#39;s now convert <code>revsys</code> to ODEs and look at the resulting equations:</p><pre><code class="language- hljs">osys = convert(ODESystem, revsys)
equations(osys)
show(stdout, MIME&quot;text/plain&quot;(), equations(osys)) # hide</code></pre><p>Notice, as described in the <a href="../using_catalyst/#Reaction-rate-laws-used-in-simulations">Reaction rate laws used in simulations</a> section, the default rate laws involve factorials in the stoichiometric coefficients. For this reason we must specify <code>m</code> and <code>n</code> as integers, and hence <em>use a tuple for the parameter mapping</em></p><pre><code class="language- hljs">p  = (k₊ =&gt; 1.0, k₋ =&gt; 1.0, m =&gt; 2, n =&gt; 2)
u₀ = [A =&gt; 1.0, B =&gt; 1.0]
oprob = ODEProblem(osys, u₀, (0.0,1.0), p)</code></pre><p>We can now solve and plot the system</p><pre><code class="language- hljs">sol = solve(oprob, Tsit5())
plot(sol)</code></pre><p><em>If we had used a vector to store parameters, <code>m</code> and <code>n</code> would be converted to floating point giving an error when solving the system.</em></p><p>An alternative approach to avoid the issues of using mixed floating point and integer variables is to disable the rescaling of rate laws as described in <a href="../using_catalyst/#Reaction-rate-laws-used-in-simulations">Reaction rate laws used in simulations</a> section. This requires passing the <code>combinatoric_ratelaws=false</code> keyword to <code>convert</code> or to <code>ODEProblem</code> (if directly building the problem from a <code>ReactionSystem</code> instead of first converting to an <code>ODESystem</code>). For the previous example this gives the following (different) system of ODEs</p><pre><code class="language- hljs">osys = convert(ODESystem, revsys; combinatoric_ratelaws=false)
equations(osys)
show(stdout, MIME&quot;text/plain&quot;(), equations(osys)) # hide</code></pre><p>Since we no longer have factorial functions appearing, our example will now run even with floating point values for <code>m</code> and <code>n</code>:</p><pre><code class="language- hljs">p  = (k₊ =&gt; 1.0, k₋ =&gt; 1.0, m =&gt; 2.0, n =&gt; 2.0)
oprob = ODEProblem(osys, u₀, (0.0,1.0), p)
sol = solve(oprob, Tsit5())
plot(sol)</code></pre><h2 id="Gene-expression-with-randomly-produced-amounts-of-protein"><a class="docs-heading-anchor" href="#Gene-expression-with-randomly-produced-amounts-of-protein">Gene expression with randomly produced amounts of protein</a><a id="Gene-expression-with-randomly-produced-amounts-of-protein-1"></a><a class="docs-heading-anchor-permalink" href="#Gene-expression-with-randomly-produced-amounts-of-protein" title="Permalink"></a></h2><p>As a second example, let&#39;s build the negative feedback model from <a href="https://augustinas1.github.io/MomentClosure.jl/dev/tutorials/geometric_reactions+conditional_closures/">MomentClosure.jl</a> that involves a bursty reaction that produces a random amount of protein. </p><p>In our model <code>G₋</code> will denote the repressed state, and <code>G₊</code> the active state where the gene can transcribe. <code>P</code> will denote the protein product of the gene. We will assume that proteins are produced in bursts that produce <code>m</code> proteins, where <code>m</code> is a (shifted) geometric random variable with mean <code>b</code>. To define <code>m</code> we must register the <code>Distributions.Geometric</code> distribution from Distributions.jl with Symbolics.jl, after which we can use it in symbolic expressions:</p><pre><code class="language-julia hljs">using Distributions: Geometric
@register_symbolic Geometric(b)
@parameters b
m = rand(Geometric(1/b)) + 1</code></pre><p>Note, as we require the shifted geometric distribution, we add one to Distributions.jl&#39;s <code>Geometric</code> random variable (which includes zero). </p><p>We can now define our model</p><pre><code class="language- hljs">burstyrn = @reaction_network burstyrn begin
    k₊, G₋ --&gt; G₊
    k₋*P^2, G₊ --&gt; G₋
    kₚ, G₊ --&gt; G₊ + $m*P
    γₚ, P --&gt; ∅
end k₊ k₋ kₚ γₚ
reactions(burstyrn)
show(stdout, MIME&quot;text/plain&quot;(), reactions(burstyrn)) # hide</code></pre><p>The parameter <code>b</code> does not need to be explicitly declared in the <code>@reaction_network</code> macro as it is detected when the expression <code>rand(Geometric(1/b)) + 1</code> is substituted for <code>m</code>.</p><p>We next convert our network to a jump process representation</p><pre><code class="language- hljs">jsys = convert(JumpSystem, burstyrn; combinatoric_ratelaws=false)
equations(jsys)
show(stdout, MIME&quot;text/plain&quot;(), equations(jsys)) # hide</code></pre><p>Notice, the <code>equations</code> of <code>jsys</code> have three <code>MassActionJump</code>s for the first three reactions, and one <code>ConstantRateJump</code> for the last reaction. If we examine the <code>ConstantRateJump</code> more closely we can see the generated <code>rate</code> and <code>affect!</code> functions for the bursty reaction that makes protein</p><pre><code class="language- hljs">equations(jsys)[4].rate
show(stdout, MIME&quot;text/plain&quot;(), equations(jsys)[4].rate) # hide</code></pre><pre><code class="language- hljs">equations(jsys)[4].affect!
show(stdout, MIME&quot;text/plain&quot;(), equations(jsys)[4].affect!) # hide</code></pre><p>Finally, we can now simulate our jumpsystem</p><pre><code class="language- hljs">pmean = 200
bval = 70
γₚval = 1
k₋val = 0.001
k₊val = 0.05
kₚval = pmean * γₚval * (k₋val * pmean^2 + k₊val) / (k₊val * bval)
p = symmap_to_varmap(jsys, (:k₊ =&gt; k₊val, :k₋ =&gt; k₋val, :kₚ =&gt; kₚval, :γₚ =&gt; γₚval, :b =&gt; bval))
u₀ = symmap_to_varmap(jsys, [:G₊ =&gt; 1, :G₋ =&gt; 0, :P =&gt; 1])
tspan = (0., 6.0)   # time interval to solve over
dprob = DiscreteProblem(jsys, u₀, tspan, p)
jprob = JumpProblem(jsys, dprob, Direct())
sol = solve(jprob, SSAStepper())
plot(sol.t, sol[jsys.P], legend=false, xlabel=&quot;time&quot;, ylabel=&quot;P(t)&quot;)</code></pre><p>To double check our results are consistent with MomentClosure.jl, let&#39;s calculate and plot the average amount of protein (which is also plotted in the MomentClosure.jl <a href="https://augustinas1.github.io/MomentClosure.jl/dev/tutorials/geometric_reactions+conditional_closures/">tutorial</a>).</p><pre><code class="language- hljs">function getmean(jprob, Nsims, tv)
    Pmean = zeros(length(tv))
    @variables t, P(t)
    for n in 1:Nsims
        sol = solve(jprob, SSAStepper())        
        Pmean .+= sol(tv, idxs=P)
    end
    Pmean ./= Nsims
end
tv = range(tspan[1],tspan[2],step=.1)
psim_mean = getmean(jprob, 20000, tv)
plot(tv, psim_mean, ylabel=&quot;average of P(t)&quot;, xlabel=&quot;time&quot;, xlim=(0.0,6.0), legend=false)</code></pre><p>Comparing, we see similar averages for <code>P(t)</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../compositional_modeling/">« Compositional Modeling of Reaction Systems</a><a class="docs-footer-nextpage" href="../reaction_network_representation/">Network Analysis in Catalyst »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 16 December 2022 16:12">Friday 16 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
