<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving the chemical master equation using FiniteStateProjection.jl · Catalyst.jl</title><meta name="title" content="Solving the chemical master equation using FiniteStateProjection.jl · Catalyst.jl"/><meta property="og:title" content="Solving the chemical master equation using FiniteStateProjection.jl · Catalyst.jl"/><meta property="twitter:title" content="Solving the chemical master equation using FiniteStateProjection.jl · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/model_simulation/finite_state_projection_simulation/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/model_simulation/finite_state_projection_simulation/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/model_simulation/finite_state_projection_simulation/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Introduction to Catalyst</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Model creation and properties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/constraint_equations/">Coupled ODEs, Algebraic Equations, and Events</a></li><li><a class="tocitem" href="../../model_creation/conservation_laws/">Working with Conservation Laws</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stoichiometries</a></li><li><a class="tocitem" href="../../model_creation/functional_parameters/">Inputs and time-dependent (or functional) parameters</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/reactionsystem_content_accessing/">Accessing Model Properties</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related Functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, Generative, Modelling of a Linear Pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/noise_modelling_approaches/">Approaches for modelling system noise</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Model simulation and visualization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../simulation_plotting/">Simulation Plotting</a></li><li><a class="tocitem" href="../simulation_structure_interfacing/">Interfacing Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../ode_simulation_performance/">Advice for Performant ODE Simulations</a></li><li><a class="tocitem" href="../sde_simulation_performance/">Advice for Performant SDE Simulations</a></li><li class="is-active"><a class="tocitem" href>Solving the chemical master equation using FiniteStateProjection.jl</a><ul class="internal"><li><a class="tocitem" href="#state_projection_one_species"><span>Finite state projection simulation of single-species model</span></a></li><li><a class="tocitem" href="#state_projection_multi_species"><span>Finite state projection simulation of multi-species model</span></a></li><li><a class="tocitem" href="#state_projection_steady_state_sim"><span>Finite state projection steady state simulations</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-8" type="checkbox"/><label class="tocitem" for="menuitem-4-8"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/periodic_events_simulation/">Modelling a Periodic Event During ODE and Jump Simulations</a></li><li><a class="tocitem" href="../examples/activation_time_distribution_measurement/">Measuring the Distribution of System Activation Times</a></li><li><a class="tocitem" href="../examples/interactive_brusselator_simulation/">Interactive Simulation and Plotting</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Network Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../network_analysis/odes/">Decomposing the Reaction Network ODEs</a></li><li><a class="tocitem" href="../../network_analysis/crn_theory/">Chemical Reaction Network Theory</a></li><li><a class="tocitem" href="../../network_analysis/network_properties/">Caching of Network Properties in <code>ReactionSystems</code></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Steady state analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing Model Steady State Properties with DynamicalSystems.jl</a></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/examples/nullcline_plotting/">Plotting Nullclines and Steady States in Phase Space</a></li><li><a class="tocitem" href="../../steady_state_functionality/examples/bifurcationkit_periodic_orbits/">Computing Periodic Orbits (Oscillations) Using BifurcationKit.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/examples/bifurcationkit_codim2/">Tracking Bifurcation Point w.r.t. Secondary Parameters using BifurcationKit.jl</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Inverse problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/petab_ode_param_fitting/">Parameter Fitting for ODEs using PEtab.jl</a></li><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for Non-data Fitting Purposes</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Spatial modelling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial Jump Simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/core_api/">Catalyst.jl API</a></li><li><a class="tocitem" href="../../api/network_analysis_api/">Network analysis and representations</a></li></ul></li><li><a class="tocitem" href="../../devdocs/dev_guide/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model simulation and visualization</a></li><li class="is-active"><a href>Solving the chemical master equation using FiniteStateProjection.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solving the chemical master equation using FiniteStateProjection.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/model_simulation/finite_state_projection_simulation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="finite-state_projection"><a class="docs-heading-anchor" href="#finite-state_projection">Solving the chemical master equation using FiniteStateProjection.jl</a><a id="finite-state_projection-1"></a><a class="docs-heading-anchor-permalink" href="#finite-state_projection" title="Permalink"></a></h1><details><summary><strong>Environment setup and package installation</strong></summary><p>The following code sets up an environment for running the code on this page.</p><pre><code class="language-julia hljs">using Pkg
Pkg.activate(; temp = true) # Creates a temporary environment, which is deleted when the Julia session ends.
Pkg.add(&quot;Catalyst&quot;)
Pkg.add(&quot;FiniteStateProjection&quot;)
Pkg.add(&quot;JumpProcesses&quot;)
Pkg.add(&quot;OrdinaryDiffEqDefault&quot;)
Pkg.add(&quot;OrdinaryDiffEqRosenbrock&quot;)
Pkg.add(&quot;Plots&quot;)
Pkg.add(&quot;SteadyStateDiffEq&quot;)</code></pre></details><details><summary><strong>Quick-start example</strong></summary><p>The following code provides a brief example of how to simulate the chemical master equation using the <a href="https://github.com/SciML/FiniteStateProjection.jl">FiniteStateProjection.jl</a> package.</p><pre><code class="language-julia hljs"># Create reaction network model (a bistable switch).
using Catalyst
rs_bistable = @reaction_network begin
    hillr(Y, v, K, n), ∅ --&gt; X
    hillr(X, v, K, n), ∅ --&gt; Y
    d, (X,Y) --&gt; 0
end

# Create a FSPSystem. The second argument denotes species order in u0 and sol.
using FiniteStateProjection
fsp_sys = FSPSystem(rs_bistable, [:X, :Y])

# Create ODEProblem. Initial condition is the system&#39;s initial distribution.
# Initial condition also designates projection space (outside of which solution should be very close to 0).
u0 = zeros(20,20)
u0[6,2] = 1.0
tspan = (0.0, 50.0)
ps = [:v =&gt; 1.0, :K =&gt; 3.0, :n =&gt; 3, :d =&gt; 0.2]
oprob = ODEProblem(fsp_sys, u0, tspan, ps)

# Simulate ODE (it can be quite large, so consider performance options).
# Plot solution as a heatmap at a specific time point.
using OrdinaryDiffEqRosenbrock, Plots
osol = solve(oprob, Rodas5P())
heatmap(0:19, 0:19, osol(50.0); xguide = &quot;Y&quot;, yguide = &quot;X&quot;)</code></pre></details><p><br/>   As previously discussed, <a href="../../introduction_to_catalyst/math_models_intro/#math_models_in_catalyst_sck_jumps"><em>stochastic chemical kinetics</em></a> models are mathematically given by jump processes that capture the exact times at which individual reactions occur, and the exact (integer) amounts of each chemical species at a given time. They represent a more microscopic model than <a href="../../introduction_to_catalyst/math_models_intro/#math_models_in_catalyst_cle_sdes">chemical Langevin equation SDE</a> and <a href="../../introduction_to_catalyst/math_models_intro/#math_models_in_catalyst_rre_odes">reaction rate equation ODE</a> models, which can be interpreted as approximations to stochastic chemical kinetics models in the large population limit.</p><p>One can study the dynamics of stochastic chemical kinetics models by simulating the stochastic processes using Monte Carlo methods. For example, they can be <a href="../simulation_introduction/#simulation_intro_jumps">exactly sampled</a> using <a href="https://en.wikipedia.org/wiki/Gillespie_algorithm">Stochastic Simulation Algorithms</a> (SSAs), which are also often referred to as Gillespie&#39;s method. To gain a good understanding of a system&#39;s dynamics, one typically has to carry out a large number of jump process simulations to minimize sampling error. To avoid such sampling error, an alternative approach is to solve ODEs for the <em>full probability distribution</em> that these processes have a given value at each time. Knowing this distribution, one can then calculate any statistic of interest that can be sampled via running many SSA simulations.</p><p><a href="https://en.wikipedia.org/wiki/Master_equation"><em>The chemical master equation</em></a> (CME) describes the time development of this probability distribution<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>, and is given by a (possibly infinite) coupled system of ODEs (with one ODE for each possible chemical state, i.e. number configuration, of the system). For a simple <a href="../../model_creation/examples/basic_CRN_library/#basic_CRN_library_bd">birth-death model</a> (<span>$\varnothing \xrightleftharpoons[d]{p} X$</span>) the CME looks like</p><p class="math-container">\[\begin{aligned}
\frac{dP(X(t)=0)}{dt} &amp;= d \cdot P(X(t)=1) - p \cdot P(X(t)=0) \\
\frac{dP(X(t)=1)}{dt} &amp;= p \cdot P(X(t)=0) + d \cdot 2P(X(t)=2) - (p + d) P(X(t)=1) \\
 &amp;\vdots\\
\frac{dP(X(t)=i)}{dt} &amp;= p \cdot P(X(t)=i-1) + d \cdot (i + 1)P(X(t)=i+1) - (p + D \cdot i) P(X(t)=i) \\
 &amp;\vdots\\
\end{aligned}\]</p><p>A general form of the CME is provided <a href="../../introduction_to_catalyst/math_models_intro/#math_models_in_catalyst_sck_jumps">here</a>. For chemical reaction networks in which the total population is bounded, the CME corresponds to a finite set of ODEs. In contrast, for networks in which the system can (in theory) become unbounded, such as networks that include zero order reactions like <span>$\varnothing \to X$</span>, the CME will correspond to an infinite set of ODEs. Even in the finite case, the number of ODEs corresponds to the number of possible state vectors (i.e. vectors with components representing the integer populations of each species in the network), and can become exceptionally large. Therefore, for even simple reaction networks there can be many more ODEs than can be represented in typical levels of computer memory, and it becomes infeasible to numerically solve the full system of ODEs that correspond to the CME. However, in many cases the probability of the system attaining species values outside some small range can become negligibly small. Here, a truncated, approximating, version of the CME can be solved practically. An approach for this is the <em>finite state projection method</em><sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. Below we describe how to use the <a href="https://github.com/SciML/FiniteStateProjection.jl">FiniteStateProjection.jl</a> package to solve the truncated CME (with the package&#39;s <a href="https://docs.sciml.ai/FiniteStateProjection/dev/">documentation</a> providing a more extensive description). While the CME approach can be very powerful, we note that even for systems with a few species, the truncated CME typically has too many states for it to be feasible to solve the full set of ODEs.</p><h2 id="state_projection_one_species"><a class="docs-heading-anchor" href="#state_projection_one_species">Finite state projection simulation of single-species model</a><a id="state_projection_one_species-1"></a><a class="docs-heading-anchor-permalink" href="#state_projection_one_species" title="Permalink"></a></h2><p>For this example, we will use a simple <a href="../../model_creation/examples/basic_CRN_library/#basic_CRN_library_bd">birth-death model</a>, where a single species (<span>$X$</span>) is created and degraded at constant rates (<span>$p$</span> and <span>$d$</span>, respectively).</p><pre><code class="language-julia hljs">using Catalyst
rs = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
end</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightleftharpoons[d]{p} \mathrm{X}  
 \end{align*}
 \]</p><p>Next, we perform jump simulations (using the <a href="../ensemble_simulations/#ensemble_simulations_monte_carlo">ensemble simulation interface</a>) of the model. Here, we can see how it develops from an initial condition and reaches a steady state distribution.</p><pre><code class="language-julia hljs">using JumpProcesses, Plots
u0 = [:X =&gt; 5]
tspan = (0.0, 10.0)
ps = [:p =&gt; 20.0, :d =&gt; 0.5]
jprob = JumpProblem(JumpInputs(rs, u0, tspan, ps))
eprob = EnsembleProblem(jprob)
esol = solve(eprob, SSAStepper(); trajectories = 10)
plot(esol; ylimit = (0.0, Inf))</code></pre><img src="d6b279d4.png" alt="Example block output"/><p>Using chemical master equation simulations, we want to simulate how the <em>full probability distribution</em> of these jump simulations develops across the simulation time frame. </p><p>As a first step, we import the FiniteStateProjection package. Next, we convert our <a href="../../api/core_api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to a <code>FSPSystem</code> (from which we later will generate the ODEs that correspond to the truncated CME).</p><pre><code class="language-julia hljs">using FiniteStateProjection
fsp_sys = FSPSystem(rs)</code></pre><p>Next, we set our initial condition. For normal simulations, <span>$X$</span>&#39;s initial condition would be a single value. Here, however, we will simulate <span>$X$</span>&#39;s probability distribution. Hence, its initial condition will also be a probability distribution. In FiniteStateProjection&#39;s interface, the initial condition is an array, where the <span>$i$</span>&#39;th index is the probability that <span>$X$</span> have an initial value of <span>$i-1$</span>. The total sum of all probabilities across the vector should be normalised to <span>$1.0$</span>. Here we assume that <span>$X$</span>&#39;s initial conditions is known to be <span>$5$</span> (hence the corresponding probability is <span>$1.0$</span>, and the remaining ones are <span>$0.0$</span>):</p><pre><code class="language-julia hljs">u0 = zeros(75)
u0[6] = 1.0
bar(u0, label = &quot;t = 0.0&quot;)</code></pre><img src="c5619dc6.svg" alt="Example block output"/><p>We also plot the full distribution using the <code>bar</code> function. Finally, the initial condition vector defines the finite space onto which we project the CME. I.e. we will assume that, throughout the entire simulation, the probability of <span>$X$</span> reaching values outside this initial vector is negligible. </p><div class="admonition is-warning" id="Warning-4b5db35ad2bd499"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-4b5db35ad2bd499" title="Permalink"></a></header><div class="admonition-body"><p>This last bit is important. Even if the probability seems to be very small on the boundary provided by the initial condition, there is still a risk that probability will &quot;leak&quot;. Here, it can be good to make simulations using different projections, ensuring that the results are consistent (especially for longer simulations). It is also possible to (at any time point) sum up the total probability density to gain a measure of how much has &quot;leaked&quot; (ideally, this sum should be as close to 1 as possible). While solving the CME over a very large space will ensure correctness, a too large a space comes with an unnecessary performance penalty.</p></div></div><p>Now, we can finally create an <code>ODEProblem</code> using our <code>FSPSystem</code>, initial conditions, and the parameters declared previously. We can simulate this <code>ODEProblem</code> like any other ODE.</p><pre><code class="language-julia hljs">using OrdinaryDiffEqDefault
oprob = ODEProblem(fsp_sys, u0, tspan, ps)
osol = solve(oprob)</code></pre><p>Finally, we can plot <span>$X$</span>&#39;s probability distribution at various simulation time points. Again, we will use the <code>bar</code> function to plot the distribution, and the interface described <a href="../simulation_structure_interfacing/#simulation_structure_interfacing_solutions">here</a> to access the simulation at specified time points.</p><pre><code class="language-julia hljs">bar(0:74, osol(1.0); bar_width = 1.0, linewidth = 0, alpha = 0.7, label = &quot;t = 1.0&quot;)
bar!(0:74, osol(2.0); bar_width = 1.0, linewidth = 0, alpha = 0.7, label = &quot;t = 2.0&quot;)
bar!(0:74, osol(5.0); bar_width = 1.0, linewidth = 0, alpha = 0.7, label = &quot;t = 5.0&quot;)
bar!(0:74, osol(10.0); bar_width = 1.0, linewidth = 0, alpha = 0.7, label = &quot;t = 10.0&quot;,
    xguide = &quot;X (copy numbers)&quot;, yguide = &quot;Probability density&quot;)</code></pre><img src="a85f5722.svg" alt="Example block output"/><h2 id="state_projection_multi_species"><a class="docs-heading-anchor" href="#state_projection_multi_species">Finite state projection simulation of multi-species model</a><a id="state_projection_multi_species-1"></a><a class="docs-heading-anchor-permalink" href="#state_projection_multi_species" title="Permalink"></a></h2><p>Next, we will consider a system with more than one species. The workflow will be identical, however, we will have to make an additional consideration regarding the initial condition, simulation performance, and plotting approach.</p><p>For this example, we will consider a simple dimerisation model. In it, <span>$X$</span> gets produced and degraded at constant rates, and can also dimerise to form <span>$X₂$</span>.</p><pre><code class="language-julia hljs">rs = @reaction_network begin
    (p,d), 0 &lt;--&gt; X
    (kB,kD), 2X &lt;--&gt; X₂
end</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightleftharpoons[d]{p} \mathrm{X} \\
2 \mathrm{X} &amp;\xrightleftharpoons[\mathtt{kD}]{\mathtt{kB}} \mathrm{\mathtt{X_2}}  
 \end{align*}
 \]</p><p>Next, we will declare our parameter values and initial condition. In this case, the initial condition is a matrix where element <span>$(i,j)$</span> denotes the initial probability that <span>$(X(0),X₂(0)) = (i-1,j-1)$</span>. In this case, we will use an initial condition where we know that <span>$(X(0),X₂(0)) = (5,0)$</span>.</p><pre><code class="language-julia hljs">ps = [:p =&gt; 1.0, :d =&gt; 0.2, :kB =&gt; 2.0, :kD =&gt; 5.0]
u0 = zeros(25,25)
u0[6,1] = 1.0</code></pre><p>In the next step, however, we have to make an additional consideration. Since we have more than one species, we have to define which dimension of the initial condition (and hence also the output solution) corresponds to which species. Here we provide a second argument to <code>FSPSystem</code>, which is a vector listing all species in the order they occur in the <code>u0</code> array.</p><pre><code class="language-julia hljs">fsp_sys = FSPSystem(rs, [:X, :X₂])</code></pre><p>Finally, we can simulate the model just like in the 1-dimensional case. As we are simulating an ODE with <span>$25⋅25 = 625$</span> states, we need to make some considerations regarding performance. In this case, we will simply specify the <code>Rodas5P()</code> ODE solver (more extensive advice on performance can be found <a href="../ode_simulation_performance/#ode_simulation_performance">here</a>). Here, we perform a simulation with a long time span (<span>$t = 100.0$</span>), aiming to find the system&#39;s steady state distribution. Next, we plot it using the <code>heatmap</code> function.</p><pre><code class="language-julia hljs">using OrdinaryDiffEqRosenbrock
oprob = ODEProblem(fsp_sys, u0, 100.0, ps)
osol = solve(oprob, Rodas5P())
heatmap(0:24, 0:24, osol[end]; xguide = &quot;X₂&quot;, yguide = &quot;X&quot;)</code></pre><img src="02abd574.svg" alt="Example block output"/><div class="admonition is-warning" id="Warning-2a0ea834d50ef0e7"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-2a0ea834d50ef0e7" title="Permalink"></a></header><div class="admonition-body"><p>The <code>heatmap</code> function &quot;flips&quot; the plot contrary to what many would consider intuitive. I.e. here the x-axis corresponds to the second species (<span>$X₂$</span>) and the y-axis to the first species (<span>$X$</span>).</p></div></div><h2 id="state_projection_steady_state_sim"><a class="docs-heading-anchor" href="#state_projection_steady_state_sim">Finite state projection steady state simulations</a><a id="state_projection_steady_state_sim-1"></a><a class="docs-heading-anchor-permalink" href="#state_projection_steady_state_sim" title="Permalink"></a></h2><p>Previously, we have shown how the <a href="https://github.com/SciML/SteadyStateDiffEq.jl">SteadyStateDiffEq.jl</a> package can be used to <a href="../../steady_state_functionality/steady_state_stability_computation/#steady_state_stability">find an ODE&#39;s steady state through forward simulation</a>. The same interface can be used for ODEs generated through FiniteStateProjection. Below, we use this to find the steady state of the dimerisation example studied in the last example.</p><pre><code class="language-julia hljs">using SteadyStateDiffEq, OrdinaryDiffEqRosenbrock
ssprob = SteadyStateProblem(fsp_sys, u0, ps)
sssol = solve(ssprob, DynamicSS(Rodas5P()))
heatmap(0:24, 0:24, sssol; xguide = &quot;X₂&quot;, yguide = &quot;X&quot;)</code></pre><img src="d3a90585.svg" alt="Example block output"/><p>Finally, we can also approximate this steady state through Monte Carlo jump simulations.</p><pre><code class="language-julia hljs">jprob = JumpProblem(JumpInputs(rs, [:X =&gt; 0, :X₂ =&gt; 0], (0.0, 100.0), ps))
output_func(sol, i) = (sol[end], false)
eprob = EnsembleProblem(jprob; output_func)
esol = solve(eprob, SSAStepper(); trajectories = 10000)
ss_jump = zeros(25,25)
for endpoint in esol
    ss_jump[endpoint[1] + 1, endpoint[2] + 1] += 1
end
heatmap(0:24, 0:24, ss_jump ./length(esol); xguide = &quot;X₂&quot;, yguide = &quot;X&quot;)</code></pre><img src="8c21894b.svg" alt="Example block output"/><p>Here we used an ensemble <a href="../examples/activation_time_distribution_measurement/#activation_time_distribution_measurement">output function</a> to only save each simulation&#39;s final state (and plot these using <code>heatmap</code>).</p><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://www.sciencedirect.com/science/article/abs/pii/037843719290283V">Daniel T. Gillespie, <em>A rigorous derivation of the chemical master equation</em>, Physica A: Statistical Mechanics and its Applications (1992).</a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://pubs.aip.org/aip/jcp/article-abstract/124/4/044104/561868/The-finite-state-projection-algorithm-for-the?redirectedFrom=fulltext">Brian Munsky, Mustafa Khammash, <em>The finite state projection algorithm for the solution of the chemical master equation</em>, Journal of Chemical Physics (2006).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sde_simulation_performance/">« Advice for Performant SDE Simulations</a><a class="docs-footer-nextpage" href="../examples/periodic_events_simulation/">Modelling a Periodic Event During ODE and Jump Simulations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Tuesday 1 July 2025 01:29">Tuesday 1 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
