<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to Catalyst · Catalyst.jl</title><meta name="title" content="Introduction to Catalyst · Catalyst.jl"/><meta property="og:title" content="Introduction to Catalyst · Catalyst.jl"/><meta property="twitter:title" content="Introduction to Catalyst · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/introduction_to_catalyst/introduction_to_catalyst/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/introduction_to_catalyst/introduction_to_catalyst/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/introduction_to_catalyst/introduction_to_catalyst/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li class="is-active"><a class="tocitem" href>Introduction to Catalyst</a><ul class="internal"><li><a class="tocitem" href="#Mass-action-ODE-models"><span>Mass action ODE models</span></a></li><li><a class="tocitem" href="#Stochastic-simulation-algorithms-(SSAs)-for-stochastic-chemical-kinetics"><span>Stochastic simulation algorithms (SSAs) for stochastic chemical kinetics</span></a></li><li><a class="tocitem" href="#Chemical-Langevin-equation-(CLE)-stochastic-differential-equation-(SDE)-models"><span>Chemical Langevin equation (CLE) stochastic differential equation (SDE) models</span></a></li><li><a class="tocitem" href="#Specifying-a-complete-model-via-the-DSL"><span>Specifying a complete model via the DSL</span></a></li><li><a class="tocitem" href="#introduction_to_catalyst_ratelaws"><span>Reaction rate laws used in simulations</span></a></li><li><a class="tocitem" href="#Notes"><span>Notes</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><span class="tocitem">Model Creation and Properties</span><ul><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-11" type="checkbox"/><label class="tocitem" for="menuitem-3-11"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Model simulation</span><ul><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for performant ODE simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for performant SDE simulations</a></li></ul></li><li><span class="tocitem">Steady state analysis</span><ul><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><span class="tocitem">Spatial Modelling</span><ul><li><a class="tocitem" href="../../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial jump simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Introduction to Catalyst</a></li><li class="is-active"><a href>Introduction to Catalyst</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction to Catalyst</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/introduction_to_catalyst/introduction_to_catalyst.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="introduction_to_catalyst"><a class="docs-heading-anchor" href="#introduction_to_catalyst">Introduction to Catalyst</a><a id="introduction_to_catalyst-1"></a><a class="docs-heading-anchor-permalink" href="#introduction_to_catalyst" title="Permalink"></a></h1><p>In this tutorial we provide an introduction to using Catalyst to specify chemical reaction networks, and then to solve ODE, jump, and SDE models generated from them [1]. At the end we show what mathematical rate laws and transition rate functions (i.e. intensities or propensities) are generated by Catalyst for ODE, SDE and jump process models. The <a href="../math_models_intro/#math_models_in_catalyst">Mathematical Models Catalyst can Generate</a> documentation illustrates the abstract mathematical models Catalyst reaction models can be converted to, but please note it assumes one has already read this tutorial as a prerequisite.</p><p>We begin by installing Catalyst and any needed packages into a new environment. This step can be skipped if you have already installed them in your current, active environment:</p><pre><code class="language-julia hljs">using Pkg

# name of the environment
Pkg.activate(&quot;catalyst_introduction&quot;)

# packages we will use in this tutorial
Pkg.add(&quot;Catalyst&quot;)
Pkg.add(&quot;OrdinaryDiffEq&quot;)
Pkg.add(&quot;Plots&quot;)
Pkg.add(&quot;Latexify&quot;)
Pkg.add(&quot;JumpProcesses&quot;)
Pkg.add(&quot;StochasticDiffEq&quot;)</code></pre><p>We next load the basic packages we&#39;ll need for our first example:</p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEq, Plots, Latexify</code></pre><p>Let&#39;s start by using the Catalyst <a href="../../api/#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro to specify a simple chemical reaction network: the well-known repressilator. We first construct the reaction network. The basic types of arrows and predefined rate laws one can use are discussed in detail within the tutorial, <a href="../../model_creation/dsl_basics/#dsl_description">The Reaction DSL</a>. Here, we use a mix of first order, zero order, and repressive Hill function rate laws. Note, <span>$\varnothing$</span> corresponds to the empty state, and is used for zeroth order production and first order degradation reactions:</p><pre><code class="language-julia hljs">rn = @reaction_network Repressilator begin
    hillr(P₃,α,K,n), ∅ --&gt; m₁
    hillr(P₁,α,K,n), ∅ --&gt; m₂
    hillr(P₂,α,K,n), ∅ --&gt; m₃
    (δ,γ), m₁ &lt;--&gt; ∅
    (δ,γ), m₂ &lt;--&gt; ∅
    (δ,γ), m₃ &lt;--&gt; ∅
    β, m₁ --&gt; m₁ + P₁
    β, m₂ --&gt; m₂ + P₂
    β, m₃ --&gt; m₃ + P₃
    μ, P₁ --&gt; ∅
    μ, P₂ --&gt; ∅
    μ, P₃ --&gt; ∅
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Model Repressilator
Unknowns (6):
  m₁(t)
  m₂(t)
  m₃(t)
  P₁(t)
  P₂(t)
  P₃(t)
Parameters (7):
  α
  K
  n
  δ
  γ
  β
  μ</code></pre><p>showing that we&#39;ve created a new network model named <code>Repressilator</code> with the listed chemical species and unknowns. <a href="../../api/#Catalyst.@reaction_network"><code>@reaction_network</code></a> returns a <a href="../../api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, which we saved in the <code>rn</code> variable. It can be converted to a variety of other mathematical models represented as <code>ModelingToolkit.AbstractSystem</code>s, or analyzed in various ways using the <a href="../../api/#api">Catalyst.jl API</a>. For example, to see the chemical species, parameters, and reactions we can use</p><pre><code class="language-julia hljs">species(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 m₁(t)
 m₂(t)
 m₃(t)
 P₁(t)
 P₂(t)
 P₃(t)</code></pre><pre><code class="language-julia hljs">parameters(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7-element Vector{Any}:
 α
 K
 n
 δ
 γ
 β
 μ</code></pre><p>and</p><pre><code class="language-julia hljs">reactions(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">15-element Vector{Reaction}:
 Catalyst.hillr(P₃(t), α, K, n), ∅ --&gt; m₁
 Catalyst.hillr(P₁(t), α, K, n), ∅ --&gt; m₂
 Catalyst.hillr(P₂(t), α, K, n), ∅ --&gt; m₃
 δ, m₁ --&gt; ∅
 γ, ∅ --&gt; m₁
 δ, m₂ --&gt; ∅
 γ, ∅ --&gt; m₂
 δ, m₃ --&gt; ∅
 γ, ∅ --&gt; m₃
 β, m₁ --&gt; m₁ + P₁
 β, m₂ --&gt; m₂ + P₂
 β, m₃ --&gt; m₃ + P₃
 μ, P₁ --&gt; ∅
 μ, P₂ --&gt; ∅
 μ, P₃ --&gt; ∅</code></pre><p>We can also use Latexify to see the corresponding reactions in Latex, which shows what the <code>hillr</code> terms mathematically correspond to</p><pre><code class="language-julia hljs">latexify(rn)</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightarrow{\frac{K^{n} \alpha}{K^{n} + P_3^{n}}} \mathrm{m_1} \\
\varnothing &amp;\xrightarrow{\frac{K^{n} \alpha}{P_1^{n} + K^{n}}} \mathrm{m_2} \\
\varnothing &amp;\xrightarrow{\frac{K^{n} \alpha}{K^{n} + P_2^{n}}} \mathrm{m_3} \\
\mathrm{m_1} &amp;\xrightleftharpoons[\gamma]{\delta} \varnothing \\
\mathrm{m_2} &amp;\xrightleftharpoons[\gamma]{\delta} \varnothing \\
\mathrm{m_3} &amp;\xrightleftharpoons[\gamma]{\delta} \varnothing \\
\mathrm{m_1} &amp;\xrightarrow{\beta} \mathrm{m_1} + \mathrm{P_1} \\
\mathrm{m_2} &amp;\xrightarrow{\beta} \mathrm{m_2} + \mathrm{P_2} \\
\mathrm{m_3} &amp;\xrightarrow{\beta} \mathrm{m_3} + \mathrm{P_3} \\
\mathrm{P_1} &amp;\xrightarrow{\mu} \varnothing \\
\mathrm{P_2} &amp;\xrightarrow{\mu} \varnothing \\
\mathrm{P_3} &amp;\xrightarrow{\mu} \varnothing  
 \end{align*}
 \]</p><p>Assuming <a href="https://graphviz.org/">Graphviz</a> is installed and command line accessible, within a Jupyter notebook we can also graph the reaction network by</p><pre><code class="language-julia hljs">g = Graph(rn)</code></pre><p>giving</p><p><img src="../../assets/repressilator.svg" alt="Repressilator solution"/></p><p>The network graph shows a variety of information, representing each species as a blue node, and each reaction as an orange dot. Black arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry. Similarly, black arrows from reactions to species indicate products, and are labelled with their output stoichiometry. In contrast, red arrows from a species to reactions indicate the species is used within the reactions&#39; rate expressions. For the repressilator, the reactions</p><pre><code class="language-julia hljs">hillr(P₃,α,K,n), ∅ --&gt; m₁
hillr(P₁,α,K,n), ∅ --&gt; m₂
hillr(P₂,α,K,n), ∅ --&gt; m₃</code></pre><p>have rates that depend on the proteins, and hence lead to red arrows from each <code>Pᵢ</code>.</p><p>Note, from the REPL or scripts one can always use <a href="../../api/#Catalyst.savegraph"><code>savegraph</code></a> to save the graph (assuming <code>Graphviz</code> is installed).</p><h2 id="Mass-action-ODE-models"><a class="docs-heading-anchor" href="#Mass-action-ODE-models">Mass action ODE models</a><a id="Mass-action-ODE-models-1"></a><a class="docs-heading-anchor-permalink" href="#Mass-action-ODE-models" title="Permalink"></a></h2><p>Let&#39;s now use our <code>ReactionSystem</code> to generate and solve a corresponding mass action ODE model. We first convert the system to a <code>ModelingToolkit.ODESystem</code> by</p><pre><code class="language-julia hljs">rn = complete(rn)
odesys = convert(ODESystem, rn)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} m_1\left( t \right)}{\mathrm{d}t} =&amp; \mathrm{hillr}\left( P_3\left( t \right), \alpha, K, n \right) + \gamma - m_1\left( t \right) \delta \\
\frac{\mathrm{d} m_2\left( t \right)}{\mathrm{d}t} =&amp; \mathrm{hillr}\left( P_1\left( t \right), \alpha, K, n \right) + \gamma - m_2\left( t \right) \delta \\
\frac{\mathrm{d} m_3\left( t \right)}{\mathrm{d}t} =&amp; \mathrm{hillr}\left( P_2\left( t \right), \alpha, K, n \right) + \gamma - m_3\left( t \right) \delta \\
\frac{\mathrm{d} P_1\left( t \right)}{\mathrm{d}t} =&amp;  - P_1\left( t \right) \mu + m_1\left( t \right) \beta \\
\frac{\mathrm{d} P_2\left( t \right)}{\mathrm{d}t} =&amp; m_2\left( t \right) \beta - P_2\left( t \right) \mu \\
\frac{\mathrm{d} P_3\left( t \right)}{\mathrm{d}t} =&amp;  - P_3\left( t \right) \mu + m_3\left( t \right) \beta
\end{align}
 \]</p><p>(Here Latexify is used automatically to display <code>odesys</code> in Latex within Markdown documents or notebook environments like Pluto.jl.)</p><p>Before we can solve the ODEs, we need to specify the values of the parameters in the model, the initial condition, and the time interval to solve the model on. To do this we need to build mappings from the symbolic parameters and the species to the corresponding numerical values for parameters and initial conditions. We can build such mappings in several ways. One is to use Julia <code>Symbols</code> to specify the values like</p><pre><code class="language-julia hljs">pmap  = (:α =&gt; .5, :K =&gt; 40, :n =&gt; 2, :δ =&gt; log(2)/120,
         :γ =&gt; 5e-3, :β =&gt; log(2)/6, :μ =&gt; log(2)/60)
u₀map = [:m₁ =&gt; 0., :m₂ =&gt; 0., :m₃ =&gt; 0., :P₁ =&gt; 20., :P₂ =&gt; 0., :P₃ =&gt; 0.]</code></pre><p>Alternatively, we can use ModelingToolkit-based symbolic species variables to specify these mappings like</p><pre><code class="language-julia hljs">psymmap  = (rn.α =&gt; .5, rn.K =&gt; 40, rn.n =&gt; 2, rn.δ =&gt; log(2)/120,
    rn.γ =&gt; 5e-3, rn.β =&gt; 20*log(2)/120, rn.μ =&gt; log(2)/60)
u₀symmap = [rn.m₁ =&gt; 0., rn.m₂ =&gt; 0., rn.m₃ =&gt; 0., rn.P₁ =&gt; 20.,
    rn.P₂ =&gt; 0., rn.P₃ =&gt; 0.]</code></pre><p>Knowing these mappings we can set up the <code>ODEProblem</code> we want to solve:</p><pre><code class="language-julia hljs"># time interval to solve on
tspan = (0., 10000.)

# create the ODEProblem we want to solve
oprob = ODEProblem(rn, u₀map, tspan, pmap)</code></pre><p>By passing <code>rn</code> directly to the <code>ODEProblem</code>, Catalyst has to (internally) call <code>convert(ODESystem, rn)</code> again to generate the symbolic ODEs. We could instead pass <code>odesys</code> directly like</p><pre><code class="language-julia hljs">odesys = complete(odesys)
oprob2 = ODEProblem(odesys, u₀symmap, tspan, psymmap)</code></pre><p><code>oprob</code> and <code>oprob2</code> are functionally equivalent, each representing the same underlying problem.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When passing <code>odesys</code> to <code>ODEProblem</code> we needed to use the symbolic variable-based parameter mappings, <code>u₀symmap</code> and <code>psymmap</code>, while when directly passing <code>rn</code> we could use either those or the <code>Symbol</code>-based mappings, <code>u₀map</code> and <code>pmap</code>. <code>Symbol</code>-based mappings can always be converted to <code>symbolic</code> mappings using <a href="../../api/#Catalyst.symmap_to_varmap"><code>symmap_to_varmap</code></a>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Above we have used <code>rn = complete(rn)</code> and <code>odesys = complete(odesys)</code> to mark these systems as <em>complete</em>, indicating to Catalyst and ModelingToolkit that these models are finalized. This must be done before any system is given as input to a <code>convert</code> call or some problem type. <code>ReactionSystem</code> models created through the <code>@reaction_network</code> DSL (which is introduced elsewhere, and primarily used throughout these documentation) are always marked as complete when generated. Hence <code>complete</code> does not need to be called on them. Symbolically generated <code>ReactionSystem</code>s, <code>ReactionSystem</code>s generated via the <code>@network_component</code> macro, and any ModelingToolkit system generated by <code>convert</code> always needs to be manually marked as <code>complete</code> as we do for <code>odesys</code> above. An expanded description on <em>completeness</em> can be found <a href="../../model_creation/compositional_modeling/#completeness_note">here</a>.</p></div></div><p>At this point we are all set to solve the ODEs. We can now use any ODE solver from within the <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">OrdinaryDiffEq.jl</a> package. We&#39;ll use the recommended default explicit solver, <code>Tsit5()</code>, and then plot the solutions:</p><pre><code class="language-julia hljs">sol = solve(oprob, Tsit5(), saveat=10.0)
plot(sol)</code></pre><img src="5c63ef73.svg" alt="Example block output"/><p>We see the well-known oscillatory behavior of the repressilator! For more on the choices of ODE solvers, see the <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">OrdinaryDiffEq.jl documentation</a>.</p><hr/><h2 id="Stochastic-simulation-algorithms-(SSAs)-for-stochastic-chemical-kinetics"><a class="docs-heading-anchor" href="#Stochastic-simulation-algorithms-(SSAs)-for-stochastic-chemical-kinetics">Stochastic simulation algorithms (SSAs) for stochastic chemical kinetics</a><a id="Stochastic-simulation-algorithms-(SSAs)-for-stochastic-chemical-kinetics-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-simulation-algorithms-(SSAs)-for-stochastic-chemical-kinetics" title="Permalink"></a></h2><p>Let&#39;s now look at a stochastic chemical kinetics model of the repressilator, modeling it with jump processes. Here, we will construct a <a href="https://docs.sciml.ai/JumpProcesses/stable/">JumpProcesses</a> <code>JumpProblem</code> that uses Gillespie&#39;s <code>Direct</code> method, and then solve it to generate one realization of the jump process:</p><pre><code class="language-julia hljs"># imports the JumpProcesses packages
using JumpProcesses

# redefine the initial condition to be integer valued
u₀map = [:m₁ =&gt; 0, :m₂ =&gt; 0, :m₃ =&gt; 0, :P₁ =&gt; 20, :P₂ =&gt; 0, :P₃ =&gt; 0]

# next we create a discrete problem to encode that our species are integer-valued:
dprob = DiscreteProblem(rn, u₀map, tspan, pmap)

# now, we create a JumpProblem, and specify Gillespie&#39;s Direct Method as the solver:
jprob = JumpProblem(rn, dprob, Direct())

# now, let&#39;s solve and plot the jump process:
sol = solve(jprob, SSAStepper())
plot(sol)</code></pre><img src="602426d4.svg" alt="Example block output"/><p>We see that oscillations remain, but become much noisier. Note, in constructing the <code>JumpProblem</code> we could have used any of the SSAs that are part of JumpProcesses instead of the <code>Direct</code> method, see the list of SSAs (i.e., constant rate jump aggregators) in the <a href="https://docs.sciml.ai/JumpProcesses/stable/jump_types/#Jump-Aggregators-for-Exact-Simulation">documentation</a>.</p><p>Common questions that arise in using the JumpProcesses SSAs (i.e. Gillespie methods) are collated in the <a href="https://docs.sciml.ai/JumpProcesses/stable/faq/">JumpProcesses FAQ</a>.</p><hr/><h2 id="Chemical-Langevin-equation-(CLE)-stochastic-differential-equation-(SDE)-models"><a class="docs-heading-anchor" href="#Chemical-Langevin-equation-(CLE)-stochastic-differential-equation-(SDE)-models">Chemical Langevin equation (CLE) stochastic differential equation (SDE) models</a><a id="Chemical-Langevin-equation-(CLE)-stochastic-differential-equation-(SDE)-models-1"></a><a class="docs-heading-anchor-permalink" href="#Chemical-Langevin-equation-(CLE)-stochastic-differential-equation-(SDE)-models" title="Permalink"></a></h2><p>At an intermediate physical scale between macroscopic ODE models and microscopic stochastic chemical kinetics models lies the CLE, given by a system of SDEs that add to each ODE above a noise term. As the repressilator has species that get very close to zero in size, it is not a good candidate to model with the CLE (where solutions can then go negative and become unphysical). Let&#39;s create a simpler reaction network for a birth-death process that will stay non-negative:</p><pre><code class="language-julia hljs">bdp = @reaction_network begin
  c₁, X --&gt; 2X
  c₂, X --&gt; 0
  c₃, 0 --&gt; X
end
p = (:c₁ =&gt; 1.0, :c₂ =&gt; 2.0, :c₃ =&gt; 50.)
u₀ = [:X =&gt; 5.]
tspan = (0.,4.)</code></pre><p>The corresponding Chemical Langevin Equation SDE is then</p><p class="math-container">\[dX(t) = \left( c_1 X\left( t \right) - c_2 X\left( t \right) + c_3 \right) dt + \sqrt{c_1 X(t)} dW_1(t) - \sqrt{c_2 X(t)} dW_2(t) + \sqrt{c_3} dW_3(t)\]</p><p>where each <span>$W_i(t)$</span> denotes an independent Brownian Motion. We can solve the CLE model by creating an <code>SDEProblem</code> and solving it similarly to what we did for ODEs above:</p><pre><code class="language-julia hljs"># imports the StochasticDiffEq package for SDE simulations
using StochasticDiffEq

# SDEProblem for CLE
sprob = SDEProblem(bdp, u₀, tspan, p)

# solve and plot, tstops is used to specify enough points
# that the plot looks well-resolved
sol = solve(sprob, LambaEM(), tstops = range(0., step = 4e-3, length = 1001))
plot(sol)</code></pre><img src="11230d9b.svg" alt="Example block output"/><p>We again have complete freedom to select any of the StochasticDiffEq.jl SDE solvers, see the <a href="https://docs.sciml.ai/stable/modules/DiffEqDocs/solvers/sde_solve/">documentation</a>.</p><hr/><h2 id="Specifying-a-complete-model-via-the-DSL"><a class="docs-heading-anchor" href="#Specifying-a-complete-model-via-the-DSL">Specifying a complete model via the DSL</a><a id="Specifying-a-complete-model-via-the-DSL-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-a-complete-model-via-the-DSL" title="Permalink"></a></h2><p>In the previous examples we specified initial conditions and parameter values via mappings that were constructed after building our <a href="../../api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. Catalyst also supports specifying default values for these during <code>ReactionSystem</code> construction. For example, for the last SDE example we could have also built and simulated the complete model using the DSL like</p><pre><code class="language-julia hljs">bdp2 = @reaction_network begin
    @parameters c₁ = 1.0 c₂ = 2.0 c₃ = 50.0
    @species X(t) = 5.0
    c₁, X --&gt; 2X
    c₂, X --&gt; 0
    c₃, 0 --&gt; X
end
tspan = (0., 4.)
sprob2 = SDEProblem(bdp2, [], tspan)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">SDEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
timespan: (0.0, 4.0)
u0: 1-element Vector{Float64}:
 5.0</code></pre><p>Let&#39;s now simulate both models, starting from the same random number generator seed, and check we get the same solutions</p><pre><code class="language-julia hljs">using Random
Random.seed!(1)
sol = solve(sprob, LambaEM(), tstops = range(0., step = 4e-3, length = 1001))
p1 = plot(sol)
Random.seed!(1)
sol2 = solve(sprob2, LambaEM(), tstops = range(0., step = 4e-3, length = 1001))
p2 = plot(sol2)
plot(p1, p2, layout = (2,1))</code></pre><img src="0b7d9a3f.svg" alt="Example block output"/><p>For details on what information can be specified via the DSL see the <a href="../../model_creation/dsl_basics/#dsl_description">The Reaction DSL</a> tutorial.</p><hr/><h2 id="introduction_to_catalyst_ratelaws"><a class="docs-heading-anchor" href="#introduction_to_catalyst_ratelaws">Reaction rate laws used in simulations</a><a id="introduction_to_catalyst_ratelaws-1"></a><a class="docs-heading-anchor-permalink" href="#introduction_to_catalyst_ratelaws" title="Permalink"></a></h2><p>In generating mathematical models from a <a href="../../api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, reaction rates are treated as <em>microscopic</em> rates. That is, for a general mass action reaction of the form <span>$n_1 S_1 + n_2 S_2 + \dots n_M S_M \to \dots$</span> with stoichiometric substrate coefficients <span>$\{n_i\}_{i=1}^M$</span> and rate constant <span>$k$</span>, the corresponding ODE and SDE rate laws are taken to be</p><p class="math-container">\[k \prod_{i=1}^M \frac{(S_i)^{n_i}}{n_i!},\]</p><p>while the jump process transition rate (i.e., the propensity or intensity function) is</p><p class="math-container">\[k \prod_{i=1}^M \frac{S_i (S_i-1) \dots (S_i-n_i+1)}{n_i!}.\]</p><p>For example, the rate law of the reaction <span>$2X + 3Y \to Z$</span> with rate constant <span>$k$</span> would be</p><p class="math-container">\[k \frac{X^2}{2!} \frac{Y^3}{3!} \\\]</p><p>giving the ODE model</p><p class="math-container">\[\begin{align*}
\frac{dX}{dt} &amp;=  -2 k \frac{X^2}{2!} \frac{Y^3}{3!}, &amp;
\frac{dY}{dt} &amp;=  -3 k \frac{X^2}{2!} \frac{Y^3}{3!}, &amp;
\frac{dZ}{dt} &amp;= k \frac{X^2}{2!} \frac{Y^3}{3!}.
\end{align*}\]</p><p>This implicit rescaling of rate constants can be disabled through explicit conversion of a <a href="../../api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to another system via <a href="../../api/#Base.convert"><code>Base.convert</code></a> using the <code>combinatoric_ratelaws=false</code> keyword argument, i.e.</p><pre><code class="language-julia hljs">rn = @reaction_network ...
convert(ODESystem, rn; combinatoric_ratelaws=false)</code></pre><p>For the previous example using this keyword argument would give the rate law</p><p class="math-container">\[k X^2 Y^3\]</p><p>and the ODE model</p><p class="math-container">\[\begin{align*}
\frac{dX}{dt} &amp;=  -2 k X^2 Y^3, &amp;
\frac{dY}{dt} &amp;=  -3 k X^2 Y^3, &amp;
\frac{dZ}{dt} &amp;= k X^2 Y^3.
\end{align*}\]</p><p>A more detailed summary of the precise mathematical equations Catalyst can generate is available in the <a href="../math_models_intro/#math_models_in_catalyst">Mathematical Models Catalyst can Generate</a> documentation.</p><hr/><h2 id="Notes"><a class="docs-heading-anchor" href="#Notes">Notes</a><a id="Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Notes" title="Permalink"></a></h2><ol><li><p>For each of the preceding models we converted the <code>ReactionSystem</code> to, i.e., ODEs, jumps, or SDEs, we had two paths for conversion:</p><p>a. Convert to the corresponding ModelingToolkit system and then use it in     creating the corresponding problem.</p><p>b. Directly create the desired problem type from the <code>ReactionSystem</code>.</p><p>The latter is more convenient, however, the former will be more efficient if one needs to repeatedly create the associated <code>Problem</code>.</p></li><li><p>ModelingToolkit offers many options for optimizing the generated ODEs and SDEs, including options to build functions for evaluating Jacobians and/or multithreaded versions of derivative evaluation functions. See the options for <a href="https://mtk.sciml.ai/dev/systems/ODESystem/#DiffEqBase.ODEProblem"><code>ODEProblem</code>s</a> and <a href="https://mtk.sciml.ai/dev/systems/SDESystem/#DiffEqBase.SDEProblem"><code>SDEProblem</code>s</a>.</p></li></ol><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ol><li><a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1011530">Torkel E. Loman, Yingbo Ma, Vasily Ilin, Shashi Gowda, Niklas Korsbo, Nikhil Yewale, Chris Rackauckas, Samuel A. Isaacson, <em>Catalyst: Fast and flexible modeling of reaction networks</em>, PLOS Computational Biology (2023).</a></li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../catalyst_for_new_julia_users/">« Introduction to Catalyst and Julia for New Julia users</a><a class="docs-footer-nextpage" href="../math_models_intro/">Mathematical Models Catalyst can Generate »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 19 July 2024 15:27">Friday 19 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
