<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Catalyst.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/api/catalyst_api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Functionality</span><ul><li><a class="tocitem" href="../../catalyst_functionality/dsl_description/">The Reaction DSL</a></li><li><a class="tocitem" href="../../catalyst_functionality/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../catalyst_functionality/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../catalyst_functionality/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../catalyst_functionality/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../catalyst_functionality/example_networks/basic_CRN_examples/">Basic Chemical Reaction Network Examples</a></li><li><a class="tocitem" href="../../catalyst_functionality/example_networks/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../catalyst_functionality/example_networks/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Catalyst Applications</span><ul><li><a class="tocitem" href="../../catalyst_applications/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../catalyst_applications/advanced_simulations/">Advanced Simulation Options</a></li><li><a class="tocitem" href="../../catalyst_applications/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../catalyst_applications/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl</a></li><li><a class="tocitem" href="../../catalyst_applications/bifurcation_diagrams/">Bifurcation Diagrams</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using SciML/Optimization.jl and DiffEqParamEstim.jl</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Reaction-network-generation-and-representation"><span>Reaction network generation and representation</span></a></li><li><a class="tocitem" href="#api_accessor_functions"><span>ModelingToolkit and Catalyst accessor functions</span></a></li><li><a class="tocitem" href="#Basic-system-properties"><span>Basic system properties</span></a></li><li><a class="tocitem" href="#Basic-reaction-properties"><span>Basic reaction properties</span></a></li><li><a class="tocitem" href="#api_network_extension_and_modification"><span>Functions to extend or modify a network</span></a></li><li><a class="tocitem" href="#Network-analysis-and-representations"><span>Network analysis and representations</span></a></li><li><a class="tocitem" href="#Network-comparison"><span>Network comparison</span></a></li><li><a class="tocitem" href="#Network-visualization"><span>Network visualization</span></a></li><li><a class="tocitem" href="#api_rate_laws"><span>Rate laws</span></a></li><li><a class="tocitem" href="#Transformations"><span>Transformations</span></a></li><li><a class="tocitem" href="#Chemistry-related-functionalities"><span>Chemistry-related functionalities</span></a></li><li><a class="tocitem" href="#Unit-validation"><span>Unit validation</span></a></li><li><a class="tocitem" href="#Utility-functions"><span>Utility functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/api/catalyst_api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Catalyst.jl-API"><a class="docs-heading-anchor" href="#Catalyst.jl-API">Catalyst.jl API</a><a id="Catalyst.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#Catalyst.jl-API" title="Permalink"></a></h1><h2 id="Reaction-network-generation-and-representation"><a class="docs-heading-anchor" href="#Reaction-network-generation-and-representation">Reaction network generation and representation</a><a id="Reaction-network-generation-and-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Reaction-network-generation-and-representation" title="Permalink"></a></h2><p>Catalyst provides the <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro for generating a complete network, stored as a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, which in turn is composed of <a href="#Catalyst.Reaction"><code>Reaction</code></a>s. <code>ReactionSystem</code>s can be converted to other <code>ModelingToolkit.AbstractSystem</code>s, including a <code>ModelingToolkit.ODESystem</code>, <code>ModelingToolkit.SDESystem</code>, or <code>ModelingToolkit.JumpSystem</code>.</p><p>When using the <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro, Catalyst will automatically attempt to detect what is a species and what is a parameter. Everything that appear as a substrate or product in some reaction will be treated as a species, while all remaining symbols will be considered parameters (corresponding to those symbols that only appear within rate expressions and/or as stoichiometric coefficients). I.e. in</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    k*X, Y --&gt; W
end</code></pre><p><code>Y</code> and <code>W</code> will all be classified as chemical species, while <code>k</code> and <code>X</code> will be classified as parameters.</p><p>The <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> generated by the <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro is a <code>ModelingToolkit.AbstractSystem</code> that symbolically represents a system of chemical reactions. In some cases it can be convenient to bypass the macro and directly generate a collection of symbolic <a href="#Catalyst.Reaction"><code>Reaction</code></a>s and a corresponding <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> encapsulating them. Below we illustrate with a simple SIR example how a system can be directly constructed, and demonstrate how to then generate from the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and solve corresponding chemical reaction ODE models, chemical Langevin equation SDE models, and stochastic chemical kinetics jump process models.</p><pre><code class="language- hljs">using Catalyst, DifferentialEquations, Plots
t = default_t()
@parameters β γ
@species S(t) I(t) R(t)

rxs = [Reaction(β, [S,I], [I], [1,1], [2])
       Reaction(γ, [I], [R])]
@named rs = ReactionSystem(rxs, t)

u₀map    = [S =&gt; 999.0, I =&gt; 1.0, R =&gt; 0.0]
parammap = [β =&gt; 1/10000, γ =&gt; 0.01]
tspan    = (0.0, 250.0)

# solve as ODEs
odesys = convert(ODESystem, rs)
oprob = ODEProblem(odesys, u₀map, tspan, parammap)
sol = solve(oprob, Tsit5())
p1 = plot(sol, title = &quot;ODE&quot;)

# solve as SDEs
sdesys = convert(SDESystem, rs)
sprob = SDEProblem(sdesys, u₀map, tspan, parammap)
sol = solve(sprob, EM(), dt=.01)
p2 = plot(sol, title = &quot;SDE&quot;)

# solve as jump process
jumpsys = convert(JumpSystem, rs)
u₀map    = [S =&gt; 999, I =&gt; 1, R =&gt; 0]
dprob = DiscreteProblem(jumpsys, u₀map, tspan, parammap)
jprob = JumpProblem(jumpsys, dprob, Direct())
sol = solve(jprob, SSAStepper())
p3 = plot(sol, title = &quot;jump&quot;)

plot(p1, p2, p3; layout = (3,1))</code></pre><article class="docstring"><header><a class="docstring-binding" id="Catalyst.@reaction_network" href="#Catalyst.@reaction_network"><code>Catalyst.@reaction_network</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@reaction_network</code></pre><p>Generates a <a href="../../catalyst_functionality/dsl_description/#dsl_description"><code>ReactionSystem</code></a> that encodes a chemical reaction network.</p><p>See <a href="../../catalyst_functionality/dsl_description/#dsl_description">The Reaction DSL</a> documentation for details on parameters to the macro.</p><p>Examples:</p><pre><code class="language-julia hljs"># a basic SIR model, with name SIR
sir_model = @reaction_network SIR begin
    c1, s + i --&gt; 2i
    c2, i --&gt; r
end

# a basic SIR model, with random generated name
sir_model = @reaction_network begin
    c1, s + i --&gt; 2i
    c2, i --&gt; r
end

# an empty network with name empty
emptyrn = @reaction_network empty

# an empty network with random generated name
emptyrn = @reaction_network</code></pre><p>ReactionSystems generated through <code>@reaction_network</code> are complete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reaction_network.jl#L119-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.make_empty_network" href="#Catalyst.make_empty_network"><code>Catalyst.make_empty_network</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_empty_network(; iv=DEFAULT_IV, name=gensym(:ReactionSystem))</code></pre><p>Construct an empty <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. <code>iv</code> is the independent variable, usually time, and <code>name</code> is the name to give the <code>ReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1385-L1390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.@reaction" href="#Catalyst.@reaction"><code>Catalyst.@reaction</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@reaction</code></pre><p>Generates a single <a href="#Catalyst.Reaction"><code>Reaction</code></a> object.</p><p>Examples:</p><pre><code class="language-julia hljs">rx = @reaction k*v, A + B --&gt; C + D

# is equivalent to
t = default_t()
@parameters k v
@species A(t) B(t) C(t) D(t)
rx == Reaction(k*v, [A,B], [C,D])</code></pre><p>Here <code>k</code> and <code>v</code> will be parameters and <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code> will be variables. Interpolation of existing parameters/variables also works</p><pre><code class="language-julia hljs">t = default_t()
@parameters k b
@species A(t)
ex = k*A^2 + t
rx = @reaction b*$ex*$A, $A --&gt; C</code></pre><p>Notes:</p><ul><li>Any symbols arising in the rate expression that aren&#39;t interpolated are treated as parameters. In the reaction part (<code>α*A + B --&gt; C + D</code>), coefficients are treated as parameters, e.g. <code>α</code>, and rightmost symbols as species, e.g. <code>A,B,C,D</code>.</li><li>Works with any <em>single</em> arrow types supported by <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a>.</li><li>Interpolation of Julia variables into the macro works similar to the <code>@reaction_network</code> macro. See <a href="../../catalyst_functionality/dsl_description/#dsl_description">The Reaction DSL</a> tutorial for more details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reaction_network.jl#L217-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.Reaction" href="#Catalyst.Reaction"><code>Catalyst.Reaction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Reaction{S, T}</code></pre><p>One chemical reaction.</p><p><strong>Fields</strong></p><ul><li><p><code>rate</code>: The rate function (excluding mass action terms).</p></li><li><p><code>substrates</code>: Reaction substrates.</p></li><li><p><code>products</code>: Reaction products.</p></li><li><p><code>substoich</code>: The stoichiometric coefficients of the reactants.</p></li><li><p><code>prodstoich</code>: The stoichiometric coefficients of the products.</p></li><li><p><code>netstoich</code>: The net stoichiometric coefficients of all species changed by the reaction.</p></li><li><p><code>only_use_rate</code>: <code>false</code> (default) if <code>rate</code> should be multiplied by mass action terms to give the rate law. <code>true</code> if <code>rate</code> represents the full reaction rate law.</p></li></ul><ul><li><code>metadata</code>: Contain additional data, such whenever the reaction have a specific noise-scaling expression for the chemical Langevin equation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Catalyst
t = default_t()
@parameters k[1:20]
@species A(t) B(t) C(t) D(t)
rxs = [Reaction(k[1], nothing, [A]),            # 0 -&gt; A
       Reaction(k[2], [B], nothing),            # B -&gt; 0
       Reaction(k[3],[A],[C]),                  # A -&gt; C
       Reaction(k[4], [C], [A,B]),              # C -&gt; A + B
       Reaction(k[5], [C], [A], [1], [2]),      # C -&gt; A + A
       Reaction(k[6], [A,B], [C]),              # A + B -&gt; C
       Reaction(k[7], [B], [A], [2], [1]),      # 2B -&gt; A
       Reaction(k[8], [A,B], [A,C]),            # A + B -&gt; A + C
       Reaction(k[9], [A,B], [C,D]),            # A + B -&gt; C + D
       Reaction(k[10], [A], [C,D], [2], [1,1]), # 2A -&gt; C + D
       Reaction(k[11], [A], [A,B], [2], [1,1]), # 2A -&gt; A + B
       Reaction(k[12], [A,B,C], [C,D], [1,3,4], [2, 3]),          # A+3B+4C -&gt; 2C + 3D
       Reaction(k[13], [A,B], nothing, [3,1], nothing),           # 3A+B -&gt; 0
       Reaction(k[14], nothing, [A], nothing, [2]),               # 0 -&gt; 2A
       Reaction(k[15]*A/(2+A), [A], nothing; only_use_rate=true), # A -&gt; 0 with custom rate
       Reaction(k[16], [A], [B]; only_use_rate=true),             # A -&gt; B with custom rate.
       Reaction(k[17]*A*exp(B), [C], [D], [2], [1]),              # 2C -&gt; D with non constant rate.
       Reaction(k[18]*B, nothing, [B], nothing, [2]),             # 0 -&gt; 2B with non constant rate.
       Reaction(k[19]*t, [A], [B]),                                # A -&gt; B with non constant rate.
       Reaction(k[20]*t*A, [B,C], [D],[2,1],[2])                  # 2A +B -&gt; 2C with non constant rate.
  ]</code></pre><p>Notes:</p><ul><li><code>nothing</code> can be used to indicate a reaction that has no reactants or no products. In this case the corresponding stoichiometry vector should also be set to <code>nothing</code>.</li><li>The three-argument form assumes all reactant and product stoichiometric coefficients are one.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.ReactionSystem" href="#Catalyst.ReactionSystem"><code>Catalyst.ReactionSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReactionSystem{V&lt;:Catalyst.NetworkProperties} &lt;: AbstractTimeDependentSystem</code></pre><p>A system of chemical reactions.</p><p><strong>Fields</strong></p><ul><li><p><code>eqs</code>: The equations (reactions and algebraic/differential) defining the system.</p></li><li><p><code>rxs</code>: The Reactions defining the system.</p></li><li><p><code>iv</code>: Independent variable (usually time).</p></li><li><p><code>sivs</code>: Spatial independent variables</p></li><li><p><code>unknowns</code>: All dependent (unknown) variables, species and non-species. Must not contain the independent variable.</p></li><li><p><code>species</code>: Dependent unknown variables representing species</p></li><li><p><code>ps</code>: Parameter variables. Must not contain the independent variable.</p></li><li><p><code>var_to_name</code>: Maps Symbol to corresponding variable.</p></li><li><p><code>observed</code>: Equations for observed variables.</p></li><li><p><code>name</code>: The name of the system</p></li><li><p><code>systems</code>: Internal sub-systems</p></li><li><p><code>defaults</code>: The default values to use when initial conditions and/or parameters are not supplied in <code>ODEProblem</code>.</p></li></ul><ul><li><p><code>connection_type</code>: Type of the system</p></li><li><p><code>networkproperties</code>: <code>NetworkProperties</code> object that can be filled in by API functions. INTERNAL – not considered part of the public API.</p></li><li><p><code>combinatoric_ratelaws</code>: Sets whether to use combinatoric scalings in rate laws. true by default.</p></li><li><p><code>continuous_events</code>: continuous_events: A <code>Vector{SymbolicContinuousCallback}</code> that model events. The integrator will use root finding to guarantee that it steps at each zero crossing.</p></li></ul><ul><li><code>discrete_events</code>: discrete_events: A <code>Vector{SymbolicDiscreteCallback}</code> that models events. Symbolic analog to <code>SciMLBase.DiscreteCallback</code> that executes an affect when a given condition is true at the end of an integration step.</li></ul><ul><li><code>metadata</code>: Metadata for the system, to be used by downstream packages.</li></ul><ul><li><code>complete</code>: complete: if a model <code>sys</code> is complete, then <code>sys.x</code> no longer performs namespacing.</li></ul><p><strong>Example</strong></p><p>Continuing from the example in the <a href="#Catalyst.Reaction"><code>Reaction</code></a> definition:</p><pre><code class="language-julia hljs"># simple constructor that infers species and parameters
@named rs = ReactionSystem(rxs, t)

# allows specification of species and parameters
@named rs = ReactionSystem(rxs, t, [A,B,C,D], k)</code></pre><p>Keyword Arguments:</p><ul><li><code>observed::Vector{Equation}</code>, equations specifying observed variables.</li><li><code>systems::Vector{AbstractSystems}</code>, vector of sub-systems. Can be <code>ReactionSystem</code>s, <code>ODESystem</code>s, or <code>NonlinearSystem</code>s.</li><li><code>name::Symbol</code>, the name of the system (must be provided, or <code>@named</code> must be used).</li><li><code>defaults::Dict</code>, a dictionary mapping parameters to their default values and species to their default initial values.</li><li><code>checks = true</code>, boolean for whether to check units.</li><li><code>networkproperties = NetworkProperties()</code>, cache for network properties calculated via API functions.</li><li><code>combinatoric_ratelaws = true</code>, sets the default value of <code>combinatoric_ratelaws</code> used in calls to <code>convert</code> or calling various problem types with the <code>ReactionSystem</code>.</li><li><code>balanced_bc_check = true</code>, sets whether to check that BC species appearing in reactions are balanced (i.e appear as both a substrate and a product with the same stoichiometry).</li></ul><p>Notes:</p><ul><li>ReactionSystems currently do rudimentary unit checking, requiring that all species have the same units, and all reactions have rate laws with units of (species units) / (time units). Unit checking can be disabled by passing the keyword argument <code>checks=false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L449">source</a></section></article><h2 id="api_accessor_functions"><a class="docs-heading-anchor" href="#api_accessor_functions">ModelingToolkit and Catalyst accessor functions</a><a id="api_accessor_functions-1"></a><a class="docs-heading-anchor-permalink" href="#api_accessor_functions" title="Permalink"></a></h2><p>A <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> is an instance of a <code>ModelingToolkit.AbstractTimeDependentSystem</code>, and has a number of fields that can be accessed using the Catalyst API and the <a href="https://docs.sciml.ai/ModelingToolkit/stable/basics/AbstractSystem/">ModelingToolkit.jl Abstract System Interface</a>. Below we overview these components.</p><p>There are three basic sets of convenience accessors that will return information either from a top-level system, the top-level system and all sub-systems that are also <code>ReactionSystem</code>s (i.e. the full reaction-network), or the top-level system, all subs-systems, and all constraint systems (i.e. the full model). To retrieve info from just a base <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> <code>rn</code>, ignoring sub-systems of <code>rn</code>, one can use the ModelingToolkit accessors (these provide direct access to the corresponding internal fields of the <code>ReactionSystem</code>)</p><ul><li><code>ModelingToolkit.get_unknowns(rn)</code> is a vector that collects all the species defined within <code>rn</code>, ordered by species and then non-species variables.</li><li><code>Catalyst.get_species(rn)</code> is a vector of all the species variables in the system. The entries in <code>get_species(rn)</code> correspond to the first <code>length(get_species(rn))</code> components in <code>get_unknowns(rn)</code>.</li><li><code>ModelingToolkit.get_ps(rn)</code> is a vector that collects all the parameters defined <em>within</em> reactions in <code>rn</code>.</li><li><code>ModelingToolkit.get_eqs(rn)</code> is a vector that collects all the <a href="#Catalyst.Reaction"><code>Reaction</code></a>s and <code>Symbolics.Equation</code> defined within <code>rn</code>, ordering all <code>Reaction</code>s before <code>Equation</code>s.</li><li><code>Catalyst.get_rxs(rn)</code> is a vector of all the <a href="#Catalyst.Reaction"><code>Reaction</code></a>s in <code>rn</code>, and corresponds to the first <code>length(get_rxs(rn))</code> entries in <code>get_eqs(rn)</code>.</li><li><code>ModelingToolkit.get_iv(rn)</code> is the independent variable used in the system (usually <code>t</code> to represent time).</li><li><code>ModelingToolkit.get_systems(rn)</code> is a vector of all sub-systems of <code>rn</code>.</li><li><code>ModelingToolkit.get_defaults(rn)</code> is a dictionary of all the default values for parameters and species in <code>rn</code>.</li></ul><p>The preceding accessors do not allocate, directly accessing internal fields of the <code>ReactionSystem</code>.</p><p>To retrieve information from the full reaction network represented by a system <code>rn</code>, which corresponds to information within both <code>rn</code> and all sub-systems, one can call:</p><ul><li><code>ModelingToolkit.unknowns(rn)</code> returns all species <em>and variables</em> across the system, <em>all sub-systems</em>, and all constraint systems. Species are ordered before non-species variables in <code>unknowns(rn)</code>, with the first <code>numspecies(rn)</code> entires in <code>unknowns(rn)</code> being the same as <code>species(rn)</code>.</li><li><a href="#Catalyst.species"><code>species(rn)</code></a> is a vector collecting all the chemical species within the system and any sub-systems that are also <code>ReactionSystems</code>.</li><li><code>ModelingToolkit.parameters(rn)</code> returns all parameters across the system, <em>all sub-systems</em>, and all constraint systems.</li><li><a href="#Catalyst.reactionparams"><code>reactionparams(rn)</code></a> is a vector of all the parameters within the system and any sub-systems that are also <code>ReactionSystem</code>s. These include all parameters that appear within some <code>Reaction</code>.</li><li><code>ModelingToolkit.equations(rn)</code> returns all <a href="#Catalyst.Reaction"><code>Reaction</code></a>s and all <code>Symbolics.Equations</code> defined across the system, <em>all sub-systems</em>, and all constraint systems. <code>Reaction</code>s are ordered ahead of <code>Equation</code>s with the first <code>numreactions(rn)</code> entries in <code>equations(rn)</code> being the same as <code>reactions(rn)</code>.</li><li><a href="#Catalyst.reactions"><code>reactions(rn)</code></a> is a vector of all the <code>Reaction</code>s within the system and any sub-systems that are also <code>ReactionSystem</code>s.</li></ul><p>These accessors will generally allocate new arrays to store their output unless there are no subsystems. In the latter case the usually return the same vector as the corresponding <code>get_*</code> function.</p><p>Below we list the remainder of the Catalyst API accessor functions mentioned above.</p><h2 id="Basic-system-properties"><a class="docs-heading-anchor" href="#Basic-system-properties">Basic system properties</a><a id="Basic-system-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-system-properties" title="Permalink"></a></h2><p>See <a href="../../catalyst_functionality/programmatic_CRN_construction/#programmatic_CRN_construction">Programmatic Construction of Symbolic Reaction Systems</a> for examples and <a href="#api_accessor_functions">ModelingToolkit and Catalyst Accessor Functions</a> for more details on the basic accessor functions.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.species" href="#Catalyst.species"><code>Catalyst.species</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">species(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of all species defined in the system and any subsystems that are of type <code>ReactionSystem</code>. To get the species and non-species variables in the system and all subsystems, including non-<code>ReactionSystem</code> subsystems, uses <code>unknowns(network)</code>.</p><p>Notes:</p><ul><li>If <code>ModelingToolkit.get_systems(network)</code> is non-empty will allocate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.nonspecies" href="#Catalyst.nonspecies"><code>Catalyst.nonspecies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nonspecies(network)</code></pre><p>Return the non-species variables within the network, i.e. those unknowns for which <code>isspecies == false</code>.</p><p>Notes:</p><ul><li>Allocates a new array to store the non-species variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L35-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactionparams" href="#Catalyst.reactionparams"><code>Catalyst.reactionparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactionparams(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of all parameters defined within the system and any subsystems that are of type <code>ReactionSystem</code>. To get the parameters in the system and all subsystems, including non-<code>ReactionSystem</code> subsystems, use <code>parameters(network)</code>.</p><p>Notes:</p><ul><li>Allocates and has to calculate these dynamically by comparison for each reaction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L48-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactions" href="#Catalyst.reactions"><code>Catalyst.reactions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactions(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of all <code>Reactions</code> in the system.</p><p>Notes:</p><ul><li>If <code>ModelingToolkit.get_systems(network)</code> is not empty, will allocate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L85-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.numspecies" href="#Catalyst.numspecies"><code>Catalyst.numspecies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numspecies(network)</code></pre><p>Return the total number of species within the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and subsystems that are <code>ReactionSystem</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.numparams" href="#Catalyst.numparams"><code>Catalyst.numparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numparams(network)</code></pre><p>Return the total number of parameters within the given system and all subsystems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.numreactions" href="#Catalyst.numreactions"><code>Catalyst.numreactions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numreactions(network)</code></pre><p>Return the total number of reactions within the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and subsystems that are <code>ReactionSystem</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L149-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.numreactionparams" href="#Catalyst.numreactionparams"><code>Catalyst.numreactionparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numreactionparams(network)</code></pre><p>Return the total number of parameters within the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and subsystems that are <code>ReactionSystem</code>s.</p><p>Notes</p><ul><li>If there are no subsystems this will be fast.</li><li>As this calls <a href="#Catalyst.reactionparams"><code>reactionparams</code></a>, it can be slow and will allocate if there are any subsystems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L163-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.speciesmap" href="#Catalyst.speciesmap"><code>Catalyst.speciesmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">speciesmap(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a Dictionary mapping species that participate in <code>Reaction</code>s to their index within <a href="#Catalyst.species"><code>species(network)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L100-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.paramsmap" href="#Catalyst.paramsmap"><code>Catalyst.paramsmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">paramsmap(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a Dictionary mapping from all parameters that appear within the system to their index within <code>parameters(network)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L114-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactionparamsmap" href="#Catalyst.reactionparamsmap"><code>Catalyst.reactionparamsmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactionparamsmap(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a Dictionary mapping from parameters that appear within <code>Reaction</code>s to their index within <a href="#Catalyst.reactionparams"><code>reactionparams(network)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L125-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isspecies" href="#Catalyst.isspecies"><code>Catalyst.isspecies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isspecies(s)</code></pre><p>Tests if the given symbolic variable corresponds to a chemical species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isconstant" href="#Catalyst.isconstant"><code>Catalyst.isconstant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Catalyst.isconstant(s)</code></pre><p>Tests if the given symbolic variable corresponds to a constant species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isbc" href="#Catalyst.isbc"><code>Catalyst.isbc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Catalyst.isbc(s)</code></pre><p>Tests if the given symbolic variable corresponds to a boundary condition species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L19-L23">source</a></section></article><h2 id="Basic-reaction-properties"><a class="docs-heading-anchor" href="#Basic-reaction-properties">Basic reaction properties</a><a id="Basic-reaction-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-reaction-properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catalyst.ismassaction" href="#Catalyst.ismassaction"><code>Catalyst.ismassaction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ismassaction(rx, rs; rxvars = get_variables(rx.rate),
                              haveivdep = nothing,
                              unknownset = Set(unknowns(rs)),
                              ivset = nothing)</code></pre><p>True if a given reaction is of mass action form, i.e. <code>rx.rate</code> does not depend on any chemical species that correspond to unknowns of the system, and does not depend explicitly on the independent variable (usually time).</p><p><strong>Arguments</strong></p><ul><li><code>rx</code>, the <a href="#Catalyst.Reaction"><code>Reaction</code></a>.</li><li><code>rs</code>, a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> containing the reaction.</li><li>Optional: <code>rxvars</code>, <code>Variable</code>s which are not in <code>rxvars</code> are ignored as possible dependencies.</li><li>Optional: <code>haveivdep</code>, <code>true</code> if the <a href="#Catalyst.Reaction"><code>Reaction</code></a> <code>rate</code> field explicitly depends on any independent variable (i.e. t or for spatial systems x,y,etc). If not set, will be automatically calculated.</li><li>Optional: <code>unknownset</code>, set of unknowns which if the rxvars are within mean rx is non-mass action.</li><li>Optional: <code>ivset</code>, a <code>Set</code> of the independent variables of the system. If not provided and the system is spatial, i.e. <code>isspatial(rs) == true</code>, it will be created with all the spatial variables and the time variable. If the rate expression contains any element of <code>ivset</code>, then <code>ismassaction(rx,rs) == false</code>. Pass a custom set to control this behavior.</li></ul><p>Notes:</p><ul><li>Non-integer stoichiometry is treated as non-mass action. This includes symbolic variables/terms or floating point numbers for stoichiometric coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L1232-L1263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.dependents" href="#Catalyst.dependents"><code>Catalyst.dependents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dependents(rx, network)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a> and a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of the <em>non-constant</em> species and variables the reaction rate law depends on. e.g., for</p><p><code>k*W, 2X + 3Y --&gt; 5Z + W</code></p><p>the returned vector would be <code>[W(t),X(t),Y(t)]</code>.</p><p>Notes:</p><ul><li>Allocates</li><li>Does not check for dependents within any subsystems.</li><li>Constant species are not considered dependents since they are internally treated as parameters.</li><li>If the rate expression depends on a non-species unknown variable that will be included in the dependents, i.e. in<pre><code class="language-julia hljs">t = default_t()
@parameters k
@variables V(t)
@species A(t) B(t) C(t)
rx = Reaction(k*V, [A, B], [C])
@named rs = ReactionSystem([rx], t)
issetequal(dependents(rx, rs), [A,B,V]) == true</code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L178-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.dependants" href="#Catalyst.dependants"><code>Catalyst.dependants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dependents(rx, network)</code></pre><p>See documentation for <a href="#Catalyst.dependents"><code>dependents</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L214-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.substoichmat" href="#Catalyst.substoichmat"><code>Catalyst.substoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">substoichmat(rn; sparse=false)</code></pre><p>Returns the substrate stoichiometry matrix, <span>$S$</span>, with <span>$S_{i j}$</span> the stoichiometric coefficient of the ith substrate within the jth reaction.</p><p>Note:</p><ul><li>Set sparse=true for a sparse matrix representation</li><li>Note that constant species are not considered substrates, but just components that modify the associated rate law.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L233-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.prodstoichmat" href="#Catalyst.prodstoichmat"><code>Catalyst.prodstoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prodstoichmat(rn; sparse=false)</code></pre><p>Returns the product stoichiometry matrix, <span>$P$</span>, with <span>$P_{i j}$</span> the stoichiometric coefficient of the ith product within the jth reaction.</p><p>Note:</p><ul><li>Set sparse=true for a sparse matrix representation</li><li>Note that constant species are not treated as products, but just components that modify the associated rate law.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L281-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.netstoichmat" href="#Catalyst.netstoichmat"><code>Catalyst.netstoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">netstoichmat(rn, sparse=false)</code></pre><p>Returns the net stoichiometry matrix, <span>$N$</span>, with <span>$N_{i j}$</span> the net stoichiometric coefficient of the ith species within the jth reaction.</p><p>Notes:</p><ul><li>Set sparse=true for a sparse matrix representation</li><li>Caches the matrix internally within <code>rn</code> so subsequent calls are fast.</li><li>Note that constant species are not treated as reactants, but just components that modify the associated rate law. As such they do not contribute to the net stoichiometry matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L331-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactionrates" href="#Catalyst.reactionrates"><code>Catalyst.reactionrates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactionrates(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, returns a vector of the symbolic reaction rates for each reaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L223-L228">source</a></section></article><h2 id="api_network_extension_and_modification"><a class="docs-heading-anchor" href="#api_network_extension_and_modification">Functions to extend or modify a network</a><a id="api_network_extension_and_modification-1"></a><a class="docs-heading-anchor-permalink" href="#api_network_extension_and_modification" title="Permalink"></a></h2><p><code>ReactionSystem</code>s can be programmatically extended using <a href="#Catalyst.@add_reactions"><code>@add_reactions</code></a>, <a href="#Catalyst.addspecies!"><code>addspecies!</code></a>, <a href="#Catalyst.addparam!"><code>addparam!</code></a> and <a href="#Catalyst.addreaction!"><code>addreaction!</code></a>, or using <a href="#ModelingToolkit.extend"><code>ModelingToolkit.extend</code></a> and <a href="#ModelingToolkit.compose"><code>ModelingToolkit.compose</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.@add_reactions" href="#Catalyst.@add_reactions"><code>Catalyst.@add_reactions</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@add_reactions</code></pre><p>Adds the reactions declared to a preexisting <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. Note, mutates the original network.</p><p>Notes:</p><ul><li>To instead generate a new network by combining two existing networks use <code>ModelingToolkit.extend</code>.</li></ul><p>Example:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    @parameters G
    π, 2*A --&gt; B
    end

# add this reaction into rn
@add_reactions rn begin
    k*A, C --&gt; D
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reaction_network.jl#L254-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.addspecies!" href="#Catalyst.addspecies!"><code>Catalyst.addspecies!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addspecies!(network::ReactionSystem, s::Symbolic; disablechecks=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, add the species corresponding to the variable <code>s</code> to the network (if it is not already defined). Returns the integer id of the species within the system.</p><p>Notes:</p><ul><li><code>disablechecks</code> will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. <em>Do not disable checks</em> unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1395-L1407">source</a></section><section><div><pre><code class="nohighlight hljs">addspecies!(network::ReactionSystem, s::Num; disablechecks=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, add the species corresponding to the variable <code>s</code> to the network (if it is not already defined). Returns the integer id of the species within the system.</p><ul><li><code>disablechecks</code> will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. <em>Do not disable checks</em> unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1428-L1439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.addparam!" href="#Catalyst.addparam!"><code>Catalyst.addparam!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addparam!(network::ReactionSystem, p::Symbolic; disablechecks=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, add the parameter corresponding to the variable <code>p</code> to the network (if it is not already defined). Returns the integer id of the parameter within the system.</p><ul><li><code>disablechecks</code> will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. <em>Do not disable checks</em> unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1444-L1455">source</a></section><section><div><pre><code class="nohighlight hljs">addparam!(network::ReactionSystem, p::Num; disablechecks=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, add the parameter corresponding to the variable <code>p</code> to the network (if it is not already defined). Returns the integer id of the parameter within the system.</p><ul><li><code>disablechecks</code> will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. <em>Do not disable checks</em> unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1473-L1484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.addreaction!" href="#Catalyst.addreaction!"><code>Catalyst.addreaction!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addreaction!(network::ReactionSystem, rx::Reaction)</code></pre><p>Add the passed in reaction to the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. Returns the integer id of <code>rx</code> in the list of <code>Reaction</code>s within <code>network</code>.</p><p>Notes:</p><ul><li>Any new species or parameters used in <code>rx</code> should be separately added to   <code>network</code> using <a href="#Catalyst.addspecies!"><code>addspecies!</code></a> and <a href="#Catalyst.addparam!"><code>addparam!</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1489-L1498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.setdefaults!" href="#Catalyst.setdefaults!"><code>Catalyst.setdefaults!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setdefaults!(rn, newdefs)</code></pre><p>Sets the default (initial) values of parameters and species in the <code>ReactionSystem</code>, <code>rn</code>.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
setdefaults!(sir, [:S =&gt; 999.0, :I =&gt; 1.0, :R =&gt; 1.0, :β =&gt; 1e-4, :ν =&gt; .01])

# or
t = default_t()
@parameter β ν
@species S(t) I(t) R(t)
setdefaults!(sir, [S =&gt; 999.0, I =&gt; 1.0, R =&gt; 0.0, β =&gt; 1e-4, ν =&gt; .01])</code></pre><p>gives initial/default values to each of <code>S</code>, <code>I</code> and <code>β</code></p><p>Notes:</p><ul><li>Can not be used to set default values for species, variables or parameters of subsystems or constraint systems. Either set defaults for those systems directly, or <a href="#ModelingToolkit.flatten"><code>flatten</code></a> to collate them into one system before setting defaults.</li><li>Defaults can be specified in any iterable container of symbols to value pairs or symbolics to value pairs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L426-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.extend" href="#ModelingToolkit.extend"><code>ModelingToolkit.extend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extend(
    sys::ModelingToolkit.AbstractSystem,
    basesys::ModelingToolkit.AbstractSystem;
    name,
    gui_metadata
) -&gt; ReactionSystem{Catalyst.NetworkProperties{Int64, V}} where V&lt;:SymbolicUtils.BasicSymbolic{Real}
</code></pre><p>extend the <code>basesys</code> with <code>sys</code>, the resulting system would inherit <code>sys</code>&#39;s name by default.</p></div></section><section><div><pre><code class="nohighlight hljs">ModelingToolkit.extend(sys::AbstractSystem, rs::ReactionSystem; name::Symbol=nameof(sys))</code></pre><p>Extends the indicated <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> with another <code>AbstractSystem</code>.</p><p>Notes:</p><ul><li>The <code>AbstractSystem</code> being added in must be an <code>ODESystem</code>, <code>NonlinearSystem</code>, or <code>ReactionSystem</code> currently.</li><li>Returns a new <code>ReactionSystem</code> and does not modify <code>rs</code>.</li><li>By default, the new <code>ReactionSystem</code> will have the same name as <code>sys</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L1829-L1839">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.compose" href="#ModelingToolkit.compose"><code>ModelingToolkit.compose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compose(sys, systems; name)
</code></pre><p>compose multiple systems together. The resulting system would inherit the first system&#39;s name.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.flatten" href="#ModelingToolkit.flatten"><code>ModelingToolkit.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Catalyst.flatten(rs::ReactionSystem)</code></pre><p>Merges all subsystems of the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> up into <code>rs</code>.</p><p>Notes:</p><ul><li>Returns a new <code>ReactionSystem</code> that represents the flattened system.</li><li>All <code>Reaction</code>s within subsystems are namespaced and merged into the list of <code>Reactions</code> of <code>rs</code>. The merged list is then available as <code>reactions(rs)</code>.</li><li>All algebraic and differential equations are merged in the equations of <code>rs</code>.</li><li>Currently only <code>ReactionSystem</code>s, <code>NonlinearSystem</code>s and <code>ODESystem</code>s are supported as sub-systems when flattening.</li><li><code>rs.networkproperties</code> is reset upon flattening.</li><li>The default value of <code>combinatoric_ratelaws</code> will be the logical or of all <code>ReactionSystem</code>s.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L1792-L1807">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge!-Tuple{ReactionSystem, ReactionSystem}" href="#Base.merge!-Tuple{ReactionSystem, ReactionSystem}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge!(network1::ReactionSystem, network2::ReactionSystem)</code></pre><p>Merge <code>network2</code> into <code>network1</code>.</p><p>Notes:</p><ul><li>Duplicate reactions between the two networks are not filtered out.</li><li><a href="#Catalyst.Reaction"><code>Reaction</code></a>s are not deepcopied to minimize allocations, so both networks will share underlying data arrays.</li><li>Subsystems are not deepcopied between the two networks and will hence be shared.</li><li>Returns <code>network1</code>.</li><li><code>combinatoric_ratelaws</code> is the value of <code>network1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1507-L1520">source</a></section></article><h2 id="Network-analysis-and-representations"><a class="docs-heading-anchor" href="#Network-analysis-and-representations">Network analysis and representations</a><a id="Network-analysis-and-representations-1"></a><a class="docs-heading-anchor-permalink" href="#Network-analysis-and-representations" title="Permalink"></a></h2><p>Note, currently API functions for network analysis and conservation law analysis do not work with constant species (currently only generated by SBMLToolkit).</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.conservationlaws" href="#Catalyst.conservationlaws"><code>Catalyst.conservationlaws</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservationlaws(netstoichmat::AbstractMatrix)::Matrix</code></pre><p>Given the net stoichiometry matrix of a reaction system, computes a matrix of conservation laws, each represented as a row in the output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1194-L1199">source</a></section><section><div><pre><code class="nohighlight hljs">conservationlaws(rs::ReactionSystem)</code></pre><p>Return the conservation law matrix of the given <code>ReactionSystem</code>, calculating it if it is not already stored within the system, or returning an alias to it.</p><p>Notes:</p><ul><li>The first time being called it is calculated and cached in <code>rn</code>, subsequent calls should be fast.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1255-L1264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.conservedquantities" href="#Catalyst.conservedquantities"><code>Catalyst.conservedquantities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservedquantities(state, cons_laws)</code></pre><p>Compute conserved quantities for a system with the given conservation laws.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1274-L1278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.conservedequations" href="#Catalyst.conservedequations"><code>Catalyst.conservedequations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservedequations(rn::ReactionSystem)</code></pre><p>Calculate symbolic equations from conservation laws, writing dependent variables as functions of independent variables and the conservation law constants.</p><p>Notes:</p><ul><li>Caches the resulting equations in <code>rn</code>, so will be fast on subsequent calls.</li></ul><p>Examples:</p><pre><code class="language- hljs">rn = @reaction_network begin
    k, A + B --&gt; C
    k2, C --&gt; A + B
    end
conservedequations(rn)</code></pre><p>gives</p><pre><code class="nohighlight hljs">2-element Vector{Equation}:
 B(t) ~ A(t) + Γ[1]
 C(t) ~ Γ[2] - A(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1134-L1157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.conservationlaw_constants" href="#Catalyst.conservationlaw_constants"><code>Catalyst.conservationlaw_constants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservationlaw_constants(rn::ReactionSystem)</code></pre><p>Calculate symbolic equations from conservation laws, writing the conservation law constants in terms of the dependent and independent variables.</p><p>Notes:</p><ul><li>Caches the resulting equations in <code>rn</code>, so will be fast on subsequent calls.</li></ul><p>Examples:</p><pre><code class="language- hljs">rn = @reaction_network begin
    k, A + B --&gt; C
    k2, C --&gt; A + B
    end
conservationlaw_constants(rn)</code></pre><p>gives</p><pre><code class="nohighlight hljs">2-element Vector{Equation}:
 Γ[1] ~ B(t) - A(t)
 Γ[2] ~ A(t) + C(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1164-L1187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.ReactionComplexElement" href="#Catalyst.ReactionComplexElement"><code>Catalyst.ReactionComplexElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReactionComplexElement{T}</code></pre><p>One reaction complex element</p><p><strong>Fields</strong></p><ul><li><p><code>speciesid</code>: The integer id of the species representing this element.</p></li><li><p><code>speciesstoich</code>: The stoichiometric coefficient of this species.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.ReactionComplex" href="#Catalyst.ReactionComplex"><code>Catalyst.ReactionComplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReactionComplex{V&lt;:Integer} &lt;: AbstractArray{Catalyst.ReactionComplexElement{V&lt;:Integer}, 1}</code></pre><p>One reaction complex.</p><p><strong>Fields</strong></p><ul><li><p><code>speciesids</code>: The integer ids of all species participating in this complex.</p></li><li><p><code>speciesstoichs</code>: The stoichiometric coefficients of all species participating in this complex.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactioncomplexmap" href="#Catalyst.reactioncomplexmap"><code>Catalyst.reactioncomplexmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactioncomplexmap(rn::ReactionSystem)</code></pre><p>Find each <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a> within the specified system, constructing a mapping from the complex to vectors that indicate which reactions it appears in as substrates and products.</p><p>Notes:</p><ul><li>Each <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a> is mapped to a vector of pairs, with each pair having the form <code>reactionidx =&gt; ± 1</code>, where <code>-1</code> indicates the complex appears as a substrate and <code>+1</code> as a product in the reaction with integer label <code>reactionidx</code>.</li><li>Constant species are ignored as part of a complex. i.e. if species <code>A</code> is constant then the reaction <code>A + B --&gt; C + D</code> is considered to consist of the complexes <code>B</code> and <code>C + D</code>. Likewise <code>A --&gt; B</code> would be treated as the same as <code>0 --&gt; B</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L620-L634">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactioncomplexes" href="#Catalyst.reactioncomplexes"><code>Catalyst.reactioncomplexes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactioncomplexes(network::ReactionSystem; sparse=false)</code></pre><p>Calculate the reaction complexes and complex incidence matrix for the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>.</p><p>Notes:</p><ul><li>returns a pair of a vector of <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a>s and the complex incidence matrix.</li><li>An empty <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a> denotes the null (∅) state (from reactions like ∅ -&gt; A or A -&gt; ∅).</li><li>Constant species are ignored in generating a reaction complex. i.e. if A is constant then A –&gt; B consists of the complexes ∅ and B.</li><li>The complex incidence matrix, <span>$B$</span>, is number of complexes by number of reactions with</li></ul><p class="math-container">\[B_{i j} = \begin{cases}
-1, &amp;\text{if the i&#39;th complex is the substrate of the j&#39;th reaction},\\
1, &amp;\text{if the i&#39;th complex is the product of the j&#39;th reaction},\\
0, &amp;\text{otherwise.}
\end{cases}\]</p><ul><li>Set sparse=true for a sparse matrix representation of the incidence matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L695-L716">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.incidencemat" href="#Catalyst.incidencemat"><code>Catalyst.incidencemat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">incidencemat(rn::ReactionSystem; sparse=false)</code></pre><p>Calculate the incidence matrix of <code>rn</code>, see <a href="#Catalyst.reactioncomplexes"><code>reactioncomplexes</code></a>.</p><p>Notes:</p><ul><li>Is cached in <code>rn</code> so that future calls, assuming the same sparsity, will also be fast.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L732-L739">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.complexstoichmat" href="#Catalyst.complexstoichmat"><code>Catalyst.complexstoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexstoichmat(network::ReactionSystem; sparse=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and vector of reaction complexes, return a matrix with positive entries of size number of species by number of complexes, where the non-zero positive entries in the kth column denote stoichiometric coefficients of the species participating in the kth reaction complex.</p><p>Notes:</p><ul><li>Set sparse=true for a sparse matrix representation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L765-L775">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.complexoutgoingmat" href="#Catalyst.complexoutgoingmat"><code>Catalyst.complexoutgoingmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexoutgoingmat(network::ReactionSystem; sparse=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and complex incidence matrix, <span>$B$</span>, return a matrix of size num of complexes by num of reactions that identifies substrate complexes.</p><p>Notes:</p><ul><li>The complex outgoing matrix, <span>$\Delta$</span>, is defined by</li></ul><p class="math-container">\[\Delta_{i j} = \begin{cases}
    = 0,    &amp;\text{if } B_{i j} = 1, \\
    = B_{i j}, &amp;\text{otherwise.}
\end{cases}\]</p><ul><li>Set sparse=true for a sparse matrix representation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L819-L835">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.incidencematgraph" href="#Catalyst.incidencematgraph"><code>Catalyst.incidencematgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">incidencematgraph(rn::ReactionSystem)</code></pre><p>Construct a directed simple graph where nodes correspond to reaction complexes and directed edges to reactions converting between two complexes.</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
complexes,incidencemat = reactioncomplexes(sir)
incidencematgraph(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L886-L905">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.linkageclasses" href="#Catalyst.linkageclasses"><code>Catalyst.linkageclasses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linkageclasses(rn::ReactionSystem)</code></pre><p>Given the incidence graph of a reaction network, return a vector of the connected components of the graph (i.e. sub-groups of reaction complexes that are connected in the incidence graph).</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
complexes,incidencemat = reactioncomplexes(sir)
linkageclasses(sir)</code></pre><p>gives</p><pre><code class="language-julia hljs">2-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L918-L944">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.deficiency" href="#Catalyst.deficiency"><code>Catalyst.deficiency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deficiency(rn::ReactionSystem)</code></pre><p>Calculate the deficiency of a reaction network.</p><p>Here the deficiency, <span>$\delta$</span>, of a network with <span>$n$</span> reaction complexes, <span>$\ell$</span> linkage classes and a rank <span>$s$</span> stoichiometric matrix is</p><p class="math-container">\[\delta = n - \ell - s\]</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
rcs,incidencemat = reactioncomplexes(sir)
δ = deficiency(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L953-L978">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.subnetworks" href="#Catalyst.subnetworks"><code>Catalyst.subnetworks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subnetworks(rn::ReactionSystem)</code></pre><p>Find subnetworks corresponding to each linkage class of the reaction network.</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
complexes,incidencemat = reactioncomplexes(sir)
subnetworks(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1007-L1025">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.linkagedeficiencies" href="#Catalyst.linkagedeficiencies"><code>Catalyst.linkagedeficiencies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linkagedeficiencies(network::ReactionSystem)</code></pre><p>Calculates the deficiency of each sub-reaction network within <code>network</code>.</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
rcs,incidencemat = reactioncomplexes(sir)
linkage_deficiencies = linkagedeficiencies(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1044-L1062">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isreversible" href="#Catalyst.isreversible"><code>Catalyst.isreversible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isreversible(rn::ReactionSystem)</code></pre><p>Given a reaction network, returns if the network is reversible or not.</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
rcs,incidencemat = reactioncomplexes(sir)
isreversible(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1075-L1093">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isweaklyreversible" href="#Catalyst.isweaklyreversible"><code>Catalyst.isweaklyreversible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isweaklyreversible(rn::ReactionSystem, subnetworks)</code></pre><p>Determine if the reaction network with the given subnetworks is weakly reversible or not.</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
rcs,incidencemat = reactioncomplexes(sir)
subnets = subnetworks(rn)
isweaklyreversible(rn, subnets)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1099-L1118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reset_networkproperties!" href="#Catalyst.reset_networkproperties!"><code>Catalyst.reset_networkproperties!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset_networkproperties!(rn::ReactionSystem)</code></pre><p>Clears the cache of various properties (like the netstoichiometry matrix). Use if such properties need to be recalculated for some reason.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L589-L594">source</a></section></article><h2 id="Network-comparison"><a class="docs-heading-anchor" href="#Network-comparison">Network comparison</a><a id="Network-comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Network-comparison" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Reaction, Reaction}" href="#Base.:==-Tuple{Reaction, Reaction}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(rx1::Reaction, rx2::Reaction)</code></pre><p>Tests whether two <a href="#Catalyst.Reaction"><code>Reaction</code></a>s are identical.</p><p>Notes:</p><ul><li>Ignores the order in which stoichiometry components are listed.</li><li><em>Does not</em> currently simplify rates, so a rate of <code>A^2+2*A+1</code> would be   considered different than <code>(A+1)^2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1295-L1304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isequivalent" href="#Catalyst.isequivalent"><code>Catalyst.isequivalent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isequivalent(rn1::ReactionSystem, rn2::ReactionSystem; ignorenames = true)</code></pre><p>Tests whether the underlying species, parameters and reactions are the same in the two <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>s. Ignores the names of the systems in testing equality.</p><p>Notes:</p><ul><li><em>Does not</em> currently simplify rates, so a rate of <code>A^2+2*A+1</code> would be   considered different than <code>(A+1)^2</code>.</li><li>Does not include <code>defaults</code> in determining equality.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1329-L1340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{ReactionSystem, ReactionSystem}" href="#Base.:==-Tuple{ReactionSystem, ReactionSystem}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(rn1::ReactionSystem, rn2::ReactionSystem)</code></pre><p>Tests whether the underlying species, parameters and reactions are the same in the two <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>s. Requires the systems to have the same names too.</p><p>Notes:</p><ul><li><em>Does not</em> currently simplify rates, so a rate of <code>A^2+2*A+1</code> would be   considered different than <code>(A+1)^2</code>.</li><li>Does not include <code>defaults</code> in determining equality.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1367-L1378">source</a></section></article><h2 id="Network-visualization"><a class="docs-heading-anchor" href="#Network-visualization">Network visualization</a><a id="Network-visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Network-visualization" title="Permalink"></a></h2><p><a href="https://korsbo.github.io/Latexify.jl/stable/">Latexify</a> can be used to convert networks to LaTeX equations by</p><pre><code class="language-julia hljs">using Latexify
latexify(rn)</code></pre><p>An optional argument, <code>form</code> allows using <code>latexify</code> to display a reaction network&#39;s ODE (as generated by the reaction rate equation) or SDE (as generated by the chemical Langevin equation) form:</p><pre><code class="language-julia hljs">latexify(rn; form=:ode)</code></pre><pre><code class="language-julia hljs">latexify(rn; form=:sde)</code></pre><p>(As of writing this, an upstream bug causes the SDE form to be erroneously displayed as the ODE form)</p><p>Finally, another optional argument (<code>expand_functions=true</code>) automatically expands functions defined by Catalyst (such as <code>mm</code>). To disable this, set <code>expand_functions=false</code>.</p><p>If <a href="https://graphviz.org/">Graphviz</a> is installed and commandline accessible, it can be used to create and save network diagrams using <a href="#Catalyst.Graph"><code>Graph</code></a> and <a href="#Catalyst.savegraph"><code>savegraph</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.Graph" href="#Catalyst.Graph"><code>Catalyst.Graph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Graph(rn::ReactionSystem)</code></pre><p>Converts a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> into a Graphviz graph. Reactions correspond to small green circles, and species to blue circles.</p><p>Notes:</p><ul><li>Black arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry.</li><li>Black arrows from reactions to species indicate products, and are labelled with their output stoichiometry.</li><li>Red arrows from species to reactions indicate that species is used within the rate expression. For example, in the reaction <code>k*A, B --&gt; C</code>, there would be a red arrow from <code>A</code> to the reaction node. In <code>k*A, A+B --&gt; C</code>, there would be red and black arrows from <code>A</code> to the reaction node.</li><li>Requires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/graphs.jl#L371-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.complexgraph" href="#Catalyst.complexgraph"><code>Catalyst.complexgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexgraph(rn::ReactionSystem; complexdata=reactioncomplexes(rn))</code></pre><p>Creates a Graphviz graph of the <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a>s in <code>rn</code>. Reactions correspond to arrows and reaction complexes to blue circles.</p><p>Notes:</p><ul><li>Black arrows from complexes to complexes indicate reactions whose rate is a parameter or a <code>Number</code>. i.e. <code>k, A --&gt; B</code>.</li><li>Red dashed arrows from complexes to complexes indicate reactions whose rate depends on species. i.e. <code>k*C, A --&gt; B</code> for <code>C</code> a species.</li><li>Requires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/graphs.jl#L323-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.savegraph" href="#Catalyst.savegraph"><code>Catalyst.savegraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">savegraph(g::Graph, fname, fmt=&quot;png&quot;)</code></pre><p>Given a <code>Graph</code> generated by <a href="#Catalyst.Graph"><code>Graph</code></a>, save the graph to the file with name <code>fname</code> and extension <code>fmt</code>.</p><p>Notes:</p><ul><li><code>fmt=&quot;png&quot;</code> is the default output format.</li><li>Requires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/graphs.jl#L414-L423">source</a></section></article><h2 id="api_rate_laws"><a class="docs-heading-anchor" href="#api_rate_laws">Rate laws</a><a id="api_rate_laws-1"></a><a class="docs-heading-anchor-permalink" href="#api_rate_laws" title="Permalink"></a></h2><p>As the underlying <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> is comprised of <code>ModelingToolkit</code> expressions, one can directly access the generated rate laws, and using <code>ModelingToolkit</code> tooling generate functions or Julia <code>Expr</code>s from them.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.oderatelaw" href="#Catalyst.oderatelaw"><code>Catalyst.oderatelaw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">oderatelaw(rx; combinatoric_ratelaw=true)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a>, return the symbolic reaction rate law used in generated ODEs for the reaction. Note, for a reaction defined by</p><p><code>k*X*Y, X+Z --&gt; 2X + Y</code></p><p>the expression that is returned will be <code>k*X(t)^2*Y(t)*Z(t)</code>. For a reaction of the form</p><p><code>k, 2X+3Y --&gt; Z</code></p><p>the expression that is returned will be <code>k * (X(t)^2/2) * (Y(t)^3/6)</code>.</p><p>Notes:</p><ul><li>Allocates</li><li><code>combinatoric_ratelaw=true</code> uses factorial scaling factors in calculating the   rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. If   <code>combinatoric_ratelaw=false</code> then the ratelaw is <code>k*S^2</code>, i.e. the scaling   factor is ignored.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L1044-L1065">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.jumpratelaw" href="#Catalyst.jumpratelaw"><code>Catalyst.jumpratelaw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jumpratelaw(rx; combinatoric_ratelaw=true)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a>, return the symbolic reaction rate law used in generated stochastic chemical kinetics model SSAs for the reaction. Note, for a reaction defined by</p><p><code>k*X*Y, X+Z --&gt; 2X + Y</code></p><p>the expression that is returned will be <code>k*X^2*Y*Z</code>. For a reaction of the form</p><p><code>k, 2X+3Y --&gt; Z</code></p><p>the expression that is returned will be <code>k * binomial(X,2) * binomial(Y,3)</code>.</p><p>Notes:</p><ul><li>Allocates</li><li><code>combinatoric_ratelaw=true</code> uses binomials in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S*(S-1)/2</code>. If <code>combinatoric_ratelaw=false</code> then the ratelaw is <code>k*S*(S-1)</code>, i.e. the rate law is not normalized by the scaling factor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L1183-L1206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.mm" href="#Catalyst.mm"><code>Catalyst.mm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mm(X,v,K) = v*X / (X + K)</code></pre><p>A Michaelis-Menten rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/registered_functions.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.mmr" href="#Catalyst.mmr"><code>Catalyst.mmr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mmr(X,v,K) = v*K / (X + K)</code></pre><p>A repressive Michaelis-Menten rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/registered_functions.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.hill" href="#Catalyst.hill"><code>Catalyst.hill</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hill(X,v,K,n) = v*(X^n) / (X^n + K^n)</code></pre><p>A Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/registered_functions.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.hillr" href="#Catalyst.hillr"><code>Catalyst.hillr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hillr(X,v,K,n) = v*(K^n) / (X^n + K^n)</code></pre><p>A repressive Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/registered_functions.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.hillar" href="#Catalyst.hillar"><code>Catalyst.hillar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hillar(X,Y,v,K,n) = v*(X^n) / (X^n + Y^n + K^n)</code></pre><p>An activation/repressing Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/registered_functions.jl#L82-L86">source</a></section></article><h2 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.convert" href="#Base.convert"><code>Base.convert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:ODESystem},rs::ReactionSystem)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.ODESystem</code>.</p><p>Keyword args and default values:</p><ul><li><code>combinatoric_ratelaws=true</code> uses factorial scaling factors in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. Set <code>combinatoric_ratelaws=false</code> for a ratelaw of <code>k*S^2</code>, i.e. the scaling factor is ignored. Defaults to the value given when the <code>ReactionSystem</code> was constructed (which itself defaults to true).</li><li><code>remove_conserved=false</code>, if set to <code>true</code> will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L1482-L1497">source</a></section><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:NonlinearSystem},rs::ReactionSystem)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.NonlinearSystem</code>.</p><p>Keyword args and default values:</p><ul><li><code>combinatoric_ratelaws=true</code> uses factorial scaling factors in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. Set <code>combinatoric_ratelaws=false</code> for a ratelaw of <code>k*S^2</code>, i.e. the scaling factor is ignored. Defaults to the value given when the <code>ReactionSystem</code> was constructed (which itself defaults to true).</li><li><code>remove_conserved=false</code>, if set to <code>true</code> will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L1522-L1538">source</a></section><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:SDESystem},rs::ReactionSystem)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.SDESystem</code>.</p><p>Notes:</p><ul><li><code>combinatoric_ratelaws=true</code> uses factorial scaling factors in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. Set <code>combinatoric_ratelaws=false</code> for a ratelaw of <code>k*S^2</code>, i.e. the scaling factor is ignored. Defaults to the value given when the <code>ReactionSystem</code> was constructed (which itself defaults to true).</li><li><code>remove_conserved=false</code>, if set to <code>true</code> will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.</li><li>Does not currently support <code>ReactionSystem</code>s that include coupled algebraic or differential equations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L1562-L1580">source</a></section><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:JumpSystem},rs::ReactionSystem; combinatoric_ratelaws=true)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.JumpSystem</code>.</p><p>Notes:</p><ul><li><code>combinatoric_ratelaws=true</code> uses binomials in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S*(S-1)/2</code>. If <code>combinatoric_ratelaws=false</code> then the ratelaw is <code>k*S*(S-1)</code>, i.e. the rate law is not normalized by the scaling factor. Defaults to the value given when the <code>ReactionSystem</code> was constructed (which itself defaults to true).</li><li>Does not currently support <code>ReactionSystem</code>s that include coupled algebraic or differential equations.</li><li>Does not currently support continuous events as these are not supported by <code>ModelingToolkit.JumpSystems</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/reactionsystem.jl#L1613-L1630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.structural_simplify" href="#ModelingToolkit.structural_simplify"><code>ModelingToolkit.structural_simplify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">structural_simplify(sys; ...)
structural_simplify(sys, io; simplify, split, kwargs...)
</code></pre><p>Structurally simplify algebraic equations in a system and compute the topological sort of the observed equations. When <code>simplify=true</code>, the <code>simplify</code> function will be applied during the tearing process. It also takes kwargs <code>allow_symbolic=false</code> and <code>allow_parameter=true</code> which limits the coefficient types during tearing.</p><p>The optional argument <code>io</code> may take a tuple <code>(inputs, outputs)</code>. This will convert all <code>inputs</code> to parameters and allow them to be unconnected, i.e., simplification will allow models where <code>n_unknowns = n_equations - n_inputs</code>.</p></div></section></article><h2 id="Chemistry-related-functionalities"><a class="docs-heading-anchor" href="#Chemistry-related-functionalities">Chemistry-related functionalities</a><a id="Chemistry-related-functionalities-1"></a><a class="docs-heading-anchor-permalink" href="#Chemistry-related-functionalities" title="Permalink"></a></h2><p>Various functionalities primarily relevant to modelling of chemical systems (but potentially also in biology). </p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.@compound" href="#Catalyst.@compound"><code>Catalyst.@compound</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@compound</code></pre><p>Macro that creates a compound species, which is composed of smaller component species.</p><p>Example:</p><pre><code class="language-julia hljs">t = default_t()
@species C(t) O(t)
@compound CO2(t) ~ C + 2O</code></pre><p>Notes: </p><ul><li>The component species must be defined before using the <code>@compound</code> macro.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/chemistry_functionality.jl#L12-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.@compounds" href="#Catalyst.@compounds"><code>Catalyst.@compounds</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@compounds</code></pre><p>Macro that creates several compound species, which each is composed of smaller component species. Uses the same syntax as <code>@compound</code>, but with one compound species one each line.</p><p>Example:</p><pre><code class="language-julia hljs">t = default_t()
@species C(t) H(t) O(t) 
@compounds
    CH4(t) = C + 4H
    O2(t) = 2O
    CO2(t) = C + 2O
    H2O(t) = 2H + O
end</code></pre><p>Notes: </p><ul><li>The component species must be defined before using the <code>@compound</code> macro.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/chemistry_functionality.jl#L97-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.iscompound" href="#Catalyst.iscompound"><code>Catalyst.iscompound</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iscompound(s)</code></pre><p>Returns <code>true</code> if the input is a compound species (else false).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/chemistry_functionality.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.components" href="#Catalyst.components"><code>Catalyst.components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">components(s)</code></pre><p>Returns a vector with a list of all the components of a compound species (created using e.g. the @compound macro).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/chemistry_functionality.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.coefficients" href="#Catalyst.coefficients"><code>Catalyst.coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coefficients(s)</code></pre><p>Returns a vector with a list of all the stoichiometric coefficients of the components of a compound species (created using e.g. the @compound macro).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/chemistry_functionality.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.component_coefficients" href="#Catalyst.component_coefficients"><code>Catalyst.component_coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">component_coefficients(s)</code></pre><p>Returns a Vector{Pari{Symbol,Int64}}, listing a compounds species (created using e.g. the @compound macro) all the coefficients and their stoichiometric coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/chemistry_functionality.jl#L181-L185">source</a></section></article><h2 id="Unit-validation"><a class="docs-heading-anchor" href="#Unit-validation">Unit validation</a><a id="Unit-validation-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-validation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.validate-Tuple{Reaction}" href="#ModelingToolkit.validate-Tuple{Reaction}"><code>ModelingToolkit.validate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate(rx::Reaction; info::String = &quot;&quot;)</code></pre><p>Check that all substrates and products within the given <a href="#Catalyst.Reaction"><code>Reaction</code></a> have the same units, and that the units of the reaction&#39;s rate expression are internally consistent (i.e. if the rate involves sums, each term in the sum has the same units).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1551-L1559">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.validate" href="#ModelingToolkit.validate"><code>ModelingToolkit.validate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">validate(rs::ReactionSystem, info::String=&quot;&quot;)</code></pre><p>Check that all species in the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> have the same units, and that the rate laws of all reactions reduce to units of (species units) / (time units).</p><p>Notes:</p><ul><li>Does not check subsystems, constraint equations, or non-species variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L1588-L1597">source</a></section></article><h2 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catalyst.symmap_to_varmap" href="#Catalyst.symmap_to_varmap"><code>Catalyst.symmap_to_varmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">symmap_to_varmap(sys, symmap)</code></pre><p>Given a system and map of <code>Symbol</code>s to values, generates a map from corresponding symbolic variables/parameters to the values that can be used to pass initial conditions and parameter mappings.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network sir begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end
subsys = @reaction_network subsys begin
    k, A --&gt; B
end
@named sys = compose(sir, [subsys])</code></pre><p>gives</p><pre><code class="nohighlight hljs">Model sys with 3 equations
Unknowns (5):
  S(t)
  I(t)
  R(t)
  subsys₊A(t)
  subsys₊B(t)
Parameters (3):
  β
  ν
  subsys₊k</code></pre><p>to specify initial condition and parameter mappings from <em>symbols</em> we can use</p><pre><code class="language-julia hljs">symmap = [:S =&gt; 1.0, :I =&gt; 1.0, :R =&gt; 1.0, :subsys₊A =&gt; 1.0, :subsys₊B =&gt; 1.0]
u0map  = symmap_to_varmap(sys, symmap)
pmap   = symmap_to_varmap(sys, [:β =&gt; 1.0, :ν =&gt; 1.0, :subsys₊k =&gt; 1.0])</code></pre><p><code>u0map</code> and <code>pmap</code> can then be used as input to various problem types.</p><p>Notes:</p><ul><li>Any <code>Symbol</code>, <code>sym</code>, within <code>symmap</code> must be a valid field of <code>sys</code>. i.e. <code>sys.sym</code> must be defined.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/447d3fd909037168aac453dd156058f7ae157728/src/networkapi.jl#L523-L566">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../faqs/">« FAQs</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 10 April 2024 13:41">Wednesday 10 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
