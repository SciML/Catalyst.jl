<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finding Steady States through Homotopy Continuation · Catalyst.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/catalyst_applications/homotopy_continuation/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Functionality</span><ul><li><a class="tocitem" href="../../catalyst_functionality/dsl_description/">The Reaction DSL</a></li><li><a class="tocitem" href="../../catalyst_functionality/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../catalyst_functionality/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../catalyst_functionality/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../catalyst_functionality/network_analysis/">Network Analysis in Catalyst</a></li></ul></li><li><span class="tocitem">Catalyst Applications</span><ul><li><a class="tocitem" href="../simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../advanced_simulations/">Advanced Simulation Options</a></li><li class="is-active"><a class="tocitem" href>Finding Steady States through Homotopy Continuation</a><ul class="internal"><li><a class="tocitem" href="#Basic-example"><span>Basic example</span></a></li><li><a class="tocitem" href="#Systems-with-conservation-laws"><span>Systems with conservation laws</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../parameter_estimation/">Parameter Estimation</a></li></ul></li><li><span class="tocitem">Example Networks</span><ul><li><a class="tocitem" href="../../example_networks/basic_CRN_examples/">Basic Chemical Reaction Network Examples</a></li><li><a class="tocitem" href="../../example_networks/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../example_networks/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/catalyst_api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Catalyst Applications</a></li><li class="is-active"><a href>Finding Steady States through Homotopy Continuation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Finding Steady States through Homotopy Continuation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/catalyst_applications/homotopy_continuation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="homotopy_continuation"><a class="docs-heading-anchor" href="#homotopy_continuation">Finding Steady States through Homotopy Continuation</a><a id="homotopy_continuation-1"></a><a class="docs-heading-anchor-permalink" href="#homotopy_continuation" title="Permalink"></a></h1><p>The steady states of a dynamical system <span>${dx \over dt} = f(x)$</span> can be found by solving <span>$0 = f(x)$</span>. This is typically a hard problem, and generally, there is no method guaranteed to find all steady states for a system that has multiple ones. However, many chemical reaction networks generate polynomial systems (for example those which are purely mass action or have only have Hill functions with integer Hill exponents). The roots of these can reliably be found through a <em>homotopy continuation</em> algorithm. This is implemented in Julia through the <a href="https://www.juliahomotopycontinuation.org/">HomotopyContinuation.jl</a> package. In this tutorial, we will demonstrate how homotopy continuation can be used to find the steady states of mass action chemical reaction networks implemented in Catalyst.</p><h2 id="Basic-example"><a class="docs-heading-anchor" href="#Basic-example">Basic example</a><a id="Basic-example-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-example" title="Permalink"></a></h2><p>For this tutorial, we will use a model from Wilhem (2009)<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> (which demonstrates bistability in a small chemical reaction network). We declare the model and the parameter set for which we want to find the steady states:</p><pre><code class="language-julia hljs">using Catalyst, ModelingToolkit
import HomotopyContinuation
const MT = ModelingToolkit
const HC = HomotopyContinuation

wilhelm_2009_model = @reaction_network begin
    k1, Y --&gt; 2X
    k2, 2X --&gt; X + Y
    k3, X + Y --&gt; Y
    k4, X --&gt; 0
end

# add default parameters values to model
setdefaults!(wilhelm_2009_model, [:k1 =&gt; 8.0, :k2 =&gt; 2.0, :k3 =&gt; 1.0, :k4 =&gt; 1.5])</code></pre><p>Next, we will need to extract the actual equations from our model. In addition, we will substitute in our parameter values to these equations.</p><pre><code class="language-julia hljs">ns = convert(NonlinearSystem, wilhelm_2009_model)

# this gets the parameter values ordered consistent with parameters(ns)
pvals = MT.varmap_to_vars([], MT.parameters(ns); defaults = MT.defaults(ns))

subs = Dict(MT.parameters(ns) .=&gt; pvals)
neweqs = map(eq -&gt; substitute(eq.rhs, subs), equations(ns))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 X(t)^2 - 8.0Y(t)
 16.0Y(t) - (X(t)^2) - 1.5X(t) - X(t)*Y(t)</code></pre><p>Finally, we use Catalyst&#39;s <code>to_multivariate_poly</code> function to reinterpret our symbolic equations in a polynomial representation that is compatible with HomotopyContinuation. We can then apply HomotopyContinuation&#39;s <code>solve</code> command to find the roots, using <code>real_solutions</code> to filter our non-physical complex steady-states:</p><pre><code class="language-julia hljs">polyeqs = Catalyst.to_multivariate_poly(neweqs)
sols = HC.real_solutions(HC.solve(polyeqs))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Vector{Float64}}:
 [2.0, 0.5000000000000001]
 [0.0, 0.0]
 [6.0, 4.5]</code></pre><p>Note that HomotopyContinuation orders variables lexicographically, so this will be the ordering present in each steady-state solution vector (i.e. <code>[X1, X2]</code> is the ordering here).</p><p>While it is not the case for this CRN, we note that solutions with negative species concentrations can be valid (unphysical) steady-states for certain systems. These will need to be filtered out as well.</p><h2 id="Systems-with-conservation-laws"><a class="docs-heading-anchor" href="#Systems-with-conservation-laws">Systems with conservation laws</a><a id="Systems-with-conservation-laws-1"></a><a class="docs-heading-anchor-permalink" href="#Systems-with-conservation-laws" title="Permalink"></a></h2><p>Finally, some systems are under-determined, and have an infinite number of possible steady states. These are typically systems containing a conservation law, e.g.</p><pre><code class="language-julia hljs">using Catalyst
import HomotopyContinuation
const MT = ModelingToolkit
const HC = HomotopyContinuation

two_state_model = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{X1} &amp;\xrightleftharpoons[k2]{k1} \mathrm{X2}  
 \end{align*}
 \]</p><p>Catalyst allows the conservation laws to be computed using the <code>conservationlaws</code> function. By using these to reduce the dimensionality of the system, as well specifying the initial amount of each species, HomotopyContinuation can again be used to find steady states. First, we set the default values of the system&#39;s initial conditions and parameter values. This will allow the system to automatically find the conserved amounts.</p><pre><code class="language-julia hljs">setdefaults!(two_state_model, [:X1 =&gt; 1.0, :X2 =&gt; 1.0, :k1 =&gt; 2.0, :k2 =&gt; 1.0])</code></pre><p>Next, we create a <code>NonlinearSystem</code>, while also removing one species via the conservation equation.</p><pre><code class="language-julia hljs">ns = convert(NonlinearSystem, two_state_model; remove_conserved = true)</code></pre><p class="math-container">\[ \begin{align}
0 =&amp; k2 \left(  - \mathrm{X1}\left( t \right) + \Gamma_1 \right) - k1 \mathrm{X1}\left( t \right)
\end{align}
 \]</p><p>Again, we next create a dictionary for parameter values that we substitute in to give our final equation.</p><pre><code class="language-julia hljs">pvals = MT.varmap_to_vars([], MT.parameters(ns); defaults = MT.defaults(ns))
subs = Dict(MT.parameters(ns) .=&gt; pvals)
neweqs = map(eq -&gt; substitute(eq.rhs, subs), equations(ns))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 2.0 - 3.0X1(t)</code></pre><p>Notice, our equations are just for <code>X1</code> as <code>X2</code> was eliminated via the conservation law.</p><p>Finally, we convert to polynomial form and solve for the steady-states</p><pre><code class="language-julia hljs">polyeqs = Catalyst.to_multivariate_poly(neweqs)
sols = HC.real_solutions(HC.solve(polyeqs))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Vector{Float64}}:
 [0.6666666666666666]</code></pre><p>If we also want the corresponding value for <code>X2</code>, we can substitute into the equation for it from the conservation laws:</p><pre><code class="language-julia hljs"># get the X2 symbolic variable
@unpack X2 = two_state_model

# get its algebraic formula in terms of X1 and parameters
ceqs = conservedequations(two_state_model)
X2eqidx = findfirst(eq -&gt; isequal(eq.lhs, X2), ceqs)
X2eq = ceqs[X2eqidx].rhs

# for each SS, set X1&#39;s value in the subs map and calculate X2
@unpack X1 = two_state_model
X2 = map(sols) do x
    X1val = x[1]
    subs[MT.value(X1)] = X1val
    substitute(X2eq, subs)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 1.3333333333333335</code></pre><p>giving that the steady-state for <code>X2</code> is about <code>1.33333</code>.</p><p>As an alternative, we could have coupled <code>neweqs</code> with the conservation law relations to have HomotopyContinuation find the steady-states simultaneously:</p><pre><code class="language-julia hljs"># move all the terms in the conserved equations to one side
# and substitute in the parameter values
subs = Dict(MT.parameters(ns) .=&gt; pvals)
conservedrelations = map(eq -&gt; substitute(eq.rhs - eq.lhs, subs), ceqs)
neweqs = vcat(neweqs, conservedrelations)

# calculate the steady-states
polyeqs = Catalyst.to_multivariate_poly(neweqs)
sols = HC.real_solutions(HC.solve(polyeqs))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Vector{Float64}}:
 [0.6666666666666666, 1.3333333333333335]</code></pre><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://bmcsystbiol.biomedcentral.com/articles/10.1186/1752-050Wilhelm-3-90">Wilhelm, T. <em>The smallest chemical reaction system with bistability</em>, BMC Systems Biology (2009).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../advanced_simulations/">« Advanced Simulation Options</a><a class="docs-footer-nextpage" href="../bifurcation_diagrams/">Bifurcation Diagrams »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 3 September 2023 15:41">Sunday 3 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
