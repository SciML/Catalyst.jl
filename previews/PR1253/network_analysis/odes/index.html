<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Decomposing the Reaction Network ODEs · Catalyst.jl</title><meta name="title" content="Decomposing the Reaction Network ODEs · Catalyst.jl"/><meta property="og:title" content="Decomposing the Reaction Network ODEs · Catalyst.jl"/><meta property="twitter:title" content="Decomposing the Reaction Network ODEs · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/network_analysis/odes/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/network_analysis/odes/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/network_analysis/odes/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Introduction to Catalyst</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Model creation and properties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/constraint_equations/">Coupled ODEs, Algebraic Equations, and Events</a></li><li><a class="tocitem" href="../../model_creation/conservation_laws/">Working with Conservation Laws</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stoichiometries</a></li><li><a class="tocitem" href="../../model_creation/functional_parameters/">Inputs and time-dependent (or functional) parameters</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/reactionsystem_content_accessing/">Accessing Model Properties</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related Functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, Generative, Modelling of a Linear Pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/noise_modelling_approaches/">Approaches for modelling system noise</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Model simulation and visualization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation Plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for Performant ODE Simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for Performant SDE Simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/examples/periodic_events_simulation/">Modelling a Periodic Event During ODE and Jump Simulations</a></li><li><a class="tocitem" href="../../model_simulation/examples/activation_time_distribution_measurement/">Measuring the Distribution of System Activation Times</a></li><li><a class="tocitem" href="../../model_simulation/examples/interactive_brusselator_simulation/">Interactive Simulation and Plotting</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Network Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Decomposing the Reaction Network ODEs</a><ul class="internal"><li><a class="tocitem" href="#network_analysis_repressilator_representation"><span>Network representation of the Repressilator <code>ReactionSystem</code></span></a></li><li><a class="tocitem" href="#network_analysis_matrix_vector_representation"><span>Matrix-vector reaction rate equation representation</span></a></li><li><a class="tocitem" href="#network_analysis_reaction_complexes"><span>Reaction complex representation</span></a></li><li class="toplevel"><a class="tocitem" href="#Full-decomposition-of-the-reaction-network-ODEs-(flux-matrix-and-mass-action-vector)"><span>Full decomposition of the reaction network ODEs (flux matrix and mass-action vector)</span></a></li><li><a class="tocitem" href="#Symbolic-ODE-functions"><span>Symbolic ODE functions</span></a></li><li><a class="tocitem" href="#Properties-of-matrix-null-spaces"><span>Properties of matrix null spaces</span></a></li><li><a class="tocitem" href="#API-Section-for-matrices-and-vectors"><span>API Section for matrices and vectors</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../crn_theory/">Chemical Reaction Network Theory</a></li><li><a class="tocitem" href="../network_properties/">Caching of Network Properties in <code>ReactionSystems</code></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Steady state analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing Model Steady State Properties with DynamicalSystems.jl</a></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/examples/bifurcationkit_periodic_orbits/">Computing Periodic Orbits (Oscillations) Using BifurcationKit.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/examples/bifurcationkit_codim2/">Tracking Bifurcation Point w.r.t. Secondary Parameters using BifurcationKit.jl</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Inverse problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/petab_ode_param_fitting/">Parameter Fitting for ODEs using PEtab.jl</a></li><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for Non-data Fitting Purposes</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Spatial modelling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial Jump Simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/core_api/">Catalyst.jl API</a></li><li><a class="tocitem" href="../../api/network_analysis_api/">Network analysis and representations</a></li></ul></li><li><a class="tocitem" href="../../devdocs/dev_guide/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Network Analysis</a></li><li class="is-active"><a href>Decomposing the Reaction Network ODEs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Decomposing the Reaction Network ODEs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/network_analysis/odes.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="network_analysis_odes"><a class="docs-heading-anchor" href="#network_analysis_odes">Decomposing the Reaction Network ODEs</a><a id="network_analysis_odes-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis_odes" title="Permalink"></a></h1><p>In this tutorial we will discuss the specific mathematical  structure of the <a href="../../introduction_to_catalyst/math_models_intro/#math_models_in_catalyst_rre_odes">ODEs that arise from the mass-action dynamics</a> of chemical reaction networks, and decompose them as a product of matrices that describe the network.  A complete summary of  the exported functions is given in the API section <a href="../../api/network_analysis_api/#api_network_analysis">Network Analysis and Representations</a>. Please consult Feinberg&#39;s <em>Foundations of Chemical Reaction Network Theory</em><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> for more discussion about the concepts on this page.</p><p>Note, currently API functions for network analysis and conservation law analysis do not work with constant species (which are generated by SBML, and can be <a href="../../model_creation/dsl_advanced/#dsl_advanced_options_constant_species">declared in Catalyst as well</a>.</p><h2 id="network_analysis_repressilator_representation"><a class="docs-heading-anchor" href="#network_analysis_repressilator_representation">Network representation of the Repressilator <code>ReactionSystem</code></a><a id="network_analysis_repressilator_representation-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis_repressilator_representation" title="Permalink"></a></h2><p>We first load Catalyst and construct our model of the repressilator</p><pre><code class="language-julia hljs">using Catalyst, CairoMakie, GraphMakie, NetworkLayout
repressilator = @reaction_network Repressilator begin
       hillr(P₃,α,K,n), ∅ --&gt; m₁
       hillr(P₁,α,K,n), ∅ --&gt; m₂
       hillr(P₂,α,K,n), ∅ --&gt; m₃
       (δ,γ), m₁ &lt;--&gt; ∅
       (δ,γ), m₂ &lt;--&gt; ∅
       (δ,γ), m₃ &lt;--&gt; ∅
       β, m₁ --&gt; m₁ + P₁
       β, m₂ --&gt; m₂ + P₂
       β, m₃ --&gt; m₃ + P₃
       μ, P₁ --&gt; ∅
       μ, P₂ --&gt; ∅
       μ, P₃ --&gt; ∅
end</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightarrow{\frac{K^{n} \alpha}{K^{n} + \mathtt{P_3}^{n}}} \mathrm{\mathtt{m_1}} \\
\varnothing &amp;\xrightarrow{\frac{K^{n} \alpha}{\mathtt{P_1}^{n} + K^{n}}} \mathrm{\mathtt{m_2}} \\
\varnothing &amp;\xrightarrow{\frac{K^{n} \alpha}{K^{n} + \mathtt{P_2}^{n}}} \mathrm{\mathtt{m_3}} \\
\mathrm{\mathtt{m_1}} &amp;\xrightleftharpoons[\gamma]{\delta} \varnothing \\
\mathrm{\mathtt{m_2}} &amp;\xrightleftharpoons[\gamma]{\delta} \varnothing \\
\mathrm{\mathtt{m_3}} &amp;\xrightleftharpoons[\gamma]{\delta} \varnothing \\
\mathrm{\mathtt{m_1}} &amp;\xrightarrow{\beta} \mathrm{\mathtt{m_1}} + \mathrm{\mathtt{P_1}} \\
\mathrm{\mathtt{m_2}} &amp;\xrightarrow{\beta} \mathrm{\mathtt{m_2}} + \mathrm{\mathtt{P_2}} \\
\mathrm{\mathtt{m_3}} &amp;\xrightarrow{\beta} \mathrm{\mathtt{m_3}} + \mathrm{\mathtt{P_3}} \\
\mathrm{\mathtt{P_1}} &amp;\xrightarrow{\mu} \varnothing \\
\mathrm{\mathtt{P_2}} &amp;\xrightarrow{\mu} \varnothing \\
\mathrm{\mathtt{P_3}} &amp;\xrightarrow{\mu} \varnothing  
 \end{align*}
 \]</p><p>In the <a href="../../model_creation/model_visualisation/#visualisation_graphs">Model Visualization</a> tutorial we showed how the above network could be visualized as a species-reaction graph. There, species are represented by the nodes of the graph and edges show the reactions in which a given species is a substrate or product.</p><pre><code class="language-julia hljs">g = plot_network(repressilator)</code></pre><img src="95053a5a.png" alt="Example block output"/><p>We also showed in the <a href="../../introduction_to_catalyst/introduction_to_catalyst/#introduction_to_catalyst">Introduction to Catalyst</a> tutorial that the reaction rate equation (RRE) ODE model for the repressilator is</p><p class="math-container">\[\begin{aligned}
\frac{dm_1(t)}{dt} =&amp; \frac{\alpha K^{n}}{K^{n} + \left( {P_3}\left( t \right) \right)^{n}} - \delta {m_1}\left( t \right) + \gamma \\
\frac{dm_2(t)}{dt} =&amp; \frac{\alpha K^{n}}{K^{n} + \left( {P_1}\left( t \right) \right)^{n}} - \delta {m_2}\left( t \right) + \gamma \\
\frac{dm_3(t)}{dt} =&amp; \frac{\alpha K^{n}}{K^{n} + \left( {P_2}\left( t \right) \right)^{n}} - \delta {m_3}\left( t \right) + \gamma \\
\frac{dP_1(t)}{dt} =&amp; \beta {m_1}\left( t \right) - \mu {P_1}\left( t \right) \\
\frac{dP_2(t)}{dt} =&amp; \beta {m_2}\left( t \right) - \mu {P_2}\left( t \right) \\
\frac{dP_3(t)}{dt} =&amp; \beta {m_3}\left( t \right) - \mu {P_3}\left( t \right)
\end{aligned}\]</p><h2 id="network_analysis_matrix_vector_representation"><a class="docs-heading-anchor" href="#network_analysis_matrix_vector_representation">Matrix-vector reaction rate equation representation</a><a id="network_analysis_matrix_vector_representation-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis_matrix_vector_representation" title="Permalink"></a></h2><p>In general, reaction rate equation (RRE) ODE models for chemical reaction networks can be represented as a first-order system of ODEs in a compact matrix-vector notation. Suppose we have a reaction network with <span>$K$</span> reactions and <span>$M$</span> species, labelled by the state vector</p><p class="math-container">\[\mathbf{x}(t) = \begin{pmatrix} x_1(t) \\ \vdots \\ x_M(t)) \end{pmatrix}.\]</p><p>For the repressilator, <span>$\mathbf{x}(t)$</span> is just</p><pre><code class="language-julia hljs">x = species(repressilator)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 m₁(t)
 m₂(t)
 m₃(t)
 P₁(t)
 P₂(t)
 P₃(t)</code></pre><p>The RRE ODEs satisfied by <span>$\mathbf{x}(t)$</span> are then</p><p class="math-container">\[\frac{d\mathbf{x}}{dt} = N \mathbf{v}(\mathbf{x}(t),t),\]</p><p>where <span>$N$</span> is a constant <span>$M$</span> by <span>$K$</span> matrix with <span>$N_{m k}$</span> the net stoichiometric coefficient of species <span>$m$</span> in reaction <span>$k$</span>. <span>$\mathbf{v}(\mathbf{x}(t),t)$</span> is the rate law vector, with <span>$v_k(\mathbf{x}(t),t)$</span> the rate law for the <span>$k$</span>th reaction. For example, for the first reaction of the repressilator above, the rate law is</p><p class="math-container">\[v_1(\mathbf{x}(t),t) = \frac{\alpha K^{n}}{K^{n} + \left( P_3(t) \right)^{n}}.\]</p><p>We can calculate each of these in Catalyst via</p><pre><code class="language-julia hljs">N = netstoichmat(repressilator)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6×15 Matrix{Int64}:
 1  0  0  -1  1   0  0   0  0  0  0  0   0   0   0
 0  1  0   0  0  -1  1   0  0  0  0  0   0   0   0
 0  0  1   0  0   0  0  -1  1  0  0  0   0   0   0
 0  0  0   0  0   0  0   0  0  1  0  0  -1   0   0
 0  0  0   0  0   0  0   0  0  0  1  0   0  -1   0
 0  0  0   0  0   0  0   0  0  0  0  1   0   0  -1</code></pre><p>and by using the <a href="../../api/core_api/#Catalyst.oderatelaw"><code>oderatelaw</code></a> function</p><pre><code class="language-julia hljs">rxs = reactions(repressilator)
ν = oderatelaw.(rxs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">15-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 ((K^n)*α) / (P₃(t)^n + K^n)
 ((K^n)*α) / (K^n + P₁(t)^n)
 ((K^n)*α) / (K^n + P₂(t)^n)
 m₁(t)*δ
 γ
 m₂(t)*δ
 γ
 m₃(t)*δ
 γ
 m₁(t)*β
 m₂(t)*β
 m₃(t)*β
 P₁(t)*μ
 P₂(t)*μ
 P₃(t)*μ</code></pre><p>Note, as <a href="../../api/core_api/#Catalyst.oderatelaw"><code>oderatelaw</code></a> takes just one reaction as input we use broadcasting to apply it to each element of <code>rxs</code>.</p><p>Let&#39;s check that this really gives the same ODEs as Catalyst. Here is what Catalyst generates by converting to an <code>ODESystem</code></p><pre><code class="language-julia hljs">osys = convert(ODESystem, repressilator)

# for display purposes we just pull out the right side of the equations
odes = [eq.rhs for eq in equations(osys)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 ((K^n)*α) / (P₃(t)^n + K^n) + γ - m₁(t)*δ
 ((K^n)*α) / (K^n + P₁(t)^n) + γ - m₂(t)*δ
 ((K^n)*α) / (K^n + P₂(t)^n) + γ - m₃(t)*δ
 -P₁(t)*μ + m₁(t)*β
 m₂(t)*β - P₂(t)*μ
 -P₃(t)*μ + m₃(t)*β</code></pre><p>whereas our matrix-vector representation gives</p><pre><code class="language-julia hljs">odes2 = N * ν</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Any}:
 ((K^n)*α) / (P₃(t)^n + K^n) + γ - m₁(t)*δ
 ((K^n)*α) / (K^n + P₁(t)^n) + γ - m₂(t)*δ
 ((K^n)*α) / (K^n + P₂(t)^n) + γ - m₃(t)*δ
 -P₁(t)*μ + m₁(t)*β
 m₂(t)*β - P₂(t)*μ
 -P₃(t)*μ + m₃(t)*β</code></pre><p>Let&#39;s check these are equal symbolically</p><pre><code class="language-julia hljs">isequal(odes, odes2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h2 id="network_analysis_reaction_complexes"><a class="docs-heading-anchor" href="#network_analysis_reaction_complexes">Reaction complex representation</a><a id="network_analysis_reaction_complexes-1"></a><a class="docs-heading-anchor-permalink" href="#network_analysis_reaction_complexes" title="Permalink"></a></h2><p>We now introduce a further decomposition of the RRE ODEs, which has been used to facilitate analysis of a variety of reaction network properties. Consider a simple reaction system like</p><pre><code class="language-julia hljs">rn = @reaction_network begin
 k, 2A + 3B --&gt; A + 2C + D
 b, C + D --&gt; 2A + 3B
end</code></pre><p class="math-container">\[ \begin{align*}
2 \mathrm{A} + 3 \mathrm{B} &amp;\xrightarrow{k} \mathrm{A} + 2 \mathrm{C} + \mathrm{D} \\
\mathrm{C} + \mathrm{D} &amp;\xrightarrow{b} 2 \mathrm{A} + 3 \mathrm{B}  
 \end{align*}
 \]</p><p>We can think of the first reaction as converting the <em>reaction complex</em>, <span>$2A+3B$</span> to the complex <span>$A+2C+D$</span> with rate <span>$k$</span>. Suppose we order our species the same way as Catalyst does, i.e.</p><p class="math-container">\[\begin{pmatrix}
x_1(t)\\
x_2(t)\\
x_3(t)\\
x_4(t)
\end{pmatrix} =
\begin{pmatrix}
A(t)\\
B(t)\\
C(t)\\
D(t)
\end{pmatrix},\]</p><p>which should be the same as</p><pre><code class="language-julia hljs">species(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 A(t)
 B(t)
 C(t)
 D(t)</code></pre><p>We can describe a given reaction complex by the stoichiometric coefficients of each species within the complex. For the reactions in <code>rn</code> these vectors would be</p><p class="math-container">\[\begin{align*}
2A+3B = \begin{pmatrix}
2\\
3\\
0\\
0
\end{pmatrix}, &amp;&amp;
A+2C+D = \begin{pmatrix}
1\\
0\\
2\\
1
\end{pmatrix},
 &amp;&amp;
C+D = \begin{pmatrix}
0\\
0\\
1\\
1
\end{pmatrix}
\end{align*}\]</p><p>Catalyst can calculate these representations as the columns of the complex stoichiometry matrix,</p><pre><code class="language-julia hljs">Z = complexstoichmat(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×3 Matrix{Int64}:
 2  1  0
 3  0  0
 0  2  1
 0  1  1</code></pre><p>If we have <span>$C$</span> complexes, <span>$Z$</span> is a <span>$M$</span> by <span>$C$</span> matrix with <span>$Z_{m c}$</span> giving the stoichiometric coefficient of species <span>$m$</span> within complex <span>$c$</span>.</p><p>We can use this representation to provide another representation of the RRE ODEs. The net stoichiometry matrix can be factored as <span>$N = Z B$</span>, where <span>$B$</span> is called the incidence matrix of the reaction network,</p><pre><code class="language-julia hljs">B = incidencemat(rn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×2 Matrix{Int64}:
 -1   1
  1   0
  0  -1</code></pre><p>Here <span>$B$</span> is a <span>$C$</span> by <span>$K$</span> matrix with <span>$B_{c k} = 1$</span> if complex <span>$c$</span> appears as a product of reaction <span>$k$</span>, and <span>$B_{c k} = -1$</span> if complex <span>$c$</span> is a substrate of reaction <span>$k$</span>.</p><p>Using our decomposition of <span>$N$</span>, the RRE ODEs become</p><p class="math-container">\[\frac{dx}{dt} = Z B \mathbf{v}(\mathbf{x}(t),t).\]</p><p>Let&#39;s verify that <span>$N = Z B$</span>,</p><pre><code class="language-julia hljs">N = netstoichmat(rn)
N == Z*B</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Reaction complexes give an alternative way to visualize a reaction network graph. Catalyst&#39;s <a href="../../api/core_api/#Catalyst.plot_complexes-Tuple{ReactionSystem}"><code>plot_complexes</code></a> command will calculate the complexes of a network and then show how they are related. For example, we can run</p><pre><code class="language-julia hljs">plot_complexes(rn)</code></pre><img src="9b20ee52.png" alt="Example block output"/><p>while for the repressilator we find</p><pre><code class="language-julia hljs">plot_complexes(repressilator)</code></pre><img src="9845e30e.png" alt="Example block output"/><p>Here ∅ represents the empty complex, black arrows show reactions converting substrate complexes into product complexes where the rate is just a number or parameter, and red arrows indicate the conversion of substrate complexes into product complexes where the rate is an expression involving chemical species.</p><h1 id="Full-decomposition-of-the-reaction-network-ODEs-(flux-matrix-and-mass-action-vector)"><a class="docs-heading-anchor" href="#Full-decomposition-of-the-reaction-network-ODEs-(flux-matrix-and-mass-action-vector)">Full decomposition of the reaction network ODEs (flux matrix and mass-action vector)</a><a id="Full-decomposition-of-the-reaction-network-ODEs-(flux-matrix-and-mass-action-vector)-1"></a><a class="docs-heading-anchor-permalink" href="#Full-decomposition-of-the-reaction-network-ODEs-(flux-matrix-and-mass-action-vector)" title="Permalink"></a></h1><p>So far we have covered two equivalent descriptions of the chemical reaction network ODEs: </p><p class="math-container">\[\begin{align}
\frac{d\mathbf{x}}{dt} &amp;= N \mathbf{v}(\mathbf{x}(t),t) \\
&amp;= Z B \mathbf{v}(\mathbf{x}(t),t).
\end{align}\]</p><p>In this section we discuss a further decomposition of the ODEs. Recall the reaction rate vector <span>$\mathbf{v}$</span>, which is a vector of length <span>$R$</span> whose elements are the rate expressions for each reaction. Its elements can be written as </p><p class="math-container">\[\mathbf{v}_{y \rightarrow y&#39;} = k_{y \rightarrow y&#39;} \mathbf{x}^y,\]</p><p>where <span>$\mathbf{x}^y = \prod_s x_s^{y_s}$</span> denotes the mass-action product of the substrate complex <span>$y$</span> from the <span>$y \rightarrow y&#39;$</span> reaction. We can define a new vector called the mass action vector <span>$\Phi(\mathbf{x}(t))$</span>, a vector of length <span>$C$</span> whose elements are the mass action products of each complex: </p><pre><code class="language-julia hljs">Φ = massactionvector(rn)</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
\frac{1}{12} \left( A\left( t \right) \right)^{2} \left( B\left( t \right) \right)^{3} \\
\frac{1}{2} \left( C\left( t \right) \right)^{2} D\left( t \right) A\left( t \right) \\
D\left( t \right) C\left( t \right) \\
\end{array}
\right]
\end{equation}
 \]</p><p>An important thing to note is this function assumes <a href="../../introduction_to_catalyst/introduction_to_catalyst/#introduction_to_catalyst_ratelaws">combinatoric ratelaws</a>, meaning that mass-action products will get rescaled by factorial factors. For instance, note that the mass-action product for the complex <code>2A + 3B</code> has a factor of 1/12, corresponding to 1/(2! 3!). This option can be turned off with <code>combinatoric_ratelaws = false</code>.</p><pre><code class="language-julia hljs">Φ_2 = massactionvector(rn; combinatoric_ratelaws = false)</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
\left( A\left( t \right) \right)^{2} \left( B\left( t \right) \right)^{3} \\
\left( C\left( t \right) \right)^{2} D\left( t \right) A\left( t \right) \\
D\left( t \right) C\left( t \right) \\
\end{array}
\right]
\end{equation}
 \]</p><p>Then the reaction rate vector <span>$\mathbf{v}$</span> can be written as </p><p class="math-container">\[\mathbf{v}(\mathbf{x}(t)) = K \Phi(\mathbf{x}(t))\]</p><p>where <span>$K$</span> is an <span>$R$</span>-by-<span>$C$</span> matrix called the flux matrix, where <span>$K_{rc}$</span> is the rate constant of reaction <span>$r$</span> if <span>$c$</span> is the index of the substrate complex of reaction <span>$r$</span>, and 0 otherwise. In Catalyst, the API function for <span>$K$</span> is <code>fluxmat</code>: </p><pre><code class="language-julia hljs">K = fluxmat(rn)</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{ccc}
k &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; b \\
\end{array}
\right]
\end{equation}
 \]</p><p>Since we have that <span>$\mathbf{v} = K\Phi$</span>, we can rewrite the above decompositions as follows: </p><p class="math-container">\[\begin{align}
\frac{d\mathbf{x}}{dt} &amp;= N \mathbf{v}(\mathbf{x}(t),t) \\
&amp;= N K \Phi(\mathbf{x}(t),t) \\
&amp;= Z B K \Phi(\mathbf{x}(t),t). 
\end{align}\]</p><p>The final matrix to discuss is the product of <span>$A_k = BK$</span>, which is a <span>$C$</span>-by-<span>$C$</span> matrix that turns out to be exactly the negative of the <a href="https://en.wikipedia.org/wiki/Laplacian_matrix">graph Laplacian</a> of the weighted graph whose nodes are reaction complexes and whose edges represent reactions, weighted by the rate constants. The API function for <span>$A_k$</span> is the <code>laplacianmat</code>: </p><pre><code class="language-julia hljs">A_k = laplacianmat(rn)</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{ccc}
 - k &amp; 0 &amp; b \\
k &amp; 0 &amp; 0 \\
0 &amp; 0 &amp;  - b \\
\end{array}
\right]
\end{equation}
 \]</p><p>We can check that </p><pre><code class="language-julia hljs">isequal(A_k, B * K)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Note that we have used <code>isequal</code> instead of <code>==</code> here because <code>laplacianmat</code> returns a <code>Matrix{Num}</code>, since some of its entries are symbolic rate constants (symbolic variables and <code>Num</code>s cannot be compared using <code>==</code>, since <code>a == b</code> is interpreted as a symbolic expression).</p><p>In summary, we have that</p><p class="math-container">\[\begin{align}
\frac{d\mathbf{x}}{dt} &amp;= N \mathbf{v}(\mathbf{x}(t),t) \\
&amp;= N K \Phi(\mathbf{x}(t),t) \\
&amp;= Z B K \Phi(\mathbf{x}(t),t) \\ 
&amp;= Z A_k \Phi(\mathbf{x}(t),t). 
\end{align}\]</p><p>All three of the objects introduced in this section (the flux matrix, mass-action vector, and Laplacian matrix) will return symbolic outputs by default, but can be made to return numerical outputs if values are specified.  For example, <code>massactionvector</code> will return a numerical output if a set of species concentrations is supplied using a dictionary, tuple, or vector of Symbol-value pairs.</p><pre><code class="language-julia hljs">concmap = Dict([:A =&gt; 3., :B =&gt; 5., :C =&gt; 2.4, :D =&gt; 1.5])
massactionvector(rn, concmap)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 93.75
 12.96
  3.5999999999999996</code></pre><p><code>fluxmat</code> and <code>laplacianmat</code> will return numeric matrices if a set of rate constants and other parameters are supplied the same way.</p><pre><code class="language-julia hljs">parammap = Dict([:k =&gt; 12., :b =&gt; 8.])
fluxmat(rn, parammap)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3 Matrix{Float64}:
 12.0  0.0  0.0
  0.0  0.0  8.0</code></pre><pre><code class="language-julia hljs">laplacianmat(rn, parammap)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 Matrix{Float64}:
 -12.0  0.0   8.0
  12.0  0.0   0.0
   0.0  0.0  -8.0</code></pre><h2 id="Symbolic-ODE-functions"><a class="docs-heading-anchor" href="#Symbolic-ODE-functions">Symbolic ODE functions</a><a id="Symbolic-ODE-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-ODE-functions" title="Permalink"></a></h2><p>In some cases it might be useful to generate the function defining the system of ODEs as a symbolic Julia function that can be used for further analysis. This can be done using Symbolics&#39; <a href="https://docs.sciml.ai/Symbolics/stable/getting_started/#Building-Functions"><code>build_function</code></a>, which takes a symbolic expression and a set of desired arguments, and converts it into a Julia function taking those arguments.</p><p>Let&#39;s build the full symbolic function corresponding to our ODE system. <code>build_function</code> will return two expressions, one for a function that outputs a new vector for the result, and one for a function that modifies the input in-place. Either expression can then be evaluated to return a Julia function.</p><pre><code class="language-julia hljs">parammap = Dict([:k =&gt; 12., :b =&gt; 8.])
K = fluxmat(rn, parammap)
odes = N * K * Φ
f_oop_expr, f_iip_expr = Symbolics.build_function(odes, species(rn))
f = eval(f_oop_expr)

c = [3., 5., 2., 6.]
f(c)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
  -933.0
 -3087.0
  2154.0
  1029.0</code></pre><p>The generated <code>f</code> now corresponds to the <span>$f(\mathbf{x}(t))$</span> on the right-hand side of <span>$\frac{d\mathbf{x}(t)}{dt} = f(\mathbf{x}(t))$</span>. Given a vector of species concentrations <span>$c$</span>, <code>f</code> will return the rate of change of each species. Steady state concentration vectors <code>c_ss</code> will satisfy <code>f(c_ss) = zeros(length(species(rn)))</code>.</p><p>Above we have generated a numeric rate matrix to substitute the rate constants into the symbolic expressions. We could have used a symbolic rate matrix, but then we would need to define the parameters <code>k, b</code>, so that the function <code>f</code> knows what <code>k</code> and <code>b</code> in its output refer to.</p><pre><code class="language-julia hljs">@parameters k b
K = fluxmat(rn)
odes = N * K * Φ
f_oop_expr, f_iip_expr = Symbolics.build_function(odes, species(rn))
f = eval(f_oop_expr)

c = [3., 5., 2., 6.]
f(c)</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
24 b - 93.75 k \\
36 b - 281.25 k \\
 - 12 b + 187.5 k \\
 - 12 b + 93.75 k \\
\end{array}
\right]
\end{equation}
 \]</p><p>Alternatively, if we use a symbolic rate matrix, we could define our function to take in both species concentrations and parameter values as arguments:</p><pre><code class="language-julia hljs">K = fluxmat(rn)
odes = N * K * Φ
f_oop_expr, f_iip_expr = Symbolics.build_function(odes, species(rn), parameters(rn))
f = eval(f_oop_expr)

c = [3., 5., 2., 6]; ks = [12., 4.]
f(c, ks)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
 -1029.0
 -3231.0
  2202.0
  1077.0</code></pre><p>Note also that <code>f</code> can take any vector with the right dimension (i.e. the number of species), not just a vector of <code>Number</code>, so it can be used to build, e.g. a vector of polynomials in Nemo for commutative algebraic methods.</p><h2 id="Properties-of-matrix-null-spaces"><a class="docs-heading-anchor" href="#Properties-of-matrix-null-spaces">Properties of matrix null spaces</a><a id="Properties-of-matrix-null-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Properties-of-matrix-null-spaces" title="Permalink"></a></h2><p>The null spaces of the matrices discussed in this section often have special meaning. Below we will discuss some of these properties.</p><p>Recall that we may write the net stoichiometry matrix <span>$N = ZB$</span>, where <code>Z</code> is the complex stoichiometry matrix and <code>B</code> is the incidence matrix of the graph.</p><p><a href="../../model_creation/conservation_laws/#conservation_laws">Conservation laws</a> arise as left null eigenvectors of the net stoichiometry matrix <span>$N$</span>, and cycles arise as right null eigenvectors of the stoichiometry matrix. A cycle may be understood as a sequence of reactions that leaves the overall species composition unchanged. These do not necessarily have to correspond to actual cycles in the graph.</p><p><a href="../crn_theory/#network_analysis_complex_and_detailed_balance">Complex balance</a> can be compactly formulated as the following: a set of steady state reaction fluxes is complex-balanced if it is in the nullspace of the incidence matrix <span>$B$</span>.</p><h2 id="API-Section-for-matrices-and-vectors"><a class="docs-heading-anchor" href="#API-Section-for-matrices-and-vectors">API Section for matrices and vectors</a><a id="API-Section-for-matrices-and-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#API-Section-for-matrices-and-vectors" title="Permalink"></a></h2><p>We have that: </p><ul><li><span>$N$</span> is the <code>netstoichmat</code></li><li><span>$Z$</span> is the <code>complexstoichmat</code></li><li><span>$B$</span> is the <code>incidencemat</code></li><li><span>$K$</span> is the <code>fluxmat</code></li><li><span>$A_k$</span> is the <code>laplacianmat</code></li><li><span>$\Phi$</span> is the <code>massactionvector</code></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.netstoichmat-network_analysis-odes" href="#Catalyst.netstoichmat-network_analysis-odes"><code>Catalyst.netstoichmat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">netstoichmat(rn, sparse=false)</code></pre><p>Returns the net stoichiometry matrix, <span>$N$</span>, with <span>$N_{i j}$</span> the net stoichiometric coefficient of the ith species within the jth reaction.</p><p>Notes:</p><ul><li>Set sparse=true for a sparse matrix representation</li><li>Caches the matrix internally within <code>rn</code> so subsequent calls are fast.</li><li>Note that constant species are not treated as reactants, but just components that modify the associated rate law. As such they do not contribute to the net stoichiometry matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/23ee62410071be9f797402f1c23ec7af7ea4a66b/src/reactionsystem.jl#L1069-L1080">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.complexstoichmat-network_analysis-odes" href="#Catalyst.complexstoichmat-network_analysis-odes"><code>Catalyst.complexstoichmat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complexstoichmat(network::ReactionSystem; sparse=false)</code></pre><p>Given a <a href="../../api/core_api/#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and vector of reaction complexes, return a matrix with positive entries of size number of species by number of complexes, where the non-zero positive entries in the kth column denote stoichiometric coefficients of the species participating in the kth reaction complex.</p><p>Notes:</p><ul><li>Set sparse=true for a sparse matrix representation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/23ee62410071be9f797402f1c23ec7af7ea4a66b/src/network_analysis.jl#L146-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.incidencemat-network_analysis-odes" href="#Catalyst.incidencemat-network_analysis-odes"><code>Catalyst.incidencemat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">incidencemat(rn::ReactionSystem; sparse=false)</code></pre><p>Calculate the incidence matrix of <code>rn</code>, see <a href="../../api/network_analysis_api/#Catalyst.reactioncomplexes"><code>reactioncomplexes</code></a>.</p><p>Notes:</p><ul><li>Is cached in <code>rn</code> so that future calls, assuming the same sparsity, will also be fast.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/23ee62410071be9f797402f1c23ec7af7ea4a66b/src/network_analysis.jl#L136-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.fluxmat-network_analysis-odes" href="#Catalyst.fluxmat-network_analysis-odes"><code>Catalyst.fluxmat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fluxmat(rn::ReactionSystem, pmap = Dict(); sparse=false)</code></pre><p>Return an r×c matrix <span>$K$</span> such that, if complex <span>$j$</span> is the substrate complex of reaction <span>$i$</span>, then <span>$K_{ij} = k$</span>, the rate constant for this reaction. Mostly a helper function for the network Laplacian, <a href="../../api/network_analysis_api/#Catalyst.laplacianmat"><code>laplacianmat</code></a>. Has the useful property that <span>$\frac{dx}{dt} = S*K*Φ(x)$</span>, where S is the <a href="../../api/core_api/#Catalyst.netstoichmat"><code>netstoichmat</code></a> or net stoichiometry matrix and <span>$Φ(x)$</span> is the <a href="../../api/network_analysis_api/#Catalyst.massactionvector"><code>massactionvector</code></a>.     Returns a symbolic matrix by default, but will return a numerical matrix if rate constants are specified as a <code>Tuple</code>, <code>Vector</code>, or <code>Dict</code> of symbol-value pairs via <code>pmap</code>.</p><p><strong>Warning</strong>: Unlike other Catalyst functions, the <code>fluxmat</code> function will return a <code>Matrix{Num}</code> in the symbolic case. This is to allow easier computation of the matrix decomposition of the ODEs, and to ensure that multiplying the sparse form of the matrix will work.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/23ee62410071be9f797402f1c23ec7af7ea4a66b/src/network_analysis.jl#L210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.laplacianmat-network_analysis-odes" href="#Catalyst.laplacianmat-network_analysis-odes"><code>Catalyst.laplacianmat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">laplacianmat(rn::ReactionSystem, pmap=Dict(); sparse=false)</code></pre><p>Return the negative of the graph Laplacian of the reaction network. The ODE system of a chemical reaction network can be factorized as <span>$\frac{dx}{dt} = Y A_k Φ(x)$</span>, where <span>$Y$</span> is the <a href="../../api/network_analysis_api/#Catalyst.complexstoichmat"><code>complexstoichmat</code></a> and <span>$A_k$</span> is the negative of the graph Laplacian, and <span>$Φ$</span> is the <a href="../../api/network_analysis_api/#Catalyst.massactionvector"><code>massactionvector</code></a>. <span>$A_k$</span> is an n-by-n matrix, where n is the number of complexes, where <span>$A_{ij} = k_{ij}$</span> if a reaction exists between the two complexes and 0 otherwise.</p><p>Returns a symbolic matrix by default, but will return a numerical matrix if parameter values are specified via pmap. </p><p><strong>Warning</strong>: Unlike other Catalyst functions, the <code>laplacianmat</code> function will return a <code>Matrix{Num}</code> in the symbolic case. This is to allow easier computation of the matrix decomposition of the ODEs, and to ensure that multiplying the sparse form of the matrix will work.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/23ee62410071be9f797402f1c23ec7af7ea4a66b/src/network_analysis.jl#L195-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catalyst.massactionvector-network_analysis-odes" href="#Catalyst.massactionvector-network_analysis-odes"><code>Catalyst.massactionvector</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">massactionvector(rn::ReactionSystem, scmap = Dict(); combinatoric_ratelaws = true)</code></pre><p>Return the vector whose entries correspond to the &quot;mass action products&quot; of each complex. For example, given the complex A + B, the corresponding entry of the vector would be <span>$A*B$</span>, and for the complex 2X + Y, the corresponding entry would be <span>$X^2*Y$</span>. The ODE system of a chemical reaction network can be factorized as <span>$rac{dx}{dt} = Y A_k Φ(x)$</span>, where <span>$Y$</span> is the <a href="../../api/network_analysis_api/#Catalyst.complexstoichmat"><code>complexstoichmat</code></a> and <span>$A_k$</span> is the negative of the <a href="../../api/network_analysis_api/#Catalyst.laplacianmat"><code>laplacianmat</code></a>. This utility returns <span>$Φ(x)$</span>.</p><p>Returns a symbolic vector by default, but will return a numerical vector if species concentrations are specified as a tuple, vector, or dictionary via scmap.</p><p>If the <code>combinatoric_ratelaws</code> option is set, will include prefactors for that (see <a href="../../introduction_to_catalyst/introduction_to_catalyst/#introduction_to_catalyst_ratelaws">introduction to Catalyst&#39;s rate laws</a>. Will default to the default for the system.</p><p><strong>Warning</strong>: Unlike other Catalyst functions, the <code>massactionvector</code> function will return a <code>Vector{Num}</code> in the symbolic case. This is to allow easier computation of the matrix decomposition of the ODEs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/23ee62410071be9f797402f1c23ec7af7ea4a66b/src/network_analysis.jl#L287-L297">source</a></section></article><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://link.springer.com/book/10.1007/978-3-030-03858-8?noAccess=true">Feinberg, M. <em>Foundations of Chemical Reaction Network Theory</em>, Applied Mathematical Sciences 202, Springer (2019).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../model_simulation/examples/interactive_brusselator_simulation/">« Interactive Simulation and Plotting</a><a class="docs-footer-nextpage" href="../crn_theory/">Chemical Reaction Network Theory »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Friday 25 April 2025 03:09">Friday 25 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
