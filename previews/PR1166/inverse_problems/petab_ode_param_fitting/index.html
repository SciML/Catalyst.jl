<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parameter Fitting for ODEs using PEtab.jl · Catalyst.jl</title><meta name="title" content="Parameter Fitting for ODEs using PEtab.jl · Catalyst.jl"/><meta property="og:title" content="Parameter Fitting for ODEs using PEtab.jl · Catalyst.jl"/><meta property="twitter:title" content="Parameter Fitting for ODEs using PEtab.jl · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/inverse_problems/petab_ode_param_fitting/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/inverse_problems/petab_ode_param_fitting/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/inverse_problems/petab_ode_param_fitting/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Introduction to Catalyst</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Model creation and properties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../model_creation/conservation_laws/">Working with conservation laws</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/reactionsystem_content_accessing/">Accessing model properties</a></li><li><a class="tocitem" href="../../model_creation/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Model simulation and visualization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for performant ODE simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for performant SDE simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/examples/periodic_events_simulation/">Modelling a periodic event during ODE and jump simulations</a></li><li><a class="tocitem" href="../../model_simulation/examples/interactive_brusselator_simulation/">Interactive Simulation and Plotting</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Steady state analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Inverse problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Parameter Fitting for ODEs using PEtab.jl</a><ul class="internal"><li><a class="tocitem" href="#Introductory-example"><span>Introductory example</span></a></li><li><a class="tocitem" href="#petab_observables"><span>Additional features: Observables</span></a></li><li><a class="tocitem" href="#petab_parameters"><span>Additional features: Parameters</span></a></li><li><a class="tocitem" href="#petab_simulation_conditions"><span>Simulation conditions</span></a></li><li><a class="tocitem" href="#petab_simulation_measurements"><span>Additional features: Measurements</span></a></li><li><a class="tocitem" href="#petab_simulation_initial_conditions"><span>Additional features: Initial conditions</span></a></li><li><a class="tocitem" href="#petab_simulation_options"><span>Additional features: Simulation options</span></a></li><li><a class="tocitem" href="#petab_optimisation"><span>Additional features: Optimisation</span></a></li><li><a class="tocitem" href="#Objective-function-extraction"><span>Objective function extraction</span></a></li><li><a class="tocitem" href="#petab_multistart_optimisation"><span>Multi-start optimisation</span></a></li><li><a class="tocitem" href="#petab_events"><span>Events</span></a></li><li><a class="tocitem" href="#petab_plotting"><span>Plot recipes</span></a></li><li><a class="tocitem" href="#petab_citations"><span>Citations</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl</a></li><li><a class="tocitem" href="../behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Spatial modelling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial jump simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../devdocs/dev_guide/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Inverse problems</a></li><li class="is-active"><a href>Parameter Fitting for ODEs using PEtab.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parameter Fitting for ODEs using PEtab.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/inverse_problems/petab_ode_param_fitting.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="petab_parameter_fitting"><a class="docs-heading-anchor" href="#petab_parameter_fitting">Parameter Fitting for ODEs using PEtab.jl</a><a id="petab_parameter_fitting-1"></a><a class="docs-heading-anchor-permalink" href="#petab_parameter_fitting" title="Permalink"></a></h1><p>The <a href="https://github.com/sebapersson/PEtab.jl">PEtab.jl package</a> implements the <a href="https://petab.readthedocs.io/en/latest/">PEtab format</a> for fitting the parameters of deterministic CRN models to data <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. PEtab.jl both implements methods for creating cost functions (determining how well parameter sets fit to data), and for minimizing these cost functions. The PEtab approach covers most cases of fitting deterministic (ODE) models to data and is a good default choice when fitting reaction rate equation ODE models. This page describes how to combine PEtab.jl and Catalyst for parameter fitting, with the PEtab.jl package providing <a href="https://sebapersson.github.io/PEtab.jl/stable/">a more extensive documentation</a> (this tutorial is partially an adaptation of this documentation). </p><p>While PEtab&#39;s interface generally is very flexible, there might be specific use-cases where it cannot create an appropriate cost-function. Here, it is recommended to instead look at using <a href="../optimization_ode_param_fitting/#optimization_parameter_fitting">Optimization.jl</a>.</p><h2 id="Introductory-example"><a class="docs-heading-anchor" href="#Introductory-example">Introductory example</a><a id="Introductory-example-1"></a><a class="docs-heading-anchor-permalink" href="#Introductory-example" title="Permalink"></a></h2><p>Let us consider a simple catalysis network, where an enzyme (<span>$E$</span>) turns a substrate (<span>$S$</span>) into a product (<span>$P$</span>):</p><pre><code class="language-julia hljs">using Catalyst, PEtab

rn = @reaction_network begin
    kB, S + E --&gt; SE
    kD, SE --&gt; S + E
    kP, SE --&gt; P + E
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{S} + \mathrm{E} &amp;\xrightleftharpoons[\mathtt{kD}]{\mathtt{kB}} \mathrm{\mathtt{SE}} \\
\mathrm{\mathtt{SE}} &amp;\xrightarrow{\mathtt{kP}} \mathrm{P} + \mathrm{E}  
 \end{align*}
 \]</p><p>From some known initial condition, and a true parameter set (which we later want to recover from the data) we generate synthetic data (on which we will demonstrate the fitting process).</p><pre><code class="language-julia hljs"># Define initial conditions and parameters.
u0 = [:S =&gt; 1.0, :E =&gt; 1.0, :SE =&gt; 0.0, :P =&gt; 0.0]
p_true = [:kB =&gt; 1.0, :kD =&gt; 0.1, :kP =&gt; 0.5]

# Generate synthetic data.
using OrdinaryDiffEqDefault
oprob_true = ODEProblem(rn, u0, (0.0, 10.0), p_true)
true_sol = solve(oprob_true)
data_sol = solve(oprob_true; saveat = 1.0)
data_ts = data_sol.t[2:end]
data_vals = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]

# Plots the true solutions and the (synthetic data) measurements.
using Plots
plot(true_sol; idxs = :P, label = &quot;True solution&quot;, lw = 4)
plot!(data_ts, data_vals; label = &quot;Measurements&quot;, seriestype = :scatter, ms = 6, color = :blue)</code></pre><img src="a7402474.svg" alt="Example block output"/><p>Generally, PEtab takes five different inputs to define an optimisation problem (the minimiser of which generates a fitted parameter set):</p><ol><li><strong>Model</strong>: The model which we want to fit to the data (a <code>ReactionSystem</code>).</li><li><strong>Observables</strong>: The possible observables that can be measured (a <code>Dict{String,PEtabObservable}</code>).</li><li><strong>Estimation parameters</strong>: The parameters which we want to fit to the data (a <code>Vector{PEtabParameter}</code>).</li><li><strong>Experimental (or simulation) conditions</strong>: The simulations (each corresponding to a potential experiment) carried out during each step of the optimisation process (a <code>Dict{String,Dict{Symbol,Float64}}</code>).</li><li><strong>Measurements</strong>: The measurements to which the model is fitted (a <code>DataFrame</code>).</li></ol><h3 id="Observables"><a class="docs-heading-anchor" href="#Observables">Observables</a><a id="Observables-1"></a><a class="docs-heading-anchor-permalink" href="#Observables" title="Permalink"></a></h3><p>The observables define the quantities that we may measure in our experiments. Typically, each corresponds to a single species, however, <a href="#petab_observables_observables">more complicated observables are possible</a>. For each observable, we also need a noise formula, defining the uncertainty in its measurements. By default, PEtab assumes normally distributed noise, with a mean equal to the true value and a standard deviation which we have to define. It is also possible to use <a href="#petab_observables_noise_formula">more advanced noise formulas</a>.</p><p>In our example, we only have a single possible observable, the <code>P</code> species. We will assume that the noise is normally distributed with a standard deviation <code>0.5</code> (in our case this is not true, however, typically the noise distribution is unknown and a guess must be made). We combine this information in a <code>PEtabObservable</code> struct (to access the <code>P</code> species we must use <a href="../../model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_symbolic_representation"><code>@unpack</code></a>). Finally, we store all our observables in a dictionary, giving each an id tag (which is later used in the measurements input).</p><pre><code class="language-julia hljs">@unpack P = rn
obs_P = PEtabObservable(P, 0.5)
observables = Dict(&quot;obs_P&quot; =&gt; obs_P)</code></pre><h3 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h3><p>Each parameter of the system can either be</p><ol><li>Known (described <a href="#petab_parameters_known">here</a>).</li><li>Depend on experimental/simulation conditions (described <a href="#petab_simulation_conditions">here</a>).</li><li>Be an unknown that we wish to fit to data.</li></ol><p>In our case, we wish to fit all three system parameters (<span>$kB$</span>, <span>$kD$</span>, and <span>$kP$</span>). For each, we create a single <code>PEtabParameter</code>, and then gather these into a single vector.</p><pre><code class="language-julia hljs">par_kB = PEtabParameter(:kB)
par_kD = PEtabParameter(:kD)
par_kP = PEtabParameter(:kP)
params = [par_kB, par_kD, par_kP]</code></pre><p>For each parameter, it is also possible to set <a href="#petab_parameters_bounds">a lower and/or upper bound</a> (by default, <span>$(0.001,1000)$</span> is used), set whether to use <a href="#petab_parameters_scales">logarithmic or linear scale</a>, or add a <a href="#petab_parameters_priors">prior distribution of its value</a>.</p><h3 id="Simulation-conditions"><a class="docs-heading-anchor" href="#Simulation-conditions">Simulation conditions</a><a id="Simulation-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-conditions" title="Permalink"></a></h3><p>Sometimes, several different experiments are performed on a system (each potentially generating several measurements). An experiment could e.g. be the time development of a system from a specific initial condition. Since each experimental condition (during the optimisation procedure, for a guess of the unknown parameters) generates a distinct simulation, these are also called simulation conditions. In our example, all data comes from a single experiment, and the simulation condition input is not required. How to define and use different experimental conditions is described <a href="#petab_simulation_conditions">here</a>.</p><h3 id="Measurements"><a class="docs-heading-anchor" href="#Measurements">Measurements</a><a id="Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Measurements" title="Permalink"></a></h3><p>Finally, we need to define the system measurements to which the parameters will be fitted. Each measurement combines:</p><ol><li>The observable which is observed (here we use the id tag defined in the <code>observables</code> dictionary).</li><li>The time point of the measurement.</li><li>The measured value.</li></ol><p>For cases where several simulation conditions are given, we also need to provide:</p><ol><li>The simulation condition which generates the measurement (<a href="#petab_simulation_conditions">here</a> is an example where this is used).</li></ol><p><em>Note also, when <a href="https://sebapersson.github.io/PEtab.jl/stable/Brannmark/">pre-equilibration</a> is used to initiate the system in a steady state, a fifth field is also required.</em></p><p>Each individual measurement is provided as a row of a <code>DataFrame</code>. The values are provided in the <code>obs_id</code>, <code>time</code>, <code>measurement</code>, and <code>simulation_id</code> columns. In our case we only need to fill in the first three:</p><pre><code class="language-julia hljs">using DataFrames
measurements = DataFrame(obs_id = &quot;obs_P&quot;, time = data_ts, measurement = data_vals)</code></pre><div><div style = "float: left;"><span>10×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">obs_id</th><th style = "text-align: left;">time</th><th style = "text-align: left;">measurement</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">1.0</td><td style = "text-align: right;">0.143532</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">2.0</td><td style = "text-align: right;">0.384062</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">3.0</td><td style = "text-align: right;">0.484386</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">4.0</td><td style = "text-align: right;">0.615729</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">5.0</td><td style = "text-align: right;">0.620503</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">6.0</td><td style = "text-align: right;">0.790439</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">7</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">7.0</td><td style = "text-align: right;">0.836538</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">8</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">8.0</td><td style = "text-align: right;">0.934431</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">9</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">9.0</td><td style = "text-align: right;">0.959457</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">10</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">10.0</td><td style = "text-align: right;">0.86184</td></tr></tbody></table></div><p>Since, in our example, all measurements are of the same observable, we can set <code>obs_id=&quot;obs_P&quot;</code>. However, it is also possible to <a href="#petab_simulation_measurements_several_observables">include measurements from several different observables</a>.</p><h3 id="Creating-a-PEtabModel"><a class="docs-heading-anchor" href="#Creating-a-PEtabModel">Creating a PEtabModel</a><a id="Creating-a-PEtabModel-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-PEtabModel" title="Permalink"></a></h3><p>Finally, we combine all inputs in a single <code>PEtabModel</code>. To it, we also pass the initial conditions of our simulations (using the <code>speciemap</code> argument). It is also possible to have <a href="#petab_simulation_initial_conditions_uncertainty">initial conditions with uncertainty</a>, <a href="#petab_simulation_conditions">that vary between different simulations</a>, or <a href="#petab_simulation_initial_conditions_fitted">that we attempt to fit to the data</a>.</p><pre><code class="language-julia hljs">petab_model = PEtabModel(rn, observables, measurements, params; speciemap = u0)</code></pre><h3 id="Fitting-parameters"><a class="docs-heading-anchor" href="#Fitting-parameters">Fitting parameters</a><a id="Fitting-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-parameters" title="Permalink"></a></h3><p>We are now able to fit our model to the data. First, we create a <code>PEtabODEProblem</code>. Here, we use <code>petab_model</code> as the only input, but it is also possible to set various <a href="#petab_simulation_options">numeric solver and automatic differentiation options</a> (such as method or tolerance).</p><pre><code class="language-julia hljs">petab_problem = PEtabODEProblem(petab_model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabODEProblem:</span> <span class="sgr34">ReactionSystemModel</span> with ODE-states 4 and 3 parameters to estimate
---------------- <span class="sgr1">Problem options</span> ---------------
Gradient method: <span class="sgr34">ForwardDiff</span>
Hessian method: <span class="sgr34">ForwardDiff</span>
ODE-solver nllh: <span class="sgr34">Rodas5P</span>
ODE-solver gradient: <span class="sgr34">Rodas5P</span></code></pre><p>Since no additional input is given, default options are selected by PEtab.jl (and generally, its choices are good).</p><p>To fit a parameter set we use the <code>calibrate</code> function. In addition to our <code>PEtabODEProblem</code>, we must also provide an initial guess (which can be generated with the <code>generate_startguesses</code> function) and an optimisation algorithm (which needs to be imported specifically). PEtab.jl supports various <a href="#petab_optimisation_optimisers">optimisation methods and options</a>.</p><pre><code class="language-julia hljs">using Optim
p0 = get_startguesses(petab_problem, 1)
res = calibrate(petab_problem, p0, IPNewton())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabOptimisationResult</span>
---------------- <span class="sgr1">Summary</span> ---------------
min(f)                = 2.30e+00
Parameters estimated  = 3
Optimiser iterations  = 21
Runtime               = 2.9e-01s
Optimiser algorithm   = Optim_IPNewton
</code></pre><p>We can now simulate our model for the fitted parameter set, and compare the result to the measurements and true solution.</p><pre><code class="language-julia hljs">oprob_fitted = remake(oprob_true; p = get_ps(res, petab_problem))
fitted_sol = solve(oprob_fitted)
plot!(fitted_sol; idxs = :P, label = &quot;Fitted solution&quot;, linestyle = :dash, lw = 4, color = :lightblue)</code></pre><img src="7b182cea.svg" alt="Example block output"/><p>Here we use the <code>get_ps</code> function to retrieve a full parameter set using the optimal parameters. Alternatively, the <code>ODEProblem</code> or fitted simulation can be retrieved directly using the <code>get_odeproblem</code> or <code>get_odesol</code> <a href="https://sebapersson.github.io/PEtab.jl/stable/API/">functions</a>, respectively (and the initial condition using the <code>get_u0</code> function). The calibration result can also be found in <code>res.xmin</code>, however, note that PEtab automatically (<a href="#petab_parameters_scales">unless a linear scale is selected</a>) converts parameters to logarithmic scale, so typically <code>10 .^res.xmin</code> are the values of interest. If you investigate the result from this example you might note, that even if PEtab.jl has found the global optimum (which fits the data well), this does not actually correspond to the true parameter set. This phenomenon is related to the concept of <em>identifiability</em>, which is very important for parameter fitting.</p><h3 id="Final-notes"><a class="docs-heading-anchor" href="#Final-notes">Final notes</a><a id="Final-notes-1"></a><a class="docs-heading-anchor-permalink" href="#Final-notes" title="Permalink"></a></h3><p>PEtab.jl also supports <a href="#petab_multistart_optimisation">multistart optimisation</a>, <a href="https://sebapersson.github.io/PEtab.jl/stable/petab_preeq_simulations/">automatic pre-equilibration before simulations</a>, and <a href="#petab_events">events</a>. Various <a href="#petab_plotting">plot recipes</a> exist for investigating the optimisation process. Please read the <a href="https://sebapersson.github.io/PEtab.jl/stable/">PEtab.jl documentation</a> for a more complete description of the package&#39;s features. Below follows additional details of various options and features (generally, PEtab is able to find good default values for most options that are not specified).</p><h2 id="petab_observables"><a class="docs-heading-anchor" href="#petab_observables">Additional features: Observables</a><a id="petab_observables-1"></a><a class="docs-heading-anchor-permalink" href="#petab_observables" title="Permalink"></a></h2><h3 id="petab_observables_observables"><a class="docs-heading-anchor" href="#petab_observables_observables">Defining non-trivial observables</a><a id="petab_observables_observables-1"></a><a class="docs-heading-anchor-permalink" href="#petab_observables_observables" title="Permalink"></a></h3><p>It is possible for observables to be any algebraic expression of species concentrations and parameters. E.g. in this example the total amount of <code>X</code> in the system is an observable:</p><pre><code class="language-julia hljs">two_state_model = @reaction_network begin
    (k1,k2), X1 &lt;--&gt; X2
end
@unpack X1, X2 = two_state_model
obs_X = PEtabObservable(X1 + X2, 0.5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabObservable:</span> <span class="sgr34">h</span> = X1(t) + X2(t) and <span class="sgr34">sd</span> = 0.5 with normal measurement noise</code></pre><p>A common application for this is to define an <a href="https://sebapersson.github.io/PEtab.jl/stable/petab_obs_noise/"><em>offset</em> and a <em>scale</em> for each observable</a>.</p><h3 id="petab_observables_noise_formula"><a class="docs-heading-anchor" href="#petab_observables_noise_formula">Advanced observables noise formulas</a><a id="petab_observables_noise_formula-1"></a><a class="docs-heading-anchor-permalink" href="#petab_observables_noise_formula" title="Permalink"></a></h3><p>In our basic example we assumed that the normally distributed noise had a standard deviation of <code>0.5</code>. However, this value may be a parameter (or indeed any algebraic expression). E.g, we could set</p><pre><code class="language-julia hljs">@parameters σ
obs_P = PEtabObservable(P, σ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabObservable:</span> <span class="sgr34">h</span> = P(t) and <span class="sgr34">sd</span> = σ with normal measurement noise</code></pre><p>and then let the parameter <span>$σ$</span> vary between different <a href="#petab_simulation_conditions">simulation conditions</a>. Alternatively we could let the noise scale linearly with the species&#39; concentration:</p><pre><code class="language-julia hljs">obs_P = PEtabObservable(P, 0.05P)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabObservable:</span> <span class="sgr34">h</span> = P(t) and <span class="sgr34">sd</span> = 0.05P(t) with normal measurement noise</code></pre><p>It would also be possible to make <span>$σ$</span> a <em>parameter that is fitted as a part of the parameter fitting process</em>.</p><p>PEtab.jl assumes that noise is normally distributed (with a standard deviation equal to the second argument provided to <code>PEtabObservable</code>). The only other (currently implemented) noise distribution is log-normally distributed noise, which is designated through the <code>transformation=:log</code> argument:</p><pre><code class="language-julia hljs">obs_P = PEtabObservable(P, σ; transformation = :log)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabObservable:</span> <span class="sgr34">h</span> = P(t) and <span class="sgr34">sd</span> = σ with log-normal measurement noise</code></pre><h2 id="petab_parameters"><a class="docs-heading-anchor" href="#petab_parameters">Additional features: Parameters</a><a id="petab_parameters-1"></a><a class="docs-heading-anchor-permalink" href="#petab_parameters" title="Permalink"></a></h2><h3 id="petab_parameters_known"><a class="docs-heading-anchor" href="#petab_parameters_known">Known parameters</a><a id="petab_parameters_known-1"></a><a class="docs-heading-anchor-permalink" href="#petab_parameters_known" title="Permalink"></a></h3><p>In our previous example, all parameters were unknowns that we wished to fit to the data. If any parameters have known values, it is possible to provide these to <code>PEtabModel</code> through the <code>parameter_map</code> argument. E.g if we had known that <span>$kB = 1.0$</span>, then we would only define <span>$kD$</span> and <span>$kP$</span> as parameters we wish to fit:</p><pre><code class="language-julia hljs">par_kD = PEtabParameter(:kD)
par_kP = PEtabParameter(:kP)
params = [par_kD, par_kP]</code></pre><p>We then provide <code>parameter_map=[:kB =&gt; 1.0]</code> when we assembly our model:</p><pre><code class="language-julia hljs">petab_model_known_param = PEtabModel(rn, observables, measurements, params; speciemap = u0, parametermap = [:kB =&gt; 1.0])</code></pre><h3 id="petab_parameters_bounds"><a class="docs-heading-anchor" href="#petab_parameters_bounds">Parameter bounds</a><a id="petab_parameters_bounds-1"></a><a class="docs-heading-anchor-permalink" href="#petab_parameters_bounds" title="Permalink"></a></h3><p>By default, when fitted, potential parameter values are assumed to be in the interval <span>$(1e-3, 1e3)$</span>. When declaring a <code>PEtabParameter</code> it is possible to change these values through the <code>lb</code> and <code>ub</code> arguments. E.g. we could use</p><pre><code class="language-julia hljs">par_kB = PEtabParameter(:kB; lb = 1e-2, ub = 1e2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabParameter:</span> <span class="sgr34">kB</span> estimated on log10-scale with bounds [1.0e-02, 1.0e+02]</code></pre><p>to achieve the more conservative bound <span>$(1e-2, 1e2)$</span> for the parameter <span>$kB$</span>.</p><h3 id="petab_parameters_scales"><a class="docs-heading-anchor" href="#petab_parameters_scales">Parameter scales</a><a id="petab_parameters_scales-1"></a><a class="docs-heading-anchor-permalink" href="#petab_parameters_scales" title="Permalink"></a></h3><p>Internally, parameters that are fitted are converted to a logarithmic scale (generally, this is considered advantageous<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>). To prevent this conversion, the <code>scale=:lin</code> argument can be used. Here we change the scale of <span>$kB$</span> to linear:</p><pre><code class="language-julia hljs">par_kB = PEtabParameter(:kB; scale = :lin)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabParameter:</span> <span class="sgr34">kB</span> estimated on lin-scale with bounds [1.0e-03, 1.0e+03]</code></pre><h3 id="petab_parameters_priors"><a class="docs-heading-anchor" href="#petab_parameters_priors">Parameter priors</a><a id="petab_parameters_priors-1"></a><a class="docs-heading-anchor-permalink" href="#petab_parameters_priors" title="Permalink"></a></h3><p>If we have prior knowledge about the distribution of a parameter, it is possible to incorporate this into the model. The prior can be any continuous, univariate, distribution from the <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl package</a>. E.g we can use:</p><pre><code class="language-julia hljs">using Distributions
par_kB = PEtabParameter(:kB; prior = Normal(1.0,0.2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabParameter:</span> <span class="sgr34">kB</span> estimated on log10-scale with bounds [1.0e-03, 1.0e+03] and prior Normal(μ=1.0, σ=0.2)</code></pre><p>to set a normally distributed prior (with mean <code>1.0</code> and standard deviation <code>0.2</code>) on the value of <span>$kB$</span>. By default, the prior is assumed to be on the linear scale of the parameter (before any potential log transform). To specify that the prior is on the logarithmic scale, the <code>prior_on_linear_scale=false</code> argument can be provided:</p><pre><code class="language-julia hljs">par_kB = PEtabParameter(:kB; prior = Normal(1.0,0.2), prior_on_linear_scale = false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabParameter:</span> <span class="sgr34">kB</span> estimated on log10-scale with bounds [1.0e-03, 1.0e+03] and prior Normal(μ=1.0, σ=0.2)</code></pre><p>In this example, setting <code>prior_on_linear_scale=false</code> makes sense as a (linear) normal distribution is non-zero for negative values (an alternative is to use a log-normal distribution, e.g. <code>prior=LogNormal(3.0, 3.0)</code>).</p><h2 id="petab_simulation_conditions"><a class="docs-heading-anchor" href="#petab_simulation_conditions">Simulation conditions</a><a id="petab_simulation_conditions-1"></a><a class="docs-heading-anchor-permalink" href="#petab_simulation_conditions" title="Permalink"></a></h2><p>Sometimes, we have data from different experimental conditions. Here, when a potential parameter set is evaluated during the fitting process, each experimental condition corresponds to one simulation condition (which produces one simulation). To account for this, PEtab permits the user to define different simulation conditions, with each condition being defined by specific values for some initial conditions and/or parameters.</p><p>If, for our previous catalysis example, we had measured the system for two different initial values of <span>$S$</span> (<span>$S(0)=1.0$</span> and <span>$S(0)=\tfrac{1}{2}$</span>), these would correspond to two different simulation conditions. For each condition we define a <code>Dict</code> mapping the species to their initial condition (here, <span>$S$</span> is the only species in each <code>Dict</code>):</p><pre><code class="language-julia hljs">c1 = Dict(:S =&gt; 1.0)
c2 = Dict(:S =&gt; 0.5)</code></pre><p>Similarly as for observables, we then gather the conditions in another <code>Dict</code>, giving each an id tag:</p><pre><code class="language-julia hljs">simulation_conditions = Dict(&quot;c1&quot; =&gt; c1, &quot;c2&quot; =&gt; c2)</code></pre><p>Again (like for observables), each measurement in the measurements <code>DataFrame</code> needs to be associated with a simulation condition id tag (describing which condition those measurements were taken from). Parameters, just like initial conditions, may vary between different conditions. If an initial condition (or parameter) occurs in one condition, it must occur in all of them.</p><p>Here follows a complete version of our basic example, but with measurements both for <span>$S(0)=1.0$</span> and <span>$S(0)=\tfrac{1}{2}$</span>.</p><pre><code class="language-julia hljs">using Catalyst, PEtab

rn = @reaction_network begin
    kB, S + E --&gt; SE
    kD, SE --&gt; S + E
    kP, SE --&gt; P + E
end

u0 = [:E =&gt; 1.0, :SE =&gt; 0.0, :P =&gt; 0.0]
p_true = [:kB =&gt; 1.0, :kD =&gt; 0.1, :kP =&gt; 0.5]

# Simulate data.
using OrdinaryDiffEqDefault
t1, d1 = let
    oprob_true = ODEProblem(rn, [:S =&gt; 1.0; u0], (0.0, 10.0), p_true)
    data_sol = solve(oprob_true; saveat = 1.0)
    data_sol.t[2:end], (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]
end
t2, d2 = let
    oprob_true = ODEProblem(rn, [:S=&gt;0.5; u0], (0.0, 10.0), p_true)
    data_sol = solve(oprob_true; saveat = 1.0)
    data_sol.t[2:end], (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]
end

@unpack P = rn
obs_P = PEtabObservable(P, 0.5)
observables = Dict(&quot;obs_P&quot; =&gt; obs_P)

par_kB = PEtabParameter(:kB)
par_kD = PEtabParameter(:kD)
par_kP = PEtabParameter(:kP)
params = [par_kB, par_kD, par_kP]

c1 = Dict(:S =&gt; 1.0)
c2 = Dict(:S =&gt; 0.5)
simulation_conditions = Dict(&quot;c1&quot; =&gt; c1, &quot;c2&quot; =&gt; c2)

using DataFrames
m1 = DataFrame(simulation_id = &quot;c1&quot;, obs_id = &quot;obs_P&quot;, time = t1, measurement = d1)
m2 = DataFrame(simulation_id = &quot;c2&quot;, obs_id = &quot;obs_P&quot;, time = t2, measurement = d2)
measurements = vcat(m1,m2)

petab_model = PEtabModel(rn, observables, measurements, params; speciemap = u0,
                         simulation_conditions = simulation_conditions)</code></pre><p>Note that the <code>u0</code> we pass into <code>PEtabModel</code> through the <code>speciemap</code> argument no longer contains the value of <span>$S$</span> (as it is provided by the conditions).</p><h2 id="petab_simulation_measurements"><a class="docs-heading-anchor" href="#petab_simulation_measurements">Additional features: Measurements</a><a id="petab_simulation_measurements-1"></a><a class="docs-heading-anchor-permalink" href="#petab_simulation_measurements" title="Permalink"></a></h2><h3 id="petab_simulation_measurements_several_observables"><a class="docs-heading-anchor" href="#petab_simulation_measurements_several_observables">Measurements of several observables</a><a id="petab_simulation_measurements_several_observables-1"></a><a class="docs-heading-anchor-permalink" href="#petab_simulation_measurements_several_observables" title="Permalink"></a></h3><p>In our previous example, all our measurements were from a single observable, <code>obs_P</code>. If we also had collected measurements of both <span>$S$</span> and <span>$P$</span>:</p><pre><code class="language-julia hljs">data_ts = data_sol.t[2:end]
data_vals_S = (0.8 .+ 0.4*rand(10)) .* data_sol[:S][2:end]
data_vals_P = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]</code></pre><p>and then corresponding observables:</p><pre><code class="language-julia hljs">@unpack S, P = rn
obs_S = PEtabObservable(S, 0.5)
obs_P = PEtabObservable(P, 0.5)
observables = Dict(&quot;obs_S&quot; =&gt; obs_P, &quot;obs_P&quot; =&gt; obs_P)</code></pre><p>we are able to include all these measurements in the same <code>measurements</code> <code>DataFrame</code>:</p><pre><code class="language-julia hljs">m1 = DataFrame(obs_id = &quot;obs_P&quot;, time = data_ts, measurement = data_vals_S)
m2 = DataFrame(obs_id = &quot;obs_S&quot;, time = data_ts, measurement = data_vals_P)
measurements = vcat(m1,m2)</code></pre><div><div style = "float: left;"><span>20×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">obs_id</th><th style = "text-align: left;">time</th><th style = "text-align: left;">measurement</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">1.0</td><td style = "text-align: right;">0.434411</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">2.0</td><td style = "text-align: right;">0.284007</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">3.0</td><td style = "text-align: right;">0.154085</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">4.0</td><td style = "text-align: right;">0.122363</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">5.0</td><td style = "text-align: right;">0.0516099</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">6.0</td><td style = "text-align: right;">0.0415794</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">7</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">7.0</td><td style = "text-align: right;">0.0236093</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">8</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">8.0</td><td style = "text-align: right;">0.014263</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">9</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">9.0</td><td style = "text-align: right;">0.00835622</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">10</td><td style = "text-align: left;">obs_P</td><td style = "text-align: right;">10.0</td><td style = "text-align: right;">0.00528937</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">11</td><td style = "text-align: left;">obs_S</td><td style = "text-align: right;">1.0</td><td style = "text-align: right;">0.131136</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">12</td><td style = "text-align: left;">obs_S</td><td style = "text-align: right;">2.0</td><td style = "text-align: right;">0.354054</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">13</td><td style = "text-align: left;">obs_S</td><td style = "text-align: right;">3.0</td><td style = "text-align: right;">0.573911</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">14</td><td style = "text-align: left;">obs_S</td><td style = "text-align: right;">4.0</td><td style = "text-align: right;">0.559714</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">15</td><td style = "text-align: left;">obs_S</td><td style = "text-align: right;">5.0</td><td style = "text-align: right;">0.604119</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">16</td><td style = "text-align: left;">obs_S</td><td style = "text-align: right;">6.0</td><td style = "text-align: right;">0.82203</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">17</td><td style = "text-align: left;">obs_S</td><td style = "text-align: right;">7.0</td><td style = "text-align: right;">0.749124</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">18</td><td style = "text-align: left;">obs_S</td><td style = "text-align: right;">8.0</td><td style = "text-align: right;">0.937891</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">19</td><td style = "text-align: left;">obs_S</td><td style = "text-align: right;">9.0</td><td style = "text-align: right;">0.865251</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">20</td><td style = "text-align: left;">obs_S</td><td style = "text-align: right;">10.0</td><td style = "text-align: right;">1.01306</td></tr></tbody></table></div><p>which then can be used as input to <code>PEtabModel</code>.</p><h3 id="Varying-parameters-between-different-simulation-conditions"><a class="docs-heading-anchor" href="#Varying-parameters-between-different-simulation-conditions">Varying parameters between different simulation conditions</a><a id="Varying-parameters-between-different-simulation-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Varying-parameters-between-different-simulation-conditions" title="Permalink"></a></h3><p>Sometimes, the parameters that are used vary between the different conditions. Consider our catalysis example, if we had performed the experiment twice, using two different enzymes with different catalytic properties, this could have generated such conditions. The two enzymes could e.g. yield different rates (<span>$kP_1$</span> and <span>$kP_2$</span>) for the <code>SE --&gt; P + E</code> reaction, but otherwise be identical. Here, the parameters <span>$kP_1$</span> and <span>$kP_2$</span> are unique to their respective conditions. PEtab.jl provides support for cases such as this, and <a href="https://sebapersson.github.io/PEtab.jl/stable/petab_cond_specific/">its documentation</a> provided instructions of how to handle them.</p><h2 id="petab_simulation_initial_conditions"><a class="docs-heading-anchor" href="#petab_simulation_initial_conditions">Additional features: Initial conditions</a><a id="petab_simulation_initial_conditions-1"></a><a class="docs-heading-anchor-permalink" href="#petab_simulation_initial_conditions" title="Permalink"></a></h2><h3 id="petab_simulation_initial_conditions_fitted"><a class="docs-heading-anchor" href="#petab_simulation_initial_conditions_fitted">Fitting initial conditions</a><a id="petab_simulation_initial_conditions_fitted-1"></a><a class="docs-heading-anchor-permalink" href="#petab_simulation_initial_conditions_fitted" title="Permalink"></a></h3><p>Sometimes, initial conditions are uncertain quantities which we wish to fit to the data. This is possible <a href="../../model_creation/dsl_advanced/#dsl_advanced_options_parametric_initial_conditions">by defining an initial condition as a parameter</a>:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    @parameters E0
    @species E(t)=E0
    kB, S + E --&gt; SE
    kD, SE --&gt; S + E
    kP, SE --&gt; P + E
end</code></pre><p>Here, the initial value of <code>E</code> is equal to the parameter <code>E0</code>. We modify our <code>u0</code> vector by removing <code>E</code> (which is no longer known):</p><pre><code class="language-julia hljs">u0 = [:S =&gt; 1.0, :SE =&gt; 0.0, :P =&gt; 0.0]</code></pre><p>Next, we add <code>E0</code> to the parameters we wish to fit:</p><pre><code class="language-julia hljs">par_kB = PEtabParameter(:kB)
par_kD = PEtabParameter(:kD)
par_kP = PEtabParameter(:kP)
par_E0 = PEtabParameter(:E0)
params = [par_kB, par_kD, par_kP, par_E0]</code></pre><p>and we can use our updated <code>rn</code>, <code>u0</code>, and <code>params</code> as input to our <code>PEtabModel</code>.</p><h3 id="petab_simulation_initial_conditions_uncertainty"><a class="docs-heading-anchor" href="#petab_simulation_initial_conditions_uncertainty">Uncertain initial conditions</a><a id="petab_simulation_initial_conditions_uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#petab_simulation_initial_conditions_uncertainty" title="Permalink"></a></h3><p>Often, while an initial condition has been reported for an experiment, its exact value is uncertain. This can be modelled by making the initial condition a <a href="#petab_simulation_initial_conditions_fitted">parameter that is fitted to the data</a> and attaching a prior to it corresponding to our certainty about its value.</p><p>Let us consider our initial example, but where we want to add uncertainty to the initial conditions of <code>S</code> and <code>E</code>. We will add priors on these, assuming normal distributions with mean <code>1.0</code> and standard deviation <code>0.1</code>. For the synthetic measured data we will use the true values <span>$S(0) = E(0) = 1.0$</span>.</p><pre><code class="language-julia hljs">using Catalyst, Distributions, PEtab

rn = @reaction_network begin
    @parameters S0 E0
    @species S(t)=S0 E(t)=E0
    kB, S + E --&gt; SE
    kD, SE --&gt; S + E
    kP, SE --&gt; P + E
end

u0 = [:SE =&gt; 0.0, :P =&gt; 0.0]
p_true = [:kB =&gt; 1.0, :kD =&gt; 0.1, :kP =&gt; 0.5, :S0=&gt;1.0, :E0 =&gt; 1.0]

using OrdinaryDiffEqDefault
oprob_true = ODEProblem(rn, u0, (0.0, 10.0), p_true)
true_sol = solve(oprob_true)
data_sol = solve(oprob_true; saveat = 1.0)
data_ts = data_sol.t[2:end]
data_vals = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]

@unpack P = rn
obs_P = PEtabObservable(P, 0.5)
observables = Dict(&quot;obs_P&quot; =&gt; obs_P)

par_kB = PEtabParameter(:kB)
par_kD = PEtabParameter(:kD)
par_kP = PEtabParameter(:kP)
par_S0 = PEtabParameter(:S0; prior = Normal(1.0, 0.1))
par_E0 = PEtabParameter(:E0; prior = Normal(1.0, 0.1))
params = [par_kB, par_kD, par_kP, par_S0, par_E0]

using DataFrames
measurements = DataFrame(obs_id = &quot;obs_P&quot;, time = data_ts, measurement = data_vals)

petab_model = PEtabModel(rn, observables, measurements, params; speciemap = u0)</code></pre><p>Here, when we fit our data we will also gain values for <code>S0</code> and <code>E0</code>, however, unless we are explicitly interested in these, they can be ignored.</p><h2 id="petab_simulation_options"><a class="docs-heading-anchor" href="#petab_simulation_options">Additional features: Simulation options</a><a id="petab_simulation_options-1"></a><a class="docs-heading-anchor-permalink" href="#petab_simulation_options" title="Permalink"></a></h2><p>While in our basic example, we do not provide any additional information to our <code>PEtabODEProblem</code>, this is an opportunity to specify how the model should be simulated, and what automatic differentiation techniques to use for the optimisation procedure (if none are provided, appropriate defaults are selected).</p><p>Here is an example, adapted from the <a href="https://sebapersson.github.io/PEtab.jl/stable/default_options/">more detailed PEtab.jl documentation</a></p><pre><code class="language-julia hljs">using OrdinaryDiffEqRosenbrock
PEtabODEProblem(petab_model,
                odesolver = ODESolver(Rodas5P(), abstol = 1e-8, reltol = 1e-8),
                gradient_method = :ForwardDiff,
                hessian_method = :ForwardDiff)</code></pre><p>where we simulate our ODE model using the <code>Rodas5P</code> method (with absolute and relative tolerance both equal <code>1e-8</code>) and use <a href="https://github.com/JuliaDiff/ForwardDiff.jl">forward automatic differentiation</a> for both gradient and hessian computation. More details on available ODE solver options can be found in <a href="https://sebapersson.github.io/PEtab.jl/stable/API/#PEtabODEProblem">the PEtab.jl documentation</a>.</p><h2 id="petab_optimisation"><a class="docs-heading-anchor" href="#petab_optimisation">Additional features: Optimisation</a><a id="petab_optimisation-1"></a><a class="docs-heading-anchor-permalink" href="#petab_optimisation" title="Permalink"></a></h2><h3 id="petab_optimisation_optimisers"><a class="docs-heading-anchor" href="#petab_optimisation_optimisers">Optimisation methods and options</a><a id="petab_optimisation_optimisers-1"></a><a class="docs-heading-anchor-permalink" href="#petab_optimisation_optimisers" title="Permalink"></a></h3><p>For our examples, we have used the <code>Optim.IPNewton</code> optimisation method. PEtab.jl supports <a href="https://sebapersson.github.io/PEtab.jl/stable/pest_algs/">several additional optimisation methods</a>. Furthermore, <code>calibrate</code>&#39;s <code>options</code> argument permits the customisation of the options for any used optimiser. E.g. to designate the maximum number of iterations of the <code>Optim.IPNewton</code> method we would use:</p><pre><code class="language-julia hljs">res = calibrate(petab_problem, p0, IPNewton(); options = Optim.Options(iterations = 10000))</code></pre><p>Please read the <a href="https://sebapersson.github.io/PEtab.jl/stable/pest_algs/">PEtab.jl documentation</a> to learn how to customize the various optimisers&#39; properties.</p><h3 id="petab_optimisation_path_recording"><a class="docs-heading-anchor" href="#petab_optimisation_path_recording">Optimisation path recording</a><a id="petab_optimisation_path_recording-1"></a><a class="docs-heading-anchor-permalink" href="#petab_optimisation_path_recording" title="Permalink"></a></h3><p>To record all the parameter sets evaluated (and their objective values) during the optimisation procedure, provide the <code>save_trace=true</code> argument to <code>calibrate</code> (or <code>calibrate_multistart</code>):</p><pre><code class="language-julia hljs">res = calibrate(petab_problem, p0, IPNewton(); save_trace = true)</code></pre><p>This is required for the various <a href="#petab_plotting">optimisation evaluation plots</a> provided by PEtab.jl. If desired, this information can be accessed in the calibration output&#39;s <code>.xtrace</code> and <code>.ftrace</code> fields.</p><h2 id="Objective-function-extraction"><a class="docs-heading-anchor" href="#Objective-function-extraction">Objective function extraction</a><a id="Objective-function-extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-function-extraction" title="Permalink"></a></h2><p>While PEtab.jl provides various tools for analysing the objective function generated by <code>PEtabODEProblem</code>, it is also possible to extract this function for customised analysis. Given a <code>PEtabODEProblem</code></p><pre><code class="language-julia hljs">petab_problem = PEtabODEProblem(petab_model)</code></pre><pre><code class="language-julia hljs">petab_problem = PEtabODEProblem(petab_model)</code></pre><p>We can find the:</p><ol><li>Objective function (negative log-likelihood) as the <code>petab_problem.nllh</code>. It takes a single argument (<code>p</code>) and returns the objective value.</li><li>Gradient as the <code>petab_problem.grad!</code> field. It takes two arguments (<code>g</code> and <code>p</code>) with the updated gradient values being written to <code>g</code>.</li><li>Hessian as the <code>petab_problem.hess!</code> field. It takes two arguments (<code>H</code> and <code>p</code>) with the updated hessian values being written to <code>H</code>.</li></ol><h2 id="petab_multistart_optimisation"><a class="docs-heading-anchor" href="#petab_multistart_optimisation">Multi-start optimisation</a><a id="petab_multistart_optimisation-1"></a><a class="docs-heading-anchor-permalink" href="#petab_multistart_optimisation" title="Permalink"></a></h2><p>To avoid the optimisation process returning a local minimum, it is often advised to run it multiple times, using different initial guesses. PEtab.jl supports this through the <code>calibrate_multistart</code> function. This is identical to the <code>calibrate</code> function, but takes one additional arguments:</p><ol><li><code>nmultistarts</code>: The number of runs to perform.</li></ol><p>And two additional optional argument:</p><ol><li><code>dirsave</code>: A location to which the output is automatically saved. If <code>dirsave=nothing</code>, no output is saved. It is recommended to save intermediate results for parameter estimation runs that take a long time, to not lose intermediate results if something goes wrong.</li><li><code>sampling_method</code>: Selects the sampling method with which to select the initial guesses (<code>QuasiMonteCarlo.LatinHypercubeSample()</code> used by default).</li></ol><p>Because <code>calibrate_multistart</code> handles initial guess sampling, unlike for <code>calibrate</code>, no initial guess has to be provided.</p><p>Here, we fit parameters through 10 independent optimisation runs, using QuasiMonteCarlo&#39;s <code>SobolSample</code> method, and save the result to the OptimisationRuns folder:</p><pre><code class="language-julia hljs">using Optim
using QuasiMonteCarlo
res_ms = calibrate_multistart(petab_problem, IPNewton(), 10; dirsave = &quot;OptimisationRuns&quot;,
    sampling_method = QuasiMonteCarlo.SobolSample())</code></pre><p>The best result across all runs can still be retrieved using <code>get_ps(res_ms, petab_problem)</code>, with the results of the individual runs being stored in the <code>res_ms.runs</code> field.</p><p>To load the result in a later session, we can call:</p><pre><code class="language-julia hljs">res_ms = PEtabMultistartResult(&quot;OptimisationRuns&quot;)</code></pre><p>where <code>&quot;OptimisationRuns&quot;</code> is the name of the save directory (specified in <code>calibrate_multistart</code>). If the OptimisationRuns folder contains the output from several runs, we can designate which to load using the <code>which_run</code> argument. Here we load the second run to be saved in that folder:</p><pre><code class="language-julia hljs">res_ms = PEtabMultistartResult(&quot;OptimisationRuns&quot;; which_run = 2)</code></pre><p>By default, <code>which_run</code> loads the first run saved to that directory.</p><h2 id="petab_events"><a class="docs-heading-anchor" href="#petab_events">Events</a><a id="petab_events-1"></a><a class="docs-heading-anchor-permalink" href="#petab_events" title="Permalink"></a></h2><p>So far, we have assumed that all experiments, after initiation, run without interference. Experiments where conditions change, or where species are added/removed during the time course, can be represented through events. In PEtab, an event is represented through the <code>PEtabEvent</code> structure. It takes three arguments:</p><ol><li>The condition for triggering the event. This can either indicate a point in time, or a boolean condition.</li><li>A rule for updating the event&#39;s target</li><li>The event&#39;s target (either a species or parameter).</li></ol><p>Here we create an event which adds <code>0.5</code> units of <code>S</code> to the system at time <code>5.0</code>:</p><pre><code class="language-julia hljs">@unpack S = rn
event1 = PEtabEvent(5.0, S + 0.5, S)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabEvent:</span> <span class="sgr34">Condition</span> t == 5.0 and <span class="sgr34">affect</span> S(t) = 0.5 + S(t)</code></pre><p>Here, the first argument is evaluated to a scalar value, in which case it is interpreted as a time point at which the event happens. If we instead want the event to happen whenever the concentration of <code>S</code> falls below <code>0.5</code> we set the first argument to a boolean condition indicating this:</p><pre><code class="language-julia hljs">event2 = PEtabEvent(S &lt; 0.5, S + 0.5, S)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">PEtabEvent:</span> <span class="sgr34">Condition</span> S(t) &lt; 0.5 and <span class="sgr34">affect</span> S(t) = 0.5 + S(t)</code></pre><p>Here, the event only triggers whenever the condition changes from <code>false</code> to <code>true</code>, and not while it remains <code>true</code> (or when changing from <code>true</code> to <code>false</code>). E.g. this event only triggers when <code>S</code> concentration passes from more than <span>$5.0$</span> to less that <span>$5.0$</span>.</p><p>Whenever we have several events or not, we bundle them together in a single vector which is later passed to the <code>PEtabODEProblem</code> using the <code>events</code> argument:</p><pre><code class="language-julia hljs">events = [event1, event2]
petab_model = PEtabModel(rn, observables, measurements, params; speciemap = u0, events = events)</code></pre><p>More details on how to use events, including how to create events with multiple targets, can be found in <a href="https://sebapersson.github.io/PEtab.jl/stable/petab_event/">PEtab.jl&#39;s documentation</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>PEtab currently ignores events <a href="../../model_creation/constraint_equations/#constraint_equations_events">created as a part of a Catalyst <code>ReactionSystem</code> model</a>, and does not support SciML-style events. Instead, events have to use the preceding interface.</p></div></div><h2 id="petab_plotting"><a class="docs-heading-anchor" href="#petab_plotting">Plot recipes</a><a id="petab_plotting-1"></a><a class="docs-heading-anchor-permalink" href="#petab_plotting" title="Permalink"></a></h2><p>There exist various types of graphs that can be used to evaluate the parameter fitting process. These can be plotted using the <code>plot</code> command, where the input is either the result of a <code>calibrate</code> or a <code>calibrate_multistart</code> run. To be able to use this functionality, you have to ensure that PEtab.jl <a href="#petab_optimisation_path_recording">records the optimisation process</a> by providing the <code>save_trace=true</code> argument to the calibration functions.</p><p>To, for a single start calibration run, plot, for each iteration of the optimization process, the best objective value achieved so far, run:</p><pre><code class="language-julia hljs">plot(res)</code></pre><img src="c2a59511.svg" alt="Example block output"/><p>For a multi-start calibration run, the default output is instead a so-called waterfall plot:</p><pre><code class="language-julia hljs">plot(res_ms)</code></pre><img src="76de4b96.svg" alt="Example block output"/><p>(for this, and the next plot, we use a multi-start optimisation result from a different model, which yields less trivial optimisation runs than our catalysis one)</p><p>In the waterfall plot, each dot shows the final objective value for a single run in the multi-start process. The runs are ordered by their objective values, and colours designate runs in the same local minimum. A common use of waterfall plots is to check whether a sufficient number of runs (typically <span>$&gt;5$</span>) has converged to the same best local minimum (in which case it is assumed to be the <em>global</em> minimum).</p><p>To instead use the best objective value plot for a multi-start run (with one curve for each run), the <code>plot_type</code> argument is used:</p><pre><code class="language-julia hljs">plot(res_ms; plot_type = :best_objective)</code></pre><img src="6fc6a4b0.svg" alt="Example block output"/><p>There exist several types of plots for both types of calibration results. More details of the types of available plots, and how to customise them, can be found <a href="https://sebapersson.github.io/PEtab.jl/stable/optimisation_output_plotting/">here</a>.</p><hr/><h2 id="petab_citations"><a class="docs-heading-anchor" href="#petab_citations">Citations</a><a id="petab_citations-1"></a><a class="docs-heading-anchor-permalink" href="#petab_citations" title="Permalink"></a></h2><p>If you use this functionality in your research, <a href="../../#doc_index_citation">in addition to Catalyst</a>, please cite the following papers to support the authors of the PEtab.jl package (currently there is no article associated with this package) and the PEtab standard:</p><pre><code class="nohighlight hljs">@misc{2023Petabljl,
  author       = {Ognissanti, Damiano AND Arutjunjan, Rafael AND Persson, Sebastian AND Hasselgren, Viktor},
  title        = {{2023Petabljl.jl}},
  howpublished = {\url{https://github.com/sebapersson/PEtab.jl/}},
  year         = {2023}
}</code></pre><pre><code class="nohighlight hljs">@article{SchmiesterSch2021,
  author    = {Schmiester, Leonard AND Schälte, Yannik AND Bergmann, Frank T. AND Camba, Tacio AND Dudkin, Erika AND Egert, Janine AND Fröhlich, Fabian AND Fuhrmann, Lara AND Hauber, Adrian L. AND Kemmer, Svenja AND Lakrisenko, Polina AND Loos, Carolin AND Merkt, Simon AND Müller, Wolfgang AND Pathirana, Dilan AND Raimúndez, Elba AND Refisch, Lukas AND Rosenblatt, Marcus AND Stapor, Paul L. AND Städter, Philipp AND Wang, Dantong AND Wieland, Franz-Georg AND Banga, Julio R. AND Timmer, Jens AND Villaverde, Alejandro F. AND Sahle, Sven AND Kreutz, Clemens AND Hasenauer, Jan AND Weindl, Daniel},
  journal   = {PLOS Computational Biology},
  title     = {PEtab—Interoperable specification of parameter estimation problems in systems biology},
  year      = {2021},
  month     = {01},
  number    = {1},
  pages     = {1-10},
  volume    = {17},
  doi       = {10.1371/journal.pcbi.1008646},
  publisher = {Public Library of Science},
  url       = {https://doi.org/10.1371/journal.pcbi.1008646},
}</code></pre><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1008646">Schmiester, L et al. <em>PEtab—Interoperable specification of parameter estimation problems in systems biology</em>, PLOS Computational Biology (2021).</a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://academic.oup.com/bioinformatics/article/35/17/3073/5280731?login=false">Hass, H et al. <em>PBenchmark problems for dynamic modeling of intracellular processes</em>, Bioinformatics (2019).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../steady_state_functionality/dynamical_systems/">« Analysing model steady state properties with DynamicalSystems.jl</a><a class="docs-footer-nextpage" href="../optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 9 January 2025 01:02">Thursday 9 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
