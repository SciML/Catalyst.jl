<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parameter Fitting for ODEs using Optimization.jl · Catalyst.jl</title><meta name="title" content="Parameter Fitting for ODEs using Optimization.jl · Catalyst.jl"/><meta property="og:title" content="Parameter Fitting for ODEs using Optimization.jl · Catalyst.jl"/><meta property="twitter:title" content="Parameter Fitting for ODEs using Optimization.jl · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/inverse_problems/optimization_ode_param_fitting/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/inverse_problems/optimization_ode_param_fitting/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/inverse_problems/optimization_ode_param_fitting/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Introduction to Catalyst</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Model creation and properties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../model_creation/conservation_laws/">Working with conservation laws</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/reactionsystem_content_accessing/">Accessing model properties</a></li><li><a class="tocitem" href="../../model_creation/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Model simulation and visualization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for performant ODE simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for performant SDE simulations</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/examples/periodic_events_simulation/">Modelling a periodic event during ODE and jump simulations</a></li><li><a class="tocitem" href="../../model_simulation/examples/interactive_brusselator_simulation/">Interactive Simulation and Plotting</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Steady state analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Inverse problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../petab_ode_param_fitting/">Parameter Fitting for ODEs using PEtab.jl</a></li><li class="is-active"><a class="tocitem" href>Parameter Fitting for ODEs using Optimization.jl</a><ul class="internal"><li><a class="tocitem" href="#optimization_parameter_fitting_basics"><span>Basic example</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_AD"><span>Utilising automatic differentiation</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_multiple_species"><span>Optimisation problems with data for multiple species</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_constraints"><span>Setting parameter constraints and boundaries</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_known_parameters"><span>Parameter fitting with known parameters</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_solver_options"><span>Optimisation solver options</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_log_scale"><span>Fitting parameters on the logarithmic scale</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_citation"><span>Citation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Spatial modelling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial jump simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../devdocs/dev_guide/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Inverse problems</a></li><li class="is-active"><a href>Parameter Fitting for ODEs using Optimization.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parameter Fitting for ODEs using Optimization.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/inverse_problems/optimization_ode_param_fitting.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="optimization_parameter_fitting"><a class="docs-heading-anchor" href="#optimization_parameter_fitting">Parameter Fitting for ODEs using Optimization.jl</a><a id="optimization_parameter_fitting-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting" title="Permalink"></a></h1><p>Fitting parameters to data involves solving an optimisation problem (that is, finding the parameter set that optimally fits your model to your data, typically by minimising an objective function)<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. The SciML ecosystem&#39;s primary package for solving optimisation problems is <a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a>. It provides access to a variety of solvers via a single common interface by wrapping a large number of optimisation libraries that have been implemented in Julia.</p><p>This tutorial demonstrates how to </p><ol><li>Create a custom objective function which minimiser corresponds to the parameter set optimally fitting the data.</li><li>Use Optimization.jl to minimize this objective function and find the parameter set providing the optimal fit.</li></ol><p>For simple parameter fitting problems (such as the one outlined below), <a href="../petab_ode_param_fitting/#petab_parameter_fitting">PEtab.jl often provides a more straightforward parameter fitting interface</a>. However, Optimization.jl provides additional flexibility in defining your objective function. Indeed, it can also be used in other contexts, such as <a href="../behaviour_optimisation/#behaviour_optimisation">finding parameter sets that maximise the magnitude of some system behaviour</a>. More details on how to use Optimization.jl can be found in its <a href="https://docs.sciml.ai/DiffEqOptimizationParamEstim/stable/">documentation</a>.</p><h2 id="optimization_parameter_fitting_basics"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_basics">Basic example</a><a id="optimization_parameter_fitting_basics-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_basics" title="Permalink"></a></h2><p>Let us consider a <a href="../../model_creation/examples/basic_CRN_library/#basic_CRN_library_mm">Michaelis-Menten enzyme kinetics model</a>, where an enzyme (<span>$E$</span>) converts a substrate (<span>$S$</span>) into a product (<span>$P$</span>):</p><pre><code class="language-julia hljs">using Catalyst
rn = @reaction_network begin
    kB, S + E --&gt; SE
    kD, SE --&gt; S + E
    kP, SE --&gt; P + E
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{S} + \mathrm{E} &amp;\xrightleftharpoons[\mathtt{kD}]{\mathtt{kB}} \mathrm{\mathtt{SE}} \\
\mathrm{\mathtt{SE}} &amp;\xrightarrow{\mathtt{kP}} \mathrm{P} + \mathrm{E}  
 \end{align*}
 \]</p><p>From some known initial condition, and a true parameter set (which we later want to recover from the data) we generate synthetic data (on which we will demonstrate the fitting process).</p><pre><code class="language-julia hljs"># Define initial conditions and parameters.
u0 = [:S =&gt; 1.0, :E =&gt; 1.0, :SE =&gt; 0.0, :P =&gt; 0.0]
ps_true = [:kB =&gt; 1.0, :kD =&gt; 0.1, :kP =&gt; 0.5]

# Generate synthetic data.
using OrdinaryDiffEqDefault
oprob_true = ODEProblem(rn, u0, (0.0, 10.0), ps_true)
true_sol = solve(oprob_true)
data_sol = solve(oprob_true; saveat = 1.0)
data_ts = data_sol.t[2:end]
data_vals = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]

# Plots the true solutions and the (synthetic) data measurements.
using Plots
plot(true_sol; idxs = :P, label = &quot;True solution&quot;, lw = 8)
plot!(data_ts, data_vals; label = &quot;Measurements&quot;, seriestype=:scatter, ms = 6, color = :blue)</code></pre><img src="68e81725.png" alt="Example block output"/><p>Next, we will formulate an objective function which, for a single parameter set, simulates our model and computes the sum-of-square distance between the data and the simulation (non-sum-of-square approaches can be used, but this is the most straightforward one).</p><pre><code class="language-julia hljs">ps_init = [:kB =&gt; 1.0, :kD =&gt; 1.0, :kP =&gt; 1.0]
oprob_base = ODEProblem(rn, u0, (0.0, 10.0), ps_init)
function objective_function(p, _)
    p = Pair.([:kB, :kD, :kP], p)
    oprob = remake(oprob_base; p)
    sol = solve(oprob; saveat = data_ts, save_idxs = :P, verbose = false, maxiters = 10000)
    SciMLBase.successful_retcode(sol) || return Inf
    return sum((sol .- data_vals) .^2)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">objective_function (generic function with 1 method)</code></pre><p>When our optimisation algorithm searches parameter space it will likely consider many highly non-plausible parameter sets. To better handle this we:</p><ol><li>Add <code>maxiters = 10000</code> to our <code>solve</code> command. As most well-behaved ODEs can be solved in relatively few timesteps, this speeds up the optimisation procedure by preventing us from spending too much time trying to simulate (for the model) unsuitable parameter sets.</li><li>Add <code>verbose = false</code> to our <code>solve</code> command. This prevents (potentially a very large number of) warnings from being printed to our output as unsuitable parameter sets are simulated.</li><li>Add the line <code>SciMLBase.successful_retcode(sol) || return Inf</code>, which returns an infinite value for parameter sets which does not lead to successful simulations.</li></ol><p>To improve optimisation performance, rather than creating a new <code>ODEProblem</code> in each iteration, we pre-declare one which we <a href="../../model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_problems_remake">apply <code>remake</code> to</a>. We also use the <code>saveat = data_ts, save_idxs = :P</code> arguments to only save the values of the measured species at the measured time points.</p><p>We can now create an <code>OptimizationProblem</code> using our <code>objective_function</code> and some initial guess of parameter values from which the optimiser will start:</p><pre><code class="language-julia hljs">using Optimization
p_guess = [1.0, 1.0, 1.0]
optprob = OptimizationProblem(objective_function, p_guess)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>OptimizationProblem</code>s cannot currently accept parameter values in the form of a map (e.g. <code>[:kB =&gt; 1.0, :kD =&gt; 1.0, :kP =&gt; 1.0]</code>). These must be provided as individual values (using the same order as the parameters occur in in the <code>parameters(rs)</code> vector). This should hopefully be remedied in future Optimization releases.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Especially if you check Optimization.jl&#39;s documentation, you will note that objective functions have the <code>f(u,p)</code> form. This is because <code>OptimizationProblem</code>s (like e.g. <code>ODEProblem</code>s) can take both variables (which are varied during the optimisation procedure), but also parameters that are fixed. In our case, the <em>optimisation variables</em> correspond to our <em>model parameters</em>. Hence, our model parameter values (<code>p</code>) are the first argument (<code>u</code>). This is also why we find the optimisation solution (our optimised parameter set) in <code>opt_sol</code>&#39;s <code>u</code> field. Our optimisation problem does not actually have any parameters, hence, the second argument of <code>objective_function</code> is unused (that is why we call it <code>_</code>, a name commonly indicating unused function arguments).</p><p>There are several modifications to our problem where it would actually have parameters. E.g. we might want to run the optimisation where one parameter has a known fixed value. If we then would like to rerun this for alternative fixed values, this value could be encoded as an <code>OptimizationProblem</code> parameter.</p></div></div><p>Finally, we can solve <code>optprob</code> to find the parameter set that best fits our data. Optimization.jl only provides a few optimisation methods natively. However, for each supported optimisation package, it provides a corresponding wrapper package to import that optimisation package for use with Optimization.jl. E.g., if we wish to use <a href="https://github.com/JuliaOpt/NLopt.jl">NLopt.jl</a>&#39;s <a href="https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method">Nelder-Mead</a> method, we must install and import the OptimizationNLopt package. A summary of all, by Optimization.jl supported, optimisation packages can be found <a href="https://docs.sciml.ai/Optimization/stable/#Overview-of-the-Optimizers">here</a>. Here, we import the NLopt.jl package and uses it to minimise our objective function (thus finding a parameter set that fits the data):</p><pre><code class="language-julia hljs">using OptimizationNLopt
optsol = solve(optprob, NLopt.LN_NELDERMEAD())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"><span class="sgr1">┌ Warning: </span></span>NLopt failed to converge: XTOL_REACHED
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ OptimizationNLopt ~/.julia/packages/OptimizationNLopt/YE3fr/src/OptimizationNLopt.jl:299</span></code></pre><p>We can now simulate our model for the found parameter set (stored in <code>optsol.u</code>), checking that it fits our data.</p><pre><code class="language-julia hljs">oprob_fitted = remake(oprob_base; p = Pair.([:kB, :kD, :kP], optsol.u))
fitted_sol = solve(oprob_fitted)
plot!(fitted_sol; idxs = :P, label = &quot;Fitted solution&quot;, linestyle = :dash, lw = 6, color = :lightblue)</code></pre><img src="f8e325a6.png" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Here, a good exercise is to check the resulting parameter set and note that, while it creates a good fit to the data, it does not actually correspond to the original parameter set. Identifiability is a concept that studies how to deal with this problem.&lt;!–NTS: re-add ref when identifiablity works again–&gt;</p></div></div><p>Say that we instead would like to use a <a href="https://en.wikipedia.org/wiki/Genetic_algorithm">genetic algorithm</a> approach, as implemented by the <a href="https://github.com/wildart/Evolutionary.jl">Evolutionary.jl</a> package. In this case we can run:</p><pre><code class="language-julia hljs">using OptimizationEvolutionary
sol = solve(optprob, Evolutionary.GA())</code></pre><p>to solve <code>optprob</code> for this combination of solve and implementation.</p><h2 id="optimization_parameter_fitting_AD"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_AD">Utilising automatic differentiation</a><a id="optimization_parameter_fitting_AD-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_AD" title="Permalink"></a></h2><p>Optimisation methods can be divided into differentiation-free and differentiation-based optimisation methods. E.g. consider finding the minimum of the function <span>$f(x) = x^2$</span>, given some initial guess of <span>$x$</span>. Here, we can simply compute the differential and descend along it until we find <span>$x=0$</span> (admittedly, for this simple problem the minimum can be computed directly). This principle forms the basis of optimisation methods such as <a href="https://en.wikipedia.org/wiki/Gradient_descent">gradient descent</a>, which utilises information of a function&#39;s differential to minimise it. When attempting to find a global minimum, to avoid getting stuck in local minimums, these methods are often augmented by additional routines. While the differentiation of most algebraic functions is trivial, it turns out that even complicated functions (such as the one we used above) can be differentiated computationally through the use of <a href="https://en.wikipedia.org/wiki/Automatic_differentiation"><em>automatic differentiation</em> (AD)</a>.</p><p>Through packages such as <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>, <a href="https://github.com/JuliaDiff/ReverseDiff.jl">ReverseDiff.jl</a>, and <a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a>, Julia supports AD for most code. Specifically for code including simulation of differential equations, differentiation is supported by <a href="https://github.com/SciML/SciMLSensitivity.jl">SciMLSensitivity.jl</a>. Generally, AD can be used without specific knowledge from the user, however, it requires an additional step in the construction of our <code>OptimizationProblem</code>. Here, we create a <a href="https://docs.sciml.ai/Optimization/stable/API/optimization_function/#optfunction">specialised <code>OptimizationFunction</code> from our objective function</a>. To it, we will also provide our choice of AD method. There are <a href="https://docs.sciml.ai/Optimization/stable/API/optimization_function/#Automatic-Differentiation-Construction-Choice-Recommendations">several alternatives</a>, and in our case we will use <code>AutoForwardDiff()</code> (a good choice for small optimisation problems). We can then create a new <code>OptimizationProblem</code> using our updated objective function:</p><pre><code class="language-julia hljs">opt_func = OptimizationFunction(objective_function, AutoForwardDiff())
opt_prob = OptimizationProblem(opt_func, p_guess)</code></pre><p>Finally, we can find the optimum using some differentiation-based optimisation methods. Here we will use <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>&#39;s <a href="https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm">Broyden–Fletcher–Goldfarb–Shanno algorithm</a> implementation:</p><pre><code class="language-julia hljs">using OptimizationOptimJL
opt_sol = solve(opt_prob, OptimizationOptimJL.BFGS())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 3-element Vector{Float64}:
 0.7188853146072621
 0.23861621593228177
 0.6038778047146905</code></pre><h2 id="optimization_parameter_fitting_multiple_species"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_multiple_species">Optimisation problems with data for multiple species</a><a id="optimization_parameter_fitting_multiple_species-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_multiple_species" title="Permalink"></a></h2><p>Imagine that, in our previous example, we had measurements of the concentration of both <span>$S$</span> and <span>$P$</span>:</p><pre><code class="language-julia hljs">data_vals_S = (0.8 .+ 0.4*rand(10)) .* data_sol[:S][2:end]
data_vals_P = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]

plot(true_sol; idxs = [:S, :P], label = [&quot;True S&quot; &quot;True P&quot;], lw = 8)
plot!(data_ts, data_vals_S; label = &quot;Measured S&quot;, seriestype=:scatter, ms = 6, color = :blue)
plot!(data_ts, data_vals_P; label = &quot;Measured P&quot;, seriestype=:scatter, ms = 6, color = :red)</code></pre><img src="4339677b.png" alt="Example block output"/><p>In this case we simply modify our objective function to take this into account:</p><pre><code class="language-julia hljs">function objective_function_S_P(p, _)
    p = Pair.([:kB, :kD, :kP], p)
    oprob = remake(oprob_base; p)
    sol = solve(oprob; saveat = data_ts, save_idxs = [:S, :P], verbose = false, maxiters = 10000)
    SciMLBase.successful_retcode(sol) || return Inf
    return sum((sol[:S] .- data_vals_S) .^2 + (sol[:P] .- data_vals_P) .^2)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">objective_function_S_P (generic function with 1 method)</code></pre><p>Here we do not normalise the contribution from each species to the objective function. However, if species are present at different concentration levels this might be necessary (or you might essentially only take the highest concentration species(s) into account).</p><p>We can now fit our model to data and plot the results:</p><pre><code class="language-julia hljs">optprob_S_P = OptimizationProblem(objective_function_S_P, p_guess)
optsol_S_P = solve(optprob_S_P, NLopt.LN_NELDERMEAD())
oprob_fitted_S_P = remake(oprob_base; p = optsol_S_P.u)
fitted_sol_S_P = solve(oprob_fitted_S_P)
plot!(fitted_sol_S_P; idxs=[:S, :P], label=&quot;Fitted solution&quot;, linestyle = :dash, lw = 6, color = [:lightblue :pink])</code></pre><img src="a7c47bd5.png" alt="Example block output"/><h2 id="optimization_parameter_fitting_constraints"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_constraints">Setting parameter constraints and boundaries</a><a id="optimization_parameter_fitting_constraints-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_constraints" title="Permalink"></a></h2><p>Sometimes, it is desirable to set boundaries on parameter values. Indeed, this can speed up the optimisation process (by preventing searching through unfeasible parts of parameter space), and can also be a requirement for some optimisation methods. This can be done by passing the <code>lb</code> (lower bounds) and <code>up</code> (upper bounds) arguments to <code>OptimizationProblem</code>. These are vectors (of the same length as the number of parameters), with each argument corresponding to the boundary value of the parameter with the same index. If we wish to constrain each parameter to the interval <span>$(0.1, 10.0)$</span> this can be done through:</p><pre><code class="language-julia hljs">optprob = OptimizationProblem(objective_function, [1.0, 1.0, 1.0]; lb = [1e-1, 1e-1, 1e-1], ub = [1e1, 1e1, 1e1])</code></pre><p>In addition to boundaries, Optimization.jl also supports setting <a href="https://docs.sciml.ai/Optimization/stable/tutorials/constraints/#constraints">linear and non-linear constraints</a> on its output solution (only available for some optimisers).</p><h2 id="optimization_parameter_fitting_known_parameters"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_known_parameters">Parameter fitting with known parameters</a><a id="optimization_parameter_fitting_known_parameters-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_known_parameters" title="Permalink"></a></h2><p>If we from previous knowledge know that <span>$kD = 0.1$</span>, and only want to fit the values of <span>$kB$</span> and <span>$kP$</span>, this can be achieved by making corresponding changes to our objective function.</p><pre><code class="language-julia hljs">function objective_function_known_kD(p, _)
    p = Pair.([:kB, :kD, :kP], [p[1], 0.1, p[2]])
    oprob = remake(oprob_base; p)
    sol = solve(oprob; saveat = data_ts, save_idxs = :P, verbose = false, maxiters = 10000)
    SciMLBase.successful_retcode(sol) || return Inf
    return sum((sol .- data_vals) .^2)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">objective_function_known_kD (generic function with 1 method)</code></pre><p>We can now create and solve the corresponding <code>OptimizationProblem</code>, but with only two parameters in the initial guess.</p><pre><code class="language-julia hljs">optprob_known_kD = OptimizationProblem(objective_function_known_kD, [1.0, 1.0])
optsol_known_kD = solve(optprob_known_kD, NLopt.LN_NELDERMEAD())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"><span class="sgr1">┌ Warning: </span></span>NLopt failed to converge: XTOL_REACHED
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ OptimizationNLopt ~/.julia/packages/OptimizationNLopt/YE3fr/src/OptimizationNLopt.jl:299</span></code></pre><h2 id="optimization_parameter_fitting_solver_options"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_solver_options">Optimisation solver options</a><a id="optimization_parameter_fitting_solver_options-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_solver_options" title="Permalink"></a></h2><p>Optimization.jl supports various <a href="https://docs.sciml.ai/Optimization/stable/API/solve/">optimisation solver options</a> that can be supplied to the <code>solve</code> command. For example, to set a maximum number of seconds (after which the optimisation process is terminated), you can use the <code>maxtime</code> argument:</p><pre><code class="language-julia hljs">optsol_fixed_kD = solve(optprob, NLopt.LN_NELDERMEAD(); maxtime = 100)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"><span class="sgr1">┌ Warning: </span></span>NLopt failed to converge: XTOL_REACHED
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ OptimizationNLopt ~/.julia/packages/OptimizationNLopt/YE3fr/src/OptimizationNLopt.jl:299</span></code></pre><p>It should be noted that not all solver options are available to all optimisation solvers.</p><h2 id="optimization_parameter_fitting_log_scale"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_log_scale">Fitting parameters on the logarithmic scale</a><a id="optimization_parameter_fitting_log_scale-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_log_scale" title="Permalink"></a></h2><p>Often it can be advantageous to fit parameters on a <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1008646">logarithmic scale (rather than on a linear scale)</a>. The most straightforward way to do this is to simply replace each parameter in the model definition by its logarithmic version:</p><pre><code class="language-julia hljs">using Catalyst
rn = @reaction_network begin
    10^kB, S + E --&gt; SE
    10^kD, SE --&gt; S + E
    10^kP, SE --&gt; P + E
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{S} + \mathrm{E} &amp;\xrightleftharpoons[10^{\mathtt{kD}}]{10^{\mathtt{kB}}} \mathrm{\mathtt{SE}} \\
\mathrm{\mathtt{SE}} &amp;\xrightarrow{10^{\mathtt{kP}}} \mathrm{P} + \mathrm{E}  
 \end{align*}
 \]</p><p>And then going forward, by keeping in mind that parameter values are logarithmic. Here, setting</p><pre><code class="language-julia hljs">p_true = [:kB =&gt; 0.0, :kD =&gt; -1.0, :kP =&gt; 10^(0.5)]</code></pre><p>corresponds to the same true parameter values as used previously (<code>[:kB =&gt; 1.0, :kD =&gt; 0.1, :kP =&gt; 0.5]</code>). Alternatively, we can provide the log-transform in the objective function:</p><pre><code class="language-julia hljs">function objective_function_logtransformed(p, _)
    p = Pair.([:kB, :kD, :kP], 10.0 .^ p)
    oprob = remake(oprob_base; p)
    sol = solve(oprob; saveat = data_ts, save_idxs = :P, verbose = false, maxiters = 10000)
    SciMLBase.successful_retcode(sol) || return Inf
    return sum((sol .- data_vals) .^2)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">objective_function_logtransformed (generic function with 1 method)</code></pre><hr/><h2 id="optimization_parameter_fitting_citation"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_citation">Citation</a><a id="optimization_parameter_fitting_citation-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_citation" title="Permalink"></a></h2><p>If you use this functionality in your research, please cite the following paper to support the authors of the Optimization.jl package:</p><pre><code class="nohighlight hljs">@software{vaibhav_kumar_dixit_2023_7738525,
	author = {Vaibhav Kumar Dixit and Christopher Rackauckas},
	month = mar,
	publisher = {Zenodo},
	title = {Optimization.jl: A Unified Optimization Package},
	version = {v3.12.1},
	doi = {10.5281/zenodo.7738525},
  	url = {https://doi.org/10.5281/zenodo.7738525},
	year = 2023
}</code></pre><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://academic.oup.com/bib/article/23/1/bbab387/6383562?login=false">Alejandro F. Villaverde, Dilan Pathirana, Fabian Fröhlich, Jan Hasenauer, Julio R. Banga, <em>A protocol for dynamic model calibration</em>, Briefings in Bioinformatics (2023).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../petab_ode_param_fitting/">« Parameter Fitting for ODEs using PEtab.jl</a><a class="docs-footer-nextpage" href="../behaviour_optimisation/">Optimization for non-data fitting purposes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 9 January 2025 01:02">Thursday 9 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
