<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Catalyst.jl API · Catalyst.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/api/catalyst_api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Catalyst for new Julia users</span><ul><li><a class="tocitem" href="../../catalyst_for_new_julia_users/intro_to_catalyst/">Introduction to Catalyst and Julia for new Julia users</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/using_catalyst/">Using Catalyst</a></li><li><a class="tocitem" href="../../tutorials/dsl/">The Reaction DSL</a></li><li><a class="tocitem" href="../../tutorials/reaction_systems/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../tutorials/basic_examples/">Basic Chemical Reaction Network Examples</a></li><li><a class="tocitem" href="../../tutorials/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../tutorials/symbolic_stoich/">Parametric Stoichiometry</a></li><li><a class="tocitem" href="../../tutorials/reaction_network_representation/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../tutorials/homotopy_continuation_tutorial/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../tutorials/bifurcation_diagram/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../tutorials/parameter_estimation/">Parameter Estimation</a></li><li><a class="tocitem" href="../../tutorials/generating_reactions_programmatically/">Smoluchowski Coagulation Equation</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>Catalyst.jl API</a><ul class="internal"><li><a class="tocitem" href="#Reaction-Network-Generation-and-Representation"><span>Reaction Network Generation and Representation</span></a></li><li><a class="tocitem" href="#ModelingToolkit-and-Catalyst-Accessor-Functions"><span>ModelingToolkit and Catalyst Accessor Functions</span></a></li><li><a class="tocitem" href="#Basic-System-Properties"><span>Basic System Properties</span></a></li><li><a class="tocitem" href="#Basic-Reaction-Properties"><span>Basic Reaction Properties</span></a></li><li><a class="tocitem" href="#Functions-to-Extend-or-Modify-a-Network"><span>Functions to Extend or Modify a Network</span></a></li><li><a class="tocitem" href="#Network-Analysis-and-Representations"><span>Network Analysis and Representations</span></a></li><li><a class="tocitem" href="#Network-Comparison"><span>Network Comparison</span></a></li><li><a class="tocitem" href="#Network-Visualization"><span>Network Visualization</span></a></li><li><a class="tocitem" href="#Rate-Laws"><span>Rate Laws</span></a></li><li><a class="tocitem" href="#Transformations"><span>Transformations</span></a></li><li><a class="tocitem" href="#Unit-Validation"><span>Unit Validation</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Catalyst.jl API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Catalyst.jl API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/api/catalyst_api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Catalyst.jl-API"><a class="docs-heading-anchor" href="#Catalyst.jl-API">Catalyst.jl API</a><a id="Catalyst.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#Catalyst.jl-API" title="Permalink"></a></h1><h2 id="Reaction-Network-Generation-and-Representation"><a class="docs-heading-anchor" href="#Reaction-Network-Generation-and-Representation">Reaction Network Generation and Representation</a><a id="Reaction-Network-Generation-and-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#Reaction-Network-Generation-and-Representation" title="Permalink"></a></h2><p>Catalyst provides the <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro for generating a complete network, stored as a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, which in turn is composed of <a href="#Catalyst.Reaction"><code>Reaction</code></a>s. <code>ReactionSystem</code>s can be converted to other <code>ModelingToolkit.AbstractSystem</code>s, including a <code>ModelingToolkit.ODESystem</code>, <code>ModelingToolkit.SDESystem</code>, or <code>ModelingToolkit.JumpSystem</code>.</p><p>An empty network can be generated using <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> with no arguments (or one argument to name the system), or the <a href="#Catalyst.make_empty_network"><code>make_empty_network</code></a> function. These can then be extended programmatically using <a href="#Catalyst.addspecies!"><code>addspecies!</code></a>, <a href="#Catalyst.addparam!"><code>addparam!</code></a>, and <a href="#Catalyst.addreaction!"><code>addreaction!</code></a>.</p><p>It is important to note for <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> that any variable not declared to be a parameter after <code>end</code> will be treated as a chemical species of the system. i.e. in</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    k*X, Y --&gt; W
end k</code></pre><p><code>X</code>, <code>Y</code> and <code>W</code> will all be classified as chemical species.</p><p>The <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> generated by the <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro is a <code>ModelingToolkit.AbstractSystem</code> that symbolically represents a system of chemical reactions. In some cases it can be convenient to bypass the macro and directly generate a collection of <a href="#Catalyst.Reaction"><code>Reaction</code></a>s and a corresponding <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> encapsulating them. Below we illustrate with a simple SIR example how a system can be directly constructed, and demonstrate how to then generate from the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and solve corresponding chemical reaction ODE models, chemical Langevin equation SDE models, and stochastic chemical kinetics jump process models.</p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEq, StochasticDiffEq, JumpProcesses
@parameters β γ t
@variables S(t) I(t) R(t)

rxs = [Reaction(β, [S,I], [I], [1,1], [2])
       Reaction(γ, [I], [R])]
@named rs = ReactionSystem(rxs, t)

u₀map    = [S =&gt; 999.0, I =&gt; 1.0, R =&gt; 0.0]
parammap = [β =&gt; 1/10000, γ =&gt; 0.01]
tspan    = (0.0, 250.0)

# solve as ODEs
odesys = convert(ODESystem, rs)
oprob = ODEProblem(odesys, u₀map, tspan, parammap)
sol = solve(oprob, Tsit5())

# solve as SDEs
sdesys = convert(SDESystem, rs)
sprob = SDEProblem(sdesys, u₀map, tspan, parammap)
sol = solve(sprob, EM(), dt=.01)

# solve as jump process
jumpsys = convert(JumpSystem, rs)
u₀map    = [S =&gt; 999, I =&gt; 1, R =&gt; 0]
dprob = DiscreteProblem(jumpsys, u₀map, tspan, parammap)
jprob = JumpProblem(jumpsys, dprob, Direct())
sol = solve(jprob, SSAStepper())</code></pre><article class="docstring"><header><a class="docstring-binding" id="Catalyst.@reaction_network" href="#Catalyst.@reaction_network"><code>Catalyst.@reaction_network</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@reaction_network</code></pre><p>Generates a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> that encodes a chemical reaction network.</p><p>See <a href="../../tutorials/dsl/#The-Reaction-DSL">The Reaction DSL</a> documentation for details on parameters to the macro.</p><p>Examples:</p><pre><code class="language-julia hljs"># a basic SIR model, with name SIR
sir_model = @reaction_network SIR begin
    c1, s + i --&gt; 2i
    c2, i --&gt; r
end c1 c2

# a basic SIR model, with random generated name
sir_model = @reaction_network begin
    c1, s + i --&gt; 2i
    c2, i --&gt; r
end c1 c2

# an empty network with name empty
emptyrn = @reaction_network empty

# an empty network with random generated name
emptyrn = @reaction_network</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reaction_network.jl#L73-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.make_empty_network" href="#Catalyst.make_empty_network"><code>Catalyst.make_empty_network</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_empty_network(; iv=DEFAULT_IV, name=gensym(:ReactionSystem))</code></pre><p>Construct an empty <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. <code>iv</code> is the independent variable, usually time, and <code>name</code> is the name to give the <code>ReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1336-L1341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.@reaction" href="#Catalyst.@reaction"><code>Catalyst.@reaction</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@reaction</code></pre><p>Generates a single <a href="#Catalyst.Reaction"><code>Reaction</code></a> object.</p><p>Examples:</p><pre><code class="language-julia hljs">rx = @reaction k*v, A + B --&gt; C + D

# is equivalent to
@parameters k v
@variables t A(t) B(t) C(t) D(t)
rx == Reaction(k*v, [A,B], [C,D])</code></pre><p>Here <code>k</code> and <code>v</code> will be parameters and <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code> will be variables. Interpolation of existing parameters/variables also works</p><pre><code class="language-julia hljs">@parameters k b
@variables t A(t)
ex = k*A^2 + t
rx = @reaction b*$ex*$A, $A --&gt; C</code></pre><p>Notes:</p><ul><li>Any symbols arising in the rate expression that aren&#39;t interpolated are treated as parameters. In the reaction part (<code>α*A + B --&gt; C + D</code>), coefficients are treated as parameters, e.g. <code>α</code>, and rightmost symbols as species, e.g. <code>A,B,C,D</code>.</li><li>Works with any <em>single</em> arrow types supported by <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a>.</li><li>Interpolation of Julia variables into the macro works similar to the <code>@reaction_network</code> macro. See <a href="../../tutorials/dsl/#The-Reaction-DSL">The Reaction DSL</a> tutorial for more details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reaction_network.jl#L135-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.Reaction" href="#Catalyst.Reaction"><code>Catalyst.Reaction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Reaction{S, T}</code></pre><p>One chemical reaction.</p><p><strong>Fields</strong></p><ul><li><p><code>rate</code></p><p>The rate function (excluding mass action terms).</p></li><li><p><code>substrates</code></p><p>Reaction substrates.</p></li><li><p><code>products</code></p><p>Reaction products.</p></li><li><p><code>substoich</code></p><p>The stoichiometric coefficients of the reactants.</p></li><li><p><code>prodstoich</code></p><p>The stoichiometric coefficients of the products.</p></li><li><p><code>netstoich</code></p><p>The net stoichiometric coefficients of all species changed by the reaction.</p></li><li><p><code>only_use_rate</code></p><p><code>false</code> (default) if <code>rate</code> should be multiplied by mass action terms to give the rate law. <code>true</code> if <code>rate</code> represents the full reaction rate law.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Catalyst
@parameters k[1:20]
@variables t A(t) B(t) C(t) D(t)
rxs = [Reaction(k[1], nothing, [A]),            # 0 -&gt; A
       Reaction(k[2], [B], nothing),            # B -&gt; 0
       Reaction(k[3],[A],[C]),                  # A -&gt; C
       Reaction(k[4], [C], [A,B]),              # C -&gt; A + B
       Reaction(k[5], [C], [A], [1], [2]),      # C -&gt; A + A
       Reaction(k[6], [A,B], [C]),              # A + B -&gt; C
       Reaction(k[7], [B], [A], [2], [1]),      # 2B -&gt; A
       Reaction(k[8], [A,B], [A,C]),            # A + B -&gt; A + C
       Reaction(k[9], [A,B], [C,D]),            # A + B -&gt; C + D
       Reaction(k[10], [A], [C,D], [2], [1,1]), # 2A -&gt; C + D
       Reaction(k[11], [A], [A,B], [2], [1,1]), # 2A -&gt; A + B
       Reaction(k[12], [A,B,C], [C,D], [1,3,4], [2, 3]),          # A+3B+4C -&gt; 2C + 3D
       Reaction(k[13], [A,B], nothing, [3,1], nothing),           # 3A+B -&gt; 0
       Reaction(k[14], nothing, [A], nothing, [2]),               # 0 -&gt; 2A
       Reaction(k[15]*A/(2+A), [A], nothing; only_use_rate=true), # A -&gt; 0 with custom rate
       Reaction(k[16], [A], [B]; only_use_rate=true),             # A -&gt; B with custom rate.
       Reaction(k[17]*A*exp(B), [C], [D], [2], [1]),              # 2C -&gt; D with non constant rate.
       Reaction(k[18]*B, nothing, [B], nothing, [2]),             # 0 -&gt; 2B with non constant rate.
       Reaction(k[19]*t, [A], [B]),                                # A -&gt; B with non constant rate.
       Reaction(k[20]*t*A, [B,C], [D],[2,1],[2])                  # 2A +B -&gt; 2C with non constant rate.
  ]</code></pre><p>Notes:</p><ul><li><code>nothing</code> can be used to indicate a reaction that has no reactants or no products. In this case the corresponding stoichiometry vector should also be set to <code>nothing</code>.</li><li>The three-argument form assumes all reactant and product stoichiometric coefficients are one.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.ReactionSystem" href="#Catalyst.ReactionSystem"><code>Catalyst.ReactionSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReactionSystem{U&lt;:Union{Nothing, ModelingToolkit.AbstractSystem}, V&lt;:Catalyst.NetworkProperties} &lt;: AbstractTimeDependentSystem</code></pre><p>A system of chemical reactions.</p><p><strong>Fields</strong></p><ul><li><p><code>eqs</code></p><p>The reactions defining the system.</p></li><li><p><code>iv</code></p><p>Independent variable (usually time).</p></li><li><p><code>sivs</code></p><p>Spatial independent variables</p></li><li><p><code>states</code></p><p>Dependent (state) variables representing amount of each species. Must not contain the independent variable.</p></li><li><p><code>ps</code></p><p>Parameter variables. Must not contain the independent variable.</p></li><li><p><code>var_to_name</code></p><p>Maps Symbol to corresponding variable.</p></li><li><p><code>observed</code></p><p>Equations for observed variables.</p></li><li><p><code>name</code></p><p>The name of the system</p></li><li><p><code>systems</code></p><p>Internal sub-systems</p></li><li><p><code>defaults</code></p><p>The default values to use when initial conditions and/or parameters are not supplied in <code>ODEProblem</code>.</p></li></ul><ul><li><p><code>connection_type</code></p><p>Type of the system</p></li><li><p><code>constraints</code></p><p>Non-<code>Reaction</code> equations that further constrain the system</p></li><li><p><code>networkproperties</code></p><p><code>NetworkProperties</code> object that can be filled in by API functions. INTERNAL – not considered part of the public API.</p></li><li><p><code>combinatoric_ratelaws</code></p><p>Sets whether to use combinatoric scalings in rate laws. true by default.</p></li></ul><p><strong>Example</strong></p><p>Continuing from the example in the <a href="#Catalyst.Reaction"><code>Reaction</code></a> definition:</p><pre><code class="language-julia hljs"># simple constructor that infers species and parameters
@named rs = ReactionSystem(rxs, t)

# allows specification of species and parameters
@named rs = ReactionSystem(rxs, t, [A,B,C,D], k)</code></pre><p>Keyword Arguments:</p><ul><li><code>observed::Vector{Equation}</code>, equations specifying observed variables.</li><li><code>systems::Vector{AbstractSystems}</code>, vector of sub-systems. Can be <code>ReactionSystem</code>s, <code>ODESystem</code>s, or <code>NonlinearSystem</code>s.</li><li><code>name::Symbol</code>, the name of the system (must be provided, or <code>@named</code> must be used).</li><li><code>defaults::Dict</code>, a dictionary mapping parameters to their default values and species to their default initial values.</li><li><code>checks = true</code>, boolean for whether to check units.</li><li><code>constraints = nothing</code>, a <code>NonlinearSystem</code> or <code>ODESystem</code> of coupled constraint equations.</li><li><code>networkproperties = NetworkProperties()</code>, cache for network properties calculated via API functions.</li><li><code>combinatoric_ratelaws = true</code>, sets the default value of <code>combinatoric_ratelaws</code> used in calls to <code>convert</code> or calling various problem types with the <code>ReactionSystem</code>.</li><li><code>balanced_bc_check = true</code>, sets whether to check that BC species appearing in reactions are balanced (i.e appear as both a substrate and a product with the same stoichiometry).</li></ul><p>Notes:</p><ul><li>ReactionSystems currently do rudimentary unit checking, requiring that all species have the same units, and all reactions have rate laws with units of (species units) / (time units). Unit checking can be disabled by passing the keyword argument <code>checks=false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L391">source</a></section></article><h2 id="ModelingToolkit-and-Catalyst-Accessor-Functions"><a class="docs-heading-anchor" href="#ModelingToolkit-and-Catalyst-Accessor-Functions">ModelingToolkit and Catalyst Accessor Functions</a><a id="ModelingToolkit-and-Catalyst-Accessor-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#ModelingToolkit-and-Catalyst-Accessor-Functions" title="Permalink"></a></h2><p>A <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> is an instance of a <code>ModelingToolkit.AbstractTimeDependentSystem</code>, and has a number of fields that can be accessed using the Catalyst API and the <a href="https://docs.sciml.ai/ModelingToolkit/stable/basics/AbstractSystem/">ModelingToolkit.jl Abstract System Interface</a>. Below we overview these components.</p><p>There are three basic sets of convenience accessors that will return information either from a top-level system, the top-level system and all sub-systems that are also <code>ReactionSystem</code>s (i.e. the full reaction-network), or the top-level system, all subs-systems, and all constraint systems (i.e. the full model). To retrieve info from just a base <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> <code>rn</code>, ignoring sub-systems of <code>rn</code>, one can use the ModelingToolkit accessors (these provide direct access to the corresponding internal fields of the <code>ReactionSystem</code>)</p><ul><li><code>get_states(rn)</code> is a vector that collects all the species defined within <code>rn</code>.</li><li><code>get_ps(rn)</code> is a vector that collects all the parameters defined <em>within</em> reactions in <code>rn</code>.</li><li><code>get_eqs(rn)</code> is a vector that collects all the <a href="#Catalyst.Reaction"><code>Reaction</code></a>s defined within <code>rn</code>.</li><li><code>get_iv(rn)</code> is the independent variable used in the system (usually <code>t</code> to represent time).</li><li><code>get_systems(rn)</code> is a vector of all sub-systems of <code>rn</code>.</li><li><code>get_defaults(rn)</code> is a dictionary of all the default values for parameters and species in <code>rn</code>.</li></ul><p>These are complemented by the Catalyst accessor</p><ul><li><code>Catalyst.get_constraints(sys)</code> is the constraint system of <code>rn</code>. If none is defined will return <code>nothing</code>.</li></ul><p>The preceding accessors do not allocate, directly accessing internal fields of the <code>ReactionSystem</code>.</p><p>To retrieve information from the full reaction network represented by a system <code>rn</code>, which corresponds to information within both <code>rn</code> and all sub-systems of type <code>ReactionSystem</code>, one can call:</p><ul><li><a href="#Catalyst.species"><code>species(rn)</code></a> is a vector collecting all the chemical species within the system and any sub-systems that are also <code>ReactionSystems</code>.</li><li><a href="#Catalyst.reactionparams"><code>reactionparams(rn)</code></a> is a vector of all the parameters within the system and any sub-systems that are also <code>ReactionSystem</code>s. These include all parameters that appear within some <code>Reaction</code>.</li><li><a href="#Catalyst.reactions"><code>reactions(rn)</code></a> is a vector of all the <code>Reaction</code>s within the system and any sub-systems that are also <code>ReactionSystem</code>s.</li></ul><p>These accessors will allocate unless there are no subsystems. In the latter case they are equivalent to the corresponding <code>get_*</code> functions.</p><p>Finally, as some sub-systems may be other system types, for example specifying algebraic constraints with a <code>NonlinearSystem</code>, it can also be convenient to collect all state variables (e.g. species and algebraic variables) and such. The following ModelingToolkit functions provide this information</p><ul><li><code>ModelingToolkit.states(rn)</code> returns all species <em>and variables</em> across the system, <em>all sub-systems</em>, and all constraint systems.</li><li><code>ModelingToolkit.parameters(rn)</code> returns all parameters across the system, <em>all sub-systems</em>, and all constraint systems.</li><li><code>ModelingToolkit.equations(rn)</code> returns all <a href="#Catalyst.Reaction"><code>Reaction</code></a>s and all <code>Equations</code> defined across the system, <em>all sub-systems</em>, and all constraint systems.</li></ul><p><code>states</code> and <code>parameters</code> should be assumed to always allocate, while <code>equations</code> will allocate unless there are no subsystems or constraint systems. In the latter case <code>equations</code> is equivalent to <code>get_eqs</code>.</p><p>Below we list the remainder of the Catalyst API accessor functions mentioned above.</p><h2 id="Basic-System-Properties"><a class="docs-heading-anchor" href="#Basic-System-Properties">Basic System Properties</a><a id="Basic-System-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-System-Properties" title="Permalink"></a></h2><p>See <a href="../../tutorials/reaction_systems/#Programmatic-Construction-of-Symbolic-Reaction-Systems">Programmatic Construction of Symbolic Reaction Systems</a> for examples and <a href="#ModelingToolkit-and-Catalyst-Accessor-Functions">ModelingToolkit and Catalyst Accessor Functions</a> for more details on the basic accessor functions.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.species" href="#Catalyst.species"><code>Catalyst.species</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">species(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of all species defined in the system and any subsystems that are of type <code>ReactionSystem</code>. To get the variables in the system and all subsystems, including non-<code>ReactionSystem</code> subsystems, uses <code>states(network)</code>.</p><p>Notes:</p><ul><li>If <code>ModelingToolkit.get_systems(network)</code> is non-empty will allocate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L53-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactionparams" href="#Catalyst.reactionparams"><code>Catalyst.reactionparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactionparams(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of all parameters defined within the system and any subsystems that are of type <code>ReactionSystem</code>. To get the parameters in the system and all subsystems, including non-<code>ReactionSystem</code> subsystems, use <code>parameters(network)</code>.</p><p>Notes:</p><ul><li>If <code>ModelingToolkit.get_systems(network)</code> is non-empty will allocate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L70-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactions" href="#Catalyst.reactions"><code>Catalyst.reactions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactions(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of all <code>Reactions</code> in the system.</p><p>Notes:</p><ul><li>If <code>ModelingToolkit.get_systems(network)</code> is not empty, will allocate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.numspecies" href="#Catalyst.numspecies"><code>Catalyst.numspecies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numspecies(network)</code></pre><p>Return the total number of species within the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and subsystems that are <code>ReactionSystem</code>s.</p><p>Notes</p><ul><li>If there are no subsystems this will be fast.</li><li>As this calls <a href="#Catalyst.species"><code>species</code></a>, it can be slow and will allocate if there are any subsystems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L144-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.numreactions" href="#Catalyst.numreactions"><code>Catalyst.numreactions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numreactions(network)</code></pre><p>Return the total number of reactions within the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and subsystems that are <code>ReactionSystem</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.numreactionparams" href="#Catalyst.numreactionparams"><code>Catalyst.numreactionparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numreactionparams(network)</code></pre><p>Return the total number of parameters within the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and subsystems that are <code>ReactionSystem</code>s.</p><p>Notes</p><ul><li>If there are no subsystems this will be fast.</li><li>As this calls <a href="#Catalyst.reactionparams"><code>reactionparams</code></a>, it can be slow and will allocate if there are any subsystems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L173-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.speciesmap" href="#Catalyst.speciesmap"><code>Catalyst.speciesmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">speciesmap(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a Dictionary mapping species that participate in <code>Reaction</code>s to their index within <a href="#Catalyst.species"><code>species(network)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.paramsmap" href="#Catalyst.paramsmap"><code>Catalyst.paramsmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">paramsmap(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a Dictionary mapping from all parameters that appear within the system to their index within <code>parameters(network)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L123-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactionparamsmap" href="#Catalyst.reactionparamsmap"><code>Catalyst.reactionparamsmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactionparamsmap(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a Dictionary mapping from parameters that appear within <code>Reaction</code>s to their index within <a href="#Catalyst.reactionparams"><code>reactionparams(network)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isconstant" href="#Catalyst.isconstant"><code>Catalyst.isconstant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Catalyst.isconstant(s)</code></pre><p>Tests if the given symbolic variable corresponds to a constant species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isbc" href="#Catalyst.isbc"><code>Catalyst.isbc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Catalyst.isbc(s)</code></pre><p>Tests if the given symbolic variable corresponds to a boundary condition species.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L17-L21">source</a></section></article><h2 id="Basic-Reaction-Properties"><a class="docs-heading-anchor" href="#Basic-Reaction-Properties">Basic Reaction Properties</a><a id="Basic-Reaction-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Reaction-Properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catalyst.ismassaction" href="#Catalyst.ismassaction"><code>Catalyst.ismassaction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ismassaction(rx, rs; rxvars = get_variables(rx.rate),
                              haveivdep = nothing,
                              stateset = Set(states(rs)),
                              ivset = nothing)</code></pre><p>True if a given reaction is of mass action form, i.e. <code>rx.rate</code> does not depend on any chemical species that correspond to states of the system, and does not depend explicitly on the independent variable (usually time).</p><p><strong>Arguments</strong></p><ul><li><code>rx</code>, the <a href="#Catalyst.Reaction"><code>Reaction</code></a>.</li><li><code>rs</code>, a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> containing the reaction.</li><li>Optional: <code>rxvars</code>, <code>Variable</code>s which are not in <code>rxvars</code> are ignored as possible dependencies.</li><li>Optional: <code>haveivdep</code>, <code>true</code> if the <a href="#Catalyst.Reaction"><code>Reaction</code></a> <code>rate</code> field explicitly depends on any independent variable (i.e. t or for spatial systems x,y,etc). If not set, will be automatically calculated.</li><li>Optional: <code>stateset</code>, set of states which if the rxvars are within mean rx is non-mass action.</li><li>Optional: <code>ivset</code>, a <code>Set</code> of the independent variables of the system. If not provided and the system is spatial, i.e. <code>isspatial(rs) == true</code>, it will be created with all the spatial variables and the time variable. If the rate expression contains any element of <code>ivset</code>, then <code>ismassaction(rx,rs) == false</code>. Pass a custom set to control this behavior.</li></ul><p>Notes:</p><ul><li>Non-integer stoichiometry is treated as non-mass action. This includes symbolic variables/terms or floating point numbers for stoichiometric coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L999-L1030">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.dependents" href="#Catalyst.dependents"><code>Catalyst.dependents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dependents(rx, network)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a> and a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of the <em>non-constant</em> species the reaction rate law depends on. e.g., for</p><p><code>k*W, 2X + 3Y --&gt; 5Z + W</code></p><p>the returned vector would be <code>[W(t),X(t),Y(t)]</code>.</p><p>Notes:</p><ul><li>Allocates</li><li>Does not check for dependents within any subsystems.</li><li>Constant species are not considered dependents since they are internally treated as parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L188-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.dependants" href="#Catalyst.dependants"><code>Catalyst.dependants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dependents(rx, network)</code></pre><p>See documentation for <a href="#Catalyst.dependents"><code>dependents</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L213-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.substoichmat" href="#Catalyst.substoichmat"><code>Catalyst.substoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">substoichmat(rn; sparse=false)</code></pre><p>Returns the substrate stoichiometry matrix, <span>$S$</span>, with <span>$S_{i j}$</span> the stoichiometric coefficient of the ith substrate within the jth reaction.</p><p>Note:</p><ul><li>Set sparse=true for a sparse matrix representation</li><li>Note that constant species are not considered substrates, but just components that modify the associated rate law.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L232-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.prodstoichmat" href="#Catalyst.prodstoichmat"><code>Catalyst.prodstoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prodstoichmat(rn; sparse=false)</code></pre><p>Returns the product stoichiometry matrix, <span>$P$</span>, with <span>$P_{i j}$</span> the stoichiometric coefficient of the ith product within the jth reaction.</p><p>Note:</p><ul><li>Set sparse=true for a sparse matrix representation</li><li>Note that constant species are not treated as products, but just components that modify the associated rate law.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L280-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.netstoichmat" href="#Catalyst.netstoichmat"><code>Catalyst.netstoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">netstoichmat(rn, sparse=false)</code></pre><p>Returns the net stoichiometry matrix, <span>$N$</span>, with <span>$N_{i j}$</span> the net stoichiometric coefficient of the ith species within the jth reaction.</p><p>Notes:</p><ul><li>Set sparse=true for a sparse matrix representation</li><li>Caches the matrix internally within <code>rn</code> so subsequent calls are fast.</li><li>Note that constant species are not treated as reactants, but just components that modify the associated rate law. As such they do not contribute to the net stoichiometry matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L330-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactionrates" href="#Catalyst.reactionrates"><code>Catalyst.reactionrates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactionrates(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, returns a vector of the symbolic reaction rates for each reaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L222-L227">source</a></section></article><h2 id="Functions-to-Extend-or-Modify-a-Network"><a class="docs-heading-anchor" href="#Functions-to-Extend-or-Modify-a-Network">Functions to Extend or Modify a Network</a><a id="Functions-to-Extend-or-Modify-a-Network-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-to-Extend-or-Modify-a-Network" title="Permalink"></a></h2><p><code>ReactionSystem</code>s can be programmatically extended using <a href="#Catalyst.addspecies!"><code>addspecies!</code></a>, <a href="#Catalyst.addparam!"><code>addparam!</code></a>, <a href="#Catalyst.addreaction!"><code>addreaction!</code></a>, <a href="#Catalyst.@add_reactions"><code>@add_reactions</code></a>, or composed using <a href="#ModelingToolkit.extend"><code>ModelingToolkit.extend</code></a> and <a href="#ModelingToolkit.compose"><code>ModelingToolkit.compose</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.@add_reactions" href="#Catalyst.@add_reactions"><code>Catalyst.@add_reactions</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@add_reactions</code></pre><p>Adds the reactions declared to a preexisting <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. All parameters used in the added reactions need to be declared after the reactions.</p><p>See the <a href="../../#Catalyst.jl-for-Reaction-Network-Modeling">Catalyst.jl for Reaction Network Modeling</a> documentation for details on parameters to the macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reaction_network.jl#L170-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.addspecies!" href="#Catalyst.addspecies!"><code>Catalyst.addspecies!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addspecies!(network::ReactionSystem, s::Symbolic; disablechecks=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, add the species corresponding to the variable <code>s</code> to the network (if it is not already defined). Returns the integer id of the species within the system.</p><p>Notes:</p><ul><li><code>disablechecks</code> will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. <em>Do not disable checks</em> unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1346-L1358">source</a></section><section><div><pre><code class="nohighlight hljs">addspecies!(network::ReactionSystem, s::Num; disablechecks=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, add the species corresponding to the variable <code>s</code> to the network (if it is not already defined). Returns the integer id of the species within the system.</p><ul><li><code>disablechecks</code> will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. <em>Do not disable checks</em> unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1375-L1386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reorder_states!" href="#Catalyst.reorder_states!"><code>Catalyst.reorder_states!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reorder_states!(rn, neworder)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and a vector <code>neworder</code>, orders the states of <code>rn</code> accordingly to <code>neworder</code>.</p><p>Notes:</p><ul><li>Currently only supports <code>ReactionSystem</code>s without constraints or subsystems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1391-L1398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.addparam!" href="#Catalyst.addparam!"><code>Catalyst.addparam!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addparam!(network::ReactionSystem, p::Symbolic; disablechecks=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, add the parameter corresponding to the variable <code>p</code> to the network (if it is not already defined). Returns the integer id of the parameter within the system.</p><ul><li><code>disablechecks</code> will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. <em>Do not disable checks</em> unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1407-L1418">source</a></section><section><div><pre><code class="nohighlight hljs">addparam!(network::ReactionSystem, p::Num; disablechecks=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, add the parameter corresponding to the variable <code>p</code> to the network (if it is not already defined). Returns the integer id of the parameter within the system.</p><ul><li><code>disablechecks</code> will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. <em>Do not disable checks</em> unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1436-L1447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.addreaction!" href="#Catalyst.addreaction!"><code>Catalyst.addreaction!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addreaction!(network::ReactionSystem, rx::Reaction)</code></pre><p>Add the passed in reaction to the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. Returns the integer id of <code>rx</code> in the list of <code>Reaction</code>s within <code>network</code>.</p><p>Notes:</p><ul><li>Any new species or parameters used in <code>rx</code> should be separately added to   <code>network</code> using <a href="#Catalyst.addspecies!"><code>addspecies!</code></a> and <a href="#Catalyst.addparam!"><code>addparam!</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1452-L1461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.setdefaults!" href="#Catalyst.setdefaults!"><code>Catalyst.setdefaults!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setdefaults!(rn, newdefs)</code></pre><p>Sets the default (initial) values of parameters and species in the <code>ReactionSystem</code>, <code>rn</code>.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν
setdefaults!(sir, [:S =&gt; 999.0, :I =&gt; 1.0, :R =&gt; 1.0, :β =&gt; 1e-4, :ν =&gt; .01])

# or
@parameter β ν
@variables t S(t) I(t) R(t)
setdefaults!(sir, [S =&gt; 999.0, I =&gt; 1.0, R =&gt; 0.0, β =&gt; 1e-4, ν =&gt; .01])</code></pre><p>gives initial/default values to each of <code>S</code>, <code>I</code> and <code>β</code></p><p>Notes:</p><ul><li>Can not be used to set default values for species, variables or parameters of subsystems or constraint systems. Either set defaults for those systems directly, or <a href="#ModelingToolkit.flatten"><code>flatten</code></a> to collate them into one system before setting defaults.</li><li>Defaults can be specified in any iterable container of symbols to value pairs or symbolics to value pairs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L401-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.extend" href="#ModelingToolkit.extend"><code>ModelingToolkit.extend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ModelingToolkit.extend(sys::Union{NonlinearSystem,ODESystem}, rs::ReactionSystem; name::Symbol=nameof(sys))</code></pre><p>Extends the indicated <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> with a <code>ModelingToolkit.NonlinearSystem</code> or <code>ModelingToolkit.ODESystem</code>, which will be stored internally as constraint equations.</p><p>Notes:</p><ul><li>Returns a new <code>ReactionSystem</code> and does not modify <code>rs</code>.</li><li>By default, the new <code>ReactionSystem</code> will have the same name as <code>sys</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L1650-L1660">source</a></section><section><div><pre><code class="nohighlight hljs">ModelingToolkit.extend(sys::ReactionSystem, rs::ReactionSystem; name::Symbol=nameof(sys))</code></pre><p>Extends the indicated <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> with another <code>ReactionSystem</code>. Similar to calling <code>merge!</code> except constraint systems are allowed (and will also be merged together).</p><p>Notes:</p><ul><li>Returns a new <code>ReactionSystem</code> and does not modify <code>rs</code>.</li><li>By default, the new <code>ReactionSystem</code> will have the same name as <code>sys</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L1671-L1681">source</a></section><section><div><pre><code class="language-julia hljs">extend(sys::ModelingToolkit.AbstractSystem, basesys::ModelingToolkit.AbstractSystem; name) -&gt; ReactionSystem
</code></pre><p>extend the <code>basesys</code> with <code>sys</code>, the resulting system would inherit <code>sys</code>&#39;s name by default.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.compose" href="#ModelingToolkit.compose"><code>ModelingToolkit.compose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compose(sys, systems; name)
</code></pre><p>compose multiple systems together. The resulting system would inherit the first system&#39;s name.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.flatten" href="#ModelingToolkit.flatten"><code>ModelingToolkit.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Catalyst.flatten(rs::ReactionSystem)</code></pre><p>Merges all subsystems of the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> up into <code>rs</code>.</p><p>Notes:</p><ul><li>Returns a new <code>ReactionSystem</code> that represents the flattened system.</li><li>All <code>Reaction</code>s within subsystems are namespaced and merged into the list of <code>Reactions</code> of <code>rs</code>. The merged list is then available as <code>reactions(rs)</code> or <code>get_eqs(rs)</code>.</li><li>All algebraic equations are merged into a <code>NonlinearSystem</code> or <code>ODESystem</code> stored as <code>get_constraints(rs)</code>. If <code>get_constraints !== nothing</code> then the algebraic equations are merged with the current constraints in a system of the same type as the current constraints, otherwise the new constraint system is an <code>ODESystem</code>.</li><li>Currently only <code>ReactionSystem</code>s, <code>NonlinearSystem</code>s and <code>ODESystem</code>s are supported as sub-systems when flattening.</li><li><code>rs.networkproperties</code> is reset upon flattening.</li><li>The default value of <code>combinatoric_ratelaws</code> will be the logical or of all <code>ReactionSystem</code>s.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L1593-L1611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge!-Tuple{ReactionSystem, ReactionSystem}" href="#Base.merge!-Tuple{ReactionSystem, ReactionSystem}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge!(network1::ReactionSystem, network2::ReactionSystem)</code></pre><p>Merge <code>network2</code> into <code>network1</code>.</p><p>Notes:</p><ul><li>Duplicate reactions between the two networks are not filtered out.</li><li><a href="#Catalyst.Reaction"><code>Reaction</code></a>s are not deepcopied to minimize allocations, so both networks will share underlying data arrays.</li><li>Subsystems are not deepcopied between the two networks and will hence be shared.</li><li>Returns <code>network1</code>.</li><li><code>combinatoric_ratelaws</code> is the value of <code>network1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1468-L1481">source</a></section></article><h2 id="Network-Analysis-and-Representations"><a class="docs-heading-anchor" href="#Network-Analysis-and-Representations">Network Analysis and Representations</a><a id="Network-Analysis-and-Representations-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Analysis-and-Representations" title="Permalink"></a></h2><p>Note, currently API functions for network analysis and conservation law analysis do not work with constant species (currently only generated by SBMLToolkit).</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.conservationlaws" href="#Catalyst.conservationlaws"><code>Catalyst.conservationlaws</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservationlaws(netstoichmat::AbstractMatrix)::Matrix</code></pre><p>Given the net stoichiometry matrix of a reaction system, computes a matrix of conservation laws, each represented as a row in the output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1169-L1174">source</a></section><section><div><pre><code class="nohighlight hljs">conservationlaws(rs::ReactionSystem)</code></pre><p>Return the conservation law matrix of the given <code>ReactionSystem</code>, calculating it if it is not already stored within the system, or returning an alias to it.</p><p>Notes:</p><ul><li>The first time being called it is calculated and cached in <code>rn</code>, subsequent calls should be fast.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1230-L1239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.conservedquantities" href="#Catalyst.conservedquantities"><code>Catalyst.conservedquantities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservedquantities(state, cons_laws)</code></pre><p>Compute conserved quantities for a system with the given conservation laws.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1249-L1253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.conservedequations" href="#Catalyst.conservedequations"><code>Catalyst.conservedequations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservedequations(rn::ReactionSystem)</code></pre><p>Calculate symbolic equations from conservation laws, writing dependent variables as functions of independent variables and the conservation law constants.</p><p>Notes:</p><ul><li>Caches the resulting equations in <code>rn</code>, so will be fast on subsequent calls.</li></ul><p>Examples:</p><pre><code class="language- hljs">rn = @reaction_network begin
    k, A + B --&gt; C
    k2, C --&gt; A + B
    end k k2
conservedequations(rn)</code></pre><p>gives</p><pre><code class="nohighlight hljs">2-element Vector{Equation}:
 B(t) ~ A(t) + _ConLaw[1]
 C(t) ~ _ConLaw[2] - A(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1109-L1132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.conservationlaw_constants" href="#Catalyst.conservationlaw_constants"><code>Catalyst.conservationlaw_constants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservationlaw_constants(rn::ReactionSystem)</code></pre><p>Calculate symbolic equations from conservation laws, writing the conservation law constants in terms of the dependent and independent variables.</p><p>Notes:</p><ul><li>Caches the resulting equations in <code>rn</code>, so will be fast on subsequent calls.</li></ul><p>Examples:</p><pre><code class="language- hljs">rn = @reaction_network begin
    k, A + B --&gt; C
    k2, C --&gt; A + B
    end k k2
conservationlaw_constants(rn)</code></pre><p>gives</p><pre><code class="nohighlight hljs">2-element Vector{Equation}:
 _ConLaw[1] ~ B(t) - A(t)
 _ConLaw[2] ~ A(t) + C(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1139-L1162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.ReactionComplexElement" href="#Catalyst.ReactionComplexElement"><code>Catalyst.ReactionComplexElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReactionComplexElement{T}</code></pre><p>One reaction complex element</p><p><strong>Fields</strong></p><ul><li><p><code>speciesid</code></p><p>The integer id of the species representing this element.</p></li><li><p><code>speciesstoich</code></p><p>The stoichiometric coefficient of this species.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.ReactionComplex" href="#Catalyst.ReactionComplex"><code>Catalyst.ReactionComplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReactionComplex{V&lt;:Integer} &lt;: AbstractArray{Catalyst.ReactionComplexElement{V&lt;:Integer}, 1}</code></pre><p>One reaction complex.</p><p><strong>Fields</strong></p><ul><li><p><code>speciesids</code></p><p>The integer ids of all species participating in this complex.</p></li><li><p><code>speciesstoichs</code></p><p>The stoichiometric coefficients of all species participating in this complex.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactioncomplexmap" href="#Catalyst.reactioncomplexmap"><code>Catalyst.reactioncomplexmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactioncomplexmap(rn::ReactionSystem)</code></pre><p>Find each <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a> within the specified system, constructing a mapping from the complex to vectors that indicate which reactions it appears in as substrates and products.</p><p>Notes:</p><ul><li>Each <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a> is mapped to a vector of pairs, with each pair having the form <code>reactionidx =&gt; ± 1</code>, where <code>-1</code> indicates the complex appears as a substrate and <code>+1</code> as a product in the reaction with integer label <code>reactionidx</code>.</li><li>Constant species are ignored as part of a complex. i.e. if species <code>A</code> is constant then the reaction <code>A + B --&gt; C + D</code> is considered to consist of the complexes <code>B</code> and <code>C + D</code>. Likewise <code>A --&gt; B</code> would be treated as the same as <code>0 --&gt; B</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L594-L608">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactioncomplexes" href="#Catalyst.reactioncomplexes"><code>Catalyst.reactioncomplexes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactioncomplexes(network::ReactionSystem; sparse=false)</code></pre><p>Calculate the reaction complexes and complex incidence matrix for the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>.</p><p>Notes:</p><ul><li>returns a pair of a vector of <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a>s and the complex incidence matrix.</li><li>An empty <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a> denotes the null (∅) state (from reactions like ∅ -&gt; A or A -&gt; ∅).</li><li>Constant species are ignored in generating a reaction complex. i.e. if A is constant then A –&gt; B consists of the complexes ∅ and B.</li><li>The complex incidence matrix, <span>$B$</span>, is number of complexes by number of reactions with</li></ul><p class="math-container">\[B_{i j} = \begin{cases}
-1, &amp;\text{if the i&#39;th complex is the substrate of the j&#39;th reaction},\\
1, &amp;\text{if the i&#39;th complex is the product of the j&#39;th reaction},\\
0, &amp;\text{otherwise.}
\end{cases}\]</p><ul><li>Set sparse=true for a sparse matrix representation of the incidence matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L669-L690">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.incidencemat" href="#Catalyst.incidencemat"><code>Catalyst.incidencemat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">incidencemat(rn::ReactionSystem; sparse=false)</code></pre><p>Calculate the incidence matrix of <code>rn</code>, see <a href="#Catalyst.reactioncomplexes"><code>reactioncomplexes</code></a>.</p><p>Notes:</p><ul><li>Is cached in <code>rn</code> so that future calls, assuming the same sparsity, will also be fast.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L706-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.complexstoichmat" href="#Catalyst.complexstoichmat"><code>Catalyst.complexstoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexstoichmat(network::ReactionSystem; sparse=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and vector of reaction complexes, return a matrix with positive entries of size number of species by number of complexes, where the non-zero positive entries in the kth column denote stoichiometric coefficients of the species participating in the kth reaction complex.</p><p>Notes:</p><ul><li>Set sparse=true for a sparse matrix representation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L739-L749">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.complexoutgoingmat" href="#Catalyst.complexoutgoingmat"><code>Catalyst.complexoutgoingmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexoutgoingmat(network::ReactionSystem; sparse=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and complex incidence matrix, <span>$B$</span>, return a matrix of size num of complexes by num of reactions that identifies substrate complexes.</p><p>Notes:</p><ul><li>The complex outgoing matrix, <span>$\Delta$</span>, is defined by</li></ul><p class="math-container">\[\Delta_{i j} = \begin{cases}
    = 0,    &amp;\text{if } B_{i j} = 1, \\
    = B_{i j}, &amp;\text{otherwise.}
\end{cases}\]</p><ul><li>Set sparse=true for a sparse matrix representation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L793-L809">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.incidencematgraph" href="#Catalyst.incidencematgraph"><code>Catalyst.incidencematgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">incidencematgraph(rn::ReactionSystem)</code></pre><p>Construct a directed simple graph where nodes correspond to reaction complexes and directed edges to reactions converting between two complexes.</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν
complexes,incidencemat = reactioncomplexes(sir)
incidencematgraph(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L860-L879">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.linkageclasses" href="#Catalyst.linkageclasses"><code>Catalyst.linkageclasses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linkageclasses(rn::ReactionSystem)</code></pre><p>Given the incidence graph of a reaction network, return a vector of the connected components of the graph (i.e. sub-groups of reaction complexes that are connected in the incidence graph).</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν
complexes,incidencemat = reactioncomplexes(sir)
linkageclasses(sir)</code></pre><p>gives</p><pre><code class="language-julia hljs">2-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L893-L919">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.deficiency" href="#Catalyst.deficiency"><code>Catalyst.deficiency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deficiency(rn::ReactionSystem)</code></pre><p>Calculate the deficiency of a reaction network.</p><p>Here the deficiency, <span>$\delta$</span>, of a network with <span>$n$</span> reaction complexes, <span>$\ell$</span> linkage classes and a rank <span>$s$</span> stoichiometric matrix is</p><p class="math-container">\[\delta = n - \ell - s\]</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν
rcs,incidencemat = reactioncomplexes(sir)
δ = deficiency(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L928-L953">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.subnetworks" href="#Catalyst.subnetworks"><code>Catalyst.subnetworks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subnetworks(rn::ReactionSystem)</code></pre><p>Find subnetworks corresponding to each linkage class of the reaction network.</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν
complexes,incidencemat = reactioncomplexes(sir)
subnetworks(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L982-L1000">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.linkagedeficiencies" href="#Catalyst.linkagedeficiencies"><code>Catalyst.linkagedeficiencies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linkagedeficiencies(network::ReactionSystem)</code></pre><p>Calculates the deficiency of each sub-reaction network within <code>network</code>.</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν
rcs,incidencemat = reactioncomplexes(sir)
linkage_deficiencies = linkagedeficiencies(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1019-L1037">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isreversible" href="#Catalyst.isreversible"><code>Catalyst.isreversible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isreversible(rn::ReactionSystem)</code></pre><p>Given a reaction network, returns if the network is reversible or not.</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν
rcs,incidencemat = reactioncomplexes(sir)
isreversible(sir)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1050-L1068">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isweaklyreversible" href="#Catalyst.isweaklyreversible"><code>Catalyst.isweaklyreversible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isweaklyreversible(rn::ReactionSystem, subnetworks)</code></pre><p>Determine if the reaction network with the given subnetworks is weakly reversible or not.</p><p>Notes:</p><ul><li>Requires the <code>incidencemat</code> to already be cached in <code>rn</code> by a previous call to <code>reactioncomplexes</code>.</li></ul><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν
rcs,incidencemat = reactioncomplexes(sir)
subnets = subnetworks(rn)
isweaklyreversible(rn, subnets)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1074-L1093">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reset_networkproperties!" href="#Catalyst.reset_networkproperties!"><code>Catalyst.reset_networkproperties!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset_networkproperties!(rn::ReactionSystem)</code></pre><p>Clears the cache of various properties (like the netstoichiometry matrix). Use if such properties need to be recalculated for some reason.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L563-L568">source</a></section></article><h2 id="Network-Comparison"><a class="docs-heading-anchor" href="#Network-Comparison">Network Comparison</a><a id="Network-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Comparison" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Reaction, Reaction}" href="#Base.:==-Tuple{Reaction, Reaction}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(rx1::Reaction, rx2::Reaction)</code></pre><p>Tests whether two <a href="#Catalyst.Reaction"><code>Reaction</code></a>s are identical.</p><p>Notes:</p><ul><li>Ignores the order in which stoichiometry components are listed.</li><li><em>Does not</em> currently simplify rates, so a rate of <code>A^2+2*A+1</code> would be   considered different than <code>(A+1)^2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1258-L1267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isequal_ignore_names" href="#Catalyst.isequal_ignore_names"><code>Catalyst.isequal_ignore_names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isequal_ignore_names(rn1::ReactionSystem, rn2::ReactionSystem)</code></pre><p>Tests whether the underlying species, parameters and reactions are the same in the two <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>s. Ignores the names of the systems in testing equality.</p><p>Notes:</p><ul><li><em>Does not</em> currently simplify rates, so a rate of <code>A^2+2*A+1</code> would be   considered different than <code>(A+1)^2</code>.</li><li>Does not include <code>defaults</code> in determining equality.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1288-L1299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{ReactionSystem, ReactionSystem}" href="#Base.:==-Tuple{ReactionSystem, ReactionSystem}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(rn1::ReactionSystem, rn2::ReactionSystem)</code></pre><p>Tests whether the underlying species, parameters and reactions are the same in the two <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>s. Requires the systems to have the same names too.</p><p>Notes:</p><ul><li><em>Does not</em> currently simplify rates, so a rate of <code>A^2+2*A+1</code> would be   considered different than <code>(A+1)^2</code>.</li><li>Does not include <code>defaults</code> in determining equality.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1317-L1328">source</a></section></article><h2 id="Network-Visualization"><a class="docs-heading-anchor" href="#Network-Visualization">Network Visualization</a><a id="Network-Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Visualization" title="Permalink"></a></h2><p><a href="https://korsbo.github.io/Latexify.jl/stable/">Latexify</a> can be used to convert networks to LaTeX mhchem equations by</p><pre><code class="language-julia hljs">using Latexify
latexify(rn)</code></pre><p>If <a href="https://graphviz.org/">Graphviz</a> is installed and commandline accessible, it can be used to create and save network diagrams using <a href="#Catalyst.Graph"><code>Graph</code></a> and <a href="#Catalyst.savegraph"><code>savegraph</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.Graph" href="#Catalyst.Graph"><code>Catalyst.Graph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Graph(rn::ReactionSystem)</code></pre><p>Converts a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> into a Graphviz graph. Reactions correspond to small green circles, and species to blue circles.</p><p>Notes:</p><ul><li>Black arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry.</li><li>Black arrows from reactions to species indicate products, and are labelled with their output stoichiometry.</li><li>Red arrows from species to reactions indicate that species is used within the rate expression. For example, in the reaction <code>k*A, B --&gt; C</code>, there would be a red arrow from <code>A</code> to the reaction node. In <code>k*A, A+B --&gt; C</code>, there would be red and black arrows from <code>A</code> to the reaction node.</li><li>Requires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/graphs.jl#L371-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.complexgraph" href="#Catalyst.complexgraph"><code>Catalyst.complexgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexgraph(rn::ReactionSystem; complexdata=reactioncomplexes(rn))</code></pre><p>Creates a Graphviz graph of the <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a>s in <code>rn</code>. Reactions correspond to arrows and reaction complexes to blue circles. </p><p>Notes:</p><ul><li>Black arrows from complexes to complexes indicate reactions whose rate is a parameter or a <code>Number</code>. i.e. <code>k, A --&gt; B</code>.</li><li>Red dashed arrows from complexes to complexes indicate reactions whose rate depends on species. i.e. <code>k*C, A --&gt; B</code> for <code>C</code> a species.</li><li>Requires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/graphs.jl#L323-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.savegraph" href="#Catalyst.savegraph"><code>Catalyst.savegraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">savegraph(g::Graph, fname, fmt=&quot;png&quot;)</code></pre><p>Given a <code>Graph</code> generated by <a href="#Catalyst.Graph"><code>Graph</code></a>, save the graph to the file with name <code>fname</code> and extension <code>fmt</code>.</p><p>Notes:</p><ul><li><code>fmt=&quot;png&quot;</code> is the default output format.</li><li>Requires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/graphs.jl#L414-L423">source</a></section></article><h2 id="Rate-Laws"><a class="docs-heading-anchor" href="#Rate-Laws">Rate Laws</a><a id="Rate-Laws-1"></a><a class="docs-heading-anchor-permalink" href="#Rate-Laws" title="Permalink"></a></h2><p>As the underlying <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> is comprised of <code>ModelingToolkit</code> expressions, one can directly access the generated rate laws, and using <code>ModelingToolkit</code> tooling generate functions or Julia <code>Expr</code>s from them.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.oderatelaw" href="#Catalyst.oderatelaw"><code>Catalyst.oderatelaw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">oderatelaw(rx; combinatoric_ratelaw=true)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a>, return the symbolic reaction rate law used in generated ODEs for the reaction. Note, for a reaction defined by</p><p><code>k*X*Y, X+Z --&gt; 2X + Y</code></p><p>the expression that is returned will be <code>k*X(t)^2*Y(t)*Z(t)</code>. For a reaction of the form</p><p><code>k, 2X+3Y --&gt; Z</code></p><p>the expression that is returned will be <code>k * (X(t)^2/2) * (Y(t)^3/6)</code>.</p><p>Notes:</p><ul><li>Allocates</li><li><code>combinatoric_ratelaw=true</code> uses factorial scaling factors in calculating the   rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. If   <code>combinatoric_ratelaw=false</code> then the ratelaw is <code>k*S^2</code>, i.e. the scaling   factor is ignored.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L814-L835">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.jumpratelaw" href="#Catalyst.jumpratelaw"><code>Catalyst.jumpratelaw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jumpratelaw(rx; combinatoric_ratelaw=true)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a>, return the symbolic reaction rate law used in generated stochastic chemical kinetics model SSAs for the reaction. Note, for a reaction defined by</p><p><code>k*X*Y, X+Z --&gt; 2X + Y</code></p><p>the expression that is returned will be <code>k*X^2*Y*Z</code>. For a reaction of the form</p><p><code>k, 2X+3Y --&gt; Z</code></p><p>the expression that is returned will be <code>k * binomial(X,2) * binomial(Y,3)</code>.</p><p>Notes:</p><ul><li>Allocates</li><li><code>combinatoric_ratelaw=true</code> uses binomials in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S*(S-1)/2</code>. If <code>combinatoric_ratelaw=false</code> then the ratelaw is <code>k*S*(S-1)</code>, i.e. the rate law is not normalized by the scaling factor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L950-L973">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.mm" href="#Catalyst.mm"><code>Catalyst.mm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mm(X,v,K) = v*X / (X + K)</code></pre><p>A Michaelis-Menten rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/registered_functions.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.mmr" href="#Catalyst.mmr"><code>Catalyst.mmr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mmr(X,v,K) = v*K / (X + K)</code></pre><p>A repressive Michaelis-Menten rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/registered_functions.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.hill" href="#Catalyst.hill"><code>Catalyst.hill</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hill(X,v,K,n) = v*(X^n) / (X^n + K^n)</code></pre><p>A Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/registered_functions.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.hillr" href="#Catalyst.hillr"><code>Catalyst.hillr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hillr(X,v,K,n) = v*(K^n) / (X^n + K^n)</code></pre><p>A repressive Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/registered_functions.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.hillar" href="#Catalyst.hillar"><code>Catalyst.hillar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hillar(X,Y,v,K,n) = v*(X^n) / (X^n + Y^n + K^n)</code></pre><p>An activation/repressing Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/registered_functions.jl#L82-L86">source</a></section></article><h2 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.convert" href="#Base.convert"><code>Base.convert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:ODESystem},rs::ReactionSystem)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.ODESystem</code>.</p><p>Keyword args and default values:</p><ul><li><code>combinatoric_ratelaws=true</code> uses factorial scaling factors in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. Set <code>combinatoric_ratelaws=false</code> for a ratelaw of <code>k*S^2</code>, i.e. the scaling factor is ignored. Defaults to the value given when the <code>ReactionSystem</code> was constructed (which itself defaults to true).</li><li><code>remove_conserved=false</code>, if set to <code>true</code> will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L1290-L1305">source</a></section><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:NonlinearSystem},rs::ReactionSystem)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.NonlinearSystem</code>.</p><p>Keyword args and default values:</p><ul><li><code>combinatoric_ratelaws=true</code> uses factorial scaling factors in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. Set <code>combinatoric_ratelaws=false</code> for a ratelaw of <code>k*S^2</code>, i.e. the scaling factor is ignored. Defaults to the value given when the <code>ReactionSystem</code> was constructed (which itself defaults to true).</li><li><code>remove_conserved=false</code>, if set to <code>true</code> will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L1323-L1339">source</a></section><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:SDESystem},rs::ReactionSystem)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.SDESystem</code>.</p><p>Notes:</p><ul><li><code>combinatoric_ratelaws=true</code> uses factorial scaling factors in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. Set <code>combinatoric_ratelaws=false</code> for a ratelaw of <code>k*S^2</code>, i.e. the scaling factor is ignored. Defaults to the value given when the <code>ReactionSystem</code> was constructed (which itself defaults to true).</li><li><code>noise_scaling=nothing::Union{Vector{Num},Num,Nothing}</code> allows for linear scaling of the noise in the chemical Langevin equations. If <code>nothing</code> is given, the default value as in Gillespie 2000 is used. Alternatively, a <code>Num</code> can be given, this is added as a parameter to the system (at the end of the parameter array). All noise terms are linearly scaled with this value. The parameter may be one already declared in the <code>ReactionSystem</code>. Finally, a <code>Vector{Num}</code> can be provided (the length must be equal to the number of reactions). Here the noise for each reaction is scaled by the corresponding parameter in the input vector. This input may contain repeat parameters.</li><li><code>remove_conserved=false</code>, if set to <code>true</code> will calculate conservation laws of the underlying set of reactions (ignoring constraint equations), and then apply them to reduce the number of equations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L1356-L1380">source</a></section><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:JumpSystem},rs::ReactionSystem; combinatoric_ratelaws=true)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.JumpSystem</code>.</p><p>Notes:</p><ul><li><code>combinatoric_ratelaws=true</code> uses binomials in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S*(S-1)/2</code>. If <code>combinatoric_ratelaws=false</code> then the ratelaw is <code>k*S*(S-1)</code>, i.e. the rate law is not normalized by the scaling factor. Defaults to the value given when the <code>ReactionSystem</code> was constructed (which itself defaults to true).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/reactionsystem.jl#L1419-L1432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.structural_simplify" href="#ModelingToolkit.structural_simplify"><code>ModelingToolkit.structural_simplify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">structural_simplify(sys)
structural_simplify(sys, io; simplify, simplify_constants, check_consistency, kwargs...)
</code></pre><p>Structurally simplify algebraic equations in a system and compute the topological sort of the observed equations. When <code>simplify=true</code>, the <code>simplify</code> function will be applied during the tearing process. It also takes kwargs <code>allow_symbolic=false</code> and <code>allow_parameter=true</code> which limits the coefficient types during tearing.</p><p>The optional argument <code>io</code> may take a tuple <code>(inputs, outputs)</code>. This will convert all <code>inputs</code> to parameters and allow them to be unconnected, i.e., simplification will allow models where <code>n_states = n_equations - n_inputs</code>.</p></div></section></article><h2 id="Unit-Validation"><a class="docs-heading-anchor" href="#Unit-Validation">Unit Validation</a><a id="Unit-Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-Validation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.validate-Tuple{Reaction}" href="#ModelingToolkit.validate-Tuple{Reaction}"><code>ModelingToolkit.validate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate(rx::Reaction; info::String = &quot;&quot;)</code></pre><p>Check that all substrates and products within the given <a href="#Catalyst.Reaction"><code>Reaction</code></a> have the same units, and that the units of the reaction&#39;s rate expression are internally consistent (i.e. if the rate involves sums, each term in the sum has the same units).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1500-L1508">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.validate" href="#ModelingToolkit.validate"><code>ModelingToolkit.validate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">validate(rs::ReactionSystem, info::String=&quot;&quot;)</code></pre><p>Check that all species in the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> have the same units, and that the rate laws of all reactions reduce to units of (species units) / (time units).</p><p>Notes:</p><ul><li>Does not check subsystems too.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L1537-L1546">source</a></section></article><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catalyst.symmap_to_varmap" href="#Catalyst.symmap_to_varmap"><code>Catalyst.symmap_to_varmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">symmap_to_varmap(sys, symmap)</code></pre><p>Given a system and map of <code>Symbol</code>s to values, generates a map from corresponding symbolic variables/parameters to the values that can be used to pass initial conditions and parameter mappings.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network sir begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν
subsys = @reaction_network subsys begin
    k, A --&gt; B
end k
@named sys = compose(sir, [subsys])</code></pre><p>gives</p><pre><code class="nohighlight hljs">Model sys with 3 equations
States (5):
  S(t)
  I(t)
  R(t)
  subsys₊A(t)
  subsys₊B(t)
Parameters (3):
  β
  ν
  subsys₊k</code></pre><p>to specify initial condition and parameter mappings from <em>symbols</em> we can use</p><pre><code class="language-julia hljs">symmap = [:S =&gt; 1.0, :I =&gt; 1.0, :R =&gt; 1.0, :subsys₊A =&gt; 1.0, :subsys₊B =&gt; 1.0]
u0map  = symmap_to_varmap(sys, symmap)
pmap   = symmap_to_varmap(sys, [:β =&gt; 1.0, :ν =&gt; 1.0, :subsys₊k =&gt; 1.0])</code></pre><p><code>u0map</code> and <code>pmap</code> can then be used as input to various problem types.</p><p>Notes:</p><ul><li>Any <code>Symbol</code>, <code>sym</code>, within <code>symmap</code> must be a valid field of <code>sys</code>. i.e. <code>sys.sym</code> must be defined.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/055f86120b03382142be773e763835035f1d5c6b/src/networkapi.jl#L497-L540">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../faqs/">« FAQs</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 8 November 2022 20:07">Tuesday 8 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
