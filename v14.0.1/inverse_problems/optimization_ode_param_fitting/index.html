<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl · Catalyst.jl</title><meta name="title" content="Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl · Catalyst.jl"/><meta property="og:title" content="Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl · Catalyst.jl"/><meta property="twitter:title" content="Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/inverse_problems/optimization_ode_param_fitting/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/inverse_problems/optimization_ode_param_fitting/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/inverse_problems/optimization_ode_param_fitting/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introduction to Catalyst</span><ul><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><span class="tocitem">Model Creation and Properties</span><ul><li><a class="tocitem" href="../../model_creation/dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../../model_creation/dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../../model_creation/programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../model_creation/constraint_equations/">Constraint Equations and Events</a></li><li><a class="tocitem" href="../../model_creation/parametric_stoichiometry/">Symbolic Stochiometries</a></li><li><a class="tocitem" href="../../model_creation/model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../../model_creation/model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../../model_creation/network_analysis/">Network Analysis in Catalyst</a></li><li><a class="tocitem" href="../../model_creation/chemistry_related_functionality/">Chemistry-related functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-11" type="checkbox"/><label class="tocitem" for="menuitem-3-11"><span class="docs-label">Model creation examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_creation/examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../../model_creation/examples/programmatic_generative_linear_pathway/">Programmatic, generative, modelling of a linear pathway</a></li><li><a class="tocitem" href="../../model_creation/examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../../model_creation/examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li></ul></li></ul></li><li><span class="tocitem">Model simulation</span><ul><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing problems, integrators, and solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for performant ODE simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for performant SDE simulations</a></li></ul></li><li><span class="tocitem">Steady state analysis</span><ul><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing model steady state properties with DynamicalSystems.jl</a></li></ul></li><li><span class="tocitem">Inverse Problems</span><ul><li class="is-active"><a class="tocitem" href>Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a><ul class="internal"><li><a class="tocitem" href="#optimization_parameter_fitting_basics"><span>Basic example</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_multiple_species"><span>Optimisation problems with data for multiple species</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_constraints"><span>Setting parameter constraints and boundaries</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_known_parameters"><span>Parameter fitting with known parameters</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_log_scale"><span>Fitting parameters on the logarithmic scale</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_multiple_experiments"><span>Parameter fitting to multiple experiments</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_solver_options"><span>Optimisation solver options</span></a></li><li><a class="tocitem" href="#optimization_parameter_fitting_citation"><span>Citation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../behaviour_optimisation/">Optimization for non-data fitting purposes</a></li><li><a class="tocitem" href="../structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../global_sensitivity_analysis/">Global Sensitivity Analysis</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Inverse problem examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/ode_fitting_oscillation/">Fitting Parameters for an Oscillatory System</a></li></ul></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Inverse Problems</a></li><li class="is-active"><a href>Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/inverse_problems/optimization_ode_param_fitting.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="optimization_parameter_fitting"><a class="docs-heading-anchor" href="#optimization_parameter_fitting">Parameter Fitting for ODEs using Optimization.jl and DiffEqParamEstim.jl</a><a id="optimization_parameter_fitting-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting" title="Permalink"></a></h1><p>Fitting parameters to data involves solving an optimisation problem (that is, finding the parameter set that optimally fits your model to your data, typically by minimising a cost function)<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. The SciML ecosystem&#39;s primary package for solving optimisation problems is <a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a>. It provides access to a variety of solvers via a single common interface by wrapping a large number of optimisation libraries that have been implemented in Julia.</p><p>This tutorial demonstrates both how to create parameter fitting cost functions using the <a href="https://github.com/SciML/DiffEqParamEstim.jl">DiffEqParamEstim.jl</a> package, and how to use Optimization.jl to minimise these. Optimization.jl can also be used in other contexts, such as <a href="../behaviour_optimisation/#behaviour_optimisation">finding parameter sets that maximise the magnitude of some system behaviour</a>. More details on how to use these packages can be found in their <a href="https://docs.sciml.ai/Optimization/stable/">respective</a> <a href="https://docs.sciml.ai/DiffEqParamEstim/stable/">documentations</a>.</p><h2 id="optimization_parameter_fitting_basics"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_basics">Basic example</a><a id="optimization_parameter_fitting_basics-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_basics" title="Permalink"></a></h2><p>Let us consider a <a href="../../model_creation/examples/basic_CRN_library/#basic_CRN_library_mm">Michaelis-Menten enzyme kinetics model</a>, where an enzyme (<span>$E$</span>) converts a substrate (<span>$S$</span>) into a product (<span>$P$</span>):</p><pre><code class="language-julia hljs">using Catalyst
rn = @reaction_network begin
    kB, S + E --&gt; SE
    kD, SE --&gt; S + E
    kP, SE --&gt; P + E
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{S} + \mathrm{E} &amp;\xrightleftharpoons[kD]{kB} \mathrm{SE} \\
\mathrm{SE} &amp;\xrightarrow{kP} \mathrm{P} + \mathrm{E}  
 \end{align*}
 \]</p><p>From some known initial condition, and a true parameter set (which we later want to recover from the data) we generate synthetic data (on which we will demonstrate the fitting process).</p><pre><code class="language-julia hljs"># Define initial conditions and parameters.
u0 = [:S =&gt; 1.0, :E =&gt; 1.0, :SE =&gt; 0.0, :P =&gt; 0.0]
ps_true = [:kB =&gt; 1.0, :kD =&gt; 0.1, :kP =&gt; 0.5]

# Generate synthetic data.
using OrdinaryDiffEq
oprob_true = ODEProblem(rn, u0, (0.0, 10.0), ps_true)
true_sol = solve(oprob_true)
data_sol = solve(oprob_true; saveat=1.0)
data_ts = data_sol.t[2:end]
data_vals = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]

# Plots the true solutions and the (synthetic) data measurements.
using Plots
plot(true_sol; idxs = :P, label = &quot;True solution&quot;, lw = 8)
plot!(data_ts, data_vals; label = &quot;Measurements&quot;, seriestype=:scatter, ms = 6, color = :blue)</code></pre><img src="ab7b2850.svg" alt="Example block output"/><p>Next, we will use DiffEqParamEstim to build a loss function to measure how well our model&#39;s solutions fit the data.</p><pre><code class="language-julia hljs">using DiffEqParamEstim, Optimization
ps_dummy = [:kB =&gt; 0.0, :kD =&gt; 0.0, :kP =&gt; 0.0]
oprob = ODEProblem(rn, u0, (0.0, 10.0), ps_dummy)
loss_function = build_loss_objective(oprob, Tsit5(), L2Loss(data_ts, data_vals), Optimization.AutoForwardDiff();
                                     maxiters = 10000, verbose = false, save_idxs = 4)</code></pre><p>To <code>build_loss_objective</code> we provide the following arguments:</p><ul><li><code>oprob</code>: The <code>ODEProblem</code> with which we simulate our model (using some dummy parameter values, since we do not know these).</li><li><code>Tsit5()</code>: The <a href="../../model_simulation/simulation_introduction/#simulation_intro_solver_options">numeric solver</a> we wish to simulate our model with.</li><li><code>L2Loss(data_ts, data_vals)</code>: Defines the loss function. While <a href="https://docs.sciml.ai/DiffEqParamEstim/stable/getting_started/#Alternative-Cost-Functions-for-Increased-Robustness">other alternatives</a> are available, <code>L2Loss</code> is the simplest one (measuring the sum of squared distances between model simulations and data measurements). Its first argument is the time points at which the data is collected, and the second is the data&#39;s values.</li><li><code>Optimization.AutoForwardDiff()</code>: Our choice of <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a> framework.</li></ul><p>Furthermore, we can pass any number of additional optional arguments, these are then passed to the internal <code>solve()</code> function (which is used to solve our ODE). Here we provide the following additional arguments:</p><ul><li><code>maxiters = 10000</code>: If the ODE integrator takes a very large number of steps, that can be a sign of a very poor fit (or stiffness in the ODEs, but that is not a concern for our current example). Reducing the <code>maxiters</code> threshold reduces the time we waste on evaluating such models. </li><li><code>verbose = false</code>: The simulation of models with highly unsuitable parameter sets typically generate various warnings (such as premature simulation termination due to reaching <code>maxiters</code> time steps). To avoid an overflow of such (here unnecessary) warnings, as we evaluate a large number of parameter sets, we turn warnings off.</li><li><code>save_idxs = 4</code>: The measured species (<span>$P$</span>) is the 4th species in our species vector (<code>species(rn)</code>). Since data is available for <span>$P(t)$</span>, we will only save the value of this species.</li></ul><p>Now we can create an <code>OptimizationProblem</code> using our <code>loss_function</code> and some initial guess of parameter values from which the optimiser will start:</p><pre><code class="language-julia hljs">optprob = OptimizationProblem(loss_function, [1.0, 1.0, 1.0])</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>OptimizationProblem</code> cannot currently accept parameter values in the form of a map (e.g. <code>[:kB =&gt; 1.0, :kD =&gt; 1.0, :kP =&gt; 1.0]</code>). These must be provided as individual values (using the same order as the parameters occur in in the <code>parameters(rs)</code> vector). Similarly, <code>build_loss_objective</code>&#39;s <code>save_idxs</code> uses the species&#39; indexes, rather than the species directly. These inconsistencies should be remedied in future DiffEqParamEstim releases.</p></div></div><p>Finally, we can optimise <code>optprob</code> to find the parameter set that best fits our data. Optimization.jl only provides a few optimisation methods natively. However, for each supported optimisation package, it provides a corresponding wrapper-package to import that optimisation package for use with Optimization.jl. E.g., if we wish to use <a href="https://github.com/JuliaOpt/NLopt.jl">NLopt.jl</a>&#39;s <a href="https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method">Nelder-Mead</a> method, we must install and import the OptimizationNLopt package. A summary of all, by Optimization.jl supported, optimisation packages can be found <a href="https://docs.sciml.ai/Optimization/stable/#Overview-of-the-Optimizers">here</a>. Here, we import the NLopt.jl package and uses it to minimise our cost function (thus finding a parameter set that fits the data):</p><pre><code class="language-julia hljs">using OptimizationNLopt
optsol = solve(optprob, NLopt.LN_NELDERMEAD())</code></pre><p>We can now simulate our model for the corresponding parameter set, checking that it fits our data.</p><pre><code class="language-julia hljs">oprob_fitted = remake(oprob; p = optsol.u)
fitted_sol = solve(oprob_fitted, Tsit5())
plot!(fitted_sol; idxs = :P, label = &quot;Fitted solution&quot;, linestyle = :dash, lw = 6, color = :lightblue)</code></pre><img src="fefcf0a6.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Here, a good exercise is to check the resulting parameter set and note that, while it creates a good fit to the data, it does not actually correspond to the original parameter set. <a href="../structural_identifiability/#structural_identifiability">Identifiability</a> is a concept that studies how to deal with this problem.</p></div></div><p>Say that we instead would like to use the <a href="https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm">Broyden–Fletcher–Goldfarb–Shannon</a> algorithm, as implemented by the <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> package. In this case we would run:</p><pre><code class="language-julia hljs">using OptimizationOptimJL
sol = solve(optprob, Optim.LBFGS())</code></pre><h2 id="optimization_parameter_fitting_multiple_species"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_multiple_species">Optimisation problems with data for multiple species</a><a id="optimization_parameter_fitting_multiple_species-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_multiple_species" title="Permalink"></a></h2><p>Imagine that, in our previous example, we had measurements of the concentration of both <em>S</em> and <em>P</em>:</p><pre><code class="language-julia hljs">data_vals_S = (0.8 .+ 0.4*rand(10)) .* data_sol[:S][2:end]
data_vals_P = (0.8 .+ 0.4*rand(10)) .* data_sol[:P][2:end]

plot(true_sol; idxs=[:S, :P], label=[&quot;True S&quot; &quot;True P&quot;], lw=8)
plot!(data_ts, data_vals_S; label=&quot;Measured S&quot;, seriestype=:scatter, ms=6, color=:blue)
plot!(data_ts, data_vals_P; label=&quot;Measured P&quot;, seriestype=:scatter, ms=6, color=:red)</code></pre><img src="0bc03163.svg" alt="Example block output"/><p>In this case we would have to use the <code>L2Loss(data_ts, hcat(data_vals_S, data_vals_P))</code> and <code>save_idxs=[1, 4]</code> arguments in <code>loss_function</code>:</p><pre><code class="language-julia hljs">loss_function_S_P = build_loss_objective(oprob, Tsit5(), L2Loss(data_ts, Array(hcat(data_vals_S, data_vals_P)&#39;)), Optimization.AutoForwardDiff(); maxiters=10000, verbose=false, save_idxs=[1, 4])</code></pre><p>Here, <code>Array(hcat(data_vals_S, data_vals_P)&#39;)</code> is required to put the data in the right form (in this case, a 2x10 matrix).</p><p>We can now fit our model to data and plot the results:</p><pre><code class="language-julia hljs">optprob_S_P = OptimizationProblem(loss_function_S_P, [1.0, 1.0, 1.0])
optsol_S_P = solve(optprob_S_P, Optim.NelderMead())
oprob_fitted_S_P = remake(oprob; p = optsol_S_P.u)
fitted_sol_S_P = solve(oprob_fitted_S_P)
plot!(fitted_sol_S_P; idxs=[:S, :P], label=&quot;Fitted solution&quot;, linestyle = :dash, lw = 6, color = [:lightblue :pink])</code></pre><img src="dbcf0884.svg" alt="Example block output"/><h2 id="optimization_parameter_fitting_constraints"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_constraints">Setting parameter constraints and boundaries</a><a id="optimization_parameter_fitting_constraints-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_constraints" title="Permalink"></a></h2><p>Sometimes, it is desirable to set boundaries on parameter values. Indeed, this can speed up the optimisation process (by preventing searching through unfeasible parts of parameter space), and can also be a requirement for some optimisation methods. This can be done by passing the <code>lb</code> (lower bounds) and <code>up</code> (upper bounds) arguments to <code>OptimizationProblem</code>. These are vectors (of the same length as the number of parameters), with each argument corresponding to the boundary value of the parameter with the same index (as used in the <code>parameters(rn)</code> vector). If we wish to constrain each parameter to the interval <span>$(0.1, 10.0)$</span> this can be done through:</p><pre><code class="language-julia hljs">optprob = OptimizationProblem(loss_function, [1.0, 1.0, 1.0]; lb = [1e-1, 1e-1, 1e-1], ub = [1e1, 1e1, 1e1])</code></pre><p>In addition to boundaries, Optimization.jl also supports setting <a href="https://docs.sciml.ai/Optimization/stable/tutorials/constraints/#constraints">linear and non-linear constraints</a> on its output solution for some optimizers.</p><h2 id="optimization_parameter_fitting_known_parameters"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_known_parameters">Parameter fitting with known parameters</a><a id="optimization_parameter_fitting_known_parameters-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_known_parameters" title="Permalink"></a></h2><p>If we from previous knowledge know that <span>$kD = 0.1$</span>, and only want to fit the values of <span>$kB$</span> and <span>$kP$</span>, this can be achieved through <code>build_loss_objective</code>&#39;s <code>prob_generator</code> argument. First, we create a function (<code>fixed_p_prob_generator</code>) that modifies our <code>ODEProblem</code> to incorporate this knowledge:</p><pre><code class="language-julia hljs">fixed_p_prob_generator(prob, p) = remake(prob; p = vcat(p[1], 0.1, p[2]))</code></pre><p>Here, it takes the <code>ODEProblem</code> (<code>prob</code>) we simulate, and the parameter set used, during the optimisation process (<code>p</code>), and creates a modified <code>ODEProblem</code> (by setting a customised parameter vector <a href="../../model_simulation/simulation_structure_interfacing/#simulation_structure_interfacing_problems_remake">using <code>remake</code></a>). Now we create our modified loss function:</p><pre><code class="language-julia hljs">loss_function_fixed_kD = build_loss_objective(oprob, Tsit5(), L2Loss(data_ts, data_vals), Optimization.AutoForwardDiff(); prob_generator = fixed_p_prob_generator, maxiters=10000, verbose=false, save_idxs=4)</code></pre><p>We can create an <code>OptimizationProblem</code> from this one like previously, but keep in mind that it (and its output results) only contains two parameter values (<span>$k$</span> and <span>$kP$</span>):</p><pre><code class="language-julia hljs">optprob_fixed_kD = OptimizationProblem(loss_function_fixed_kD, [1.0, 1.0])
optsol_fixed_kD = solve(optprob_fixed_kD, Optim.NelderMead())</code></pre><h2 id="optimization_parameter_fitting_log_scale"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_log_scale">Fitting parameters on the logarithmic scale</a><a id="optimization_parameter_fitting_log_scale-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_log_scale" title="Permalink"></a></h2><p>Often it can be advantageous to fit parameters on a <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1008646">logarithmic scale (rather than on a linear scale)</a>. The best way to do this is to simply replace each parameter in the model definition by its logarithmic version:</p><pre><code class="language-julia hljs">using Catalyst
rn = @reaction_network begin
    10^kB, S + E --&gt; SE
    10^kD, SE --&gt; S + E
    10^kP, SE --&gt; P + E
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{S} + \mathrm{E} &amp;\xrightleftharpoons[10^{kD}]{10^{kB}} \mathrm{SE} \\
\mathrm{SE} &amp;\xrightarrow{10^{kP}} \mathrm{P} + \mathrm{E}  
 \end{align*}
 \]</p><p>And then going forward, by keeping in mind that parameter values are logarithmic. Here, setting</p><pre><code class="language-julia hljs">p_true = [:kB =&gt; 0.0, :kD =&gt; -1.0, :kP =&gt; 10^(0.5)]</code></pre><p>corresponds to the same true parameter values as used previously (<code>[:kB =&gt; 1.0, :kD =&gt; 0.1, :kP =&gt; 0.5]</code>).</p><h2 id="optimization_parameter_fitting_multiple_experiments"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_multiple_experiments">Parameter fitting to multiple experiments</a><a id="optimization_parameter_fitting_multiple_experiments-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_multiple_experiments" title="Permalink"></a></h2><p>Say that we had measured our model for several different initial conditions, and would like to fit our model to all these measurements simultaneously. This can be done by first creating a <a href="../../model_simulation/ensemble_simulations/#ensemble_simulations">corresponding <code>EnsembleProblem</code></a>. How to then create loss functions for these are described in more detail <a href="https://docs.sciml.ai/DiffEqParamEstim/stable/tutorials/ensemble/">here</a>.</p><h2 id="optimization_parameter_fitting_solver_options"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_solver_options">Optimisation solver options</a><a id="optimization_parameter_fitting_solver_options-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_solver_options" title="Permalink"></a></h2><p>Optimization.jl supports various <a href="https://docs.sciml.ai/Optimization/stable/API/solve/">optimisation solver options</a> that can be supplied to the <code>solve</code> command. For example, to set a maximum number of seconds (after which the optimisation process is terminated), you can use the <code>maxtime</code> argument:</p><pre><code class="language-julia hljs">optsol_fixed_kD = solve(optprob, Optim.NelderMead(); maxtime = 100)</code></pre><hr/><h2 id="optimization_parameter_fitting_citation"><a class="docs-heading-anchor" href="#optimization_parameter_fitting_citation">Citation</a><a id="optimization_parameter_fitting_citation-1"></a><a class="docs-heading-anchor-permalink" href="#optimization_parameter_fitting_citation" title="Permalink"></a></h2><p>If you use this functionality in your research, please cite the following paper to support the authors of the Optimization.jl package:</p><pre><code class="nohighlight hljs">@software{vaibhav_kumar_dixit_2023_7738525,
	author = {Vaibhav Kumar Dixit and Christopher Rackauckas},
	month = mar,
	publisher = {Zenodo},
	title = {Optimization.jl: A Unified Optimization Package},
	version = {v3.12.1},
	doi = {10.5281/zenodo.7738525},
  	url = {https://doi.org/10.5281/zenodo.7738525},
	year = 2023
}</code></pre><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://academic.oup.com/bib/article/23/1/bbab387/6383562?login=false">Alejandro F. Villaverde, Dilan Pathirana, Fabian Fröhlich, Jan Hasenauer, Julio R. Banga, <em>A protocol for dynamic model calibration</em>, Briefings in Bioinformatics (2023).</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../steady_state_functionality/dynamical_systems/">« Analysing model steady state properties with DynamicalSystems.jl</a><a class="docs-footer-nextpage" href="../behaviour_optimisation/">Optimization for non-data fitting purposes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 16 July 2024 15:04">Tuesday 16 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
