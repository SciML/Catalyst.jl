<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Catalyst.jl API · Catalyst.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/using_catalyst/">Using Catalyst</a></li><li><a class="tocitem" href="../../tutorials/dsl/">The Reaction DSL</a></li><li><a class="tocitem" href="../../tutorials/reaction_systems/">Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../../tutorials/basic_examples/">Basic Chemical Reaction Network Examples</a></li><li><a class="tocitem" href="../../tutorials/compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../../tutorials/symbolic_stoich/">Parametric Stoichiometry</a></li><li><a class="tocitem" href="../../tutorials/bifurcation_diagram/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../tutorials/parameter_estimation/">Parameter Estimation</a></li><li><a class="tocitem" href="../../tutorials/generating_reactions_programmatically/">Generating ReactionSystems Programmatically</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>Catalyst.jl API</a><ul class="internal"><li><a class="tocitem" href="#Reaction-Network-Generation-and-Representation"><span>Reaction Network Generation and Representation</span></a></li><li><a class="tocitem" href="#ModelingToolkit-and-Catalyst-Accessor-Functions"><span>ModelingToolkit and Catalyst Accessor Functions</span></a></li><li><a class="tocitem" href="#Basic-System-Properties"><span>Basic System Properties</span></a></li><li><a class="tocitem" href="#Basic-Reaction-Properties"><span>Basic Reaction Properties</span></a></li><li><a class="tocitem" href="#Functions-to-Extend-or-Modify-a-Network"><span>Functions to Extend or Modify a Network</span></a></li><li><a class="tocitem" href="#Network-Analysis-and-Representations"><span>Network Analysis and Representations</span></a></li><li><a class="tocitem" href="#Network-Comparison"><span>Network Comparison</span></a></li><li><a class="tocitem" href="#Network-Visualization"><span>Network Visualization</span></a></li><li><a class="tocitem" href="#Rate-Laws"><span>Rate Laws</span></a></li><li><a class="tocitem" href="#Transformations"><span>Transformations</span></a></li><li><a class="tocitem" href="#Unit-Validation"><span>Unit Validation</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Catalyst.jl API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Catalyst.jl API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/api/catalyst_api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Catalyst.jl-API"><a class="docs-heading-anchor" href="#Catalyst.jl-API">Catalyst.jl API</a><a id="Catalyst.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#Catalyst.jl-API" title="Permalink"></a></h1><h2 id="Reaction-Network-Generation-and-Representation"><a class="docs-heading-anchor" href="#Reaction-Network-Generation-and-Representation">Reaction Network Generation and Representation</a><a id="Reaction-Network-Generation-and-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#Reaction-Network-Generation-and-Representation" title="Permalink"></a></h2><p>Catalyst provides the <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro for generating a complete network, stored as a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, which in turn is composed of <a href="#Catalyst.Reaction"><code>Reaction</code></a>s. <code>ReactionSystem</code>s can be converted to other <code>ModelingToolkit.AbstractSystem</code>s, including a <code>ModelingToolkit.ODESystem</code>, <code>ModelingToolkit.SDESystem</code>, or <code>ModelingToolkit.JumpSystem</code>.</p><p>An empty network can be generated using <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> with no arguments (or one argument to name the system), or the <a href="#Catalyst.make_empty_network"><code>make_empty_network</code></a> function. These can then be extended programmatically using <a href="#Catalyst.addspecies!"><code>addspecies!</code></a>, <a href="#Catalyst.addparam!"><code>addparam!</code></a>, and <a href="#Catalyst.addreaction!"><code>addreaction!</code></a>.</p><p>It is important to note for <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> that any variable not declared to be a parameter after <code>end</code> will be treated as a chemical species of the system. i.e. in</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    k*X, Y --&gt; W
end k</code></pre><p><code>X</code>, <code>Y</code> and <code>W</code> will all be classified as chemical species.</p><p>The <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> generated by the <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a> macro is a <code>ModelingToolkit.AbstractSystem</code> that symbolically represents a system of chemical reactions. In some cases it can be convenient to bypass the macro and directly generate a collection of <a href="#Catalyst.Reaction"><code>Reaction</code></a>s and a corresponding <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> encapsulating them. Below we illustrate with a simple SIR example how a system can be directly constructed, and demonstrate how to then generate from the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and solve corresponding chemical reaction ODE models, chemical Langevin equation SDE models, and stochastic chemical kinetics jump process models. </p><pre><code class="language-julia hljs">using Catalyst, OrdinaryDiffEq, StochasticDiffEq, DiffEqJump
@parameters β γ t
@variables S(t) I(t) R(t)

rxs = [Reaction(β, [S,I], [I], [1,1], [2])
       Reaction(γ, [I], [R])]
@named rs = ReactionSystem(rxs, t)

u₀map    = [S =&gt; 999.0, I =&gt; 1.0, R =&gt; 0.0]
parammap = [β =&gt; 1/10000, γ =&gt; 0.01]
tspan    = (0.0, 250.0)

# solve as ODEs
odesys = convert(ODESystem, rs)
oprob = ODEProblem(odesys, u₀map, tspan, parammap)
sol = solve(oprob, Tsit5())

# solve as SDEs
sdesys = convert(SDESystem, rs)
sprob = SDEProblem(sdesys, u₀map, tspan, parammap)
sol = solve(sprob, EM(), dt=.01)

# solve as jump process
jumpsys = convert(JumpSystem, rs)
u₀map    = [S =&gt; 999, I =&gt; 1, R =&gt; 0]
dprob = DiscreteProblem(jumpsys, u₀map, tspan, parammap)
jprob = JumpProblem(jumpsys, dprob, Direct())
sol = solve(jprob, SSAStepper())</code></pre><article class="docstring"><header><a class="docstring-binding" id="Catalyst.@reaction_network" href="#Catalyst.@reaction_network"><code>Catalyst.@reaction_network</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@reaction_network</code></pre><p>Generates a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> that encodes a chemical reaction network.</p><p>See the <a href="../../tutorials/dsl/#The-Reaction-DSL">The Reaction DSL</a> documentation for details on parameters to the macro.</p><p>Examples:</p><pre><code class="language-julia hljs"># a basic SIR model, with name SIR
sir_model = @reaction_network SIR begin
    c1, s + i --&gt; 2i
    c2, i --&gt; r
end c1 c2

# a basic SIR model, with random generated name
sir_model = @reaction_network begin
    c1, s + i --&gt; 2i
    c2, i --&gt; r
end c1 c2

# an empty network with name empty
emptyrn = @reaction_network empty

# an empty network with random generated name
emptyrn = @reaction_network</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reaction_network.jl#L73-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.make_empty_network" href="#Catalyst.make_empty_network"><code>Catalyst.make_empty_network</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_empty_network(; iv=DEFAULT_IV, name=gensym(:ReactionSystem))</code></pre><p>Construct an empty <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. <code>iv</code> is the independent variable, usually time, and <code>name</code> is the name to give the <code>ReactionSystem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L1032-L1037">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.@reaction" href="#Catalyst.@reaction"><code>Catalyst.@reaction</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@reaction</code></pre><p>Generates a single <a href="#Catalyst.Reaction"><code>Reaction</code></a> object.</p><p>Examples:</p><pre><code class="language-julia hljs">rx = @reaction k*v, A + B --&gt; C + D

# is equivalent to
@parameters k v
@variables t A(t) B(t) C(t) D(t)
rx == Reaction(k*v, [A,B], [C,D])</code></pre><p>Here <code>k</code> and <code>v</code> will be parameters and <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code> will be variables. Interpolation of existing parameters/variables also works</p><pre><code class="language-julia hljs">@parameters k b
@variables t A(t)
ex = k*A^2 + t
rx = @reaction b*$ex*$A, $A --&gt; C</code></pre><p>Notes:</p><ul><li>Any symbols arising in the rate expression that aren&#39;t interpolated are treated as parameters, while any in the reaction part (<code>A + B --&gt; C + D</code>) are treated as species.</li><li>Works with any <em>single</em> arrow types supported by <a href="#Catalyst.@reaction_network"><code>@reaction_network</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reaction_network.jl#L141-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.Reaction" href="#Catalyst.Reaction"><code>Catalyst.Reaction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Reaction{S, T}</code></pre><p>One chemical reaction.</p><p><strong>Fields</strong></p><ul><li><p><code>rate</code></p><p>The rate function (excluding mass action terms).</p></li><li><p><code>substrates</code></p><p>Reaction substrates.</p></li><li><p><code>products</code></p><p>Reaction products.</p></li><li><p><code>substoich</code></p><p>The stoichiometric coefficients of the reactants.</p></li><li><p><code>prodstoich</code></p><p>The stoichiometric coefficients of the products.</p></li><li><p><code>netstoich</code></p><p>The net stoichiometric coefficients of all species changed by the reaction.</p></li><li><p><code>only_use_rate</code></p><p><code>false</code> (default) if <code>rate</code> should be multiplied by mass action terms to give the rate law. <code>true</code> if <code>rate</code> represents the full reaction rate law.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Catalyst
@parameters k[1:20]
@variables t A(t) B(t) C(t) D(t)
rxs = [Reaction(k[1], nothing, [A]),            # 0 -&gt; A
       Reaction(k[2], [B], nothing),            # B -&gt; 0
       Reaction(k[3],[A],[C]),                  # A -&gt; C
       Reaction(k[4], [C], [A,B]),              # C -&gt; A + B
       Reaction(k[5], [C], [A], [1], [2]),      # C -&gt; A + A
       Reaction(k[6], [A,B], [C]),              # A + B -&gt; C
       Reaction(k[7], [B], [A], [2], [1]),      # 2B -&gt; A
       Reaction(k[8], [A,B], [A,C]),            # A + B -&gt; A + C
       Reaction(k[9], [A,B], [C,D]),            # A + B -&gt; C + D
       Reaction(k[10], [A], [C,D], [2], [1,1]), # 2A -&gt; C + D
       Reaction(k[11], [A], [A,B], [2], [1,1]), # 2A -&gt; A + B
       Reaction(k[12], [A,B,C], [C,D], [1,3,4], [2, 3]),          # A+3B+4C -&gt; 2C + 3D
       Reaction(k[13], [A,B], nothing, [3,1], nothing),           # 3A+B -&gt; 0
       Reaction(k[14], nothing, [A], nothing, [2]),               # 0 -&gt; 2A
       Reaction(k[15]*A/(2+A), [A], nothing; only_use_rate=true), # A -&gt; 0 with custom rate
       Reaction(k[16], [A], [B]; only_use_rate=true),             # A -&gt; B with custom rate.
       Reaction(k[17]*A*exp(B), [C], [D], [2], [1]),              # 2C -&gt; D with non constant rate.
       Reaction(k[18]*B, nothing, [B], nothing, [2]),             # 0 -&gt; 2B with non constant rate.
       Reaction(k[19]*t, [A], [B]),                                # A -&gt; B with non constant rate.
       Reaction(k[20]*t*A, [B,C], [D],[2,1],[2])                  # 2A +B -&gt; 2C with non constant rate.
  ]</code></pre><p>Notes:</p><ul><li><code>nothing</code> can be used to indicate a reaction that has no reactants or no products. In this case the corresponding stoichiometry vector should also be set to <code>nothing</code>.</li><li>The three-argument form assumes all reactant and product stoichiometric coefficients are one.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reactionsystem.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.ReactionSystem" href="#Catalyst.ReactionSystem"><code>Catalyst.ReactionSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReactionSystem{U&lt;:Union{Nothing, ModelingToolkit.AbstractSystem}} &lt;: AbstractTimeDependentSystem</code></pre><p>A system of chemical reactions.</p><p><strong>Fields</strong></p><ul><li><p><code>eqs</code></p><p>The reactions defining the system.</p></li><li><p><code>iv</code></p><p>Independent variable (usually time).</p></li><li><p><code>states</code></p><p>Dependent (state) variables representing amount of each species. Must not contain the independent variable.</p></li><li><p><code>ps</code></p><p>Parameter variables. Must not contain the independent variable.</p></li><li><p><code>var_to_name</code></p><p>Maps Symbol to corresponding variable.</p></li><li><p><code>observed</code></p><p>Equations for observed variables.</p></li><li><p><code>name</code></p><p>The name of the system</p></li><li><p><code>systems</code></p><p>Internal sub-systems</p></li><li><p><code>defaults</code></p><p>The default values to use when initial conditions and/or parameters are not supplied in <code>ODEProblem</code>.</p></li></ul><ul><li><p><code>connection_type</code></p><p>Type of the system</p></li><li><p><code>constraints</code></p><p>Non-<code>Reaction</code> equations that further constrain the system</p></li></ul><p><strong>Example</strong></p><p>Continuing from the example in the <a href="#Catalyst.Reaction"><code>Reaction</code></a> definition:</p><pre><code class="language-julia hljs"># simple constructor that infers species and parameters
@named rs = ReactionSystem(rxs, t)

# allows specification of species and parameters
@named rs = ReactionSystem(rxs, t, [A,B,C,D], k)</code></pre><p>Keyword Arguments:</p><ul><li><code>observed::Vector{Equation}</code>, equations specifying observed variables.</li><li><code>systems::Vector{AbstractSystems}</code>, vector of sub-systems. Can be <code>ReactionSystem</code>s, <code>ODESystem</code>s, or <code>NonlinearSystem</code>s.</li><li><code>name::Symbol</code>, the name of the system (must be provided, or <code>@named</code> must be used).</li><li><code>defaults::Dict</code>, a dictionary mapping parameters to their default values and species to their default initial values.</li><li><code>checks = true</code>, boolean for whether to check units.</li><li><code>constraints = nothing</code>, a <code>NonlinearSystem</code> or <code>ODESystem</code> of coupled constraint equations.</li></ul><p>Notes:</p><ul><li>ReactionSystems currently do rudimentary unit checking, requiring that all species have the same units, and all reactions have rate laws with units of (species units) / (time units). Unit checking can be disabled by passing the keyword argument <code>checks=false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reactionsystem.jl#L169">source</a></section></article><h2 id="ModelingToolkit-and-Catalyst-Accessor-Functions"><a class="docs-heading-anchor" href="#ModelingToolkit-and-Catalyst-Accessor-Functions">ModelingToolkit and Catalyst Accessor Functions</a><a id="ModelingToolkit-and-Catalyst-Accessor-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#ModelingToolkit-and-Catalyst-Accessor-Functions" title="Permalink"></a></h2><p>A <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> is an instance of a <code>ModelingToolkit.AbstractTimeDependentSystem</code>, and has a number of fields that can be accessed using the Catalyst API and the <a href="https://mtk.sciml.ai/dev/basics/AbstractSystem/">ModelingToolkit.jl Abstract System Interface</a>. Below we overview these components.</p><p>There are three basic sets of convenience accessors that will return information either from a top-level system, the top-level system and all sub-systems that are also <code>ReactionSystem</code>s (i.e. the full reaction-network), or the top-level system, all subs-systems, and all constraint systems (i.e. the full model). To retrieve info from just a base <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> <code>rn</code>, ignoring sub-systems of <code>rn</code>, one can use the ModelingToolkit accessors (these provide direct access to the corresponding internal fields of the <code>ReactionSystem</code>)</p><ul><li><code>get_states(rn)</code> is a vector that collects all the species defined within <code>rn</code>. </li><li><code>get_ps(rn)</code> is a vector that collects all the parameters defined <em>within</em> reactions in <code>rn</code>. </li><li><code>get_eqs(rn)</code> is a vector that collects all the <a href="#Catalyst.Reaction"><code>Reaction</code></a>s defined within <code>rn</code>.</li><li><code>get_iv(rn)</code> is the independent variable used in the system (usually <code>t</code> to represent time).</li><li><code>get_systems(rn)</code> is a vector of all sub-systems of <code>rn</code>.</li><li><code>get_defaults(rn)</code> is a dictionary of all the default values for parameters and species in <code>rn</code>.</li></ul><p>These are complemented by the Catalyst accessor</p><ul><li><code>Catalyst.get_constraints(sys)</code> is the constraint system of <code>rn</code>. If none is defined will return <code>nothing</code>.</li></ul><p>The preceding accessors do not allocate, directly accessing internal fields of the <code>ReactionSystem</code>. </p><p>To retrieve information from the full reaction network represented by a system <code>rn</code>, which corresponds to information within both <code>rn</code> and all sub-systems of type <code>ReactionSystem</code>, one can call:</p><ul><li><a href="#Catalyst.species"><code>species(rn)</code></a> is a vector collecting all the chemical species within the system and any sub-systems that are also <code>ReactionSystems</code>. </li><li><a href="#Catalyst.reactionparams"><code>reactionparams(rn)</code></a> is a vector of all the parameters within the system and any sub-systems that are also <code>ReactionSystem</code>s. These include all parameters that appear within some <code>Reaction</code>.</li><li><a href="#Catalyst.reactions"><code>reactions(rn)</code></a> is a vector of all the <code>Reaction</code>s within the system and any sub-systems that are also <code>ReactionSystem</code>s.</li></ul><p>These accessors will allocate unless there are no subsystems. In the latter case they are equivalent to the corresponding <code>get_*</code> functions.</p><p>Finally, as some sub-systems may be other system types, for example specifying algebraic constraints with a <code>NonlinearSystem</code>, it can also be convenient to collect all state variables (e.g. species and algebraic variables) and such. The following ModelingToolkit functions provide this information</p><ul><li><code>ModelingToolkit.states(rn)</code> returns all species <em>and variables</em> across the system, <em>all sub-systems</em>, and all constraint systems.</li><li><code>ModelingToolkit.parameters(rn)</code> returns all parameters across the system, <em>all sub-systems</em>, and all constraint systems.</li><li><code>ModelingToolkit.equations(rn)</code> returns all <a href="#Catalyst.Reaction"><code>Reaction</code></a>s and all <code>Equations</code> defined across the system, <em>all sub-systems</em>, and all constraint systems.</li></ul><p><code>states</code> and <code>parameters</code> should be assumed to always allocate, while <code>equations</code> will allocate unless there are no subsystems or constraint systems. In the latter case <code>equations</code> is equivalent to <code>get_eqs</code>.</p><p>Below we list the remainder of the Catalyst API accessor functions mentioned above.</p><h2 id="Basic-System-Properties"><a class="docs-heading-anchor" href="#Basic-System-Properties">Basic System Properties</a><a id="Basic-System-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-System-Properties" title="Permalink"></a></h2><p>See <a href="../../tutorials/reaction_systems/#Symbolic-Reaction-Systems">Symbolic Reaction Systems</a> for examples and <a href="#ModelingToolkit-and-Catalyst-Accessor-Functions">ModelingToolkit and Catalyst Accessor Functions</a> for more details on the basic accessor functions.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.species" href="#Catalyst.species"><code>Catalyst.species</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">species(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of all species defined in the system and any subsystems that are of type <code>ReactionSystem</code>. To get the variables in the system and all subsystems, including non-<code>ReactionSystem</code> subsystems, uses <code>states(network)</code>.</p><p>Notes:</p><ul><li>If <code>ModelingToolkit.get_systems(network)</code> is non-empty will allocate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L51-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactionparams" href="#Catalyst.reactionparams"><code>Catalyst.reactionparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactionparams(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of all parameters defined within the system and any subsystems that are of type <code>ReactionSystem</code>. To get the parameters in the system and all subsystems, including non-<code>ReactionSystem</code> subsystems, use <code>parameters(network)</code>.</p><p>Notes:</p><ul><li>If <code>ModelingToolkit.get_systems(network)</code> is non-empty will allocate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L68-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactions" href="#Catalyst.reactions"><code>Catalyst.reactions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactions(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of all <code>Reactions</code> in the system.</p><p>Notes:</p><ul><li>If <code>ModelingToolkit.get_systems(network)</code> is not empty, will allocate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.numspecies" href="#Catalyst.numspecies"><code>Catalyst.numspecies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numspecies(network)</code></pre><p>Return the total number of species within the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and subsystems that are <code>ReactionSystem</code>s. </p><p>Notes</p><ul><li>If there are no subsystems this will be fast.</li><li>As this calls <a href="#Catalyst.species"><code>species</code></a>, it can be slow and will allocate if there are any subsystems. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L139-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.numreactions" href="#Catalyst.numreactions"><code>Catalyst.numreactions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numreactions(network)</code></pre><p>Return the total number of reactions within the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and subsystems that are <code>ReactionSystem</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.numreactionparams" href="#Catalyst.numreactionparams"><code>Catalyst.numreactionparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numreactionparams(network)</code></pre><p>Return the total number of parameters within the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and subsystems that are <code>ReactionSystem</code>s.</p><p>Notes</p><ul><li>If there are no subsystems this will be fast.</li><li>As this calls <a href="#Catalyst.reactionparams"><code>reactionparams</code></a>, it can be slow and will allocate if there are any subsystems. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L168-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.speciesmap" href="#Catalyst.speciesmap"><code>Catalyst.speciesmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">speciesmap(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a Dictionary mapping species that participate in <code>Reaction</code>s to their index within <a href="#Catalyst.species"><code>species(network)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.paramsmap" href="#Catalyst.paramsmap"><code>Catalyst.paramsmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">paramsmap(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a Dictionary mapping from all parameters that appear within the system to their index within <code>parameters(network)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactionparamsmap" href="#Catalyst.reactionparamsmap"><code>Catalyst.reactionparamsmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactionparamsmap(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a Dictionary mapping from parameters that appear within <code>Reaction</code>s to their index within <a href="#Catalyst.reactionparams"><code>reactionparams(network)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L129-L134">source</a></section></article><h2 id="Basic-Reaction-Properties"><a class="docs-heading-anchor" href="#Basic-Reaction-Properties">Basic Reaction Properties</a><a id="Basic-Reaction-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Reaction-Properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catalyst.ismassaction" href="#Catalyst.ismassaction"><code>Catalyst.ismassaction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ismassaction(rx, rs; rxvars = get_variables(rx.rate),
                              haveivdep = any(var -&gt; isequal(get_iv(rs),var), rxvars),
                              stateset = Set(states(rs)))</code></pre><p>True if a given reaction is of mass action form, i.e. <code>rx.rate</code> does not depend on any chemical species that correspond to states of the system, and does not depend explicitly on the independent variable (usually time).</p><p><strong>Arguments</strong></p><ul><li><code>rx</code>, the <a href="#Catalyst.Reaction"><code>Reaction</code></a>.</li><li><code>rs</code>, a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> containing the reaction.</li><li>Optional: <code>rxvars</code>, <code>Variable</code>s which are not in <code>rxvars</code> are ignored as possible dependencies.</li><li>Optional: <code>haveivdep</code>, <code>true</code> if the <a href="#Catalyst.Reaction"><code>Reaction</code></a> <code>rate</code> field explicitly depends on the independent variable.</li><li>Optional: <code>stateset</code>, set of states which if the rxvars are within mean rx is non-mass action.</li></ul><p>Notes:</p><ul><li>Non-integer stoichiometry is treated as non-mass action. This includes symbolic variables/terms or floating point numbers for stoichiometric coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reactionsystem.jl#L579-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.dependents" href="#Catalyst.dependents"><code>Catalyst.dependents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dependents(rx, network)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a> and a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, return a vector of <code>ModelingToolkit.Num</code>s corresponding to species the <em>reaction rate law</em> depends on. E.g., for</p><p><code>k*W, 2X + 3Y --&gt; 5Z + W</code></p><p>the returned vector would be <code>[W(t),X(t),Y(t)]</code>.</p><p>Notes:</p><ul><li>Allocates</li><li>Does not check for dependents within any subsystems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L183-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.dependants" href="#Catalyst.dependants"><code>Catalyst.dependants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dependents(rx, network)</code></pre><p>See documentation for <a href="#Catalyst.dependents"><code>dependents</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.substoichmat" href="#Catalyst.substoichmat"><code>Catalyst.substoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">substoichmat(rn; sparse=false, smap=speciesmap(rn))</code></pre><p>Returns the substrate stoichiometry matrix, <span>$S$</span>, with <span>$S_{i j}$</span> the stoichiometric coefficient of the ith substrate within the jth reaction.</p><p>Note:</p><ul><li>Set sparse=true for a sparse matrix representation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L226-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.prodstoichmat" href="#Catalyst.prodstoichmat"><code>Catalyst.prodstoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prodstoichmat(rn; sparse=false, smap=speciesmap(rn))</code></pre><p>Returns the product stoichiometry matrix, <span>$P$</span>, with <span>$P_{i j}$</span> the stoichiometric coefficient of the ith product within the jth reaction.</p><p>Note:</p><ul><li>Set sparse=true for a sparse matrix representation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L263-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.netstoichmat" href="#Catalyst.netstoichmat"><code>Catalyst.netstoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">netstoichmat(rn, sparse=false; smap=speciesmap(rn))</code></pre><p>Returns the net stoichiometry matrix, <span>$N$</span>, with <span>$N_{i j}$</span> the net stoichiometric coefficient of the ith species within the jth reaction.</p><p>Note:</p><ul><li>Set sparse=true for a sparse matrix representation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L300-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactionrates" href="#Catalyst.reactionrates"><code>Catalyst.reactionrates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactionrates(network)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, returns a vector of the symbolic reaction rates for each reaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L216-L221">source</a></section></article><h2 id="Functions-to-Extend-or-Modify-a-Network"><a class="docs-heading-anchor" href="#Functions-to-Extend-or-Modify-a-Network">Functions to Extend or Modify a Network</a><a id="Functions-to-Extend-or-Modify-a-Network-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-to-Extend-or-Modify-a-Network" title="Permalink"></a></h2><p><code>ReactionSystem</code>s can be programmatically extended using <a href="#Catalyst.addspecies!"><code>addspecies!</code></a>, <a href="#Catalyst.addparam!"><code>addparam!</code></a>, <a href="#Catalyst.addreaction!"><code>addreaction!</code></a>, <a href="#Catalyst.@add_reactions"><code>@add_reactions</code></a>, or composed using <a href="#ModelingToolkit.extend"><code>ModelingToolkit.extend</code></a> and <a href="#ModelingToolkit.compose"><code>ModelingToolkit.compose</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.@add_reactions" href="#Catalyst.@add_reactions"><code>Catalyst.@add_reactions</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@add_reactions</code></pre><p>Adds the reactions declared to a preexisting <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. All parameters used in the added reactions need to be declared after the reactions.</p><p>See the <a href="../../#Catalyst.jl-for-Reaction-Models">Catalyst.jl for Reaction Models</a> documentation for details on parameters to the macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reaction_network.jl#L174-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.addspecies!" href="#Catalyst.addspecies!"><code>Catalyst.addspecies!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addspecies!(network::ReactionSystem, s::Symbolic; disablechecks=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, add the species corresponding to the variable <code>s</code> to the network (if it is not already defined). Returns the integer id of the species within the system.</p><p>Notes:</p><ul><li><code>disablechecks</code> will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. <em>Do not disable checks</em> unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L1042-L1054">source</a></section><section><div><pre><code class="nohighlight hljs">addspecies!(network::ReactionSystem, s::Num; disablechecks=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, add the species corresponding to the variable <code>s</code> to the network (if it is not already defined). Returns the integer id of the species within the system.</p><ul><li><code>disablechecks</code> will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. <em>Do not disable checks</em> unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L1069-L1080">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reorder_states!" href="#Catalyst.reorder_states!"><code>Catalyst.reorder_states!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reorder_states!(rn, neworder)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and a vector <code>neworder</code>, orders the states of <code>rn</code> accordingly to <code>neworder</code>.</p><p>Notes:</p><ul><li>Currently only supports <code>ReactionSystem</code>s without constraints or subsystems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L1085-L1092">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.addparam!" href="#Catalyst.addparam!"><code>Catalyst.addparam!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addparam!(network::ReactionSystem, p::Symbolic; disablechecks=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, add the parameter corresponding to the variable <code>p</code> to the network (if it is not already defined). Returns the integer id of the parameter within the system.</p><ul><li><code>disablechecks</code> will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. <em>Do not disable checks</em> unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L1099-L1110">source</a></section><section><div><pre><code class="nohighlight hljs">addparam!(network::ReactionSystem, p::Num; disablechecks=false)</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>, add the parameter corresponding to the variable <code>p</code> to the network (if it is not already defined). Returns the integer id of the parameter within the system.</p><ul><li><code>disablechecks</code> will disable checking for whether the passed in variable is already defined, which is useful when adding many new variables to the system. <em>Do not disable checks</em> unless you are sure the passed in variable is a new variable, as this will potentially leave the system in an undefined state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L1126-L1137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.addreaction!" href="#Catalyst.addreaction!"><code>Catalyst.addreaction!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addreaction!(network::ReactionSystem, rx::Reaction)</code></pre><p>Add the passed in reaction to the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. Returns the integer id of <code>rx</code> in the list of <code>Reaction</code>s within <code>network</code>.</p><p>Notes:</p><ul><li>Any new species or parameters used in <code>rx</code> should be separately added to   <code>network</code> using <a href="#Catalyst.addspecies!"><code>addspecies!</code></a> and <a href="#Catalyst.addparam!"><code>addparam!</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L1142-L1151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.setdefaults!" href="#Catalyst.setdefaults!"><code>Catalyst.setdefaults!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setdefaults!(rn, newdefs)</code></pre><p>Sets the default (initial) values of parameters and species in the <code>ReactionSystem</code>, <code>rn</code>.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν
setdefaults!(sir, [:S =&gt; 999.0, :I =&gt; 1.0, :R =&gt; 1.0, :β =&gt; 1e-4, :ν =&gt; .01])

# or
@parameter β ν
@variables t S(t) I(t) R(t)
setdefaults!(sir, [S =&gt; 999.0, I =&gt; 1.0, R =&gt; 0.0, β =&gt; 1e-4, ν =&gt; .01])</code></pre><p>gives initial/default values to each of <code>S</code>, <code>I</code> and <code>β</code></p><p>Notes:</p><ul><li>Can not be used to set default values for species, variables or parameters of subsystems or constraint systems. Either set defaults for those systems directly, or <a href="#ModelingToolkit.flatten"><code>flatten</code></a> to collate them into one system before setting defaults.</li><li>Defaults can be specified in any iterable container of symbols to value pairs or symbolics to value pairs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L334-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.extend" href="#ModelingToolkit.extend"><code>ModelingToolkit.extend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ModelingToolkit.extend(sys::Union{NonlinearSystem,ODESystem}, rs::ReactionSystem; name::Symbol=nameof(sys))</code></pre><p>Extends the indicated <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> with a <code>ModelingToolkit.NonlinearSystem</code> or <code>ModelingToolkit.ODESystem</code>, which will be stored internally as constraint equations.</p><p>Notes:</p><ul><li>Returns a new <code>ReactionSystem</code> and does not modify <code>rs</code>.</li><li>By default, the new <code>ReactionSystem</code> will have the same name as <code>sys</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reactionsystem.jl#L1028-L1038">source</a></section><section><div><pre><code class="nohighlight hljs">ModelingToolkit.extend(sys::ReactionSystem, rs::ReactionSystem; name::Symbol=nameof(sys))</code></pre><p>Extends the indicated <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> with another <code>ReactionSystem</code>. Similar to calling <code>merge!</code> except constraint systems are allowed (and will also be merged together).</p><p>Notes:</p><ul><li>Returns a new <code>ReactionSystem</code> and does not modify <code>rs</code>.</li><li>By default, the new <code>ReactionSystem</code> will have the same name as <code>sys</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reactionsystem.jl#L1047-L1057">source</a></section><section><div><pre><code class="language-julia hljs">extend(sys::ModelingToolkit.AbstractSystem, basesys::ModelingToolkit.AbstractSystem; name) -&gt; ReactionSystem
</code></pre><p>extend the <code>basesys</code> with <code>sys</code>, the resulting system would inherit <code>sys</code>&#39;s name by default.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.compose" href="#ModelingToolkit.compose"><code>ModelingToolkit.compose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compose(sys, systems; name)
</code></pre><p>compose multiple systems together. The resulting system would inherit the first system&#39;s name.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.flatten" href="#ModelingToolkit.flatten"><code>ModelingToolkit.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Catalyst.flatten(rs::ReactionSystem)</code></pre><p>Merges all subsystems of the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> up into <code>rs</code>.</p><p>Notes:</p><ul><li>Returns a new <code>ReactionSystem</code> that represents the flattened system.</li><li>All <code>Reaction</code>s within subsystems are namespaced and merged into the list of <code>Reactions</code> of <code>rs</code>. The merged list is then available as <code>reactions(rs)</code> or <code>get_eqs(rs)</code>.</li><li>All algebraic equations are merged into a <code>NonlinearSystem</code> or <code>ODESystem</code> stored as <code>get_constraints(rs)</code>. If <code>get_constraints !== nothing</code> then the algebraic equations are merged with the current constraints in a system of the same type as the current constraints, otherwise the new constraint system is an <code>ODESystem</code>.</li><li>Currently only <code>ReactionSystem</code>s, <code>NonlinearSystem</code>s and <code>ODESystem</code>s are supported as sub-systems when flattening.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reactionsystem.jl#L970-L987">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge!-Tuple{ReactionSystem, ReactionSystem}" href="#Base.merge!-Tuple{ReactionSystem, ReactionSystem}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge!(network1::ReactionSystem, network2::ReactionSystem)</code></pre><p>Merge <code>network2</code> into <code>network1</code>.</p><p>Notes:</p><ul><li>Duplicate reactions between the two networks are not filtered out.</li><li><a href="#Catalyst.Reaction"><code>Reaction</code></a>s are not deepcopied to minimize allocations, so both networks will share underlying data arrays.</li><li>Subsystems are not deepcopied between the two networks and will hence be shared.</li><li>Returns <code>network1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L1157-L1169">source</a></section></article><h2 id="Network-Analysis-and-Representations"><a class="docs-heading-anchor" href="#Network-Analysis-and-Representations">Network Analysis and Representations</a><a id="Network-Analysis-and-Representations-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Analysis-and-Representations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catalyst.conservationlaws" href="#Catalyst.conservationlaws"><code>Catalyst.conservationlaws</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservationlaws(netstoichmat::AbstractMatrix)::Matrix</code></pre><p>Given the net stoichiometry matrix of a reaction system, computes a matrix of conservation laws, each represented as a row in the output. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L923-L929">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.conservedquantities" href="#Catalyst.conservedquantities"><code>Catalyst.conservedquantities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conservedquantities(state, cons_laws)</code></pre><p>Compute conserved quantities for a system with the given conservation laws.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L948-L952">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.ReactionComplexElement" href="#Catalyst.ReactionComplexElement"><code>Catalyst.ReactionComplexElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReactionComplexElement{T}</code></pre><p>One reaction complex element</p><p><strong>Fields</strong></p><ul><li><p><code>speciesid</code></p><p>The integer id of the species representing this element.</p></li><li><p><code>speciesstoich</code></p><p>The stoichiometric coefficient of this species.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.ReactionComplex" href="#Catalyst.ReactionComplex"><code>Catalyst.ReactionComplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReactionComplex{V&lt;:Integer} &lt;: AbstractArray{Catalyst.ReactionComplexElement{V&lt;:Integer}, 1}</code></pre><p>One reaction complex.</p><p><strong>Fields</strong></p><ul><li><p><code>speciesids</code></p><p>The integer ids of all species participating in this complex.</p></li><li><p><code>speciesstoichs</code></p><p>The stoichiometric coefficients of all species participating in this complex.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactioncomplexmap" href="#Catalyst.reactioncomplexmap"><code>Catalyst.reactioncomplexmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactioncomplexmap(rn::ReactionSystem; smap=speciesmap(rn))</code></pre><p>Find each <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a> within the specified system, constructing a mapping from the complex to vectors that indicate which reactions it appears in as substrates and products.</p><p>Notes:</p><ul><li>Each <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a> is mapped to a vector of pairs, with each pair having the form <code>reactionidx =&gt; ± 1</code>, where <code>-1</code> indicates the complex appears as a substrate and <code>+1</code> as a product in the reaction with integer label <code>reactionidx</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L537-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.reactioncomplexes" href="#Catalyst.reactioncomplexes"><code>Catalyst.reactioncomplexes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reactioncomplexes(network::ReactionSystem; sparse=false, smap=speciesmap(rn), 
                  complextorxsmap=reactioncomplexmap(rn; smap=smap))</code></pre><p>Calculate the reaction complexes and complex incidence matrix for the given <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>. </p><p>Notes:</p><ul><li>returns a pair of a vector of <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a>s and the complex incidence matrix.</li><li>An empty <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a> denotes the null (∅) state (from reactions like ∅ -&gt; A or A -&gt; ∅).</li><li>The complex incidence matrix, <span>$B$</span>, is number of complexes by number of reactions with</li></ul><p class="math-container">\[B_{i j} = \begin{cases}
-1, &amp;\text{if the i&#39;th complex is the substrate of the j&#39;th reaction},\\
1, &amp;\text{if the i&#39;th complex is the product of the j&#39;th reaction},\\
0, &amp;\text{otherwise.}
\end{cases}\]</p><ul><li>Set sparse=true for a sparse matrix representation of the incidence matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L600-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.complexstoichmat" href="#Catalyst.complexstoichmat"><code>Catalyst.complexstoichmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexstoichmat(network::ReactionSystem; sparse=false, rcs=keys(reactioncomplexmap(rn)))</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and vector of reaction complexes, return a matrix with positive entries of size number of species by number of complexes, where the non-zero positive entries in the kth column denote stoichiometric coefficients of the species participating in the kth reaction complex.</p><p>Notes:</p><ul><li><code>rcs</code> correspond to an iterable of the <code>ReactionComplexes</code>, i.e. <code>rcs=keys(reactioncomplexmap(rn))</code> or <code>reactioncomplexes(rn)[1]</code>.</li><li>Set sparse=true for a sparse matrix representation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L652-L664">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.complexoutgoingmat" href="#Catalyst.complexoutgoingmat"><code>Catalyst.complexoutgoingmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexoutgoingmat(network; sparse=false, B=reactioncomplexes(rn)[2])</code></pre><p>Given a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> and complex incidence matrix, <span>$B$</span>, return a matrix of size num of complexes by num of reactions that identifies substrate complexes.</p><p>Notes:</p><ul><li>The complex outgoing matrix, <span>$\Delta$</span>, is defined by </li></ul><p class="math-container">\[\Delta_{i j} = \begin{cases}
    = 0,    &amp;\text{if } B_{i j} = 1, \\
    = B_{i j}, &amp;\text{otherwise.}
\end{cases}\]</p><ul><li>Set sparse=true for a sparse matrix representation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L699-L715">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.incidencematgraph" href="#Catalyst.incidencematgraph"><code>Catalyst.incidencematgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">incidencematgraph(incidencemat)</code></pre><p>Given an incidence matrix of a reaction-network, construct a directed simple graph where nodes correspond to reaction complexes and directed edges to reactions converting between two complexes.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν
rcs,incidencemat = reactioncomplexes(sir)
incidencegraph   = incidencematgraph(incidencemat)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L723-L739">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.linkageclasses" href="#Catalyst.linkageclasses"><code>Catalyst.linkageclasses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linkageclasses(incidencegraph)</code></pre><p>Given the incidence graph of a reaction network, return a vector of the connected components of the graph (i.e. sub-groups of reaction complexes that are connected in the incidence graph).</p><p>For example, continuing the example from <a href="#Catalyst.incidencematgraph"><code>incidencematgraph</code></a></p><pre><code class="language-julia hljs">julia&gt; linkageclasses(incidencegraph)
2-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L775-L789">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.deficiency" href="#Catalyst.deficiency"><code>Catalyst.deficiency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deficiency(netstoich_mat, incidence_graph, linkage_classes)</code></pre><p>Calculate the deficiency of a reaction network. </p><p>Here the deficiency, <span>$\delta$</span>, of a network with <span>$n$</span> reaction complexes,  <span>$\ell$</span> linkage classes and a rank <span>$s$</span> stoichiometric matrix is</p><p class="math-container">\[\delta = n - \ell - s\]</p><p>For example, </p><pre><code class="language-julia hljs">sir = @reaction_network SIR begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν
rcs,incidencemat = reactioncomplexes(sir)
incidence_graph  = incidencematgraph(incidencemat)
linkage_classes   = linkageclasses(incidence_graph)
netstoich_mat    = netstoichmat(sir)
δ = deficiency(netstoich_mat, incidence_graph, linkage_classes)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L795-L819">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.subnetworks" href="#Catalyst.subnetworks"><code>Catalyst.subnetworks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subnetworks(network, linkage_classes ; rxs = reactions(network),
              complextorxmap = collect(values(reactioncomplexmap(network))),
              p = parameters(network))</code></pre><p>Find subnetworks corresponding to the each linkage class of reaction network</p><p>For example, continuing the example from <a href="#Catalyst.deficiency"><code>deficiency</code></a></p><pre><code class="language-julia hljs">   subnets = subnetworks(sir, linkage_classes)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L841-L852">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.linkagedeficiencies" href="#Catalyst.linkagedeficiencies"><code>Catalyst.linkagedeficiencies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linkagedeficiencies(subnetworks::AbstractVector, linkage_classes::AbstractVector)</code></pre><p>Calculates the deficiency of each sub-reaction network defined by a collection of linkage_classes.</p><p>For example, continuing the example from <a href="#Catalyst.deficiency"><code>deficiency</code></a></p><pre><code class="language-julia hljs">subnets = subnetworks(sir, linkage_classes)
linkage_deficiencies = linkagedeficiency(subnets, linkage_classes)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L869-L880">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isreversible" href="#Catalyst.isreversible"><code>Catalyst.isreversible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isreversible(incidencegraph)</code></pre><p>Given an incidence graph of the reaction network, returns if the network is reversible or not. For example, continuing the example from <a href="#Catalyst.linkagedeficiencies"><code>linkagedeficiencies</code></a></p><pre><code class="language-julia hljs">isreversible(incidence_graph)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L891-L899">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isweaklyreversible" href="#Catalyst.isweaklyreversible"><code>Catalyst.isweaklyreversible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isweaklyreversible(subnetworks)</code></pre><p>Given the subnetworks corresponding to the each linkage class of reaction network, determines if the reaction network is weakly reversible or not. For example, continuing the example from <a href="#Catalyst.isreversible"><code>isreversible</code></a></p><pre><code class="language-julia hljs">isweaklyreversible(subnets)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L904-L913">source</a></section></article><h2 id="Network-Comparison"><a class="docs-heading-anchor" href="#Network-Comparison">Network Comparison</a><a id="Network-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Comparison" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Reaction, Reaction}" href="#Base.:==-Tuple{Reaction, Reaction}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(rx1::Reaction, rx2::Reaction)</code></pre><p>Tests whether two <a href="#Catalyst.Reaction"><code>Reaction</code></a>s are identical.</p><p>Notes:</p><ul><li>Ignores the order in which stoichiometry components are listed.</li><li><em>Does not</em> currently simplify rates, so a rate of <code>A^2+2*A+1</code> would be   considered different than <code>(A+1)^2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L957-L966">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.isequal_ignore_names" href="#Catalyst.isequal_ignore_names"><code>Catalyst.isequal_ignore_names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isequal_ignore_names(rn1::ReactionSystem, rn2::ReactionSystem)</code></pre><p>Tests whether the underlying species, parameters and reactions are the same in the two <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>s. Ignores the names of the systems in testing equality.</p><p>Notes:</p><ul><li><em>Does not</em> currently simplify rates, so a rate of <code>A^2+2*A+1</code> would be   considered different than <code>(A+1)^2</code>.</li><li>Does not include <code>defaults</code> in determining equality.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L985-L996">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{ReactionSystem, ReactionSystem}" href="#Base.:==-Tuple{ReactionSystem, ReactionSystem}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(rn1::ReactionSystem, rn2::ReactionSystem)</code></pre><p>Tests whether the underlying species, parameters and reactions are the same in the two <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a>s. Requires the systems to have the same names too.</p><p>Notes:</p><ul><li><em>Does not</em> currently simplify rates, so a rate of <code>A^2+2*A+1</code> would be   considered different than <code>(A+1)^2</code>.</li><li>Does not include <code>defaults</code> in determining equality.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L1012-L1023">source</a></section></article><h2 id="Network-Visualization"><a class="docs-heading-anchor" href="#Network-Visualization">Network Visualization</a><a id="Network-Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Visualization" title="Permalink"></a></h2><p><a href="https://github.com/korsbo/Latexify.jl">Latexify</a> can be used to convert networks to LaTeX mhchem equations by</p><pre><code class="language-julia hljs">using Latexify
latexify(rn)</code></pre><p>If <a href="https://graphviz.org/">Graphviz</a> is installed and commandline accessible, it can be used to create and save network diagrams using <a href="#Catalyst.Graph"><code>Graph</code></a> and <a href="#Catalyst.savegraph"><code>savegraph</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.Graph" href="#Catalyst.Graph"><code>Catalyst.Graph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Graph(rn::ReactionSystem)</code></pre><p>Converts a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> into a Graphviz graph. Reactions correspond to small green circles, and species to blue circles.</p><p>Notes:</p><ul><li>Black arrows from species to reactions indicate reactants, and are labelled with their input stoichiometry.</li><li>Black arrows from reactions to species indicate products, and are labelled with their output stoichiometry.</li><li>Red arrows from species to reactions indicate that species is used within the rate expression. For example, in the reaction <code>k*A, B --&gt; C</code>, there would be a red arrow from <code>A</code> to the reaction node. In <code>k*A, A+B --&gt; C</code>, there would be red and black arrows from <code>A</code> to the reaction node.</li><li>Requires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/graphs.jl#L337-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.complexgraph" href="#Catalyst.complexgraph"><code>Catalyst.complexgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">complexgraph(rn::ReactionSystem; complexdata=reactioncomplexes(rn))</code></pre><p>Creates a Graphviz graph of the <a href="#Catalyst.ReactionComplex"><code>ReactionComplex</code></a>s in <code>rn</code>. Reactions correspond to arrows and reaction complexes to blue circles. </p><p>Notes:</p><ul><li>Black arrows from complexes to complexes indicate reactions whose rate is a parameter or a <code>Number</code>. i.e. <code>k, A --&gt; B</code>.</li><li>Red dashed arrows from complexes to complexes indicate reactions whose rate depends on species. i.e. <code>k*C, A --&gt; B</code> for <code>C</code> a species.</li><li>Requires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/graphs.jl#L291-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.savegraph" href="#Catalyst.savegraph"><code>Catalyst.savegraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">savegraph(g::Graph, fname, fmt=&quot;png&quot;)</code></pre><p>Given a <code>Graph</code> generated by <a href="#Catalyst.Graph"><code>Graph</code></a>, save the graph to the file with name <code>fname</code> and extension <code>fmt</code>.</p><p>Notes:</p><ul><li><code>fmt=&quot;png&quot;</code> is the default output format.</li><li>Requires the Graphviz jll to be installed, or Graphviz to be installed and commandline accessible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/graphs.jl#L377-L386">source</a></section></article><h2 id="Rate-Laws"><a class="docs-heading-anchor" href="#Rate-Laws">Rate Laws</a><a id="Rate-Laws-1"></a><a class="docs-heading-anchor-permalink" href="#Rate-Laws" title="Permalink"></a></h2><p>As the underlying <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> is comprised of <code>ModelingToolkit</code> expressions, one can directly access the generated rate laws, and using <code>ModelingToolkit</code> tooling generate functions or Julia <code>Expr</code>s from them.</p><article class="docstring"><header><a class="docstring-binding" id="Catalyst.oderatelaw" href="#Catalyst.oderatelaw"><code>Catalyst.oderatelaw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">oderatelaw(rx; combinatoric_ratelaw=true)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a>, return the symbolic reaction rate law used in generated ODEs for the reaction. Note, for a reaction defined by</p><p><code>k*X*Y, X+Z --&gt; 2X + Y</code></p><p>the expression that is returned will be <code>k*X(t)^2*Y(t)*Z(t)</code>. For a reaction of the form</p><p><code>k, 2X+3Y --&gt; Z</code></p><p>the expression that is returned will be <code>k * (X(t)^2/2) * (Y(t)^3/6)</code>.</p><p>Notes:</p><ul><li>Allocates</li><li><code>combinatoric_ratelaw=true</code> uses factorial scaling factors in calculating the   rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. If   <code>combinatoric_ratelaw=false</code> then the ratelaw is <code>k*S^2</code>, i.e. the scaling   factor is ignored. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reactionsystem.jl#L426-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.jumpratelaw" href="#Catalyst.jumpratelaw"><code>Catalyst.jumpratelaw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jumpratelaw(rx; rxvars=get_variables(rx.rate), combinatoric_ratelaw=true)</code></pre><p>Given a <a href="#Catalyst.Reaction"><code>Reaction</code></a>, return the symbolic reaction rate law used in generated stochastic chemical kinetics model SSAs for the reaction. Note, for a reaction defined by</p><p><code>k*X*Y, X+Z --&gt; 2X + Y</code></p><p>the expression that is returned will be <code>k*X^2*Y*Z</code>. For a reaction of the form</p><p><code>k, 2X+3Y --&gt; Z</code></p><p>the expression that is returned will be <code>k * binomial(X,2) * binomial(Y,3)</code>.</p><p>Notes:</p><ul><li><code>rxvars</code> should give the <code>Variable</code>s, i.e. species and parameters, the rate depends on.</li><li>Allocates</li><li><code>combinatoric_ratelaw=true</code> uses binomials in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S*(S-1)/2</code>. If <code>combinatoric_ratelaw=false</code> then the ratelaw is <code>k*S*(S-1)</code>, i.e. the rate law is not normalized by the scaling factor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reactionsystem.jl#L530-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.mm" href="#Catalyst.mm"><code>Catalyst.mm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mm(X,v,K) = v*X / (X + K)</code></pre><p>A Michaelis-Menten rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/registered_functions.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.mmr" href="#Catalyst.mmr"><code>Catalyst.mmr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mmr(X,v,K) = v*K / (X + K)</code></pre><p>A repressive Michaelis-Menten rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/registered_functions.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.hill" href="#Catalyst.hill"><code>Catalyst.hill</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hill(X,v,K,n) = v*(X^n) / (X^n + K^n)</code></pre><p>A Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/registered_functions.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.hillr" href="#Catalyst.hillr"><code>Catalyst.hillr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hillr(X,v,K,n) = v*(K^n) / (X^n + K^n)</code></pre><p>A repressive Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/registered_functions.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catalyst.hillar" href="#Catalyst.hillar"><code>Catalyst.hillar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hillar(X,Y,v,K,n) = v*(X^n) / (X^n + Y^n + K^n)</code></pre><p>An activation/repressing Hill rate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/registered_functions.jl#L49-L53">source</a></section></article><h2 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.convert" href="#Base.convert"><code>Base.convert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:ODESystem},rs::ReactionSystem)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.ODESystem</code>.</p><p>Notes:</p><ul><li><code>combinatoric_ratelaws=true</code> uses factorial scaling factors in calculating the rate</li></ul><p>law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. If <code>combinatoric_ratelaws=false</code> then the ratelaw is <code>k*S^2</code>, i.e. the scaling factor is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reactionsystem.jl#L728-L739">source</a></section><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:NonlinearSystem},rs::ReactionSystem)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.NonlinearSystem</code>.</p><p>Notes:</p><ul><li><code>combinatoric_ratelaws=true</code> uses factorial scaling factors in calculating the rate</li></ul><p>law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. If <code>combinatoric_ratelaws=false</code> then the ratelaw is <code>k*S^2</code>, i.e. the scaling factor is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reactionsystem.jl#L752-L764">source</a></section><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:SDESystem},rs::ReactionSystem)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.SDESystem</code>.</p><p>Notes:</p><ul><li><code>combinatoric_ratelaws=true</code> uses factorial scaling factors in calculating the rate</li></ul><p>law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S^2/2!</code>. If <code>combinatoric_ratelaws=false</code> then the ratelaw is <code>k*S^2</code>, i.e. the scaling factor is ignored.</p><ul><li><code>noise_scaling=nothing::Union{Vector{Num},Num,Nothing}</code> allows for linear</li></ul><p>scaling of the noise in the chemical Langevin equations. If <code>nothing</code> is given, the default value as in Gillespie 2000 is used. Alternatively, a <code>Num</code> can be given, this is added as a parameter to the system (at the end of the parameter array). All noise terms are linearly scaled with this value. The parameter may be one already declared in the <code>ReactionSystem</code>. Finally, a <code>Vector{Num}</code> can be provided (the length must be equal to the number of reactions). Here the noise for each reaction is scaled by the corresponding parameter in the input vector. This input may contain repeat parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reactionsystem.jl#L778-L798">source</a></section><section><div><pre><code class="language-julia hljs">Base.convert(::Type{&lt;:JumpSystem},rs::ReactionSystem; combinatoric_ratelaws=true)</code></pre><p>Convert a <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> to an <code>ModelingToolkit.JumpSystem</code>.</p><p>Notes:</p><ul><li><code>combinatoric_ratelaws=true</code> uses binomials in calculating the rate law, i.e. for <code>2S -&gt; 0</code> at rate <code>k</code> the ratelaw would be <code>k*S*(S-1)/2</code>. If <code>combinatoric_ratelaws=false</code> then the ratelaw is <code>k*S*(S-1)</code>, i.e. the rate law is not normalized by the scaling factor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/reactionsystem.jl#L830-L842">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.structural_simplify" href="#ModelingToolkit.structural_simplify"><code>ModelingToolkit.structural_simplify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">structural_simplify(sys; simplify)
</code></pre><p>Structurally simplify algebraic equations in a system and compute the topological sort of the observed equations. When <code>simplify=true</code>, the <code>simplify</code> function will be applied during the tearing process.</p></div></section></article><h2 id="Unit-Validation"><a class="docs-heading-anchor" href="#Unit-Validation">Unit Validation</a><a id="Unit-Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-Validation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.validate-Tuple{Reaction}" href="#ModelingToolkit.validate-Tuple{Reaction}"><code>ModelingToolkit.validate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate(rx::Reaction; info::String = &quot;&quot;)</code></pre><p>Check that all substrates and products within the given <a href="#Catalyst.Reaction"><code>Reaction</code></a> have the same units, and that the units of the reaction&#39;s rate expression are internally consistent (i.e. if the rate involves sums, each term in the sum has the same units).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L1187-L1195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.validate" href="#ModelingToolkit.validate"><code>ModelingToolkit.validate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">validate(rs::ReactionSystem, info::String=&quot;&quot;)</code></pre><p>Check that all species in the <a href="#Catalyst.ReactionSystem"><code>ReactionSystem</code></a> have the same units, and that the rate laws of all reactions reduce to units of (species units) / (time units).</p><p>Notes:</p><ul><li>Does not check subsystems too. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L1223-L1232">source</a></section></article><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Catalyst.symmap_to_varmap" href="#Catalyst.symmap_to_varmap"><code>Catalyst.symmap_to_varmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">symmap_to_varmap(sys, symmap)</code></pre><p>Given a system and map of <code>Symbol</code>s to values, generates a map from corresponding symbolic variables/parameters to the values that can be used to pass initial conditions and parameter mappings.</p><p>For example,</p><pre><code class="language-julia hljs">sir = @reaction_network sir begin
    β, S + I --&gt; 2I
    ν, I --&gt; R
end β ν
subsys = @reaction_network subsys begin
    k, A --&gt; B
end k
@named sys = compose(sir, [subsys])</code></pre><p>gives</p><pre><code class="nohighlight hljs">Model sys with 3 equations
States (5):
  S(t)
  I(t)
  R(t)
  subsys₊A(t)
  subsys₊B(t)
Parameters (3):
  β
  ν
  subsys₊k</code></pre><p>to specify initial condition and parameter mappings from <em>symbols</em> we can use</p><pre><code class="language-julia hljs">symmap = [:S =&gt; 1.0, :I =&gt; 1.0, :R =&gt; 1.0, :subsys₊A =&gt; 1.0, :subsys₊B =&gt; 1.0]
u0map  = symmap_to_varmap(sys, symmap)
pmap   = symmap_to_varmap(sys, [:β =&gt; 1.0, :ν =&gt; 1.0, :subsys₊k =&gt; 1.0])</code></pre><p><code>u0map</code> and <code>pmap</code> can then be used as input to various problem types.</p><p>Notes:</p><ul><li>Any <code>Symbol</code>, <code>sym</code>, within <code>symmap</code> must be a valid field of <code>sys</code>. i.e. <code>sys.sym</code> must be defined.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Catalyst.jl/blob/252bcd9dccfb40f31544d05a2e5714b968dca40e/src/networkapi.jl#L431-L474">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../faqs/">« FAQs</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Saturday 19 March 2022 03:42">Saturday 19 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
