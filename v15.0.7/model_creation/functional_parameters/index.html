<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Inputs and time-dependent (or functional) parameters · Catalyst.jl</title><meta name="title" content="Inputs and time-dependent (or functional) parameters · Catalyst.jl"/><meta property="og:title" content="Inputs and time-dependent (or functional) parameters · Catalyst.jl"/><meta property="twitter:title" content="Inputs and time-dependent (or functional) parameters · Catalyst.jl"/><meta name="description" content="Documentation for Catalyst.jl."/><meta property="og:description" content="Documentation for Catalyst.jl."/><meta property="twitter:description" content="Documentation for Catalyst.jl."/><meta property="og:url" content="https://docs.sciml.ai/Catalyst/stable/model_creation/functional_parameters/"/><meta property="twitter:url" content="https://docs.sciml.ai/Catalyst/stable/model_creation/functional_parameters/"/><link rel="canonical" href="https://docs.sciml.ai/Catalyst/stable/model_creation/functional_parameters/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Catalyst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Catalyst.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Introduction to Catalyst</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../introduction_to_catalyst/catalyst_for_new_julia_users/">Introduction to Catalyst and Julia for New Julia users</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/introduction_to_catalyst/">Introduction to Catalyst</a></li><li><a class="tocitem" href="../../introduction_to_catalyst/math_models_intro/">Mathematical Models Catalyst can Generate</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Model creation and properties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../dsl_basics/">The Catalyst DSL - Introduction</a></li><li><a class="tocitem" href="../dsl_advanced/">The Catalyst DSL - Advanced Features and Options</a></li><li><a class="tocitem" href="../programmatic_CRN_construction/">Programmatic Construction of Symbolic Reaction Systems</a></li><li><a class="tocitem" href="../compositional_modeling/">Compositional Modeling of Reaction Systems</a></li><li><a class="tocitem" href="../constraint_equations/">Coupled ODEs, Algebraic Equations, and Events</a></li><li><a class="tocitem" href="../conservation_laws/">Working with Conservation Laws</a></li><li><a class="tocitem" href="../parametric_stoichiometry/">Symbolic Stoichiometries</a></li><li class="is-active"><a class="tocitem" href>Inputs and time-dependent (or functional) parameters</a><ul class="internal"><li><a class="tocitem" href="#functional_parameters_basic_example"><span>Basic example</span></a></li><li><a class="tocitem" href="#functional_parameters_circ_rhythm"><span>Inserting a customised, time-dependent, input</span></a></li><li><a class="tocitem" href="#functional_parameters_sir"><span>Non-time functional parameters</span></a></li></ul></li><li><a class="tocitem" href="../model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files</a></li><li><a class="tocitem" href="../model_visualisation/">Model Visualisation</a></li><li><a class="tocitem" href="../reactionsystem_content_accessing/">Accessing Model Properties</a></li><li><a class="tocitem" href="../chemistry_related_functionality/">Chemistry-related Functionality</a></li><li><input class="collapse-toggle" id="menuitem-3-13" type="checkbox"/><label class="tocitem" for="menuitem-3-13"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/basic_CRN_library/">Library of Basic Chemical Reaction Network Models</a></li><li><a class="tocitem" href="../examples/programmatic_generative_linear_pathway/">Programmatic, Generative, Modelling of a Linear Pathway</a></li><li><a class="tocitem" href="../examples/hodgkin_huxley_equation/">Hodgkin-Huxley Equation</a></li><li><a class="tocitem" href="../examples/smoluchowski_coagulation_equation/">Smoluchowski Coagulation Equation</a></li><li><a class="tocitem" href="../examples/noise_modelling_approaches/">Approaches for modelling system noise</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Model simulation and visualization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/simulation_introduction/">Model Simulation Introduction</a></li><li><a class="tocitem" href="../../model_simulation/simulation_plotting/">Simulation Plotting</a></li><li><a class="tocitem" href="../../model_simulation/simulation_structure_interfacing/">Interfacing Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../model_simulation/ensemble_simulations/">Ensemble/Monte Carlo Simulations</a></li><li><a class="tocitem" href="../../model_simulation/ode_simulation_performance/">Advice for Performant ODE Simulations</a></li><li><a class="tocitem" href="../../model_simulation/sde_simulation_performance/">Advice for Performant SDE Simulations</a></li><li><a class="tocitem" href="../../model_simulation/finite_state_projection_simulation/">Solving the chemical master equation using FiniteStateProjection.jl</a></li><li><input class="collapse-toggle" id="menuitem-4-8" type="checkbox"/><label class="tocitem" for="menuitem-4-8"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_simulation/examples/periodic_events_simulation/">Modelling a Periodic Event During ODE and Jump Simulations</a></li><li><a class="tocitem" href="../../model_simulation/examples/activation_time_distribution_measurement/">Measuring the Distribution of System Activation Times</a></li><li><a class="tocitem" href="../../model_simulation/examples/interactive_brusselator_simulation/">Interactive Simulation and Plotting</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Network Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../network_analysis/odes/">Decomposing the Reaction Network ODEs</a></li><li><a class="tocitem" href="../../network_analysis/crn_theory/">Chemical Reaction Network Theory</a></li><li><a class="tocitem" href="../../network_analysis/network_properties/">Caching of Network Properties in <code>ReactionSystems</code></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Steady state analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/homotopy_continuation/">Finding Steady States through Homotopy Continuation</a></li><li><a class="tocitem" href="../../steady_state_functionality/nonlinear_solve/">Finding Steady States using NonlinearSolve.jl and SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/steady_state_stability_computation/">Steady state stability computation</a></li><li><a class="tocitem" href="../../steady_state_functionality/bifurcation_diagrams/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../steady_state_functionality/dynamical_systems/">Analysing Model Steady State Properties with DynamicalSystems.jl</a></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../steady_state_functionality/examples/nullcline_plotting/">Plotting Nullclines and Steady States in Phase Space</a></li><li><a class="tocitem" href="../../steady_state_functionality/examples/bifurcationkit_periodic_orbits/">Computing Periodic Orbits (Oscillations) Using BifurcationKit.jl</a></li><li><a class="tocitem" href="../../steady_state_functionality/examples/bifurcationkit_codim2/">Tracking Bifurcation Point w.r.t. Secondary Parameters using BifurcationKit.jl</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Inverse problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../inverse_problems/petab_ode_param_fitting/">Parameter Fitting for ODEs using PEtab.jl</a></li><li><a class="tocitem" href="../../inverse_problems/optimization_ode_param_fitting/">Parameter Fitting for ODEs using Optimization.jl</a></li><li><a class="tocitem" href="../../inverse_problems/behaviour_optimisation/">Optimization for Non-data Fitting Purposes</a></li><li><a class="tocitem" href="../../inverse_problems/structural_identifiability/">Structural Identifiability Analysis</a></li><li><a class="tocitem" href="../../inverse_problems/global_sensitivity_analysis/">Global Sensitivity Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Spatial modelling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../spatial_modelling/lattice_reaction_systems/">Introduction to Spatial Modelling with Catalyst</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_structure_ interaction/">Interfacing with Lattice Problems, Integrators, and Solutions</a></li><li><a class="tocitem" href="../../spatial_modelling/lattice_simulation_plotting/">Plotting Spatial Simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_ode_simulations/">Spatial ODE simulations</a></li><li><a class="tocitem" href="../../spatial_modelling/spatial_jump_simulations/">Spatial Jump Simulations</a></li></ul></li><li><a class="tocitem" href="../../faqs/">FAQs</a></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/core_api/">Catalyst.jl API</a></li><li><a class="tocitem" href="../../api/network_analysis_api/">Network analysis and representations</a></li></ul></li><li><a class="tocitem" href="../../devdocs/dev_guide/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Model creation and properties</a></li><li class="is-active"><a href>Inputs and time-dependent (or functional) parameters</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Inputs and time-dependent (or functional) parameters</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Catalyst.jl/blob/master/docs/src/model_creation/functional_parameters.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="time_dependent_parameters"><a class="docs-heading-anchor" href="#time_dependent_parameters">Inputs and time-dependent (or functional) parameters</a><a id="time_dependent_parameters-1"></a><a class="docs-heading-anchor-permalink" href="#time_dependent_parameters" title="Permalink"></a></h1><p>Catalyst supports the usage of &quot;functional parameters&quot;. In practice, these are parameters that are given by (typically) time-dependent functions (they can also depend on e.g. species values, as discussed <a href="#functional_parameters_sir">here</a>). They are a way to inject custom functions into models. Functional parameters can be used when rates depend on real data, or to represent complicated functions (which use e.g. <code>for</code> loops or random number generation). Here, the function&#39;s values are declared as a data interpolation (which interpolates discrete samples to a continuous function). This is then used as the functional parameter&#39;s value in the simulation. This tutorial first shows how to create time-dependent functional parameters, and then gives an example where the functional parameter depends on a species value.</p><p>An alternative approach for representing complicated functions is by <a href="../dsl_basics/#dsl_description_nonconstant_rates_function_registration">using <code>@register_symbolic</code></a>.</p><h2 id="functional_parameters_basic_example"><a class="docs-heading-anchor" href="#functional_parameters_basic_example">Basic example</a><a id="functional_parameters_basic_example-1"></a><a class="docs-heading-anchor-permalink" href="#functional_parameters_basic_example" title="Permalink"></a></h2><p>Let us first consider an easy, quick-start example (the next section will discuss what is going on in more detail). We will consider a simple <a href="../examples/basic_CRN_library/#basic_CRN_library_bd">birth-death model</a>, but where the birth rate is determined by an input parameter (for which the value depends on time). First, we <a href="../programmatic_CRN_construction/#programmatic_CRN_construction">define the input parameter programmatically</a>, and its values across all time points using the <a href="https://github.com/SciML/DataInterpolations.jl">DataInterpolations.jl</a> package. In this example we will use the input function <span>$pIn(t) = (2 + t)/(1 + t)$</span>. Finally, we plot the input function, demonstrating how while it is defined at discrete points, DataInterpolations.jl generalises this to a continuous function.</p><pre><code class="language-julia hljs">using Catalyst, DataInterpolations, Plots
t = default_t()
tend = 10.0
ts = collect(0.0:0.05:tend)
spline = LinearInterpolation((2 .+ ts) ./ (1 .+ ts), ts)
@parameters (pIn::typeof(spline))(..)
plot(spline)</code></pre><img src="50d20e30.svg" alt="Example block output"/><p>Next, we create our model, <a href="../dsl_advanced/#dsl_advanced_options_symbolics_and_DSL_interpolation">interpolating</a> the input parameter into the <code>@reaction_network</code> declaration.</p><pre><code class="language-julia hljs">bd_model = @reaction_network begin
    $pIn(t), 0 --&gt; X
    d, X --&gt; 0
end</code></pre><p class="math-container">\[ \begin{align*}
\varnothing &amp;\xrightleftharpoons[d]{\mathrm{\mathtt{pIn}}\left( t \right)} \mathrm{X}  
 \end{align*}
 \]</p><p>Finally, we can simulate our model as normal (but where we set the value of the <code>pIn</code> parameter to our interpolated data).</p><pre><code class="language-julia hljs">using OrdinaryDiffEqDefault
u0 = [:X =&gt; 0.5]
ps = [:d =&gt; 2.0, :pIn =&gt; spline]
oprob = ODEProblem(bd_model, u0, tend, ps)
sol = solve(oprob)
plot(sol)</code></pre><img src="fdb5636e.svg" alt="Example block output"/><div class="admonition is-info" id="Note-4eba86faed8cd374"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4eba86faed8cd374" title="Permalink"></a></header><div class="admonition-body"><p>For this simple example, <span>$(2 + t)/(1 + t)$</span> could have been used directly as a reaction rate (or written as a normal function), technically making the functional parameter approach unnecessary. However, here we used this function as a simple example of how discrete data can be made continuous using DataInterpolations, and then have its values inserted using a (functional) parameter.</p></div></div><h2 id="functional_parameters_circ_rhythm"><a class="docs-heading-anchor" href="#functional_parameters_circ_rhythm">Inserting a customised, time-dependent, input</a><a id="functional_parameters_circ_rhythm-1"></a><a class="docs-heading-anchor-permalink" href="#functional_parameters_circ_rhythm" title="Permalink"></a></h2><p>Let us now go through everything again, but providing some more details. Let us first consider the input parameter. We have previously described how a <a href="../dsl_basics/#dsl_description_nonconstant_rates_time">time-dependent rate can model a circadian rhythm</a>. For real applications, due to e.g. clouds, sunlight is not a perfect sine wave. Here, a common solution is to take real sunlight data from some location and use in the model. Here, we will create synthetic (noisy) data as our light input:</p><pre><code class="language-julia hljs">using Plots
tend = 120.0
ts = collect(0.0:1.0:tend)
light = sin.(ts/6) .+ 1
light = [max(0.0, l - rand()) for l in light]
plot(ts, light; seriestype = :scatter, label = &quot;Experienced light&quot;)</code></pre><img src="5cd3f8a4.svg" alt="Example block output"/><p>Now this input is only actually defined at the sample points, making it incompatible with a continuous ODE simulation. To enable this, we will use the DataInterpolations package to create an interpolated version of this data, which forms the actual input:</p><pre><code class="language-julia hljs">using DataInterpolations
interpolated_light = LinearInterpolation(light, ts)
plot(interpolated_light)</code></pre><img src="c188a12e.svg" alt="Example block output"/><p>We are now ready to declare our model. We will consider a protein with an active and an inactive form (<span>$Pₐ$</span> and <span>$Pᵢ$</span>) where the activation is driven by the presence of sunlight. In this example we we create our model using the <a href="../programmatic_CRN_construction/#programmatic_CRN_construction">programmatic approach</a>. Do note the special syntax we use to declare our input parameter, where we both designate it as a generic function and its type as the type of our interpolated input. Also note that, within the model, we mark the input parameter (<code>light_in</code>) as a function of <code>t</code>.</p><pre><code class="language-julia hljs">using Catalyst
t = default_t()
in_type = typeof(interpolated_light)
@parameters kA kD (light_in::in_type)(..)
@species Pₐ(t) Pᵢ(t)
rxs = [
    Reaction(kA*light_in(t), [Pᵢ], [Pₐ]),
    Reaction(kD, [Pₐ], [Pᵢ])
]
@named rs = ReactionSystem(rxs, t)
rs = complete(rs)</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{\mathtt{P_i}} &amp;\xrightleftharpoons[\mathtt{kD}]{\mathtt{kA} \mathrm{\mathtt{light}_{in}}\left( t \right)} \mathrm{\mathtt{P_a}}  
 \end{align*}
 \]</p><p>Now we can simulate our model. Here, we use the interpolated data as the input parameter&#39;s value.</p><pre><code class="language-julia hljs">using OrdinaryDiffEqDefault
u0 = [Pᵢ =&gt; 1.0, Pₐ =&gt; 0.0]
ps = [kA =&gt; 1.5, kD =&gt; 1.0, light_in =&gt; interpolated_light]
oprob = ODEProblem(rs, u0, tend, ps)
sol = solve(oprob)
plot(sol)</code></pre><img src="917dcfcf.svg" alt="Example block output"/><h3 id="functional_parameters_circ_rhythm_dsl"><a class="docs-heading-anchor" href="#functional_parameters_circ_rhythm_dsl">Interpolating the input into the DSL</a><a id="functional_parameters_circ_rhythm_dsl-1"></a><a class="docs-heading-anchor-permalink" href="#functional_parameters_circ_rhythm_dsl" title="Permalink"></a></h3><p>It is possible to use time-dependent inputs when creating models <a href="../dsl_basics/#dsl_description">through the DSL</a> as well. However, it can still be convenient to declare the input parameter programmatically as above. Next, we can <a href="../dsl_advanced/#dsl_advanced_options_symbolics_and_DSL_interpolation">interpolate</a> it into our DSL-declaration (ensuring to also make it a function of <code>t</code>):</p><pre><code class="language-julia hljs">rs_dsl = @reaction_network rs begin
    (kA*$light_in(t), kD), Pᵢ &lt;--&gt; Pₐ
end</code></pre><p class="math-container">\[ \begin{align*}
\mathrm{\mathtt{P_i}} &amp;\xrightleftharpoons[\mathtt{kD}]{\mathtt{kA} \mathrm{\mathtt{light}_{in}}\left( t \right)} \mathrm{\mathtt{P_a}}  
 \end{align*}
 \]</p><p>We can confirm that this model is identical to our programmatic one (and should we wish to, we can simulate it using identical syntax).</p><pre><code class="language-julia hljs">rs == rs_dsl</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h2 id="functional_parameters_sir"><a class="docs-heading-anchor" href="#functional_parameters_sir">Non-time functional parameters</a><a id="functional_parameters_sir-1"></a><a class="docs-heading-anchor-permalink" href="#functional_parameters_sir" title="Permalink"></a></h2><p>Previously we have demonstrated functional parameters that are functions of time. However, functional parameters can be functions of any variable (however, currently, more than one argument is not supported). Here we will demonstrate this using a <a href="../examples/basic_CRN_library/#basic_CRN_library_sir">SIR model</a>, but instead of having the infection rate scale linearly with the number of infected individuals, we instead assume we have measured data of the infection rate (as dependent on the number of infected individuals) and wish to use this instead. Normally we use the following infection reaction in the SIR model:</p><pre><code class="language-julia hljs">@reaction k1, S + I --&gt; 2I</code></pre><p>For ODE models, this would give the same equations as</p><pre><code class="language-julia hljs">@reaction k1*I, S --&gt; I</code></pre><p>Due to performance reasons (especially for jump simulations) the former approach is <em>strongly</em> encouraged. Here, however, we will assume that we have measured real data of how the number of infected individuals affects the infection rate, and wish to use this in our model, i.e. something like this:</p><pre><code class="language-julia hljs">@reaction k1*i_rate(I), S --&gt; I</code></pre><p>This is a case where we can use a functional parameter, whose value depends on the value of <span>$I$</span>.</p><p>We start by declaring the functional parameter that describes how the infection rate depends on the number of infected individuals. We also plot the measured infection rate, and compare it to the theoretical rate usually used in the SIR model.</p><pre><code class="language-julia hljs">using DataInterpolations, Plots
I_grid = collect(0.0:5.0:100.0)
I_measured = 300.0 *(0.8*rand(length(I_grid)) .+ 0.6) .* I_grid ./ (300 .+ I_grid)
I_rate = LinearInterpolation(I_measured, I_grid)
plot(I_rate; label = &quot;Measured infection rate&quot;)
plot!(I_grid, I_grid; label = &quot;Normal SIR infection rate&quot;)</code></pre><img src="22b11a90.svg" alt="Example block output"/><p>Next, we create our model (using the DSL approach).</p><pre><code class="language-julia hljs">using Catalyst
@parameters (inf_rate::typeof(I_rate))(..)
sir = @reaction_network rs begin
    k1*$inf_rate(I), S --&gt; I
    k2, I --&gt; R
end</code></pre><p>Finally, we can simulate our model.</p><pre><code class="language-julia hljs">using OrdinaryDiffEqDefault
u0 = [:S =&gt; 99.0, :I =&gt; 1.0, :R =&gt; 0.0]
ps = [:k1 =&gt; 0.002, :k2 =&gt; 0.01, :inf_rate =&gt; I_rate]
oprob = ODEProblem(sir, u0, 250.0, ps)
sol = solve(oprob)
plot(sol)</code></pre><img src="2a38bab7.svg" alt="Example block output"/><div class="admonition is-info" id="Note-1d0d5baa67da0756"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1d0d5baa67da0756" title="Permalink"></a></header><div class="admonition-body"><p>When declaring a functional parameter of time, it is easy to set its grid values (i.e. ensure they range from the first to the final time point). For Functional parameters that depend on species concentrations it is trickier, and one must make sure that any potential input-species values that can occur during the simulation are represented in the interpolation. </p></div></div><h3 id="functional_parameters_interpolation_algs"><a class="docs-heading-anchor" href="#functional_parameters_interpolation_algs">Using different data interpolation approaches</a><a id="functional_parameters_interpolation_algs-1"></a><a class="docs-heading-anchor-permalink" href="#functional_parameters_interpolation_algs" title="Permalink"></a></h3><p>Up until now we have used <a href="https://en.wikipedia.org/wiki/Linear_interpolation">linear interpolation</a> of our data. However, DataInterpolations.jl <a href="https://docs.sciml.ai/DataInterpolations/stable/methods/">supports other interpolation methods</a>. To demonstrate these we here generate a data set, and then show the linear, cubic, and constant interpolations:</p><pre><code class="language-julia hljs">using DataInterpolations, Plots
xs = collect(0.0:1.0:10.0)
ys = xs ./ (5*rand(length(xs)) .+ xs)
spline_linear = LinearInterpolation(ys, xs)
spline_cubuc = CubicSpline(ys, xs)
spline_const = ConstantInterpolation(ys, xs)
plot(spline_linear)
plot!(spline_cubuc)
plot!(spline_const)</code></pre><img src="925fb7a0.svg" alt="Example block output"/><p>Finally, DataInterpolations.jl also allows various <a href="https://docs.sciml.ai/DataInterpolations/stable/extrapolation_methods/">extrapolation methods</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../parametric_stoichiometry/">« Symbolic Stoichiometries</a><a class="docs-footer-nextpage" href="../model_file_loading_and_export/">Loading Chemical Reaction Network Models from Files »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Wednesday 28 May 2025 18:23">Wednesday 28 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
